/* SAP CVOM 4.0 © <2012-2013> SAP AG. All rights reserved. Build Version 4.0.5.297 */(function(){var a;if(window){sap=window.sap||{}}else{sap=sap||{}}if(sap){sap.common=sap.common||{}}if(sap.common){sap.common.globalization=sap.common.globalization||{}}sap.common.globalization.VERSION=function(){return"6.2.0"};sap.common.globalization.BUILD=function(){return 1};sap.common.globalization.declare=function(c){if(!c){throw new Error("name required")}if(typeof(c)!="string"){throw new Error("name has to be a string")}if(c.charAt(0)=="."||c.charAt(c.length-1)=="."||c.indexOf("..")!=-1){throw new Error("illegal name: "+c)}c=c.split(".");var d=window;for(var b=0;b<c.length;b++){d[c[b]]=d[c[b]]||{};d=d[c[b]]}return d};sap.common.globalization.require=function(b){};sap.common.globalization.extend=function(f,b){var c=f.prototype;f.superclass=b.prototype;var d=function(){};d.prototype=b.prototype;f.prototype=new d();for(var e in c){if(c.hasOwnProperty(e)){f.prototype[e]=c[e]}}f.prototype.constructor=f;if(b.prototype.constructor==Object.prototype.constructor){b.prototype.constructor=b}return f}})();(function(){sap.common.globalization.declare("sap.common.globalization.NumericFormatManager");sap.common.globalization.require("sap.common.globalization.utils.NumberUtil");sap.common.globalization.require("sap.common.globalization.utils.BooleanUtil");sap.common.globalization.require("sap.common.globalization.utils.DataFormatUtils");sap.common.globalization.require("sap.common.globalization.utils.StringUtil");sap.common.globalization.require("sap.common.globalization.numericFormat.FTUtil");sap.common.globalization.require("sap.common.globalization.numericFormat.FT");sap.common.globalization.require("sap.common.globalization.defaultFormat.CustomNumericFormatLocaleFactory");sap.common.globalization.require("sap.common.globalization.defaultFormat.DefaultShortDateFormatLocaleFactory");sap.common.globalization.require("sap.common.globalization.defaultFormat.DefaultDateFormatLocaleFactory");sap.common.globalization.require("sap.common.globalization.defaultFormat.DefaultDateTimeFormatLocaleFactory");sap.common.globalization.require("sap.common.globalization.defaultFormat.DefaultTimeFormatLocaleFactory");sap.common.globalization.require("sap.common.globalization.defaultFormat.DefaultNumericFormatLocaleFactory");sap.common.globalization.require("sap.common.globalization.defaultFormat.DefaultCurrencyFormatLocaleFactory");sap.common.globalization.require("sap.common.globalization.defaultFormat.CustomDateFormatLocaleFactory");sap.common.globalization.require("sap.common.globalization.numericFormat.FLocalization");sap.common.globalization.require("sap.common.globalization.GlobalizationNumericConstant");sap.common.globalization.require("sap.common.globalization.GlobalizationPreference");var a=sap.common.globalization.NumericFormatManager;a.DEFAULT_FORMAT_DATE_TIME="SAP_FORMAT_DEFAULT_DATE_TIME";a.DEFAULT_FORMAT_TIME="SAP_FORMAT_DEFAULT_TIME";a.DEFAULT_FORMAT_SHORT_DATE="SAP_FORMAT_DEFAULT_SHORT_DATE";a.DEFAULT_FORMAT_LONG_DATE="SAP_FORMAT_DEFAULT_LONG_DATE";a.DEFAULT_FORMAT_NUMBER="SAP_DEFAULT_NUMBER_FORMAT";a.DEFAULT_FORMAT_BOOLEAN="SAP_DEFAULT_BOOLEAN_FORMAT";a._formatsCache={};a.resetFormatsCache=function(){a._formatsCache={}};a.setPVL=function(e,d){var b=sap.common.globalization.GlobalizationPreference.getInstance().pvl();sap.common.globalization.GlobalizationPreference.getInstance().setPvl(e);var c=sap.common.globalization.GlobalizationPreference.getInstance().pvl();if(!b||c!=b){a._formatsCache={};if(!d){a.setCustomizedLocaleInfo(null)}}};a.getPVL=function(){return sap.common.globalization.GlobalizationPreference.getInstance().pvl()};a.setCustomizedLocaleInfo=function(c,b){if(b){delete c.dayStrings;delete c.shortDayStrings;delete c.monthStrings;delete c.shortMonthStrings;delete c.amPms}sap.common.globalization.numericFormat.FLocalization.getInstance().setCustomizedLocaleInfo(c)};a.getThousandSeparator=function(){return sap.common.globalization.GlobalizationNumericConstant.getDisplayThousandSeparator()};a.getDecimalSeparator=function(){return sap.common.globalization.GlobalizationNumericConstant.getDisplayDecimalSeparator()};a.formatToText=function(e,b,d,c){return this._format(e,b,false,d,c)};a.formatToTextWithColor=function(e,b,d,c){return this._format(e,b,true,d,c)};a.getFormattedColor=function(c){var b=undefined;if(c&&c.hasOwnProperty("color")){b=c.color}return b};a.getFormattedText=function(b){var c=b;if(b&&b.hasOwnProperty("text")){c=b.text}return c};a.getFormat=function(f){if((f==null)||(f=="")){return null}if(!a._formatsCache){a._formatsCache=new Object()}var k=a._formatsCache[f];var b=sap.common.globalization.defaultFormat;if(k==null){if(f==a.DEFAULT_FORMAT_SHORT_DATE||f==a.DEFAULT_FORMAT_LONG_DATE||f==a.DEFAULT_FORMAT_DATE_TIME||f==a.DEFAULT_FORMAT_TIME){var f;var m=b.CustomNumericFormatLocaleFactory.getInstance();switch(f){case a.DEFAULT_FORMAT_SHORT_DATE:var j=new b.DefaultShortDateFormatLocaleFactory();k=new sap.common.globalization.numericFormat.FT(j,m);f=j.getDefaultDateFormat();break;case a.DEFAULT_FORMAT_LONG_DATE:var c=new b.DefaultDateFormatLocaleFactory();k=new sap.common.globalization.numericFormat.FT(c,m);f=c.getDefaultDateFormat();break;case a.DEFAULT_FORMAT_DATE_TIME:var e=new b.DefaultDateTimeFormatLocaleFactory();k=new sap.common.globalization.numericFormat.FT(e,m);f=e.getDefaultDateFormat();break;case a.DEFAULT_FORMAT_TIME:default:var i=new b.DefaultTimeFormatLocaleFactory();k=new sap.common.globalization.numericFormat.FT(i,m);f=i.getDefaultDateFormat()}k.parse(f)}else{if(f==a.DEFAULT_FORMAT_NUMBER){var g=new b.DefaultNumericFormatLocaleFactory();var g;var l=g.getDefaultNumericFormat();k=new sap.common.globalization.numericFormat.FT(b.CustomDateFormatLocaleFactory.getInstance(),g);k.parse(l)}else{if(b.DefaultCurrencyFormatLocaleFactory.isDefaultCurrencyFormat(f)){var h=new b.DefaultCurrencyFormatLocaleFactory(f);var d=h.getDefaultCurrencyFormat();k=new sap.common.globalization.numericFormat.FT(b.CustomDateFormatLocaleFactory.getInstance(),h);k.parse(d)}else{if(f==a.DEFAULT_FORMAT_BOOLEAN){k=new sap.common.globalization.numericFormat.FTBoolean();k.parse(f)}else{k=new sap.common.globalization.numericFormat.FT();k.parse(f)}}}}a._formatsCache[f]=k}return k};a._format=function(i,f,h,j,m){var k=i==null?"":i;var g=a.getFormat(f);var d=false;var e=NaN;var j=j==undefined?true:j;var l;var b=String(k);if(g){if(g.isParsedSuccess()==false&&m==true){b=i}else{g.color=undefined;var c=false;if(j){if(sap.common.globalization.utils.NumberUtil.isNumericValue(k)){c=true}}else{if(sap.common.globalization.utils.BaseUtils.isNumber(k)){c=true}}if(c){b=g.display(Number(k));e=Number(g.color)}else{if(sap.common.globalization.utils.BooleanUtil.isBooleanValue(k)&&sap.common.globalization.numericFormat.FTUtil.isBooleanFT(g)){b=g.display(k)}else{if(k instanceof Date){b=g.display(k)}}}}}if(h&&!isNaN(e)){if(!l){l={}}l.color=e;l.text=b}else{l=b}return l};a.format=function(c,b){var d=a.getFormat(b);if(d==null){return c}return d.display(c)};a.SAP_PARAMETERS={};a.resetParameters=function(){a.SAP_PARAMETERS={}};a.setBooleanDisplayString=function(b,c){sap.common.globalization.GlobalizationBooleanConstant.BOOLEAN_STRING_TRUE=b;sap.common.globalization.GlobalizationBooleanConstant.BOOLEAN_STRING_FALSE=c}})();(function(){sap.common.globalization.declare("sap.common.globalization.GlobalizationPreference");sap.common.globalization.require("sap.common.globalization.NumericFormatManager");sap.common.globalization.GlobalizationPreference=function(){this.__className="sap.common.globalization.GlobalizationPreference";this._preferredViewingLocale=null};var a=sap.common.globalization.GlobalizationPreference;a._instance=null;a.DOCUMENT_LOCALE="en";a.getInstance=function(){if(!a._instance){a._instance=new sap.common.globalization.GlobalizationPreference()}return a._instance};a.resetInstance=function(){a._instance=new sap.common.globalization.GlobalizationPreference()};a.prototype.pvl=function(){return this._preferredViewingLocale};a.prototype.setPvl=function(b){if(b!=this._preferredViewingLocale){this._preferredViewingLocale=b}};a.prototype.pvlIsoLanguageCode=function(){return this._getIsoLanguageCode(this.pvl())};a.prototype.documentLocale=function(){return a.DOCUMENT_LOCALE};a.prototype.documentIsoLanguageCode=function(){return this._getIsoLanguageCode(a.DOCUMENT_LOCALE)};a.prototype._getIsoLanguageCode=function(b){if(b){return String(b).split("_")[0]}return b}})();(function(){sap.common.globalization.declare("sap.common.globalization.GlobalizationBooleanConstant");var a=sap.common.globalization.GlobalizationBooleanConstant;a.BOOLEAN_STRING_TRUE="TRUE";a.BOOLEAN_STRING_FALSE="FALSE";a.getBooleanStrings=function(){return[a.BOOLEAN_STRING_TRUE,a.BOOLEAN_STRING_FALSE]}})();(function(){sap.common.globalization.declare("sap.common.globalization.GlobalizationNumericConstant");sap.common.globalization.require("sap.common.globalization.GlobalizationPreference");sap.common.globalization.GlobalizationNumericConstant=function(){this.__className="sap.common.globalization.GlobalizationNumericConstant"};var a=sap.common.globalization.GlobalizationNumericConstant;a._FORMAT_TYPE_NUMBER="number";a._FORMAT_TYPE_CURRENCY="currency";a._KEY_TYPE_NUMERIC="numeric";a._KEY_TOKEN_DISPLAY_THOUSANDS_SEPARATOR="displayThousandsSeparator";a._KEY_TOKEN_DISPLAY_DECIMAL_SEPARATOR="displayDecimalSeparator";a._DEFAULT_FORMAT_STRING={af:{number:"#,##0.###",currency:"¤#,##0.00"},af_ZA:{},ar:{number:"#,##0.###;#,##0.###-",currency:"¤ #,##0.00;¤ #,##0.00-"},ar_AE:{},ar_BH:{},ar_DZ:{},ar_EG:{},ar_IQ:{},ar_JO:{},ar_KW:{},ar_LB:{},ar_LY:{},ar_MA:{},ar_OM:{},ar_QA:{number:"#0.###;#0.###-",currency:"¤#0.00"},ar_SA:{number:"#0.###;#0.###-",currency:"¤#0.00"},ar_SY:{number:"#0.###;#0.###-",currency:"¤#0.00"},ar_TN:{number:"#0.###;#0.###-",currency:"¤#0.00"},ar_YE:{number:"#0.###;#0.###-",currency:"¤#0.00"},az:{number:"#,##0.###",currency:"¤ #,##0.00"},az_AZ:{},be:{number:"#,##0.###",currency:"¤#,##0.00"},be_BY:{},bg:{number:"#,##0.###",currency:"#,##0.00 ¤"},bg_BG:{},bn:{number:"#,##,##0.###",currency:"#,##,##0.00¤;(#,##,##0.00¤)"},bn_IN:{},bs:{number:"#,##0.###",currency:"¤ #,##0.00"},bs_BA:{},ca:{number:"#,##0.###",currency:"#,##0.00 ¤"},ca_ES:{},cs:{number:"#,##0.###",currency:"#,##0.00 ¤"},cs_CZ:{},cy:{number:"#,##0.###",currency:"¤#,##0.00"},cy_GB:{},da:{number:"#,##0.###",currency:"#,##0.00 ¤"},da_DK:{},de:{number:"#,##0.###",currency:"#,##0.00 ¤"},de_AT:{currency:"¤ #,##0.00"},de_CH:{currency:"¤ #,##0.00;¤-#,##0.00"},de_DE:{},de_LI:{currency:"¤ #,##0.00"},de_LU:{},el:{number:"#,##0.###",currency:"#,##0.00 ¤"},el_GR:{},en:{number:"#,##0.###",currency:"¤#,##0.00;(¤#,##0.00)"},en_AU:{currency:"¤#,##0.00"},en_BZ:{currency:"¤#,##0.00"},en_CA:{},en_GB:{currency:"¤#,##0.00"},en_IE:{currency:"¤#,##0.00"},en_JM:{currency:"¤#,##0.00"},en_NZ:{currency:"¤#,##0.00"},en_PH:{},en_TT:{currency:"¤#,##0.00"},en_US:{},en_VI:{},en_ZA:{currency:"¤#,##0.00"},en_ZW:{currency:"¤#,##0.00"},es:{number:"#,##0.###",currency:"¤ #,##0.00"},es_AR:{},es_BO:{},es_CL:{currency:"¤#,##0.00;¤-#,##0.00"},es_CO:{},es_CR:{},es_DO:{},es_EC:{currency:"¤#,##0.00;¤-#,##0.00"},es_ES:{},es_GT:{},es_HN:{},es_MX:{},es_NI:{},es_PA:{},es_PE:{},es_PR:{},es_PY:{currency:"¤ #,##0.00;¤ -#,##0.00"},es_SV:{},es_UY:{currency:"¤ #,##0.00;(¤ #,##0.00)"},es_VE:{currency:"¤#,##0.00;¤-#,##0.00"},et:{number:"#,##0.###",currency:"#,##0.00 ¤"},et_EE:{},eu:{number:"#,##0.###",currency:"#,##0.00 ¤"},eu_ES:{},fa:{number:"#,##0.###;'-#,##0.###'",currency:"#,##0.00 ¤;'-#,##0.00' ¤"},fa_IR:{},fi:{number:"#,##0.###",currency:"#,##0.00 ¤"},fi_FI:{},fo:{number:"#,##0.###",currency:"¤#,##0.00;¤-#,##0.00"},fo_FO:{},fr:{number:"#,##0.###",currency:"#,##0.00 ¤"},fr_BE:{},fr_CA:{currency:"#,##0.00 ¤;(#,##0.00 ¤)"},fr_CH:{currency:"¤ #,##0.00;¤-#,##0.00"},fr_FR:{},fr_LU:{},fr_MC:{},gl:{number:"#,##0.###",currency:"#,##0.00 ¤"},gl_ES:{},gu:{number:"#,##,##0.###",currency:"¤ #,##,##0.00"},gu_IN:{},he:{number:"#,##0.###",currency:"#,##0.00 ¤"},he_IL:{},hi:{number:"#,##,##0.###",currency:"¤ #,##,##0.00"},hi_IN:{},hr:{number:"#,##0.###",currency:"#,##0.00 ¤"},hr_HR:{},hu:{number:"#,##0.###",currency:"#,##0.00 ¤"},hu_HU:{},hy:{number:"#0.###",currency:"#0.00 ¤"},hy_AM:{},id:{number:"#,##0.###",currency:"¤#,##0.00"},id_ID:{},is:{number:"#,##0.###",currency:"#,##0.00 ¤"},is_IS:{},it:{number:"#,##0.###",currency:"¤ #,##0.00"},it_CH:{currency:"¤ #,##0.00;¤-#,##0.00"},it_IT:{},ja:{number:"#,##0.###",currency:"¤#,##0.00"},ja_JP:{},ka:{number:"#,##0.###",currency:"¤ #,##0.00"},ka_GE:{},kk:{number:"#,##0.###",currency:"#,##0.00 ¤"},kk_KZ:{},kn:{number:"#,##,##0.###",currency:"¤ #,##,##0.00"},kn_IN:{},ko:{number:"#,##0.###",currency:"¤#,##0.00"},ko_KR:{},kok:{number:"#,##,##0.###",currency:"¤ #,##,##0.00"},kok_IN:{},lt:{number:"#,##0.###",currency:"#,##0.00 ¤"},lt_LT:{},lv:{number:"#,##0.###",currency:"#,##0.00 ¤"},lv_LV:{},mk:{number:"#,##0.###;(#,##0.###)",currency:"¤ #,##0.00"},mk_MK:{},ml:{number:"#,##,##0.###",currency:"#,##,##0.00¤"},ml_IN:{},mn:{number:"#,##0.###",currency:"¤ #,##0.00"},mn_MN:{},mr:{number:"#,##,##0.###",currency:"¤ #,##,##0.00"},mr_IN:{},ms:{number:"#,##0.###",currency:"¤#,##0.00;(¤#,##0.00)"},ms_BN:{currency:"¤ #,##0.00"},ms_MY:{},mt:{number:"#,##0.###",currency:"¤#,##0.00"},mt_MT:{},nb:{number:"#,##0.###",currency:"¤ #,##0.00"},nb_NO:{},nl:{number:"#,##0.###",currency:"¤ #,##0.00;¤ #,##0.00-"},nl_BE:{currency:"#,##0.00 ¤"},nl_NL:{},nn:{number:"#,##0.###",currency:"#,##0.00 ¤"},nn_NO:{},pa:{number:"#,##,##0.###",currency:"¤ #,##,##0.00"},pa_IN:{},pl:{number:"#,##0.###",currency:"#,##0.00 ¤"},pl_PL:{},pt:{number:"#,##0.###",currency:"¤#,##0.00;(¤#,##0.00)"},pt_BR:{},pt_PT:{currency:"#,##0.00 ¤"},ro:{number:"#,##0.###",currency:"#,##0.00 ¤"},ro_RO:{},ru:{number:"#,##0.###",currency:"#,##0.00 ¤"},ru_RU:{},se:{number:"#,##0.###",currency:"¤ #,##0.00"},se_NO:{},sk:{number:"#,##0.###",currency:"#,##0.00 ¤"},sk_SK:{},sl:{number:"#,##0.###",currency:"#,##0.00 ¤"},sl_SI:{},sq:{number:"#,##0.###",currency:"¤#,##0.00"},sq_AL:{},sr:{number:"#,##0.###",currency:"#,##0.00 ¤"},sr_BA:{},sr_CS:{},sv:{number:"#,##0.###",currency:"#,##0.00 ¤"},sv_FI:{},sv_SE:{},sw:{number:"#,##0.###",currency:"#,##0.00 ¤"},sw_KE:{currency:"¤#,##0.00"},syr:{number:"#,##0.###",currency:"¤ #,##0.00"},syr_SY:{},ta:{number:"#,##,##0.###",currency:"¤ #,##,##0.00"},ta_IN:{},te:{number:"#,##,##0.###",currency:"¤ #,##,##0.00"},te_IN:{},th:{number:"#,##0.###",currency:"¤#,##0.00;¤-#,##0.00"},th_TH:{},tn:{number:"#,##0.###",currency:"¤#,##0.00"},tn_ZA:{},tr:{number:"#,##0.###",currency:"#,##0.00 ¤"},tr_TR:{},uk:{number:"#,##0.###",currency:"#,##0.00 ¤"},uk_UA:{},uz:{number:"#,##0.###",currency:"¤ #,##0.00"},uz_UZ:{},vi:{number:"#,##0.###",currency:"#,##0.00 ¤"},vi_VN:{},xh:{number:"#,##0.###",currency:"¤#,##0.00"},xh_ZA:{},zh:{number:"#,##0.###",currency:"¤#,##0.00"},zh_CN:{},zh_HK:{},zh_MO:{},zh_SG:{},zh_TW:{},zu:{number:"#,##0.###",currency:"¤#,##0.00"},zu_ZA:{}};a._RESOURCE_MAP={af:{numeric:{displayThousandsSeparator:" ",displayDecimalSeparator:","}},af_ZA:{numeric:{}},ar:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},ar_AE:{numeric:{}},ar_BH:{numeric:{}},ar_DZ:{numeric:{}},ar_EG:{numeric:{}},ar_IQ:{numeric:{}},ar_JO:{numeric:{}},ar_KW:{numeric:{}},ar_LB:{numeric:{}},ar_LY:{numeric:{}},ar_MA:{numeric:{}},ar_OM:{numeric:{}},ar_QA:{numeric:{}},ar_SA:{numeric:{}},ar_SY:{numeric:{}},ar_TN:{numeric:{}},ar_YE:{numeric:{}},az:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},az_AZ:{numeric:{}},be:{numeric:{displayThousandsSeparator:" ",displayDecimalSeparator:","}},be_BY:{numeric:{}},bg:{numeric:{displayThousandsSeparator:" ",displayDecimalSeparator:","}},bg_BG:{numeric:{}},bn:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},bn_IN:{numeric:{}},bs:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},bs_BA:{numeric:{}},ca:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},ca_ES:{numeric:{}},cs:{numeric:{displayThousandsSeparator:" ",displayDecimalSeparator:","}},cs_CZ:{numeric:{}},cy:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},cy_GB:{numeric:{}},da:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},da_DK:{numeric:{}},de:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},de_AT:{numeric:{}},de_CH:{numeric:{displayThousandsSeparator:"'",displayDecimalSeparator:"."}},de_DE:{numeric:{}},de_LI:{numeric:{displayThousandsSeparator:"'",displayDecimalSeparator:"."}},de_LU:{numeric:{}},el:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},el_GR:{numeric:{}},en:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},en_AU:{numeric:{}},en_BZ:{numeric:{}},en_CA:{numeric:{}},en_GB:{numeric:{}},en_IE:{numeric:{}},en_JM:{numeric:{}},en_NZ:{numeric:{}},en_PH:{numeric:{}},en_TT:{numeric:{}},en_US:{numeric:{}},en_VI:{numeric:{}},en_ZA:{numeric:{displayThousandsSeparator:" ",displayDecimalSeparator:","}},en_ZW:{numeric:{}},es:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},es_AR:{numeric:{}},es_BO:{numeric:{}},es_CL:{numeric:{}},es_CO:{numeric:{}},es_CR:{numeric:{}},es_DO:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},es_EC:{numeric:{}},es_ES:{numeric:{}},es_GT:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},es_HN:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},es_MX:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},es_NI:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},es_PA:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},es_PE:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},es_PR:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},es_PY:{numeric:{}},es_SV:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},es_UY:{numeric:{}},es_VE:{numeric:{}},et:{numeric:{displayThousandsSeparator:" ",displayDecimalSeparator:","}},et_EE:{numeric:{}},eu:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},eu_ES:{numeric:{}},fa:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},fa_IR:{numeric:{}},fi:{numeric:{displayThousandsSeparator:" ",displayDecimalSeparator:","}},fi_FI:{numeric:{}},fo:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},fo_FO:{numeric:{}},fr:{numeric:{displayThousandsSeparator:" ",displayDecimalSeparator:","}},fr_BE:{numeric:{displayThousandsSeparator:"."}},fr_CA:{numeric:{}},fr_CH:{numeric:{displayThousandsSeparator:"'",displayDecimalSeparator:"."}},fr_FR:{numeric:{}},fr_LU:{numeric:{displayThousandsSeparator:"."}},fr_MC:{numeric:{}},gl:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},gl_ES:{numeric:{}},gu:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},gu_IN:{numeric:{}},he:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},he_IL:{numeric:{}},hi:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},hi_IN:{numeric:{}},hr:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},hr_HR:{numeric:{}},hu:{numeric:{displayThousandsSeparator:" ",displayDecimalSeparator:","}},hu_HU:{numeric:{}},hy:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},hy_AM:{numeric:{}},id:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},id_ID:{numeric:{}},is:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},is_IS:{numeric:{}},it:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},it_CH:{numeric:{displayThousandsSeparator:"'",displayDecimalSeparator:"."}},it_IT:{numeric:{}},ja:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},ja_JP:{numeric:{}},ka:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},ka_GE:{numeric:{}},kk:{numeric:{displayThousandsSeparator:" ",displayDecimalSeparator:","}},kk_KZ:{numeric:{}},kn:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},kn_IN:{numeric:{}},ko:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},ko_KR:{numeric:{}},kok:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},kok_IN:{numeric:{}},lt:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},lt_LT:{numeric:{}},lv:{numeric:{displayThousandsSeparator:" ",displayDecimalSeparator:","}},lv_LV:{numeric:{}},mk:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},mk_MK:{numeric:{}},ml:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},ml_IN:{numeric:{}},mn:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},mn_MN:{numeric:{}},mr:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},mr_IN:{numeric:{}},ms:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},ms_BN:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},ms_MY:{numeric:{}},mt:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},mt_MT:{numeric:{}},nb:{numeric:{displayThousandsSeparator:" ",displayDecimalSeparator:","}},nb_NO:{numeric:{}},nl:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},nl_BE:{numeric:{}},nl_NL:{numeric:{}},nn:{numeric:{displayThousandsSeparator:" ",displayDecimalSeparator:","}},nn_NO:{numeric:{}},pa:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},pa_IN:{numeric:{}},pl:{numeric:{displayThousandsSeparator:" ",displayDecimalSeparator:","}},pl_PL:{numeric:{}},pt:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},pt_BR:{numeric:{}},pt_PT:{numeric:{displayThousandsSeparator:" "}},ro:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},ro_RO:{numeric:{}},ru:{numeric:{displayThousandsSeparator:" ",displayDecimalSeparator:","}},ru_RU:{numeric:{}},se:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},se_NO:{numeric:{}},sk:{numeric:{displayThousandsSeparator:" ",displayDecimalSeparator:","}},sk_SK:{numeric:{}},sl:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},sl_SI:{numeric:{}},sq:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},sq_AL:{numeric:{}},sr:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},sr_BA:{numeric:{}},sr_CS:{numeric:{}},sv:{numeric:{displayThousandsSeparator:" ",displayDecimalSeparator:","}},sv_FI:{numeric:{}},sv_SE:{numeric:{}},sw:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},sw_KE:{numeric:{}},syr:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},syr_SY:{numeric:{}},ta:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},ta_IN:{numeric:{}},te:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},te_IN:{numeric:{}},th:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},th_TH:{numeric:{}},tn:{numeric:{displayThousandsSeparator:" ",displayDecimalSeparator:","}},tn_ZA:{numeric:{}},tr:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},tr_TR:{numeric:{}},uk:{numeric:{displayThousandsSeparator:" ",displayDecimalSeparator:","}},uk_UA:{numeric:{}},uz:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},uz_UZ:{numeric:{}},vi:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},vi_VN:{numeric:{}},xh:{numeric:{displayThousandsSeparator:" ",displayDecimalSeparator:","}},xh_ZA:{numeric:{}},zh:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},zh_CN:{numeric:{}},zh_HK:{numeric:{}},zh_MO:{numeric:{}},zh_SG:{numeric:{}},zh_TW:{numeric:{}},zu:{numeric:{displayThousandsSeparator:" ",displayDecimalSeparator:","}},zu_ZA:{numeric:{}}};a.getParseThousandSeparator=function(b){return","};a.getDisplayThousandSeparator=function(b){var b=b||null;if(b){if(a._resourceExist(b,a._KEY_TYPE_NUMERIC,a._KEY_TOKEN_DISPLAY_THOUSANDS_SEPARATOR)){return a.getNumericResource(b,a._KEY_TYPE_NUMERIC,a._KEY_TOKEN_DISPLAY_THOUSANDS_SEPARATOR)}else{return null}}return a._getAppropriateNumericResource(a._KEY_TYPE_NUMERIC,a._KEY_TOKEN_DISPLAY_THOUSANDS_SEPARATOR)};a.getParseDecimalSeparator=function(b){return"."};a.getDisplayDecimalSeparator=function(b){var b=b||null;if(b){if(a._resourceExist(b,a._KEY_TYPE_NUMERIC,a._KEY_TOKEN_DISPLAY_DECIMAL_SEPARATOR)){return a.getNumericResource(b,a._KEY_TYPE_NUMERIC,a._KEY_TOKEN_DISPLAY_DECIMAL_SEPARATOR)}else{return null}}return a._getAppropriateNumericResource(a._KEY_TYPE_NUMERIC,a._KEY_TOKEN_DISPLAY_DECIMAL_SEPARATOR)};a.getParseCurrencySymbol=function(){return"¤"};a.getDefaultNumberFormat=function(b){var b=b||null;if(b){if(a._formatExist(b,a._FORMAT_TYPE_NUMBER)){return a._getNumericFormat(b,a._FORMAT_TYPE_NUMBER)}else{return null}}return a._getAppropriateNumericFormat(a._FORMAT_TYPE_NUMBER)};a.getDefaultCurrencyFormat=function(b){var b=b||null;if(b){if(a._formatExist(b,a._FORMAT_TYPE_CURRENCY)){return a._getNumericFormat(b,a._FORMAT_TYPE_CURRENCY)}else{return null}}return a._getAppropriateNumericFormat(a._FORMAT_TYPE_CURRENCY)};a.getActualLocaleForDefaultCurrencyFormat=function(){return a.getActualLocaleForNumerFormat(a._FORMAT_TYPE_CURRENCY)};a.getActualLocaleForDefaultNumberFormat=function(){return a.getActualLocaleForNumerFormat(a._FORMAT_TYPE_NUMBER)};a.getActualLocaleForNumerFormat=function(d){var e=sap.common.globalization.GlobalizationPreference.getInstance().pvl();if(a._formatExist(e,d)){return e}var c=sap.common.globalization.GlobalizationPreference.getInstance().pvlIsoLanguageCode();if(a._formatExist(c,d)){return c}var f=sap.common.globalization.GlobalizationPreference.getInstance().documentLocale();if(a._formatExist(f,d)){return f}var b=sap.common.globalization.GlobalizationPreference.getInstance().documentIsoLanguageCode();if(a._formatExist(b,d)){return b}return"en"};a._getAppropriateNumericFormat=function(b){return a._getNumericFormat(a.getActualLocaleForNumerFormat(b),b)};a._formatExist=function(b,c){return(b&&c&&a._DEFAULT_FORMAT_STRING[b]&&a._DEFAULT_FORMAT_STRING[b][c])};a._getNumericFormat=function(b,c){return a._DEFAULT_FORMAT_STRING[b][c]};a._getAppropriateNumericResource=function(e,b){var f=sap.common.globalization.GlobalizationPreference.getInstance().pvl();if(a._resourceExist(f,e,b)){return a.getNumericResource(f,e,b)}var d=sap.common.globalization.GlobalizationPreference.getInstance().pvlIsoLanguageCode();if(a._resourceExist(d,e,b)){return a.getNumericResource(d,e,b)}var g=sap.common.globalization.GlobalizationPreference.getInstance().documentLocale();if(a._resourceExist(g,e,b)){return a.getNumericResource(g,e,b)}var c=sap.common.globalization.GlobalizationPreference.getInstance().documentIsoLanguageCode();if(a._resourceExist(c,e,b)){return a.getNumericResource(c,e,b)}return a.getNumericResource("en",e,b)};a._resourceExist=function(b,d,c){return(b&&d&&c&&a._RESOURCE_MAP[b]&&a._RESOURCE_MAP[b][d]&&a._RESOURCE_MAP[b][d][c])};a.getNumericResource=function(b,d,c){return a._RESOURCE_MAP[b][d][c]}})();(function(){sap.common.globalization.declare("sap.common.globalization.GlobalizationDateConstant");sap.common.globalization.require("sap.common.globalization.GlobalizationPreference");sap.common.globalization.GlobalizationDateConstant=function(){this.__className="sap.common.globalization.defaultFormat.GlobalizationDateConstant"};var a=sap.common.globalization.GlobalizationDateConstant;a.FORMAT_TYPE_SHORTDATE="shortDate",a.FORMAT_TYPE_LONGDATE="longDate",a.FORMAT_TYPE_DATE_TIME="dateTime",a.FORMAT_TYPE_TIME="timeFormat",a.KEY_TYPE_DATE="date",a.KEY_TYPE_TIME="time",a.KEY_TOKEN_SHORT_DAY="shortDay",a.KEY_TOKEN_LONG_DAY="longDay",a.KEY_TOKEN_SHORT_MONTH="shortMonth",a.KEY_TOKEN_LONG_MONTH="longMonth",a.KEY_TOKEN_AM_PM="amPm",a.KEY_DATE_SEPARATOR="dateSeparator",a.KEY_TIME_SEPARATOR="timeSeparator",a.KEY_TOKEN_ABBREV_ERA="eraAbbr",a.DEFAULT_FORMAT_STRING={af:{longDate:"dddd dd MMMM yyyy;@",shortDate:"yyyy-MM-dd;@",dateTime:"yyyy MMM d HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},af_ZA:{},ar:{longDate:"dddd، d MMMM، yyyy;@",shortDate:"d/M/yyyy;@",dateTime:"dd/MM/yyyy h:mm:ss AM/PM;@",timeFormat:"h:mm:ss AM/PM;@"},ar_AE:{},ar_BH:{},ar_DZ:{},ar_EG:{},ar_IQ:{},ar_JO:{},ar_KW:{},ar_LB:{},ar_LY:{},ar_MA:{},ar_OM:{},ar_QA:{},ar_SA:{},ar_SY:{},ar_TN:{},ar_YE:{},az:{longDate:"dddd, d, MMMM, yyyy;@",shortDate:"yyyy-MM-dd;@",dateTime:"d MMM, yyyy HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},az_AZ:{},be:{longDate:"dddd, d MMMM yyyy;@",shortDate:"d.M.yy;@",dateTime:"d.M.yyyy HH.mm.ss;@",timeFormat:"HH.mm.ss;@"},be_BY:{},bg:{longDate:"dd MMMM yyyy, dddd;@",shortDate:"dd.MM.yy;@",dateTime:"dd.MM.yyyy HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},bg_BG:{},bn:{longDate:"dddd, d MMMM, yyyy;@",shortDate:"d/M/yy;@",dateTime:"d MMM, yyyy h:mm:ss AM/PM;@",timeFormat:"h:mm:ss AM/PM;@"},bn_IN:{},bs:{longDate:"dddd, yyyy MMMM dd;@",shortDate:"yyyy-MM-dd;@",dateTime:"yyyy MMM d HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},bs_BA:{},ca:{longDate:'dddd d "de" MMMM "de" yyyy;@',shortDate:"dd/MM/yy;@",dateTime:"dd/MM/yyyy H:mm:ss;@",timeFormat:"H:mm:ss;@"},ca_ES:{},cs:{longDate:"dddd, d. MMMM yyyy;@",shortDate:"d.M.yy;@",dateTime:"d.M.yyyy H:mm:ss;@",timeFormat:"H:mm:ss;@"},cs_CZ:{},cy:{longDate:"dddd, yyyy MMMM dd;@",shortDate:"yyyy-MM-dd;@",dateTime:"yyyy MMM d h:mm:ss AM/PM;@",timeFormat:"h:mm:ss AM/PM;@"},cy_GB:{},da:{longDate:'dddd "den" d. MMMM yyyy;@',shortDate:"dd/MM/yy;@",dateTime:"dd/MM/yyyy HH.mm.ss;@",timeFormat:"HH.mm.ss;@"},da_DK:{},de:{longDate:"dddd, d. MMMM yyyy;@",shortDate:"dd.MM.yy;@",dateTime:"dd.MM.yyyy HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},de_AT:{longDate:"dddd, dd. MMMM yyyy;@"},de_CH:{},de_DE:{},de_LI:{},de_LU:{},el:{longDate:"dddd, dd MMMM yyyy;@",shortDate:"dd/MM/yyyy;@",dateTime:"dd MMM yyyy h:mm:ss AM/PM;@",timeFormat:"h:mm:ss AM/PM;@"},el_GR:{},en:{longDate:"dddd, MMMM d, yyyy;@",shortDate:"M/d/yy;@",dateTime:"MMM d, yyyy h:mm:ss AM/PM;@",timeFormat:"h:mm:ss AM/PM;@"},en_AU:{longDate:"dddd, d MMMM yyyy;@",shortDate:"d/MM/yy;@",dateTime:"dd/MM/yyyy h:mm:ss AM/PM;@"},en_BZ:{dateTime:"dd-MMM-yyyy h:mm:ss AM/PM;@"},en_CA:{shortDate:"yy-MM-dd;@",dateTime:"yyyy-MM-dd h:mm:ss AM/PM;@"},en_GB:{longDate:"dddd, d MMMM yyyy;@",shortDate:"dd/MM/yyyy;@",dateTime:"d MMM yyyy HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},en_IE:{longDate:"dddd d MMMM yyyy;@",shortDate:"dd/MM/yyyy;@",dateTime:"d MMM yyyy HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},en_JM:{},en_NZ:{longDate:"dddd, d MMMM yyyy;@",shortDate:"d/MM/yy;@",dateTime:"d/MM/yyyy h:mm:ss AM/PM;@"},en_PH:{},en_TT:{},en_US:{},en_VI:{},en_ZA:{longDate:"dddd dd MMMM yyyy;@",shortDate:"yyyy/MM/dd;@",dateTime:"dd MMM yyyy h:mm:ss AM/PM;@"},en_ZW:{longDate:"dddd dd MMMM yyyy;@",shortDate:"d/M/yyyy;@",dateTime:"dd MMM, yyyy h:mm:ss AM/PM;@"},es:{longDate:'dddd d "de" MMMM "de" yyyy;@',shortDate:"dd/MM/yy;@",dateTime:"dd/MM/yyyy HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},es_AR:{},es_BO:{},es_CL:{shortDate:"dd-MM-yy;@",dateTime:"dd-MM-yyyy H:mm:ss;@",timeFormat:"H:mm:ss;@"},es_CO:{shortDate:"d/MM/yy;@",dateTime:"d/MM/yyyy H:mm:ss;@",timeFormat:"H:mm:ss;@"},es_CR:{},es_DO:{},es_EC:{dateTime:"dd/MM/yyyy H:mm:ss;@",timeFormat:"H:mm:ss;@"},es_ES:{},es_GT:{shortDate:"d/MM/yy;@",dateTime:"d/MM/yyyy HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},es_HN:{longDate:'dddd dd "de" MMMM "de" yyyy;@'},es_MX:{},es_NI:{},es_PA:{shortDate:"MM/dd/yy;@",dateTime:"MM/dd/yyyy HH:mm:ss;@"},es_PE:{shortDate:"d/MM/yy;@"},es_PR:{shortDate:"MM/dd/yy;@",dateTime:"MM/dd/yyyy HH:mm:ss;@"},es_PY:{},es_SV:{},es_UY:{},es_VE:{},et:{longDate:"dddd, d, MMMM yyyy;@",shortDate:"dd.MM.yy;@",dateTime:"dd.MM.yyyy H:mm:ss;@",timeFormat:"H:mm:ss;@"},et_EE:{},eu:{longDate:'dddd, yyyy"eko" MMMM"ren" dd"a";@',shortDate:"yyyy-MM-dd;@",dateTime:"yyyy MMM d HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},eu_ES:{},fa:{longDate:"dddd d MMMM yyyy;@",shortDate:"yy/M/d;@",dateTime:"yyyy/M/d، H:mm:ss;@",timeFormat:"H:mm:ss;@"},fa_IR:{},fi:{longDate:"dddd d. MMMM yyyy;@",shortDate:"d.M.yyyy;@",dateTime:"d.M.yyyy H.mm.ss;@",timeFormat:"H.mm.ss;@"},fi_FI:{},fo:{longDate:"dddd dd MMMM yyyy;@",shortDate:"dd-MM-yy;@",dateTime:"dd-MM-yyyy HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},fo_FO:{},fr:{longDate:"dddd d MMMM yyyy;@",shortDate:"dd/MM/yy;@",dateTime:"d MMM yyyy HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},fr_BE:{shortDate:"d/MM/yy;@"},fr_CA:{shortDate:"yy-MM-dd;@",dateTime:"yyyy-MM-dd HH:mm:ss;@"},fr_CH:{longDate:"dddd, d MMMM yyyy;@",shortDate:"dd.MM.yy;@"},fr_FR:{},fr_LU:{},fr_MC:{},gl:{longDate:"dddd dd MMMM yyyy;@",shortDate:"dd/MM/yy;@",dateTime:"d MMM, yyyy HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},gl_ES:{},gu:{longDate:"dddd, d MMMM, yyyy;@",shortDate:"d-MM-yy;@",dateTime:"d MMM, yyyy hh:mm:ss AM/PM;@",timeFormat:"hh:mm:ss AM/PM;@"},gu_IN:{},he:{longDate:"dddd, d בMMMM yyyy;@",shortDate:"dd/MM/yy;@",dateTime:"dd/MM/yyyy HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},he_IL:{},hi:{longDate:"dddd, d MMMM yyyy;@",shortDate:"d-M-yy;@",dateTime:"dd-MM-yyyy h:mm:ss AM/PM;@",timeFormat:"h:mm:ss AM/PM;@"},hi_IN:{},hr:{longDate:"dddd, d. MMMM yyyy.;@",shortDate:"dd.MM.yyyy.;@",dateTime:"d.M.yyyy. HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},hr_HR:{},hu:{longDate:"yyyy. MMMM d., dddd;@",shortDate:"yyyy.MM.dd.;@",dateTime:"yyyy.MM.dd. H:mm:ss;@",timeFormat:"H:mm:ss;@"},hu_HU:{},hy:{longDate:"dddd, MMMM d, yyyy;@",shortDate:"MM/dd/yy;@",dateTime:"MMM d, yyyy HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},hy_AM:{},id:{longDate:"dddd, dd MMMM yyyy;@",shortDate:"dd/MM/yy;@",dateTime:"d MMM yyyy HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},id_ID:{},is:{longDate:"dddd, d. MMMM yyyy;@",shortDate:"d.M.yyyy;@",dateTime:"d.M.yyyy HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},is_IS:{},it:{longDate:"dddd d MMMM yyyy;@",shortDate:"dd/MM/yy;@",dateTime:"dd/MMM/yyyy HH.mm.ss;@",timeFormat:"HH.mm.ss;@"},it_CH:{longDate:"dddd, d MMMM yyyy;@",shortDate:"dd.MM.yy;@",dateTime:"d-MMM-yyyy HH.mm.ss;@"},it_IT:{},ja:{longDate:"yyyy年M月d日dddd;@",shortDate:"yy/MM/dd;@",dateTime:"yyyy/MM/dd H:mm:ss;@",timeFormat:"H:mm:ss;@"},ja_JP:{},ka:{longDate:"dddd, yyyy MMMM dd;@",shortDate:"yyyy-MM-dd;@",dateTime:"yyyy MMM d HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},ka_GE:{},kk:{longDate:'dddd, d MMMM yyyy "ж".;@',shortDate:"dd.MM.yy;@",dateTime:"dd.MM.yyyy HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},kk_KZ:{},kn:{longDate:"dddd d MMMM yyyy;@",shortDate:"d-M-yy;@",dateTime:"d MMM yyyy hh:mm:ss AM/PM;@",timeFormat:"hh:mm:ss AM/PM;@"},kn_IN:{},ko:{longDate:"yyyy년 M월 d일 dddd;@",shortDate:"yy. M. d.;@",dateTime:"yyyy. M. d. AM/PM h:mm:ss;@",timeFormat:"AM/PM h:mm:ss;@"},ko_KR:{},kok:{longDate:"dddd, yyyy MMMM dd;@",shortDate:"yyyy-MM-dd;@",dateTime:"yyyy MMM d HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},kok_IN:{},lt:{longDate:'yyyy "m". MMMM d "d".,dddd;@',shortDate:"yyyy-MM-dd;@",dateTime:"yyyy.MM.dd HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},lt_LT:{},lv:{longDate:'dddd, yyyy. "gada" d. MMMM;@',shortDate:"dd.MM.yy;@",dateTime:'yyyy. "gada" d. MMM HH:mm:ss;@',timeFormat:"HH:mm:ss;@"},lv_LV:{},mk:{longDate:"dddd, dd MMMM yyyy;@",shortDate:"dd.M.yy;@",dateTime:"dd.M.yyyy HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},mk_MK:{},ml:{longDate:"yyyy, MMMM d, dddd;@",shortDate:"dd/MM/yy;@",dateTime:"yyyy, MMM d h:mm:ss AM/PM;@",timeFormat:"h:mm:ss AM/PM;@"},ml_IN:{},mn:{longDate:"dddd, yyyy MMMM dd;@",shortDate:"yyyy-MM-dd;@",dateTime:"yyyy MMM d HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},mn_MN:{},mr:{longDate:"dddd d MMMM yyyy;@",shortDate:"d-M-yy;@",dateTime:"d MMM yyyy h-mm-ss AM/PM;@",timeFormat:"h-mm-ss AM/PM;@"},mr_IN:{},ms:{longDate:"dddd, yyyy MMMM dd;@",shortDate:"yyyy-MM-dd;@",dateTime:"yyyy MMM d HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},ms_BN:{longDate:"dd MMMM yyyy;@",dateTime:"dd/MM/yyyy H:mm:ss;@",timeFormat:"H:mm:ss;@"},ms_MY:{},mt:{longDate:'dddd, d "ta"’ MMMM yyyy;@',shortDate:"dd/MM/yyyy;@",dateTime:"dd MMM yyyy HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},mt_MT:{},nb:{longDate:"dddd d. MMMM yyyy;@",shortDate:"dd.MM.yy;@",dateTime:"d. MMM yyyy HH.mm.ss;@",timeFormat:"HH.mm.ss;@"},nb_NO:{},nl:{longDate:"dddd d MMMM yyyy;@",shortDate:"dd-MM-yy;@",dateTime:"d MMM yyyy HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},nl_BE:{shortDate:"d/MM/yy;@",dateTime:"d-MMM-yyyy HH:mm:ss;@"},nl_NL:{},nn:{longDate:"dddd d. MMMM yyyy;@",shortDate:"dd.MM.yy;@",dateTime:"d. MMM. yyyy HH.mm.ss;@",timeFormat:"HH.mm.ss;@"},nn_NO:{},pa:{longDate:"dddd, dd MMMM yyyy;@",shortDate:"dd/MM/yyyy;@",dateTime:"d MMM yyyy h:mm:ss AM/PM;@",timeFormat:"h:mm:ss AM/PM;@"},pa_IN:{},pl:{longDate:"dddd, d MMMM yyyy;@",shortDate:"dd-MM-yy;@",dateTime:"dd-MM-yyyy HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},pl_PL:{},pt:{longDate:'dddd, d "de" MMMM "de" yyyy;@',shortDate:"dd/MM/yy;@",dateTime:"dd/MM/yyyy HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},pt_BR:{},pt_PT:{dateTime:'d "de" MMM "de" yyyy HH:mm:ss;@'},ro:{longDate:"dddd, d MMMM yyyy;@",shortDate:"dd.MM.yyyy;@",dateTime:"dd.MM.yyyy, HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},ro_RO:{},ru:{longDate:'dddd, d MMMM yyyy "г".;@',shortDate:"dd.MM.yy;@",dateTime:"dd.MM.yyyy H:mm:ss;@",timeFormat:"H:mm:ss;@"},ru_RU:{},se:{longDate:"dddd, yyyy MMMM dd;@",shortDate:"yyyy-MM-dd;@",dateTime:"yyyy MMM d HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},se_NO:{},sk:{longDate:"dddd, d. MMMM yyyy;@",shortDate:"d.M.yyyy;@",dateTime:"d.M.yyyy H:mm:ss;@",timeFormat:"H:mm:ss;@"},sk_SK:{},sl:{longDate:"dddd, dd. MMMM yyyy;@",shortDate:"d. MM. yy;@",dateTime:"d. MMM. yyyy HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},sl_SI:{},sq:{longDate:"dddd, dd MMMM yyyy;@",shortDate:"yy-MM-dd;@",dateTime:"yyyy-MM-dd h.mm.ss.AM/PM;@",timeFormat:"h.mm.ss.AM/PM;@"},sq_AL:{},sr:{longDate:"dddd, dd. MMMM yyyy.;@",shortDate:"d.M.yy.;@",dateTime:"dd.MM.yyyy. HH.mm.ss;@",timeFormat:"HH.mm.ss;@"},sr_BA:{},sr_CS:{},sv:{longDate:"dddd d MMMM yyyy;@",shortDate:"yyyy-MM-dd;@",dateTime:"d MMM yyyy HH.mm.ss;@",timeFormat:"HH.mm.ss;@"},sv_FI:{},sv_SE:{},sw:{longDate:"dddd, yyyy MMMM dd;@",shortDate:"yyyy-MM-dd;@",dateTime:"yyyy MMM d HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},sw_KE:{},syr:{longDate:"dddd, yyyy MMMM dd;@",shortDate:"yyyy-MM-dd;@",dateTime:"y MMM d HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},syr_SY:{},ta:{longDate:"dddd, d MMMM, yyyy;@",shortDate:"d-M-yy;@",dateTime:"d MMM, yyyy h:mm:ss AM/PM;@",timeFormat:"h:mm:ss AM/PM;@"},ta_IN:{},te:{longDate:"dddd d MMMM yyyy;@",shortDate:"dd-MM-yy;@",dateTime:"d MMM yyyy h:mm:ss AM/PM;@",timeFormat:"h:mm:ss AM/PM;@"},te_IN:{},th:{longDate:"ddddที่ d MMMM G yyyy;@",shortDate:"d/M/yyyy;@",dateTime:"d MMM yyyy, H:mm:ss;@",timeFormat:"H:mm:ss;@"},th_TH:{},tn:{longDate:"dddd, yyyy MMMM dd;@",shortDate:"yyyy-MM-dd;@",dateTime:"yyyy MMM d HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},tn_ZA:{},tr:{longDate:"dd MMMM yyyy dddd;@",shortDate:"dd.MM.yyyy;@",dateTime:"dd MMM yyyy HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},tr_TR:{},uk:{longDate:'dddd, d MMMM yyyy "р".;@',shortDate:"dd.MM.yy;@",dateTime:"d MMM yyyy HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},uk_UA:{},uz:{longDate:"dddd, yyyy MMMM dd;@",shortDate:"yyyy-MM-dd;@",dateTime:"yyyy MMM d HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},uz_UZ:{},vi:{longDate:'dddd, "ngày" dd MMMM "năm" yyyy;@',shortDate:"dd/MM/yyyy;@",dateTime:"HH:mm:ss dd-MM-yyyy;@",timeFormat:"HH:mm:ss;@"},vi_VN:{},xh:{longDate:"dddd, yyyy MMMM dd;@",shortDate:"yyyy-MM-dd;@",dateTime:"yyyy MMM d HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},xh_ZA:{},zh:{longDate:"yyyy年M月d日dddd;@",shortDate:"yy-M-d;@",dateTime:"yyyy-M-d AM/PMhh:mm:ss;@",timeFormat:"AM/PMhh:mm:ss;@"},zh_CN:{},zh_HK:{},zh_MO:{},zh_SG:{},zh_TW:{},zu:{longDate:"dddd dd MMMM yyyy;@",shortDate:"yyyy-MM-dd;@",dateTime:"d MMM yyyy h:mm:ss AM/PM;@",timeFormat:"h:mm:ss AM/PM;@"},zu_ZA:{}},a.RESOURCE_MAP={af:{date:{dateSeparator:"-",era:["voor Christus","na Christus"],eraAbbr:["v.C.","n.C."],shortDay:["So","Ma","Di","Wo","Do","Vr","Sa"],shortMonth:["Jan","Feb","Mar","Apr","Mei","Jun","Jul","Aug","Sep","Okt","Nov","Des"],longDay:["Sondag","Maandag","Dinsdag","Woensdag","Donderdag","Vrydag","Saterdag"],longMonth:["Januarie","Februarie","Maart","April","Mei","Junie","Julie","Augustus","September","Oktober","November","Desember"]},time:{timeSeparator:":",amPm:["vm.","nm."]}},af_ZA:{date:{},time:{}},ar:{date:{dateSeparator:"/",era:["قبل الميلاد","ميلادي"],eraAbbr:["ق.م","م"],shortDay:["أحد","إثنين","ثلاثاء","أربعاء","خميس","جمعة","سبت"],shortMonth:["يناير","فبراير","مارس","أبريل","مايو","يونيو","يوليو","أغسطس","سبتمبر","أكتوبر","نوفمبر","ديسمبر"],longDay:["الأحد","الإثنين","الثلاثاء","الأربعاء","الخميس","الجمعة","السبت"],longMonth:["يناير","فبراير","مارس","أبريل","مايو","يونيو","يوليو","أغسطس","سبتمبر","أكتوبر","نوفمبر","ديسمبر"]},time:{timeSeparator:":",amPm:["ص","م"]}},ar_AE:{date:{},time:{}},ar_BH:{date:{},time:{}},ar_DZ:{date:{},time:{}},ar_EG:{date:{},time:{}},ar_IQ:{date:{},time:{}},ar_JO:{date:{shortDay:["الأحد","الاثنين","الثلاثاء","الأربعاء","الخميس","الجمعة","السبت"],shortMonth:["كانون الثاني","شباط","آذار","نيسان","أيار","حزيران","تموز","آب","أيلول","تشرين الأول","تشرين الثاني","كانون الأول"],longMonth:["كانون الثاني","شباط","آذار","نيسان","أيار","حزيران","تموز","آب","أيلول","تشرين الأول","تشرين الثاني","كانون الأول"]},time:{}},ar_KW:{date:{},time:{}},ar_LB:{date:{shortDay:["الأحد","الاثنين","الثلاثاء","الأربعاء","الخميس","الجمعة","السبت"],shortMonth:["كانون الثاني","شباط","آذار","نيسان","نوار","حزيران","تموز","آب","أيلول","تشرين الأول","تشرين الثاني","كانون الأول"],longMonth:["كانون الثاني","شباط","آذار","نيسان","نوار","حزيران","تموز","آب","أيلول","تشرين الأول","تشرين الثاني","كانون الأول"]},time:{}},ar_LY:{date:{},time:{}},ar_MA:{date:{},time:{}},ar_OM:{date:{},time:{}},ar_QA:{date:{shortDay:["الأحد","الاثنين","الثلاثاء","الأربعاء","الخميس","الجمعة","السبت"]},time:{}},ar_SA:{date:{shortDay:["الأحد","الاثنين","الثلاثاء","الأربعاء","الخميس","الجمعة","السبت"]},time:{}},ar_SY:{date:{shortDay:["الأحد","الاثنين","الثلاثاء","الأربعاء","الخميس","الجمعة","السبت"],shortMonth:["كانون الثاني","شباط","آذار","نيسان","نوار","حزيران","تموز","آب","أيلول","تشرين الأول","تشرين الثاني","كانون الأول"],longMonth:["كانون الثاني","شباط","آذار","نيسان","نوار","حزيران","تموز","آب","أيلول","تشرين الأول","تشرين الثاني","كانون الأول"]},time:{}},ar_TN:{date:{shortDay:["الأحد","الاثنين","الثلاثاء","الأربعاء","الخميس","الجمعة","السبت"]},time:{}},ar_YE:{date:{shortDay:["الأحد","الاثنين","الثلاثاء","الأربعاء","الخميس","الجمعة","السبت"]},time:{}},az:{date:{dateSeparator:"-",era:["eramızdan əvvəl","bizim eramızın"],eraAbbr:["e.ə.","b.e."],shortDay:["B.","B.E.","Ç.A.","Ç.","C.A.","C","Ş."],shortMonth:["yan","fev","mar","apr","may","iyn","iyl","avq","sen","okt","noy","dek"],longDay:["bazar","bazar ertəsi","çərşənbə axşamı","çərşənbə","cümə axşamı","cümə","şənbə"],longMonth:["Yanvar","Fevral","Mart","Aprel","May","İyun","İyul","Avqust","Sentyabr","Oktyabr","Noyabr","Dekabr"]},time:{timeSeparator:":",amPm:["AM","PM"]}},az_AZ:{date:{},time:{}},be:{date:{dateSeparator:".",era:["да н.э.","н.э."],eraAbbr:["да н.е.","н.е."],eraNarrow:["да н.э.","н.э."],shortDay:["нд","пн","аў","ср","чц","пт","сб"],shortMonth:["сту","лют","сак","кра","май","чэр","ліп","жні","вер","кас","ліс","сне"],longDay:["нядзеля","панядзелак","аўторак","серада","чацвер","пятніца","субота"],longMonth:["студзень","люты","сакавік","красавік","май","чэрвень","ліпень","жнівень","верасень","кастрычнік","лістапад","снежань"]},time:{timeSeparator:".",amPm:["да палудня","пасля палудня"]}},be_BY:{date:{},time:{}},bg:{date:{dateSeparator:".",era:["пр.Хр.","сл.Хр."],eraAbbr:["пр. н. е.","от н. е."],eraNarrow:["сл.н.е."],shortDay:["нд","пн","вт","ср","чт","пт","сб"],shortMonth:["ян.","февр.","март","апр.","май","юни","юли","авг.","септ.","окт.","ноем.","дек."],longDay:["неделя","понеделник","вторник","сряда","четвъртък","петък","събота"],longMonth:["януари","февруари","март","април","май","юни","юли","август","септември","октомври","ноември","декември"]},time:{timeSeparator:":",amPm:["пр. об.","сл. об."]}},bg_BG:{date:{},time:{}},bn:{date:{dateSeparator:"/",eraAbbr:["খৃষ্টপূর্ব","খৃষ্টাব্দ"],shortDay:["রবি","সোম","মঙ্গল","বুধ","বৃহস্পতি","শুক্র","শনি"],shortMonth:["জানুয়ারী","ফেব্রুয়ারী","মার্চ","এপ্রিল","মে","জুন","জুলাই","আগস্ট","সেপ্টেম্বর","অক্টোবর","নভেম্বর","ডিসেম্বর"],longDay:["রবিবার","সোমবার","মঙ্গলবার","বুধবার","বৃহষ্পতিবার","শুক্রবার","শনিবার"],longMonth:["জানুয়ারী","ফেব্রুয়ারী","মার্চ","এপ্রিল","মে","জুন","জুলাই","আগস্ট","সেপ্টেম্বর","অক্টোবর","নভেম্বর","ডিসেম্বর"]},time:{timeSeparator:":",amPm:["পূর্বাহ্ণ","অপরাহ্ণ"]}},bn_IN:{date:{},time:{}},bs:{date:{dateSeparator:"-",eraAbbr:["BCE","CE"],shortDay:["7","1","2","3","4","5","6"],shortMonth:["1","2","3","4","5","6","7","8","9","10","11","12"],longDay:["7","1","2","3","4","5","6"],longMonth:["1","2","3","4","5","6","7","8","9","10","11","12"]},time:{timeSeparator:":",amPm:["AM","PM"]}},bs_BA:{date:{},time:{}},ca:{date:{dateSeparator:"/",eraAbbr:["aC","dC"],shortDay:["dg.","dl.","dt.","dc.","dj.","dv.","ds."],shortMonth:["gen.","febr.","març","abr.","maig","juny","jul.","ag.","set.","oct.","nov.","des."],longDay:["diumenge","dilluns","dimarts","dimecres","dijous","divendres","dissabte"],longMonth:["gener","febrer","març","abril","maig","juny","juliol","agost","setembre","octubre","novembre","desembre"]},time:{timeSeparator:":",amPm:["a.m.","p.m."]}},ca_ES:{date:{},time:{}},cs:{date:{dateSeparator:".",eraAbbr:["př.Kr.","po Kr."],shortDay:["ne","po","út","st","čt","pá","so"],shortMonth:["1","2","3","4","5","6","7","8","9","10","11","12",],longDay:["neděle","pondělí","úterý","středa","čtvrtek","pátek","sobota"],longMonth:["ledna","února","března","dubna","května","června","července","srpna","září","října","listopadu","prosince"]},time:{timeSeparator:":",amPm:["dop.","odp."]}},cs_CZ:{date:{},time:{}},cy:{date:{dateSeparator:"-",era:["Cyn Crist","Oed Crist"],eraAbbr:["CC","OC"],eraNarrow:["C","O"],shortDay:["Sul","Llun","Maw","Mer","Iau","Gwen","Sad"],shortMonth:["Ion","Chwef","Mawrth","Ebrill","Mai","Meh","Gorff","Awst","Medi","Hyd","Tach","Rhag"],longDay:["Dydd Sul","Dydd Llun","Dydd Mawrth","Dydd Mercher","Dydd Iau","Dydd Gwener","Dydd Sadwrn"],longMonth:["Ionawr","Chwefror","Mawrth","Ebrill","Mai","Mehefin","Gorffenaf","Awst","Medi","Hydref","Tachwedd","Rhagfyr"]},time:{timeSeparator:":",amPm:["AM","PM"]}},cy_GB:{date:{},time:{}},da:{date:{dateSeparator:"/",era:["f.Kr.","e.Kr."],eraAbbr:["f.Kr.","e.Kr."],shortDay:["søn","man","tir","ons","tor","fre","lør"],shortMonth:["jan.","feb.","mar.","apr.","maj","jun.","jul.","aug.","sep.","okt.","nov.","dec."],longDay:["søndag","mandag","tirsdag","onsdag","torsdag","fredag","lørdag"],longMonth:["januar","februar","marts","april","maj","juni","juli","august","september","oktober","november","december"]},time:{timeSeparator:".",amPm:["f.m.","e.m."]}},da_DK:{date:{},time:{}},de:{date:{dateSeparator:".",era:["v. Chr.","n. Chr."],eraAbbr:["v. Chr.","n. Chr."],shortDay:["So.","Mo.","Di.","Mi.","Do.","Fr.","Sa."],shortMonth:["Jan","Feb","Mär","Apr","Mai","Jun","Jul","Aug","Sep","Okt","Nov","Dez"],longDay:["Sonntag","Montag","Dienstag","Mittwoch","Donnerstag","Freitag","Samstag"],longMonth:["Januar","Februar","März","April","Mai","Juni","Juli","August","September","Oktober","November","Dezember"]},time:{timeSeparator:":",amPm:["vorm.","nachm."]}},de_AT:{date:{shortMonth:["Jän","Feb","Mär","Apr","Mai","Jun","Jul","Aug","Sep","Okt","Nov","Dez"],longMonth:["Jänner","Februar","März","April","Mai","Juni","Juli","August","September","Oktober","November","Dezember"]},time:{}},de_CH:{date:{},time:{}},de_DE:{date:{},time:{}},de_LI:{date:{},time:{}},de_LU:{date:{},time:{}},el:{date:{dateSeparator:"/",era:["π.Χ.","μ.Χ."],eraAbbr:["π.Χ.","μ.Χ."],shortDay:["Κυρ","Δευ","Τρι","Τετ","Πεμ","Παρ","Σαβ"],shortMonth:["Ιαν","Φεβ","Μαρ","Απρ","Μαϊ","Ιουν","Ιουλ","Αυγ","Σεπ","Οκτ","Νοε","Δεκ"],longDay:["Κυριακή","Δευτέρα","Τρίτη","Τετάρτη","Πέμπτη","Παρασκευή","Σάββατο"],longMonth:["Ιανουαρίου","Φεβρουαρίου","Μαρτίου","Απριλίου","Μαΐου","Ιουνίου","Ιουλίου","Αυγούστου","Σεπτεμβρίου","Οκτωβρίου","Νοεμβρίου","Δεκεμβρίου"]},time:{timeSeparator:":",amPm:["π.μ.","μ.μ."]}},el_GR:{date:{},time:{}},en:{date:{dateSeparator:"/",era:["Before Christ","Anno Domini"],eraAbbr:["BC","AD"],eraNarrow:["B","A"],shortDay:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],shortMonth:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],longDay:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],longMonth:["January","February","March","April","May","June","July","August","September","October","November","December"]},time:{timeSeparator:":",amPm:["AM","PM"]}},en_AU:{date:{dateSeparator:"/"},time:{}},en_BZ:{date:{dateSeparator:"/"},time:{timeSeparator:":"}},en_CA:{date:{dateSeparator:"-"},time:{}},en_GB:{date:{dateSeparator:"/"},time:{timeSeparator:":"}},en_IE:{date:{dateSeparator:"/"},time:{timeSeparator:":",amPm:["a.m.","p.m."]}},en_JM:{date:{},time:{}},en_NZ:{date:{dateSeparator:"/"},time:{}},en_PH:{date:{},time:{}},en_TT:{date:{},time:{}},en_US:{date:{},time:{}},en_VI:{date:{},time:{}},en_ZA:{date:{dateSeparator:"/"},time:{}},en_ZW:{date:{dateSeparator:"/"},time:{}},es:{date:{dateSeparator:"/",era:["antes de Cristo","anno Dómini"],eraAbbr:["a.C.","d.C."],shortDay:["dom","lun","mar","mié","jue","vie","sáb"],shortMonth:["ene","feb","mar","abr","may","jun","jul","ago","sep","oct","nov","dic"],longDay:["domingo","lunes","martes","miércoles","jueves","viernes","sábado"],longMonth:["enero","febrero","marzo","abril","mayo","junio","julio","agosto","septiembre","octubre","noviembre","diciembre"]},time:{timeSeparator:":",amPm:["a.m.","p.m."]}},es_AR:{date:{},time:{amPm:["a.m.","p.m."]}},es_BO:{date:{},time:{}},es_CL:{date:{dateSeparator:"-"},time:{timeSeparator:":"}},es_CO:{date:{dateSeparator:"/"},time:{timeSeparator:":"}},es_CR:{date:{},time:{}},es_DO:{date:{},time:{}},es_EC:{date:{},time:{timeSeparator:":"}},es_ES:{date:{},time:{}},es_GT:{date:{dateSeparator:"/"},time:{}},es_HN:{date:{},time:{}},es_MX:{date:{},time:{}},es_NI:{date:{},time:{}},es_PA:{date:{dateSeparator:"/"},time:{}},es_PE:{date:{dateSeparator:"/"},time:{}},es_PR:{date:{dateSeparator:"/"},time:{}},es_PY:{date:{},time:{}},es_SV:{date:{},time:{}},es_UY:{date:{},time:{}},es_VE:{date:{},time:{}},et:{date:{dateSeparator:".",era:["enne meie aega","meie aja järgi"],eraAbbr:["e.m.a.","m.a.j."],shortDay:["P","E","T","K","N","R","L"],shortMonth:["jaan","veebr","märts","apr","mai","juuni","juuli","aug","sept","okt","nov","dets"],longDay:["pühapäev","esmaspäev","teisipäev","kolmapäev","neljapäev","reede","laupäev"],longMonth:["jaanuar","veebruar","märts","aprill","mai","juuni","juuli","august","september","oktoober","november","detsember"]},time:{timeSeparator:":",amPm:["AM","PM"]}},et_EE:{date:{},time:{}},eu:{date:{dateSeparator:"-",eraAbbr:["BCE","CE"],shortDay:["ig","al","as","az","og","or","lr"],shortMonth:["urt","ots","mar","api","mai","eka","uzt","abu","ira","urr","aza","abe"],longDay:["igandea","astelehena","asteartea","asteazkena","osteguna","ostirala","larunbata"],longMonth:["urtarrila","otsaila","martxoa","apirila","maiatza","ekaina","uztaila","abuztua","iraila","urria","azaroa","abendua"]},time:{timeSeparator:":",amPm:["AM","PM"]}},eu_ES:{date:{},time:{}},fa:{date:{dateSeparator:"/",era:["قبل از میلاد","میلادی"],eraAbbr:["ق.م.","م."],eraNarrow:["ق","م"],shortDay:["یکشنبه","دوشنبه","سهشنبه","چهارشنبه","پنجشنبه","جمعه","شنبه"],shortMonth:["ژانویهٔ","فوریهٔ","مارس","آوریل","مهٔ","ژوئن","ژوئیهٔ","اوت","سپتامبر","اکتبر","نوامبر","دسامبر"],longDay:["یکشنبه","دوشنبه","سهشنبه","چهارشنبه","پنجشنبه","جمعه","شنبه"],longMonth:["ژانویهٔ","فوریهٔ","مارس","آوریل","مهٔ","ژوئن","ژوئیهٔ","اوت","سپتامبر","اکتبر","نوامبر","دسامبر"]},time:{timeSeparator:":",amPm:["قبل از ظهر","بعد از ظهر"]}},fa_IR:{date:{},time:{}},fi:{date:{dateSeparator:".",era:["ennen Kristuksen syntymää","jälkeen Kristuksen syntymän"],eraAbbr:["eKr.","jKr."],shortDay:["su","ma","ti","ke","to","pe","la"],shortMonth:["tammikuuta","helmikuuta","maaliskuuta","huhtikuuta","toukokuuta","kesäkuuta","heinäkuuta","elokuuta","syyskuuta","lokakuuta","marraskuuta","joulukuuta"],longDay:["sunnuntaina","maanantaina","tiistaina","keskiviikkona","torstaina","perjantaina","lauantaina"],longMonth:["tammikuuta","helmikuuta","maaliskuuta","huhtikuuta","toukokuuta","kesäkuuta","heinäkuuta","elokuuta","syyskuuta","lokakuuta","marraskuuta","joulukuuta"]},time:{timeSeparator:".",amPm:["ap.","ip."]}},fi_FI:{date:{},time:{}},fo:{date:{dateSeparator:"-",era:["fyrir Krist","eftir Krist"],eraAbbr:["BCE","CE"],eraNarrow:["f.Kr.","e.Kr."],shortDay:["sun","mán","týs","mik","hós","frí","ley"],shortMonth:["jan","feb","mar","apr","mai","jun","jul","aug","sep","okt","nov","des"],longDay:["sunnudagur","mánadagur","týsdagur","mikudagur","hósdagur","fríggjadagur","leygardagur"],longMonth:["januar","februar","mars","apríl","mai","juni","juli","august","september","oktober","november","desember"]},time:{timeSeparator:":",amPm:["AM","PM"]}},fo_FO:{date:{},time:{}},fr:{date:{dateSeparator:"/",era:["avant Jésus-Christ","après Jésus-Christ"],eraAbbr:["av. J.-C.","ap. J.-C."],shortDay:["dim.","lun.","mar.","mer.","jeu.","ven.","sam."],shortMonth:["janv.","févr.","mars","avr.","mai","juin","juil.","août","sept.","oct.","nov.","déc."],longDay:["dimanche","lundi","mardi","mercredi","jeudi","vendredi","samedi"],longMonth:["janvier","février","mars","avril","mai","juin","juillet","août","septembre","octobre","novembre","décembre"]},time:{timeSeparator:":",amPm:["AM","PM"]}},fr_BE:{date:{dateSeparator:"/"},time:{}},fr_CA:{date:{dateSeparator:"-"},time:{}},fr_CH:{date:{dateSeparator:"."},time:{}},fr_FR:{date:{},time:{}},fr_LU:{date:{},time:{}},fr_MC:{date:{},time:{}},gl:{date:{dateSeparator:"/",era:["antes de Cristo","despois de Cristo"],eraAbbr:["a.C.","d.C."],shortDay:["Dom","Lun","Mar","Mér","Xov","Ven","Sáb"],shortMonth:["Xan","Feb","Mar","Abr","Mai","Xuñ","Xul","Ago","Set","Out","Nov","Dec"],longDay:["Domingo","Luns","Martes","Mércores","Xoves","Venres","Sábado"],longMonth:["Xaneiro","Febreiro","Marzo","Abril","Maio","Xuño","Xullo","Agosto","Setembro","Outubro","Novembro","Decembro"]},time:{timeSeparator:":",amPm:["AM","PM"]}},gl_ES:{date:{},time:{}},gu:{date:{dateSeparator:"-",era:["ઈસવીસન પૂર્વે","ઇસવીસન"],eraAbbr:["BCE","CE"],eraNarrow:["ઇ સ પુ","ઇસ"],shortDay:["રવિ","સોમ","મંગળ","બુધ","ગુરુ","શુક્ર","શનિ"],shortMonth:["જાન્યુ","ફેબ્રુ","માર્ચ","એપ્રિલ","મે","જૂન","જુલાઈ","ઑગસ્ટ","સપ્ટે","ઑક્ટો","નવે","ડિસે"],longDay:["રવિવાર","સોમવાર","મંગળવાર","બુધવાર","ગુરુવાર","શુક્રવાર","શનિવાર"],longMonth:["જાન્યુઆરી","ફેબ્રુઆરી","માર્ચ","એપ્રિલ","મે","જૂન","જુલાઈ","ઑગસ્ટ","સપ્ટેમ્બર","ઑક્ટ્બર","નવેમ્બર","ડિસેમ્બર"]},time:{timeSeparator:":",amPm:["am","pm"]}},gu_IN:{date:{},time:{}},he:{date:{dateSeparator:"/",era:["לפני הספירה","לספירה"],eraAbbr:["לפנה״ס","לסה״נ"],shortDay:["יום א'","יום ב'","יום ג'","יום ד'","יום ה'","יום ו'","שבת"],shortMonth:["ינו","פבר","מרס","אפר","מאי","יונ","יול","אוג","ספט","אוק","נוב","דצמ"],longDay:["יום ראשון","יום שני","יום שלישי","יום רביעי","יום חמישי","יום שישי","יום שבת"],longMonth:["ינואר","פברואר","מרס","אפריל","מאי","יוני","יולי","אוגוסט","ספטמבר","אוקטובר","נובמבר","דצמבר"]},time:{timeSeparator:":",amPm:['לפנה"צ','אחה"צ']}},he_IL:{date:{},time:{}},hi:{date:{dateSeparator:"-",eraAbbr:["ईसापूर्व","सन"],shortDay:["रवि","सोम","मंगल","बुध","गुरु","शुक्र","शनि"],shortMonth:["जनवरी","फरवरी","मार्च","अप्रैल","मई","जून","जुलाई","अगस्त","सितम्बर","अक्तूबर","नवम्बर","दिसम्बर"],longDay:["रविवार","सोमवार","मंगलवार","बुधवार","गुरुवार","शुक्रवार","शनिवार"],longMonth:["जनवरी","फरवरी","मार्च","अप्रैल","मई","जून","जुलाई","अगस्त","सितम्बर","अक्तूबर","नवम्बर","दिसम्बर"]},time:{timeSeparator:":",amPm:["AM","PM"]}},hi_IN:{date:{},time:{}},hr:{date:{dateSeparator:".",era:["Prije Krista","Poslije Krista"],eraAbbr:["pr.n.e.","AD"],shortDay:["ned","pon","uto","sri","čet","pet","sub"],shortMonth:["01.","02.","03.","04.","05.","06.","07.","08.","09.","10.","11.","12."],longDay:["nedjelja","ponedjeljak","utorak","srijeda","četvrtak","petak","subota"],longMonth:["siječnja","veljače","ožujka","travnja","svibnja","lipnja","srpnja","kolovoza","rujna","listopada","studenoga","prosinca"]},time:{timeSeparator:":",amPm:["AM","PM"]}},hr_HR:{date:{},time:{}},hu:{date:{dateSeparator:".",era:["időszámításunk előtt","időszámításunk szerint"],eraAbbr:["i. e.","i. sz."],shortDay:["V","H","K","Sze","Cs","P","Szo"],shortMonth:["jan.","febr.","márc.","ápr.","máj.","jún.","júl.","aug.","szept.","okt.","nov.","dec."],longDay:["vasárnap","hétfő","kedd","szerda","csütörtök","péntek","szombat"],longMonth:["január","február","március","április","május","június","július","augusztus","szeptember","október","november","december"]},time:{timeSeparator:":",amPm:["de.","du."]}},hu_HU:{date:{},time:{}},hy:{date:{dateSeparator:"/",eraAbbr:["Ք․Ա․","Ք․Ե․"],shortDay:["Կիր","Երկ","Երք","Չոր","Հնգ","Ուր","Շաբ"],shortMonth:["Յնր","Փտր","Մրտ","Ապր","Մյս","Յնս","Յլս","Օգս","Սեպ","Հոկ","Նոյ","Դեկ"],longDay:["Կիրակի","Երկուշաբթի","Երեքշաբթի","Չորեքշաբթի","Հինգշաբթի","Ուրբաթ","Շաբաթ"],longMonth:["Յունուար","Փետրուար","Մարտ","Ապրիլ","Մայիս","Յունիս","Յուլիս","Օգոստոս","Սեպտեմբեր","Հոկտեմբեր","Նոյեմբեր","Դեկտեմբեր"]},time:{timeSeparator:":",amPm:["Առ․","Եր․"]}},hy_AM:{date:{},time:{}},id:{date:{dateSeparator:"/",eraAbbr:["BCE","CE"],shortDay:["Min","Sen","Sel","Rab","Kam","Jum","Sab"],shortMonth:["Jan","Feb","Mar","Apr","Mei","Jun","Jul","Agu","Sep","Okt","Nov","Des"],longDay:["Minggu","Senin","Selasa","Rabu","Kamis","Jumat","Sabtu"],longMonth:["Januari","Februari","Maret","April","Mei","Juni","Juli","Agustus","September","Oktober","November","Desember"]},time:{timeSeparator:":",amPm:["AM","PM"]}},id_ID:{date:{},time:{}},is:{date:{dateSeparator:".",eraAbbr:["fyrir Krist","eftir Krist",],eraNarrow:["f.k.","e.k."],shortDay:["sun","mán","þri","mið","fim","fös","lau"],shortMonth:["jan","feb","mar","apr","maí","jún","júl","ágú","sep","okt","nóv","des"],longDay:["sunnudagur","mánudagur","þriðjudagur","miðvikudagur","fimmtudagur","föstudagur","laugardagur"],longMonth:["janúar","febrúar","mars","apríl","maí","júní","júlí","ágúst","september","október","nóvember","desember"]},time:{timeSeparator:":",amPm:["f.h.","e.h."]}},is_IS:{date:{},time:{}},it:{date:{dateSeparator:"/",era:["a.C.","d.C"],eraAbbr:["aC","dC"],shortDay:["dom","lun","mar","mer","gio","ven","sab"],shortMonth:["gen","feb","mar","apr","mag","giu","lug","ago","set","ott","nov","dic"],longDay:["domenica","lunedì","martedì","mercoledì","giovedì","venerdì","sabato"],longMonth:["gennaio","febbraio","marzo","aprile","maggio","giugno","luglio","agosto","settembre","ottobre","novembre","dicembre"]},time:{timeSeparator:".",amPm:["m.","p."]}},it_CH:{date:{dateSeparator:"."},time:{}},it_IT:{date:{},time:{}},ja:{date:{dateSeparator:"/",era:["紀元前","西暦"],eraAbbr:["紀元前","西暦"],shortDay:["日","月","火","水","木","金","土"],shortMonth:["1月","2月","3月","4月","5月","6月","7月","8月","9月","10月","11月","12月"],longDay:["日曜日","月曜日","火曜日","水曜日","木曜日","金曜日","土曜日"],longMonth:["1月","2月","3月","4月","5月","6月","7月","8月","9月","10月","11月","12月"]},time:{timeSeparator:":",amPm:["午前","午後"]}},ja_JP:{date:{},time:{}},ka:{date:{dateSeparator:"-",era:["ჩვენს წელთაღრიცხვამდე","ჩვენი წელთაღრიცხვით"],eraAbbr:["ჩვენს წელთაღრიცხვამდე","ჩვენი წელთაღრიცხვით"],eraNarrow:["ჩვენს წელთაღრიცხვამდე","ჩვენი წელთაღრიცხვით"],shortDay:["კვი","ორშ","სამ","ოთხ","ხუთ","პარ","შაბ"],shortMonth:["იან","თებ","მარ","აპრ","მაი","ივნ","ივლ","აგვ","სექ","ოქტ","ნოე","დეკ"],longDay:["კვირა","ორშაბათი","სამშაბათი","ოთხშაბათი","ხუთშაბათი","პარასკევი","შაბათი"],longMonth:["იანვარი","თებერვალი","მარტი","აპრილი","მაისი","ივნისი","ივლისი","აგვისტო","სექტემბერი","ოქტომბერი","ნოემბერი","დეკემბერი"]},time:{timeSeparator:":",amPm:["დილის","საღამოს"]}},ka_GE:{date:{},time:{}},kk:{date:{dateSeparator:".",eraAbbr:["BCE","CE"],shortDay:["жс.","дс.","сс.","ср.","бс.","жм.","сһ."],shortMonth:["қаң.","ақп.","нау.","сәу.","мам.","мау.","шіл.","там.","қыр.","қаз.","қар.","желт."],longDay:["жексені","дуйсенбі","сейсенбі","сәренбі","бейсенбі","жұма","сенбі"],longMonth:["қаңтар","ақпан","наурыз","сәуір","мамыр","маусым","шілде","тамыз","қыркүйек","қазан","қараша","желтоқсан"]},time:{timeSeparator:":",amPm:["AM","PM"]}},kk_KZ:{date:{},time:{}},kn:{date:{dateSeparator:"-",era:["ಈಸಪೂವ೯.","ಕ್ರಿಸ್ತ ಶಕ"],eraAbbr:["BCE","CE"],shortDay:["ರ.","ಸೋ.","ಮಂ.","ಬು.","ಗು.","ಶು.","ಶನಿ."],shortMonth:["ಜನವರೀ","ಫೆಬ್ರವರೀ","ಮಾರ್ಚ್","ಎಪ್ರಿಲ್","ಮೆ","ಜೂನ್","ಜುಲೈ","ಆಗಸ್ಟ್","ಸಪ್ಟೆಂಬರ್","ಅಕ್ಟೋಬರ್","ನವೆಂಬರ್","ಡಿಸೆಂಬರ್"],longDay:["ರವಿವಾರ","ಸೋಮವಾರ","ಮಂಗಳವಾರ","ಬುಧವಾರ","ಗುರುವಾರ","ಶುಕ್ರವಾರ","ಶನಿವಾರ"],longMonth:["ಜನವರೀ","ಫೆಬ್ರವರೀ","ಮಾರ್ಚ್","ಎಪ್ರಿಲ್","ಮೆ","ಜೂನ್","ಜುಲೈ","ಆಗಸ್ಟ್","ಸಪ್ಟೆಂಬರ್","ಅಕ್ಟೋಬರ್","ನವೆಂಬರ್","ಡಿಸೆಂಬರ್"]},time:{timeSeparator:":",amPm:["am","pm"]}},kn_IN:{date:{},time:{}},ko:{date:{dateSeparator:". ",era:["서력기원전","서력기원"],eraAbbr:["기원전","서기"],shortDay:["일","월","화","수","목","금","토"],shortMonth:["1월","2월","3월","4월","5월","6월","7월","8월","9월","10월","11월","12월"],longDay:["일요일","월요일","화요일","수요일","목요일","금요일","토요일"],longMonth:["1월","2월","3월","4월","5월","6월","7월","8월","9월","10월","11월","12월"]},time:{timeSeparator:":",amPm:["오전","오후"]}},ko_KR:{date:{},time:{}},kok:{date:{dateSeparator:"-",eraAbbr:["क्रिस्तपूर्व","क्रिस्तशखा"],shortDay:["रवि","सोम","मंगळ","बुध","गुरु","शुक्र","शनि"],shortMonth:["जानेवारी","फेबृवारी","मार्च","एप्रिल","मे","जून","जुलै","ओगस्ट","सेप्टेंबर","ओक्टोबर","नोव्हेंबर","डिसेंबर"],longDay:["आदित्यवार","सोमवार","मंगळार","बुधवार","गुरुवार","शुक्रवार","शनिवार"],longMonth:["जानेवारी","फेब्रुवारी","मार्च","एप्रिल","मे","जून","जुलै","ओगस्ट","सेप्टेंबर","ओक्टोबर","नोव्हेंबर","डिसेंबर"]},time:{timeSeparator:":",amPm:["म.पू.","म.नं."]}},kok_IN:{date:{},time:{}},lt:{date:{dateSeparator:"-",era:["prieš Kristų","po Kristaus"],eraAbbr:["pr. Kr.","po Kr."],shortDay:["Sk","Pr","An","Tr","Kt","Pn","Št"],shortMonth:["Sau","Vas","Kov","Bal","Geg","Bir","Lie","Rgp","Rgs","Spl","Lap","Grd"],longDay:["sekmadienis","pirmadienis","antradienis","trečiadienis","ketvirtadienis","penktadienis","šeštadienis"],longMonth:["sausio","vasario","kovo","balandžio","gegužės","birželio","liepos","rugpjūčio","rugsėjo","spalio","lapkričio","gruodžio"]},time:{timeSeparator:":",amPm:["priešpiet","popiet"]}},lt_LT:{date:{},time:{}},lv:{date:{dateSeparator:".",era:["pirms mūsu ēras","mūsu ērā"],eraAbbr:["p.m.ē.","m.ē."],eraNarrow:["p.m.ē.","m.ē."],shortDay:["Sv","Pr","Ot","Tr","Ce","Pk","Se"],shortMonth:["janv.","febr.","marts","apr.","maijs","jūn.","jūl.","aug.","sept.","okt.","nov.","dec."],longDay:["svētdiena","pirmdiena","otrdiena","trešdiena","ceturtdiena","piektdiena","sestdiena"],longMonth:["janvāris","februāris","marts","aprīlis","maijs","jūnijs","jūlijs","augusts","septembris","oktobris","novembris","decembris"]},time:{timeSeparator:":",amPm:["AM","PM"]}},lv_LV:{date:{},time:{}},mk:{date:{dateSeparator:".",eraAbbr:["пр.н.е.","ае."],shortDay:["нед.","пон.","вт.","сре.","чет.","пет.","саб."],shortMonth:["јан.","фев.","мар.","апр.","мај","јун.","јул.","авг.","септ.","окт.","ноем.","декем."],longDay:["недела","понеделник","вторник","среда","четврток","петок","сабота"],longMonth:["јануари","февруари","март","април","мај","јуни","јули","август","септември","октомври","ноември","декември"]},time:{timeSeparator:":",amPm:["претпладне","попладне"]}},mk_MK:{date:{},time:{}},ml:{date:{dateSeparator:"/",era:["ക്രിസ്തുവിനു് മുമ്പ്","ക്രിസ്തുവിന് പിന്പ്"],eraAbbr:["ക്രി.മു.","ക്രി.പി."],eraNarrow:["ക്രി.മു.","ക്രി.പി."],shortDay:["ഞായര്","തിങ്കള്","ചൊവ്വ","ബുധന്","വ്യാഴം","വെള്ളി","ശനി"],shortMonth:["ജനു","ഫെബ്രു","മാര്","ഏപ്രി","മേയ്","ജൂണ്","ജൂലൈ","ഓഗ","സെപ്റ്റം","ഒക്ടോ","നവം","ഡിസം"],longDay:["ഞായറാഴ്ച","തിങ്കളാഴ്ച","ചൊവ്വാഴ്ച","ബുധനാഴ്ച","വ്യാഴാഴ്ച","വെള്ളിയാഴ്ച","ശനിയാഴ്ച"],longMonth:["ജനുവരി","ഫെബ്രുവരി","മാര്ച്ച്","ഏപ്രില്","മേയ്","ജൂണ്","ജൂലൈ","ഓഗസ്റ്റ്","സെപ്റ്റംബര്","ഒക്ടോബര്","നവംബര്","ഡിസംബര്"]},time:{timeSeparator:":",amPm:["am","pm"]}},ml_IN:{date:{},time:{}},mn:{date:{dateSeparator:"-",era:["манай эриний өмнөх","манай эриний"],eraAbbr:["BCE","CE"],shortDay:["1","2","3","4","5","6","7"],shortMonth:["1","2","3","4","5","6","7","8","9","10","11","12"],longDay:["1","2","3","4","5","6","7"],longMonth:["1","2","3","4","5","6","7","8","9","10","11","12"]},time:{timeSeparator:":",amPm:["AM","PM"]}},mn_MN:{date:{},time:{}},mr:{date:{dateSeparator:"-",era:["ईसवीसनपूर्व","ईसवीसन"],eraAbbr:["ई.स.पू.","ई.स."],shortDay:["रवि","सोम","मंगळ","बुध","गुरु","शुक्र","शनि"],shortMonth:["जानेवारी","फेब्रुवारी","मार्च","एप्रिल","मे","जून","जुलै","ऑगस्ट","सप्टेंबर","ऑक्टोबर","नोव्हेंबर","डिसेंबर"],longDay:["रविवार","सोमवार","मंगळवार","बुधवार","गुरुवार","शुक्रवार","शनिवार"],longMonth:["जानेवारी","फेब्रुवारी","मार्च","एप्रिल","मे","जून","जुलै","ऑगस्ट","सप्टेंबर","ऑक्टोबर","नोव्हेंबर","डिसेंबर"]},time:{timeSeparator:"-",amPm:["am","pm"]}},mr_IN:{date:{},time:{}},ms:{date:{dateSeparator:"-",eraAbbr:["BCE","CE"],shortDay:["Ahd","Isn","Sel","Rab","Kha","Jum","Sab"],shortMonth:["Jan","Feb","Mac","Apr","Mei","Jun","Jul","Ogos","Sep","Okt","Nov","Dis"],longDay:["Ahad","Isnin","Selasa","Rabu","Khamis","Jumaat","Sabtu"],longMonth:["Januari","Februari","Mac","April","Mei","Jun","Julai","Ogos","September","Oktober","November","Disember"]},time:{timeSeparator:":",amPm:["AM","PM"]}},ms_BN:{date:{},time:{timeSeparator:":"}},ms_MY:{date:{},time:{}},mt:{date:{dateSeparator:"/",era:["Qabel Kristu","Wara Kristu"],eraAbbr:["QK","WK"],shortDay:["Ħad","Tne","Tli","Erb","Ħam","Ġim","Sib"],shortMonth:["Jan","Fra","Mar","Apr","Mej","Ġun","Lul","Aww","Set","Ott","Nov","Diċ"],longDay:["Il-Ħadd","It-Tnejn","It-Tlieta","L-Erbgħa","Il-Ħamis","Il-Ġimgħa","Is-Sibt"],longMonth:["Jannar","Frar","Marzu","April","Mejju","Ġunju","Lulju","Awwissu","Settembru","Ottubru","Novembru","Diċembru"]},time:{timeSeparator:":",amPm:["QN","WN"]}},mt_MT:{date:{},time:{}},nb:{date:{dateSeparator:".",era:["f.Kr.","e.Kr."],eraAbbr:["f.Kr.","e.Kr."],shortDay:["søn.","man.","tir.","ons.","tor.","fre.","lør."],shortMonth:["jan.","feb.","mars","apr.","mai","juni","juli","aug.","sep.","okt.","nov.","des."],longDay:["søndag","mandag","tirsdag","onsdag","torsdag","fredag","lørdag"],longMonth:["januar","februar","mars","april","mai","juni","juli","august","september","oktober","november","desember"]},time:{timeSeparator:".",amPm:["AM","PM"]}},nb_NO:{date:{},time:{}},nl:{date:{dateSeparator:"-",era:["Voor Christus","Anno Domini"],eraAbbr:["v. Chr.","n. Chr."],shortDay:["zo","ma","di","wo","do","vr","za"],shortMonth:["jan.","feb.","mrt.","apr.","mei","jun.","jul.","aug.","sep.","okt.","nov.","dec."],longDay:["zondag","maandag","dinsdag","woensdag","donderdag","vrijdag","zaterdag"],longMonth:["januari","februari","maart","april","mei","juni","juli","augustus","september","oktober","november","december"]},time:{timeSeparator:":",amPm:["AM","PM"]}},nl_BE:{date:{dateSeparator:"/"},time:{}},nl_NL:{date:{},time:{}},nn:{date:{dateSeparator:".",era:["f.Kr.","e.Kr."],eraAbbr:["f.Kr.","e.Kr."],shortDay:["sø.","må.","ty.","on.","to.","fr.","la."],shortMonth:["jan","feb","mar","apr","mai","jun","jul","aug","sep","okt","nov","des"],longDay:["søndag","måndag","tysdag","onsdag","torsdag","fredag","laurdag"],longMonth:["januar","februar","mars","april","mai","juni","juli","august","september","oktober","november","desember"]},time:{timeSeparator:".",amPm:["formiddag","ettermiddag"]}},nn_NO:{date:{},time:{}},pa:{date:{dateSeparator:"/",era:["ਈਸਾਪੂਰਵ","ਸੰਨ"],eraAbbr:["BCE","CE"],shortDay:["ਐਤ.","ਸੋਮ.","ਮੰਗਲ.","ਬੁਧ.","ਵੀਰ.","ਸ਼ੁਕਰ.","ਸ਼ਨੀ."],shortMonth:["ਜਨਵਰੀ","ਫ਼ਰਵਰੀ","ਮਾਰਚ","ਅਪ੍ਰੈਲ","ਮਈ","ਜੂਨ","ਜੁਲਾਈ","ਅਗਸਤ","ਸਤੰਬਰ","ਅਕਤੂਬਰ","ਨਵੰਬਰ","ਦਸੰਬਰ"],longDay:["ਐਤਵਾਰ","ਸੋਮਵਾਰ","ਮੰਗਲਵਾਰ","ਬੁਧਵਾਰ","ਵੀਰਵਾਰ","ਸ਼ੁੱਕਰਵਾਰ","ਸ਼ਨੀਚਰਵਾਰ"],longMonth:["ਜਨਵਰੀ","ਫ਼ਰਵਰੀ","ਮਾਰਚ","ਅਪ੍ਰੈਲ","ਮਈ","ਜੂਨ","ਜੁਲਾਈ","ਅਗਸਤ","ਸਤੰਬਰ","ਅਕਤੂਬਰ","ਨਵੰਬਰ","ਦਸੰਬਰ"]},time:{timeSeparator:":",amPm:["ਸਵੇਰੇ","ਸ਼ਾਮ"]}},pa_IN:{date:{},time:{}},pl:{date:{dateSeparator:"-",era:["p.n.e.","n.e."],eraAbbr:["p.n.e.","n.e."],shortDay:["niedz.","pon.","wt.","śr.","czw.","pt.","sob."],shortMonth:["sty","lut","mar","kwi","maj","cze","lip","sie","wrz","paź","lis","gru"],longDay:["niedziela","poniedziałek","wtorek","środa","czwartek","piątek","sobota"],longMonth:["stycznia","lutego","marca","kwietnia","maja","czerwca","lipca","sierpnia","września","października","listopada","grudnia"]},time:{timeSeparator:":",amPm:["AM","PM"]}},pl_PL:{date:{},time:{}},pt:{date:{dateSeparator:"/",era:["Antes de Cristo","Ano do Senhor"],eraAbbr:["a.C.","d.C."],shortDay:["dom","seg","ter","qua","qui","sex","sáb"],shortMonth:["jan","fev","mar","abr","mai","jun","jul","ago","set","out","nov","dez"],longDay:["domingo","segunda-feira","terça-feira","quarta-feira","quinta-feira","sexta-feira","sábado"],longMonth:["janeiro","fevereiro","março","abril","maio","junho","julho","agosto","setembro","outubro","novembro","dezembro"]},time:{timeSeparator:":",amPm:["AM","PM"]}},pt_BR:{date:{},time:{}},pt_PT:{date:{shortMonth:["Jan","Fev","Mar","Abr","Mai","Jun","Jul","Ago","Set","Out","Nov","Dez"],longMonth:["Janeiro","Fevereiro","Março","Abril","Maio","Junho","Julho","Agosto","Setembro","Outubro","Novembro","Dezembro"]},time:{amPm:["Antes do meio-dia","Depois do meio-dia"]}},ro:{date:{dateSeparator:".",era:["înainte de Hristos","după Hristos"],eraAbbr:["î.Hr.","d.Hr."],shortDay:["Du","Lu","Ma","Mi","Jo","Vi","Sâ"],shortMonth:["ian.","feb.","mar.","apr.","mai","iun.","iul.","aug.","sept.","oct.","nov.","dec."],longDay:["duminică","luni","marți","miercuri","joi","vineri","sâmbătă"],longMonth:["ianuarie","februarie","martie","aprilie","mai","iunie","iulie","august","septembrie","octombrie","noiembrie","decembrie"]},time:{timeSeparator:":",amPm:["AM","PM"]}},ro_RO:{date:{},time:{}},ru:{date:{dateSeparator:".",era:["до н.э.","н.э."],eraAbbr:["до н.э.","н.э."],shortDay:["Вс","Пн","Вт","Ср","Чт","Пт","Сб"],shortMonth:["янв.","февр.","марта","апр.","мая","июня","июля","авг.","сент.","окт.","нояб.","дек."],longDay:["воскресенье","понедельник","вторник","среда","четверг","пятница","суббота"],longMonth:["января","февраля","марта","апреля","мая","июня","июля","августа","сентября","октября","ноября","декабря"]},time:{timeSeparator:":",amPm:["AM","PM"]}},ru_RU:{date:{},time:{}},se:{date:{dateSeparator:"-",era:["ovdal Kristtusa","maŋŋel Kristtusa"],eraAbbr:["BCE","CE"],eraNarrow:["o.Kr.","m.Kr."],shortDay:["1","2","3","4","5","6","7"],shortMonth:["1","2","3","4","5","6","7","8","9","10","11","12"],longDay:["1","2","3","4","5","6","7"],longMonth:["1","2","3","4","5","6","7","8","9","10","11","12"]},time:{timeSeparator:":",amPm:["AM","PM"]}},se_NO:{date:{},time:{}},sk:{date:{dateSeparator:".",eraAbbr:["pred n.l.","n.l."],shortDay:["ne","po","ut","st","št","pi","so"],shortMonth:["jan","feb","mar","apr","máj","jún","júl","aug","sep","okt","nov","dec"],longDay:["nedeľa","pondelok","utorok","streda","štvrtok","piatok","sobota"],longMonth:["januára","februára","marca","apríla","mája","júna","júla","augusta","septembra","októbra","novembra","decembra"]},time:{timeSeparator:":",amPm:["dopoludnia","popoludní"]}},sk_SK:{date:{},time:{}},sl:{date:{dateSeparator:". ",era:["pred našim štetjem","naše štetje"],eraAbbr:["pr. n. št.","po Kr."],shortDay:["ned","pon","tor","sre","čet","pet","sob"],shortMonth:["jan","feb","mar","apr","maj","jun","jul","avg","sep","okt","nov","dec"],longDay:["nedelja","ponedeljek","torek","sreda","četrtek","petek","sobota"],longMonth:["januar","februar","marec","april","maj","junij","julij","avgust","september","oktober","november","december"]},time:{timeSeparator:":",amPm:["dop.","pop."]}},sl_SI:{date:{},time:{}},sq:{date:{dateSeparator:"-",eraAbbr:["p.e.r.","n.e.r."],shortDay:["Die","Hën","Mar","Mër","Enj","Pre","Sht"],shortMonth:["Jan","Shk","Mar","Pri","Maj","Qer","Kor","Gsh","Sht","Tet","Nën","Dhj"],longDay:["e diel","e hënë","e martë","e mërkurë","e enjte","e premte","e shtunë"],longMonth:["janar","shkurt","mars","prill","maj","qershor","korrik","gusht","shtator","tetor","nëntor","dhjetor"]},time:{timeSeparator:".",amPm:["PD","MD"]}},sq_AL:{date:{},time:{}},sr:{date:{dateSeparator:".",era:["Пре нове ере","Нове ере"],eraAbbr:["п. н. е.","н. е"],eraNarrow:["п.н.е.","н.е."],shortDay:["нед","пон","уто","сре","чет","пет","суб"],shortMonth:["јан","феб","мар","апр","мај","јун","јул","авг","сеп","окт","нов","дец"],longDay:["недеља","понедељак","уторак","среда","четвртак","петак","субота"],longMonth:["јануар","фебруар","март","април","мај","јун","јул","август","септембар","октобар","новембар","децембар"]},time:{timeSeparator:".",amPm:["пре подне","поподне"]}},sr_BA:{date:{},time:{}},sr_CS:{date:{},time:{}},sv:{date:{dateSeparator:"-",era:["före Kristus","efter Kristus"],eraAbbr:["f.Kr.","e.Kr."],shortDay:["sön","mån","tis","ons","tors","fre","lör"],shortMonth:["jan","feb","mar","apr","maj","jun","jul","aug","sep","okt","nov","dec"],longDay:["söndag","måndag","tisdag","onsdag","torsdag","fredag","lördag"],longMonth:["januari","februari","mars","april","maj","juni","juli","augusti","september","oktober","november","december"]},time:{timeSeparator:".",amPm:["fm","em"]}},sv_FI:{date:{},time:{}},sv_SE:{date:{},time:{}},sw:{date:{dateSeparator:"-",era:["Kabla ya Kristo","Baada ya Kristo"],eraAbbr:["KK","BK"],shortDay:["Jpi","Jtt","Jnn","Jtn","Alh","Iju","Jmo"],shortMonth:["Jan","Feb","Mac","Apr","Mei","Jun","Jul","Ago","Sep","Okt","Nov","Des"],longDay:["Jumapili","Jumatatu","Jumanne","Jumatano","Alhamisi","Ijumaa","Jumamosi"],longMonth:["Januari","Februari","Machi","Aprili","Mei","Juni","Julai","Agosti","Septemba","Oktoba","Novemba","Desemba"]},time:{timeSeparator:":",amPm:["AM","PM"]}},sw_KE:{date:{},time:{}},syr:{date:{dateSeparator:"-",shortDay:["1","2","3","4","5","6","7"],shortMonth:["ܟܢ ܒ","ܫܒܛ","ܐܕܪ","ܢܝܣܢ","ܐܝܪ","ܚܙܝܪܢ","ܬܡܘܙ","ܐܒ","ܐܝܠܘܠ","ܬܫ ܐ","ܬܫ ܒ","ܟܢ ܐ"],longDay:["1","2","3","4","5","6","7"],longMonth:["ܟܢ ܒ","ܫܒܛ","ܐܕܪ","ܢܝܣܢ","ܐܝܪ","ܚܙܝܪܢ","ܬܡܘܙ","ܐܒ","ܐܝܠܘܠ","ܬܫ ܐ","ܬܫ ܒ","ܟܢ ܐ"]},time:{timeSeparator:":",amPm:["AM","PM"]}},syr_SY:{date:{},time:{}},ta:{date:{dateSeparator:"-",era:["கிறிஸ்துவுக்கு முன்","அனோ டோமினி"],eraAbbr:["கிமு","கிபி"],shortDay:["ஞா","தி","செ","பு","வி","வெ","ச"],shortMonth:["ஜன.","பிப்.","மார்.","ஏப்.","மே","ஜூன்","ஜூலை","ஆக.","செப்.","அக்.","நவ.","டிச."],longDay:["ஞாயிறு","திங்கள்","செவ்வாய்","புதன்","வியாழன்","வெள்ளி","சனி"],longMonth:["ஜனவரி","பிப்ரவரி","மார்ச்","ஏப்ரல்","மே","ஜூன்","ஜூலை","ஆகஸ்ட்","செப்டம்பர்","அக்டோபர்","நவம்பர்","டிசம்பர்"]},time:{timeSeparator:":",amPm:["am","pm"]}},ta_IN:{date:{},time:{}},te:{date:{dateSeparator:"-",era:["ఈసాపూర్వ.","సన్."],eraAbbr:["BCE","CE"],shortDay:["ఆది","సోమ","మంగళ","బుధ","గురు","శుక్ర","శని"],shortMonth:["జనవరి","ఫిబ్రవరి","మార్చి","ఏప్రిల్","మే","జూన్","జూలై","ఆగస్టు","సెప్టెంబర్","అక్టోబర్","నవంబర్","డిసెంబర్"],longDay:["ఆదివారం","సోమవారం","మంగళవారం","బుధవారం","గురువారం","శుక్రవారం","శనివారం"],longMonth:["జనవరి","ఫిబ్రవరి","మార్చి","ఏప్రిల్","మే","జూన్","జూలై","ఆగస్టు","సెప్టెంబర్","అక్టోబర్","నవంబర్","డిసెంబర్"]},time:{timeSeparator:":",amPm:["am","pm"]}},te_IN:{date:{},time:{}},th:{date:{dateSeparator:"/",era:["ปีก่อนคริสต์ศักราช","คริสต์ศักราช"],eraAbbr:["ปีก่อน ค.ศ.","ค.ศ."],eraNarrow:["ก่อน ค.ศ."],shortDay:["อา.","จ.","อ.","พ.","พฤ.","ศ.","ส."],shortMonth:["ม.ค.","ก.พ.","มี.ค.","เม.ย.","พ.ค.","มิ.ย.","ก.ค.","ส.ค.","ก.ย.","ต.ค.","พ.ย.","ธ.ค."],longDay:["วันอาทิตย์","วันจันทร์","วันอังคาร","วันพุธ","วันพฤหัสบดี","วันศุกร์","วันเสาร์"],longMonth:["มกราคม","กุมภาพันธ์","มีนาคม","เมษายน","พฤษภาคม","มิถุนายน","กรกฎาคม","สิงหาคม","กันยายน","ตุลาคม","พฤศจิกายน","ธันวาคม"]},time:{timeSeparator:":",amPm:["ก่อนเที่ยง","หลังเที่ยง"]}},th_TH:{date:{},time:{}},tn:{date:{dateSeparator:"-",era:["BC","AD"],eraAbbr:["BCE","CE"],shortDay:["1","2","3","4","5","6","7"],shortMonth:["1","2","3","4","5","6","7","8","9","10","11","12"],longDay:["1","2","3","4","5","6","7"],longMonth:["1","2","3","4","5","6","7","8","9","10","11","12"]},time:{timeSeparator:":",amPm:["AM","PM"]}},tn_ZA:{date:{},time:{}},tr:{date:{dateSeparator:".",era:["Milattan Önce","Milattan Sonra"],eraAbbr:["MÖ","MS"],shortDay:["Paz","Pzt","Sal","Çar","Per","Cum","Cmt"],shortMonth:["Oca","Şub","Mar","Nis","May","Haz","Tem","Ağu","Eyl","Eki","Kas","Ara"],longDay:["Pazar","Pazartesi","Salı","Çarşamba","Perşembe","Cuma","Cumartesi"],longMonth:["Ocak","Şubat","Mart","Nisan","Mayıs","Haziran","Temmuz","Ağustos","Eylül","Ekim","Kasım","Aralık"]},time:{timeSeparator:":",amPm:["AM","PM"]}},tr_TR:{date:{},time:{}},uk:{date:{dateSeparator:".",era:["до нашої ери","нашої ери"],eraAbbr:["до н.е.","н.е."],shortDay:["Нд","Пн","Вт","Ср","Чт","Пт","Сб"],shortMonth:["січ.","лют.","бер.","квіт.","трав.","черв.","лип.","серп.","вер.","жовт.","лист.","груд."],longDay:["Неділя","Понеділок","Вівторок","Середа","Четвер","Пʼятниця","Субота"],longMonth:["січня","лютого","березня","квітня","травня","червня","липня","серпня","вересня","жовтня","листопада","грудня"]},time:{timeSeparator:":",amPm:["дп","пп"]}},uk_UA:{date:{},time:{}},uz:{date:{dateSeparator:"-",eraAbbr:["BCE","CE"],shortDay:["1","2","3","4","5","6","7"],shortMonth:["1","2","3","4","5","6","7","8","9","10","11","12"],longDay:["1","2","3","4","5","6","7"],longMonth:["1","2","3","4","5","6","7","8","9","10","11","12"]},time:{timeSeparator:":",amPm:["AM","PM"]}},uz_UZ:{date:{},time:{}},vi:{date:{dateSeparator:"/",eraAbbr:["tr. CN","sau CN"],shortDay:["CN","Th 2","Th 3","Th 4","Th 5","Th 6","Th 7"],shortMonth:["thg 1","thg 2","thg 3","thg 4","thg 5","thg 6","thg 7","thg 8","thg 9","thg 10","thg 11","thg 12"],longDay:["Chủ nhật","Thứ hai","Thứ ba","Thứ tư","Thứ năm","Thứ sáu","Thứ bảy"],longMonth:["tháng một","tháng hai","tháng ba","tháng tư","tháng năm","tháng sáu","tháng bảy","tháng tám","tháng chín","tháng mười","tháng mười một","tháng mười hai"]},time:{timeSeparator:":",amPm:["SA","CH"]}},vi_VN:{date:{},time:{}},xh:{date:{dateSeparator:"-",era:["BC","umnyaka wokuzalwa kukaYesu"],eraAbbr:["BCE","CE"],shortDay:["1","2","3","4","5","6","7"],shortMonth:["1","2","3","4","5","6","7","8","9","10","11","12"],longDay:["1","2","3","4","5","6","7"],longMonth:["1","2","3","4","5","6","7","8","9","10","11","12"]},time:{timeSeparator:":",amPm:["AM","PM"]}},xh_ZA:{date:{},time:{}},zh:{date:{dateSeparator:"-",era:["公元前","公元"],eraAbbr:["公元前","公元"],shortDay:["周日","周一","周二","周三","周四","周五","周六"],shortMonth:["1月","2月","3月","4月","5月","6月","7月","8月","9月","10月","11月","12月"],longDay:["星期日","星期一","星期二","星期三","星期四","星期五","星期六"],longMonth:["1月","2月","3月","4月","5月","6月","7月","8月","9月","10月","11月","12月"]},time:{timeSeparator:":",amPm:["上午","下午"]}},zh_CN:{date:{},time:{}},zh_HK:{date:{},time:{}},zh_MO:{date:{},time:{}},zh_SG:{date:{},time:{}},zh_TW:{date:{},time:{}},zu:{date:{dateSeparator:"-",eraAbbr:["BC","AD"],shortDay:["Son","Mso","Bil","Tha","Sin","Hla","Mgq"],shortMonth:["Jan","Feb","Mas","Apr","Mey","Jun","Jul","Aga","Sep","Okt","Nov","Dis"],longDay:["Sonto","Msombuluko","Lwesibili","Lwesithathu","uLwesine","Lwesihlanu","Mgqibelo"],longMonth:["Januwari","Februwari","Mashi","Apreli","Meyi","Juni","Julayi","Agasti","Septhemba","Okthoba","Novemba","Disemba"]},time:{timeSeparator:":",amPm:["AM","PM"]}},zu_ZA:{date:{},time:{}}};a.formatExist=function(b,c){return(b&&c&&a.DEFAULT_FORMAT_STRING[b]&&a.DEFAULT_FORMAT_STRING[b][c])};a.getDefaultDateFormat=function(b,c){return a.DEFAULT_FORMAT_STRING[b][c]};a.getShortDay=function(b){if(b){if(a.resourceExist(b,a.KEY_TYPE_DATE,a.KEY_TOKEN_SHORT_DAY)){return a.getDateResource(b,a.KEY_TYPE_DATE,a.KEY_TOKEN_SHORT_DAY)}else{return null}}return a.getAppropriateDateResource(a.KEY_TYPE_DATE,a.KEY_TOKEN_SHORT_DAY)};a.getLongDay=function(b){if(b){if(a.resourceExist(b,a.KEY_TYPE_DATE,a.KEY_TOKEN_LONG_DAY)){return a.getDateResource(b,a.KEY_TYPE_DATE,a.KEY_TOKEN_LONG_DAY)}else{return null}}return a.getAppropriateDateResource(a.KEY_TYPE_DATE,a.KEY_TOKEN_LONG_DAY)};a.getShortMonth=function(b){if(b){if(a.resourceExist(b,a.KEY_TYPE_DATE,a.KEY_TOKEN_SHORT_MONTH)){return a.getDateResource(b,a.KEY_TYPE_DATE,a.KEY_TOKEN_SHORT_MONTH)}else{return null}}return a.getAppropriateDateResource(a.KEY_TYPE_DATE,a.KEY_TOKEN_SHORT_MONTH)};a.getLongMonth=function(b){if(b){if(a.resourceExist(b,a.KEY_TYPE_DATE,a.KEY_TOKEN_LONG_MONTH)){return a.getDateResource(b,a.KEY_TYPE_DATE,a.KEY_TOKEN_LONG_MONTH)}else{return null}}return a.getAppropriateDateResource(a.KEY_TYPE_DATE,a.KEY_TOKEN_LONG_MONTH)};a.getDateSeparator=function(b){if(b){if(a.resourceExist(b,a.KEY_TYPE_DATE,a.KEY_DATE_SEPARATOR)){return a.getDateResource(b,a.KEY_TYPE_DATE,a.KEY_DATE_SEPARATOR).toString()}else{return null}}return a.getAppropriateDateResource(a.KEY_TYPE_DATE,a.KEY_DATE_SEPARATOR).toString()};a.getTimeSeparator=function(b){if(b){if(a.resourceExist(b,a.KEY_TYPE_TIME,a.KEY_TIME_SEPARATOR)){return a.getDateResource(b,a.KEY_TYPE_TIME,a.KEY_TIME_SEPARATOR).toString()}else{return null}}return a.getAppropriateDateResource(a.KEY_TYPE_TIME,a.KEY_TIME_SEPARATOR).toString()};a.getAmPmToken=function(b){if(b){if(a.resourceExist(b,a.KEY_TYPE_TIME,a.KEY_TOKEN_AM_PM)){return a.getDateResource(b,a.KEY_TYPE_TIME,a.KEY_TOKEN_AM_PM)}else{return null}}return a.getAppropriateDateResource(a.KEY_TYPE_TIME,a.KEY_TOKEN_AM_PM)};a.getAbbrevEraString=function(b){if(b){if(a.resourceExist(b,a.KEY_TYPE_DATE,a.KEY_TOKEN_ABBREV_ERA)){return a.getDateResource(b,a.KEY_TYPE_DATE,a.KEY_TOKEN_ABBREV_ERA)}else{return null}}return a.getAppropriateDateResource(a.KEY_TYPE_DATE,a.KEY_TOKEN_ABBREV_ERA)};a.getDefaultShorDateFormat=function(b){if(b){if(a.formatExist(b,a.FORMAT_TYPE_SHORTDATE)){return a.getDefaultDateFormat(b,a.FORMAT_TYPE_SHORTDATE).toString()}else{return""}}return a.getAppropriateDateFormat(a.FORMAT_TYPE_SHORTDATE).toString()};a.getDefaultLongDateFormat=function(b){if(b){if(a.formatExist(b,a.FORMAT_TYPE_LONGDATE)){return a.getDefaultDateFormat(b,a.FORMAT_TYPE_LONGDATE).toString()}else{return null}}return a.getAppropriateDateFormat(a.FORMAT_TYPE_LONGDATE)};a.getDefaultDateTimeFormat=function(b){if(b){if(a.formatExist(b,a.FORMAT_TYPE_DATE_TIME)){return a.getDefaultDateFormat(b,a.FORMAT_TYPE_DATE_TIME).toString()}else{return null}}return a.getAppropriateDateFormat(a.FORMAT_TYPE_DATE_TIME).toString()};a.getDefaultTimeFormat=function(b){if(b){if(a.formatExist(b,a.FORMAT_TYPE_TIME)){return a.getDefaultDateFormat(b,a.FORMAT_TYPE_TIME).toString()}else{return null}}return a.getAppropriateDateFormat(a.FORMAT_TYPE_TIME).toString()};a.getAppropriateDateFormat=function(d){var e=sap.common.globalization.GlobalizationPreference.getInstance().pvl();if(a.formatExist(e,d)){return a.getDefaultDateFormat(e,d).toString()}var c=sap.common.globalization.GlobalizationPreference.getInstance().pvlIsoLanguageCode();if(a.formatExist(c,d)){return a.getDefaultDateFormat(c,d).toString()}var f=sap.common.globalization.GlobalizationPreference.getInstance().documentLocale();if(a.formatExist(f,d)){return a.getDefaultDateFormat(f,d).toString()}var b=sap.common.globalization.GlobalizationPreference.getInstance().documentIsoLanguageCode();if(a.formatExist(b,d)){return a.getDefaultDateFormat(b,d).toString()}return a.getDefaultDateFormat("en",d).toString()};a.getAppropriateDateResource=function(e,b){var f=sap.common.globalization.GlobalizationPreference.getInstance().pvl();if(a.resourceExist(f,e,b)){return a.getDateResource(f,e,b)}var d=sap.common.globalization.GlobalizationPreference.getInstance().pvlIsoLanguageCode();if(a.resourceExist(d,e,b)){return a.getDateResource(d,e,b)}var g=sap.common.globalization.GlobalizationPreference.getInstance().documentLocale();if(a.resourceExist(g,e,b)){return a.getDateResource(g,e,b)}var c=sap.common.globalization.GlobalizationPreference.getInstance().documentIsoLanguageCode();if(a.resourceExist(c,e,b)){return a.getDateResource(c,e,b)}return a.getDateResource("en",e,b)};a.resourceExist=function(b,d,c){return(b&&d&&c&&a.RESOURCE_MAP[b]&&a.RESOURCE_MAP[b][d]&&a.RESOURCE_MAP[b][d][c])};a.getDateResource=function(b,d,c){return a.RESOURCE_MAP[b][d][c]}})();(function(){sap.common.globalization.declare("sap.common.globalization.GlobalizationNumericUtil");sap.common.globalization.GlobalizationNumericUtil=function(){this.__className="sap.common.globalization.GlobalizationNumericUtil"};sap.common.globalization.GlobalizationNumericUtil.isTwoDigitGroupingCountry=function(a){switch(a){case"bn":case"bn_IN":case"gu":case"gu_IN":case"hi":case"hi_IN":case"kn":case"kn_IN":case"kok":case"kok_IN":case"ml":case"ml_IN":case"mr":case"mr_IN":case"pa":case"pa_IN":case"ta":case"ta_IN":case"te":case"te_IN":return true;default:return false}}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FLocalization");sap.common.globalization.require("sap.common.globalization.defaultFormat.DateParseLocaleInfoImpl");sap.common.globalization.require("sap.common.globalization.defaultFormat.DateDisplayLocaleInfoImpl");sap.common.globalization.require("sap.common.globalization.defaultFormat.NumericDisplayLocaleInfoImpl");sap.common.globalization.require("sap.common.globalization.defaultFormat.NumericParseLocaleInfoImpl");sap.common.globalization.require("sap.common.globalization.GlobalizationPreference");sap.common.globalization.require("sap.common.globalization.utils.StringUtil");sap.common.globalization.require("sap.common.globalization.GlobalizationDateConstant");sap.common.globalization.require("sap.common.globalization.GlobalizationNumericConstant");sap.common.globalization.require("sap.common.globalization.NumericFormatManager");sap.common.globalization.numericFormat.FLocalization=function(){this.__className="sap.common.globalization.numericFormat.FLocalization";this._setDisplayLocaleInfo();this._numericParseLocaleInfo=null;this._numericDisplayLocaleInfo=null;this._dateParseLocaleInfo=null;this._dateDisplayLocaleInfo=null};var a=sap.common.globalization.numericFormat.FLocalization;a._defaultLocale="en";a._DayStrings=null;a._shortDayStrings=null;a._MonthStrings=null;a._shortMonthStrings=null;a._DateTimeCodes=null;a._NumericStrings=null;a._DateTimeStrings=null;a._CurrencySymbol=null;a._SAPCurrencySymbol=null;a._SAPDateString=null;a._SAPTimeString=null;a._SAPThousandsSeparator=null;a._SAPDecimalSeparator=null;a._SAPLongDay=null;a._SAPShortDay=null;a._SAPLongMonth=null;a._SAPShortMonth=null;a._AmPms=null;a._singleton=null;sap.common.globalization.numericFormat.FLocalization.prototype.replaceNBSP=function(e){if(e){var f="";var c=160;for(var d=0;d<e.length;++d){if(e.charCodeAt(d)==c){f+=" "}else{f+=e.charAt(d)}}e=f}return e};a.getInstance=function(){if(!a._singleton){a._initStrings();a._initializePvlDateStrings();a._initSAPGlobilizationStrings();a._singleton=new sap.common.globalization.numericFormat.FLocalization();a._singleton.IMSABBREVDAYNAME1=a._shortDayStrings.en[1]}return a._singleton};a.resetInstance=function(){a._resetAllStaticVars();a._initStrings();a._initializePvlDateStrings();a._initSAPGlobilizationStrings();a._singleton=new sap.common.globalization.numericFormat.FLocalization();a._singleton.IMSABBREVDAYNAME1=a._shortDayStrings.en[1]};var b={monthStrings:"_MonthStrings",shortMonthStrings:"_shortMonthStrings",dayStrings:"_DayStrings",shortDayStrings:"_shortDayStrings",dateTimeCodes:"_DateTimeCodes",numericStrings:"_NumericStrings",dateTimeStrings:"_DateTimeStrings",currencySymbol:"_CurrencySymbol",amPms:"_AmPms"};a.prototype._setDisplayLocaleInfo=function(){this.IMDateSeparator=a._DateTimeStrings.en[1];this.IMDayCode=a._DateTimeCodes.en[5];this.IMDecimalSeparator=a._NumericStrings.en[1];this.IMGeneralFormatName="General";this.IMHourCode=a._DateTimeCodes.en[3];this.IMMinuteCode=a._DateTimeCodes.en[1];this.IMMonthCode=a._DateTimeCodes.en[4];this.IMSABBREVDAYNAME1=a._shortDayStrings.en[1];this.IMSABBREVDAYNAME2=a._shortDayStrings.en[2];this.IMSABBREVDAYNAME3=a._shortDayStrings.en[3];this.IMSABBREVDAYNAME4=a._shortDayStrings.en[4];this.IMSABBREVDAYNAME5=a._shortDayStrings.en[5];this.IMSABBREVDAYNAME6=a._shortDayStrings.en[6];this.IMSABBREVDAYNAME7=a._shortDayStrings.en[7];this.IMSABBREVMONTHNAME1=a._shortMonthStrings.en[1];this.IMSABBREVMONTHNAME10=a._shortMonthStrings.en[10];this.IMSABBREVMONTHNAME11=a._shortMonthStrings.en[11];this.IMSABBREVMONTHNAME12=a._shortMonthStrings.en[12];this.IMSABBREVMONTHNAME2=a._shortMonthStrings.en[2];this.IMSABBREVMONTHNAME3=a._shortMonthStrings.en[3];this.IMSABBREVMONTHNAME4=a._shortMonthStrings.en[4];this.IMSABBREVMONTHNAME5=a._shortMonthStrings.en[5];this.IMSABBREVMONTHNAME6=a._shortMonthStrings.en[6];this.IMSABBREVMONTHNAME7=a._shortMonthStrings.en[7];this.IMSABBREVMONTHNAME8=a._shortMonthStrings.en[8];this.IMSABBREVMONTHNAME9=a._shortMonthStrings.en[9];this.IMSDAYNAME1=a._DayStrings.en[1];this.IMSDAYNAME2=a._DayStrings.en[2];this.IMSDAYNAME3=a._DayStrings.en[3];this.IMSDAYNAME4=a._DayStrings.en[4];this.IMSDAYNAME5=a._DayStrings.en[5];this.IMSDAYNAME6=a._DayStrings.en[6];this.IMSDAYNAME7=a._DayStrings.en[7];this.IMSMONTHNAME1=a._MonthStrings.en[1];this.IMSMONTHNAME10=a._MonthStrings.en[10];this.IMSMONTHNAME11=a._MonthStrings.en[11];this.IMSMONTHNAME12=a._MonthStrings.en[12];this.IMSMONTHNAME2=a._MonthStrings.en[2];this.IMSMONTHNAME3=a._MonthStrings.en[3];this.IMSMONTHNAME4=a._MonthStrings.en[4];this.IMSMONTHNAME5=a._MonthStrings.en[5];this.IMSMONTHNAME6=a._MonthStrings.en[6];this.IMSMONTHNAME7=a._MonthStrings.en[7];this.IMSMONTHNAME8=a._MonthStrings.en[8];this.IMSMONTHNAME9=a._MonthStrings.en[9];this.IMSecondCode=a._DateTimeCodes.en[2];this.IMTimeSeparator=a._DateTimeStrings.en[2];this.IMYearCode=a._DateTimeCodes.en[6];this.IMCurrencySymbol=a._CurrencySymbol.en[1];this.SAPDateSeparator=a._SAPDateString;this.SAPTimeSeparator=a._SAPTimeString;this.SAPCurrencySymbol=a._SAPCurrencySymbol;this.SAPDecimalSeparator=a._SAPDecimalSeparator;this.SAPThousandsSeparator=a._SAPThousandsSeparator;this.SAPLongDay=a._SAPLongDay;this.SAPShortDay=a._SAPShortDay;this.SAPLongMonth=a._SAPLongMonth;this.SAPShortMonth=a._SAPShortMonth;this.IMAMTOKEN=a._AmPms.en[1];this.IMPMTOKEN=a._AmPms.en[2];this._IMThousandsSeparator=this.replaceNBSP(a._NumericStrings.en[2])};a.prototype.setCustomizedLocaleInfo=function(e){if(e){var d;for(d in b){if(e.hasOwnProperty(d)){var g=b[d];this._setCustomizedLocaleInfoByType(g,e[d])}}}else{var c=sap.common.globalization.GlobalizationDateConstant;var f=sap.common.globalization.GlobalizationNumericConstant;this._setCustomizedLocaleInfoByType(b.dayStrings,c.getLongDay());this._setCustomizedLocaleInfoByType(b.shortDayStrings,c.getShortDay());this._setCustomizedLocaleInfoByType(b.monthStrings,c.getLongMonth());this._setCustomizedLocaleInfoByType(b.shortMonthStrings,c.getShortMonth());this._setCustomizedLocaleInfoByType(b.amPms,c.getAmPmToken());this._setCustomizedLocaleInfoByType(b.dateTimeStrings,[c.getDateSeparator(),c.getTimeSeparator()]);this._setCustomizedLocaleInfoByType(b.numericStrings,[f.getDisplayDecimalSeparator(),f.getDisplayThousandSeparator()]);this._dateParseLocaleInfo=null;this._dateDisplayLocaleInfo=null;this._numericParseLocaleInfo=null;this._numericDisplayLocaleInfo=null;a._initializePvlDayStrings()}this._setDisplayLocaleInfo()};a.prototype._setCustomizedLocaleInfoByType=function(e,f){if(f&&f.length>0){var c;for(var d=0;d<f.length;d++){c=d+1;a[e]["en"][c]=f[d]}}};a._initStrings=function(){a._DayStrings={en:{1:"Monday",2:"Tuesday",3:"Wednesday",4:"Thursday",5:"Friday",6:"Saturday",7:"Sunday"}};a._shortDayStrings={en:{1:"Mon",2:"Tue",3:"Wed",4:"Thu",5:"Fri",6:"Sat",7:"Sun"}};a._MonthStrings={en:{1:"January",2:"February",3:"March",4:"April",5:"May",6:"June",7:"July",8:"August",9:"September",10:"October",11:"November",12:"December"}};a._shortMonthStrings={en:{1:"Jan",2:"Feb",3:"Mar",4:"Apr",5:"May",6:"Jun",7:"Jul",8:"Aug",9:"Sep",10:"Oct",11:"Nov",12:"Dec"}};a._DateTimeCodes={en:{1:"m",2:"s",3:"h",4:"M",5:"D",6:"Y"}};a._NumericStrings={en:{1:".",2:","}};a._DateTimeStrings={en:{1:"/",2:":"}};a._CurrencySymbol={en:{1:"$",2:"$"}};a._AmPms={en:{1:"AM",2:"PM"}}};a._initSAPGlobilizationStrings=function(){var d=sap.common.globalization.NumericFormatManager;var e=d.SAP_PARAMETERS["BICSWS_DECIMAL"];e=e?e:d.SAP_PARAMETERS["SAP_decimal"];var l=d.SAP_PARAMETERS["BICSWS_THOUSANDSEPARATOR"];l=l?l:d.SAP_PARAMETERS["SAP_thousandSeparator"];var f=d.SAP_PARAMETERS["BICSWS_MONTHSLONG"];f=f?f:d.SAP_PARAMETERS["SAP_monthsLong"];var g=d.SAP_PARAMETERS["BICSWS_MONTHSSHORT"];g=g?g:d.SAP_PARAMETERS["SAP_monthsShort"];var c=d.SAP_PARAMETERS["BICSWS_DAYSLONG"];c=c?c:d.SAP_PARAMETERS["SAP_daysLong"];var m=d.SAP_PARAMETERS["BICSWS_DAYSSHORT"];m=m?m:d.SAP_PARAMETERS["SAP_daysShort"];var k=d.SAP_PARAMETERS["BICSWS_DATESEPARATOR"];k=k?k:d.SAP_PARAMETERS["SAP_dateSeparator"];var j=d.SAP_PARAMETERS["BICSWS_TIMESEPARATOR"];j=j?j:d.SAP_PARAMETERS["SAP_timeSeparator"];var h=d.SAP_PARAMETERS["SAP_s_g_n_FLocalization._CurrencySymbol"];var i;if(c){i=c.split(",");a._SAPLongDay=i;a._DayStrings.en[1]=i[0];a._DayStrings.en[2]=i[1];a._DayStrings.en[3]=i[2];a._DayStrings.en[4]=i[3];a._DayStrings.en[5]=i[4];a._DayStrings.en[6]=i[5];a._DayStrings.en[7]=i[6]}if(m){i=m.split(",");a._SAPShortDay=i;a._shortDayStrings.en[1]=i[0];a._shortDayStrings.en[2]=i[1];a._shortDayStrings.en[3]=i[2];a._shortDayStrings.en[4]=i[3];a._shortDayStrings.en[5]=i[4];a._shortDayStrings.en[6]=i[5];a._shortDayStrings.en[7]=i[6]}if(f){i=f.split(",");a._SAPLongMonth=i;a._MonthStrings.en[1]=i[0];a._MonthStrings.en[2]=i[1];a._MonthStrings.en[3]=i[2];a._MonthStrings.en[4]=i[3];a._MonthStrings.en[5]=i[4];a._MonthStrings.en[6]=i[5];a._MonthStrings.en[7]=i[6];a._MonthStrings.en[8]=i[7];a._MonthStrings.en[9]=i[8];a._MonthStrings.en[10]=i[9];a._MonthStrings.en[11]=i[10];a._MonthStrings.en[12]=i[11]}if(g){i=g.split(",");a._SAPShortMonth=i;a._shortMonthStrings.en[1]=i[0];a._shortMonthStrings.en[2]=i[1];a._shortMonthStrings.en[3]=i[2];a._shortMonthStrings.en[4]=i[3];a._shortMonthStrings.en[5]=i[4];a._shortMonthStrings.en[6]=i[5];a._shortMonthStrings.en[7]=i[6];a._shortMonthStrings.en[8]=i[7];a._shortMonthStrings.en[9]=i[8];a._shortMonthStrings.en[10]=i[9];a._shortMonthStrings.en[11]=i[10];a._shortMonthStrings.en[12]=i[11]}if(e){a._SAPDecimalSeparator=e}if(l){a._SAPThousandsSeparator=l}if(k){a._SAPDateString=k}if(j){a._SAPTimeString=j}if(h){a._SAPCurrencySymbol=h}};a.prototype.IMThousandsSeparator=function(c){if(arguments.length>=1){this._IMThousandsSeparator=this.replaceNBSP(c);return this}else{return this._IMThousandsSeparator}};a.prototype.getDateParseLocaleInfo=function(){if(!this._dateParseLocaleInfo){this._dateParseLocaleInfo=new sap.common.globalization.defaultFormat.DateParseLocaleInfoImpl();this._dateParseLocaleInfo.IMDateSeparator(this.IMDateSeparator);this._dateParseLocaleInfo.IMTimeSeparator(this.IMTimeSeparator)}return this._dateParseLocaleInfo};a.prototype.getDateDisplayLocaleInfo=function(){if(!this._dateDisplayLocaleInfo){this._dateDisplayLocaleInfo=new sap.common.globalization.defaultFormat.DateDisplayLocaleInfoImpl();this._dateDisplayLocaleInfo.IMDateSeparator(this.SAPDateSeparator);this._dateDisplayLocaleInfo.IMSDAYNAME1(this.IMSDAYNAME1);this._dateDisplayLocaleInfo.IMSDAYNAME2(this.IMSDAYNAME2);this._dateDisplayLocaleInfo.IMSDAYNAME3(this.IMSDAYNAME3);this._dateDisplayLocaleInfo.IMSDAYNAME4(this.IMSDAYNAME4);this._dateDisplayLocaleInfo.IMSDAYNAME5(this.IMSDAYNAME5);this._dateDisplayLocaleInfo.IMSDAYNAME6(this.IMSDAYNAME6);this._dateDisplayLocaleInfo.IMSDAYNAME7(this.IMSDAYNAME7);this._dateDisplayLocaleInfo.IMSABBREVDAYNAME1(this.IMSABBREVDAYNAME1);this._dateDisplayLocaleInfo.IMSABBREVDAYNAME2(this.IMSABBREVDAYNAME2);this._dateDisplayLocaleInfo.IMSABBREVDAYNAME3(this.IMSABBREVDAYNAME3);this._dateDisplayLocaleInfo.IMSABBREVDAYNAME4(this.IMSABBREVDAYNAME4);this._dateDisplayLocaleInfo.IMSABBREVDAYNAME5(this.IMSABBREVDAYNAME5);this._dateDisplayLocaleInfo.IMSABBREVDAYNAME6(this.IMSABBREVDAYNAME6);this._dateDisplayLocaleInfo.IMSABBREVDAYNAME7(this.IMSABBREVDAYNAME7);this._dateDisplayLocaleInfo.IMSMONTHNAME1(this.IMSMONTHNAME1);this._dateDisplayLocaleInfo.IMSMONTHNAME2(this.IMSMONTHNAME2);this._dateDisplayLocaleInfo.IMSMONTHNAME3(this.IMSMONTHNAME3);this._dateDisplayLocaleInfo.IMSMONTHNAME4(this.IMSMONTHNAME4);this._dateDisplayLocaleInfo.IMSMONTHNAME5(this.IMSMONTHNAME5);this._dateDisplayLocaleInfo.IMSMONTHNAME6(this.IMSMONTHNAME6);this._dateDisplayLocaleInfo.IMSMONTHNAME7(this.IMSMONTHNAME7);this._dateDisplayLocaleInfo.IMSMONTHNAME8(this.IMSMONTHNAME8);this._dateDisplayLocaleInfo.IMSMONTHNAME9(this.IMSMONTHNAME9);this._dateDisplayLocaleInfo.IMSMONTHNAME10(this.IMSMONTHNAME10);this._dateDisplayLocaleInfo.IMSMONTHNAME11(this.IMSMONTHNAME11);this._dateDisplayLocaleInfo.IMSMONTHNAME12(this.IMSMONTHNAME12);this._dateDisplayLocaleInfo.IMSABBREVMONTHNAME1(this.IMSABBREVMONTHNAME1);this._dateDisplayLocaleInfo.IMSABBREVMONTHNAME2(this.IMSABBREVMONTHNAME2);this._dateDisplayLocaleInfo.IMSABBREVMONTHNAME3(this.IMSABBREVMONTHNAME3);this._dateDisplayLocaleInfo.IMSABBREVMONTHNAME4(this.IMSABBREVMONTHNAME4);this._dateDisplayLocaleInfo.IMSABBREVMONTHNAME5(this.IMSABBREVMONTHNAME5);this._dateDisplayLocaleInfo.IMSABBREVMONTHNAME6(this.IMSABBREVMONTHNAME6);this._dateDisplayLocaleInfo.IMSABBREVMONTHNAME7(this.IMSABBREVMONTHNAME7);this._dateDisplayLocaleInfo.IMSABBREVMONTHNAME8(this.IMSABBREVMONTHNAME8);this._dateDisplayLocaleInfo.IMSABBREVMONTHNAME9(this.IMSABBREVMONTHNAME9);this._dateDisplayLocaleInfo.IMSABBREVMONTHNAME10(this.IMSABBREVMONTHNAME10);this._dateDisplayLocaleInfo.IMSABBREVMONTHNAME11(this.IMSABBREVMONTHNAME11);this._dateDisplayLocaleInfo.IMSABBREVMONTHNAME12(this.IMSABBREVMONTHNAME12);this._dateDisplayLocaleInfo.IMTimeSeparator(this.SAPTimeSeparator);this._dateDisplayLocaleInfo.IMAMTOKEN(this.IMAMTOKEN);this._dateDisplayLocaleInfo.IMPMTOKEN(this.IMPMTOKEN)}return this._dateDisplayLocaleInfo};a.prototype.numericParseLocaleInfo=function(){if(!this._numericParseLocaleInfo){this._numericParseLocaleInfo=new sap.common.globalization.defaultFormat.NumericParseLocaleInfoImpl(this._IMThousandsSeparator,this.IMDecimalSeparator,this.IMCurrencySymbol)}return this._numericParseLocaleInfo};a.prototype.numericDisplayLocaleInfo=function(){if(!this._numericDisplayLocaleInfo){var c=(this.SAPThousandsSeparator?this.SAPThousandsSeparator:this._IMThousandsSeparator);var e=(this.SAPDecimalSeparator?this.SAPDecimalSeparator:this.IMDecimalSeparator);var d=(this.SAPCurrencySymbol?this.SAPCurrencySymbol:this.IMCurrencySymbol);this._numericDisplayLocaleInfo=new sap.common.globalization.defaultFormat.NumericDisplayLocaleInfoImpl(c,e,d)}return this._numericDisplayLocaleInfo};a._initializePvlDayStrings=function(){var d=sap.common.globalization.GlobalizationDateConstant.getLongDay();if(d){a._DayStrings.en[1]=d[1];a._DayStrings.en[2]=d[2];a._DayStrings.en[3]=d[3];a._DayStrings.en[4]=d[4];a._DayStrings.en[5]=d[5];a._DayStrings.en[6]=d[6];a._DayStrings.en[7]=d[0]}var c=sap.common.globalization.GlobalizationDateConstant.getShortDay();if(c){a._shortDayStrings.en[1]=c[1];a._shortDayStrings.en[2]=c[2];a._shortDayStrings.en[3]=c[3];a._shortDayStrings.en[4]=c[4];a._shortDayStrings.en[5]=c[5];a._shortDayStrings.en[6]=c[6];a._shortDayStrings.en[7]=c[0]}};a._initializePvlDateStrings=function(){var e=sap.common.globalization.GlobalizationPreference.getInstance().pvl();if(e&&!sap.common.globalization.utils.StringUtil.isBlankString(e)){a._initializePvlDayStrings();var f=sap.common.globalization.GlobalizationDateConstant.getLongMonth();if(f){a._MonthStrings.en[1]=f[0];a._MonthStrings.en[2]=f[1];a._MonthStrings.en[3]=f[2];a._MonthStrings.en[4]=f[3];a._MonthStrings.en[5]=f[4];a._MonthStrings.en[6]=f[5];a._MonthStrings.en[7]=f[6];a._MonthStrings.en[8]=f[7];a._MonthStrings.en[9]=f[8];a._MonthStrings.en[10]=f[9];a._MonthStrings.en[11]=f[10];a._MonthStrings.en[12]=f[11]}var d=sap.common.globalization.GlobalizationDateConstant.getShortMonth();if(d){a._shortMonthStrings.en[1]=d[0];a._shortMonthStrings.en[2]=d[1];a._shortMonthStrings.en[3]=d[2];a._shortMonthStrings.en[4]=d[3];a._shortMonthStrings.en[5]=d[4];a._shortMonthStrings.en[6]=d[5];a._shortMonthStrings.en[7]=d[6];a._shortMonthStrings.en[8]=d[7];a._shortMonthStrings.en[9]=d[8];a._shortMonthStrings.en[10]=d[9];a._shortMonthStrings.en[11]=d[10];a._shortMonthStrings.en[12]=d[11]}var c=sap.common.globalization.GlobalizationDateConstant.getAmPmToken();if(c){a._AmPms.en[1]=c[0];a._AmPms.en[2]=c[1]}}};a._resetAllStaticVars=function(){a._DayStrings=null;a._shortDayStrings=null;a._MonthStrings=null;a._shortMonthStrings=null;a._DateTimeCodes=null;a._NumericStrings=null;a._DateTimeStrings=null;a._CurrencySymbol=null;a._SAPCurrencySymbol=null;a._SAPDateString=null;a._SAPTimeString=null;a._SAPThousandsSeparator=null;a._SAPDecimalSeparator=null;a._SAPLongDay=null;a._SAPShortDay=null;a._SAPLongMonth=null;a._SAPShortMonth=null;a._AmPms=null}})();(function(){sap.common.globalization.declare("sap.common.globalization.utils.BaseUtils");var b=sap.common.globalization.utils.BaseUtils;var a=0;sap.common.globalization.utils.BaseUtils.genUID=function(){if(!a){a=0}return"xgen_"+(a++)};var c={"[object Boolean]":"boolean","[object Number]":"number","[object String]":"string","[object Function]":"function","[object Array]":"array","[object Date]":"date","[object RegExp]":"regexp","[object Object]":"object"};sap.common.globalization.utils.BaseUtils.applyProperties=function(g,f){if(f!=null){var d=f.length;for(var e=0;e<d;e++){var h=f[e];if(h&&h!=null){this.applyObjectProperty(g,h.name,h.value)}}}};sap.common.globalization.utils.BaseUtils.applyObjectProperty=function(g,f,d){try{if(b.isFunction(g[f])){g[f](d)}else{if(g.hasOwnProperty(f)){g[f]=d}}}catch(h){if(console){console.log(h)}}};sap.common.globalization.utils.BaseUtils.getObjectProperty=function(f,d){try{if(b.isFunction(f[d])){return f[d]()}else{if(f.hasOwnProperty(d)){return f[d]}}}catch(g){if(console){console.log(g)}}};sap.common.globalization.utils.BaseUtils.type=function(d){return d==null?String(d):c[Object.prototype.toString.call(d)]||"object"};sap.common.globalization.utils.BaseUtils.isFunction=function(d){return b.type(d)==="function"};sap.common.globalization.utils.BaseUtils.isBoolean=function(d){return b.type(d)==="boolean"};sap.common.globalization.utils.BaseUtils.isString=function(d){return b.type(d)==="string"};sap.common.globalization.utils.BaseUtils.isArray=function(d){return b.type(d)==="array"};sap.common.globalization.utils.BaseUtils.isNumber=function(d){return b.type(d)==="number"};sap.common.globalization.utils.BaseUtils.isRegExp=function(d){return b.type(d)==="regexp"};sap.common.globalization.utils.BaseUtils.sortArrayOn=function(d,f,e){if(b.isArray(d)&&b.isString(f)){d.sort(function(h,g){return e?(h[f]<g[f])-(h[f]>g[f]):(h[f]>g[f])-(h[f]<g[f])})}}})();(function(){sap.common.globalization.declare("sap.common.globalization.utils.UnitAbbreviations");sap.common.globalization.require("sap.common.globalization.utils.BaseUtils");sap.common.globalization.utils.UnitAbbreviations=function(){this.__className="sap.common.globalization.utils.UnitAbbreviations";this.thousands="K";this.millions="M";this.billions="B";this.trillions="T"};sap.common.globalization.utils.UnitAbbreviations.prototype.toObject=function(){return{thousands:this.thousands,millions:this.millions,billions:this.billions,trillions:this.trillions}};sap.common.globalization.utils.UnitAbbreviations.prototype.copyFromObject=function(a){if(!a){a={thousands:"K",millions:"M",billions:"B",trillions:"T"}}var b=false;for(attr in ["thousands","millions","billions","trillions"]){if(sap.common.globalization.utils.BaseUtils.isString(a[attr])&&a[attr]!=this[attr]){this[attr]=a[attr];b=true}}return b}})();(function(){sap.common.globalization.declare("sap.common.globalization.utils.BooleanUtil");sap.common.globalization.require("sap.common.globalization.utils.BaseUtils");sap.common.globalization.utils.BooleanUtil.isBooleanValue=function(a){if(sap.common.globalization.utils.BaseUtils.isBoolean(a)){return true}else{if(sap.common.globalization.utils.BaseUtils.isString(a)){return String(a).toLowerCase()=="true"||String(a).toLowerCase()=="false"}else{return false}}}})();(function(){sap.common.globalization.declare("sap.common.globalization.utils.ColorUtil");sap.common.globalization.require("sap.common.globalization.utils.BaseUtils");sap.common.globalization.utils.ColorUtil.convertToHexString=function(c){if(c==null||!sap.common.globalization.utils.BaseUtils.isNumber(c)||isNaN(c)){return null}var h="#",b=["r","g","b"],d=sap.common.globalization.utils.ColorUtil.convertToRGBObject(c);for(var f=0,a=b.length;f<a;f++){var g=b[f],e=d[g].toString(16);if(e.length==1){h+="0"}h+=e}return h};sap.common.globalization.utils.ColorUtil.convertToRGBObject=function(a){if(a==null||!sap.common.globalization.utils.BaseUtils.isNumber(a)||isNaN(a)){return null}return{r:(a&16711680)>>16,g:(a&65280)>>8,b:a&255}}})();(function(){sap.common.globalization.declare("sap.common.globalization.utils.DataFormatUtils");sap.common.globalization.require("sap.common.globalization.utils.ColorUtil");sap.common.globalization.utils.DataFormatUtils.decorateColorHTML=function(b,a){if(!isNaN(a)){return'<FONT COLOR="'+sap.common.globalization.utils.ColorUtil.convertToHexString(a)+'"/>'+b+"</FONT>"}return b};sap.common.globalization.utils.DataFormatUtils.DataFormatUtils=function(){throw new Error("Should not initialize DataFormatUtils.")}})();(function(){sap.common.globalization.declare("sap.common.globalization.utils.NumberUtil");sap.common.globalization.require("sap.common.globalization.utils.BaseUtils");sap.common.globalization.require("sap.common.globalization.utils.UnitAbbreviations");sap.common.globalization.require("sap.common.globalization.utils.StringUtil");sap.common.globalization.utils.NumberUtil.checkEquality=function(d,c,a){a=a||-5;if(d==c){return true}var b=Math.pow(10,a-1);var e=d-c;return e<b&&e>-b};sap.common.globalization.utils.NumberUtil.lessThanEqual=function(b,c,a){a=a||-5;return((b<c)||sap.common.globalization.utils.NumberUtil.checkEquality(b,c,a))};sap.common.globalization.utils.NumberUtil.greaterThanEqual=function(b,c,a){a=a||-5;return((b>c)||sap.common.globalization.utils.NumberUtil.checkEquality(b,c,a))};sap.common.globalization.utils.NumberUtil.getPrecision=function(d){var c=String(d);var e=c.length;var b=c.indexOf(".");var a=e-(b+1);return a};sap.common.globalization.utils.NumberUtil.roundToPrecision=function(e,c){var f=e.toString(10);var d=f.split(".");var a=(d&&d.length>1?d[1].length:0);if(a<=c){return e}var b=Math.pow(10,c);return Math.round(e*b)/b};sap.common.globalization.utils.NumberUtil.roundToNearest=function(b,a,c){a=a||1;c=c||0;return Math.round((b+c)/a)*a-c};sap.common.globalization.utils.NumberUtil.abbreviate=function(f,g,c){var h=1000;var d=1000000;var b=1000000000;var a=1000000000000;g=g||null;c=c||1;if(!g){g=new sap.common.globalization.utils.UnitAbbreviations()}var i="";var e=Math.abs(f);if(e>=a){f/=a;i=g.trillions}else{if(e>=b){f/=b;i=g.billions}else{if(e>=d){f/=d;i=g.millions}else{if(e>=h){f/=h;i=g.thousands}}}}f=sap.common.globalization.utils.NumberUtil.roundToPrecision(f,c);return String(f)+i};sap.common.globalization.utils.NumberUtil.parseNumber=function(c,b){var a=b;if(c!=null){var d=Number(c);if(isNaN(d)==false){a=d}}return a};sap.common.globalization.utils.NumberUtil.isNumericValue=function(a){if(sap.common.globalization.utils.BaseUtils.isNumber(a)&&!isNaN(a)){return true}else{if(sap.common.globalization.utils.BaseUtils.isString(a)){return sap.common.globalization.utils.StringUtil.isNumber(String(a))}else{return false}}}})();(function(){sap.common.globalization.declare("sap.common.globalization.utils.StringUtil");sap.common.globalization.require("sap.common.globalization.utils.BaseUtils");sap.common.globalization.utils.StringUtil.escapeEntities=function(a){if(a){a=a.split("&").join("&amp;");a=a.split("<").join("&lt;");a=a.split(">").join("&gt;");a=a.split('"').join("&quot;");a=a.split("'").join("&apos;")}return a};sap.common.globalization.utils.StringUtil.trim=function(a){return a.replace(/^\s*/,"").replace(/\s*$/,"")};sap.common.globalization.utils.StringUtil.isBlankString=function(a){if(a==null||!(sap.common.globalization.utils.BaseUtils.isString(a))){return false}return sap.common.globalization.utils.StringUtil.trim(a)===""};sap.common.globalization.utils.StringUtil.isNumber=function(a){if(isNaN(Number(a))){return false}else{if(sap.common.globalization.utils.StringUtil.isBlankString(a)){return false}else{return true}}}})();(function(){sap.common.globalization.declare("sap.common.globalization.defaultFormat.DefaultDateFormatLocaleFactory");sap.common.globalization.require("sap.common.globalization.numericFormat.FDate");sap.common.globalization.require("sap.common.globalization.GlobalizationDateConstant");sap.common.globalization.require("sap.common.globalization.GlobalizationPreference");sap.common.globalization.require("sap.common.globalization.numericFormat.FDate");sap.common.globalization.require("sap.common.globalization.numericFormat.FDefaultDate");sap.common.globalization.require("sap.common.globalization.numericFormat.FLocalization");sap.common.globalization.require("sap.common.globalization.numericFormat.");sap.common.globalization.defaultFormat.DefaultDateFormatLocaleFactory=function(){this.__className="sap.common.globalization.defaultFormat.DefaultDateFormatLocaleFactory";this._parseLocaleInfo=null;this._displayLocaleInfo=null};var a=sap.common.globalization.defaultFormat.DefaultDateFormatLocaleFactory;a.prototype.getDateParseLocaleInfo=function(){if(!this._parseLocaleInfo){this._parseLocaleInfo=this.getPredefinedDateParseLocaleString()}return this._parseLocaleInfo};a.prototype.getDateDisplayLocaleInfo=function(){if(!this._displayLocaleInfo){this._displayLocaleInfo=this.getPredefinedDateDisplayLocaleString();this.applySAPDateTokensAndSeparators(this._displayLocaleInfo)}return this._displayLocaleInfo};a.prototype.getDefaultDateFormat=function(){return sap.common.globalization.GlobalizationDateConstant.getDefaultLongDateFormat()};a.prototype.createFDate=function(){return new sap.common.globalization.numericFormat.FDefaultDate(this.getDateParseLocaleInfo(),this.getDateDisplayLocaleInfo())};a.prototype.getPredefinedDateParseLocaleString=function(){return new sap.common.globalization.defaultFormat.DateParseLocaleInfoImpl()};a.prototype.getPredefinedDateDisplayLocaleString=function(){var e=new sap.common.globalization.defaultFormat.DateDisplayLocaleInfoImpl();var f=sap.common.globalization.GlobalizationDateConstant.getLongDay();if(f){e.IMSDAYNAME1(f[1]);e.IMSDAYNAME2(f[2]);e.IMSDAYNAME3(f[3]);e.IMSDAYNAME4(f[4]);e.IMSDAYNAME5(f[5]);e.IMSDAYNAME6(f[6]);e.IMSDAYNAME7(f[0])}var c=sap.common.globalization.GlobalizationDateConstant.getShortDay();if(c){e.IMSABBREVDAYNAME1(c[1]);e.IMSABBREVDAYNAME2(c[2]);e.IMSABBREVDAYNAME3(c[3]);e.IMSABBREVDAYNAME4(c[4]);e.IMSABBREVDAYNAME5(c[5]);e.IMSABBREVDAYNAME6(c[6]);e.IMSABBREVDAYNAME7(c[0])}var g=sap.common.globalization.GlobalizationDateConstant.getLongMonth();if(g){e.IMSMONTHNAME1(g[0]);e.IMSMONTHNAME2(g[1]);e.IMSMONTHNAME3(g[2]);e.IMSMONTHNAME4(g[3]);e.IMSMONTHNAME5(g[4]);e.IMSMONTHNAME6(g[5]);e.IMSMONTHNAME7(g[6]);e.IMSMONTHNAME8(g[7]);e.IMSMONTHNAME9(g[8]);e.IMSMONTHNAME10(g[9]);e.IMSMONTHNAME11(g[10]);e.IMSMONTHNAME12(g[11])}var d=sap.common.globalization.GlobalizationDateConstant.getShortMonth();if(d){e.IMSABBREVMONTHNAME1(d[0]);e.IMSABBREVMONTHNAME2(d[1]);e.IMSABBREVMONTHNAME3(d[2]);e.IMSABBREVMONTHNAME4(d[3]);e.IMSABBREVMONTHNAME5(d[4]);e.IMSABBREVMONTHNAME6(d[5]);e.IMSABBREVMONTHNAME7(d[6]);e.IMSABBREVMONTHNAME8(d[7]);e.IMSABBREVMONTHNAME9(d[8]);e.IMSABBREVMONTHNAME10(d[9]);e.IMSABBREVMONTHNAME11(d[10]);e.IMSABBREVMONTHNAME12(d[11])}var b=sap.common.globalization.GlobalizationDateConstant.getAbbrevEraString();if(b&&b[1]){e.IMEraToken(b[1])}return e};a.prototype.applySAPDateTokensAndSeparators=function(c){var b=sap.common.globalization.numericFormat.FLocalization.getInstance();if(b.SAPShortDay){c.IMSABBREVDAYNAME1(b.SAPShortDay[0]);c.IMSABBREVDAYNAME2(b.SAPShortDay[1]);c.IMSABBREVDAYNAME3(b.SAPShortDay[2]);c.IMSABBREVDAYNAME4(b.SAPShortDay[3]);c.IMSABBREVDAYNAME5(b.SAPShortDay[4]);c.IMSABBREVDAYNAME6(b.SAPShortDay[5]);c.IMSABBREVDAYNAME7(b.SAPShortDay[6])}if(b.SAPLongDay){c.IMSDAYNAME1(b.SAPLongDay[0]);c.IMSDAYNAME2(b.SAPLongDay[1]);c.IMSDAYNAME3(b.SAPLongDay[2]);c.IMSDAYNAME4(b.SAPLongDay[3]);c.IMSDAYNAME5(b.SAPLongDay[4]);c.IMSDAYNAME6(b.SAPLongDay[5]);c.IMSDAYNAME7(b.SAPLongDay[6])}if(b.SAPShortMonth){c.IMSABBREVMONTHNAME1(b.SAPShortMonth[0]);c.IMSABBREVMONTHNAME2(b.SAPShortMonth[1]);c.IMSABBREVMONTHNAME3(b.SAPShortMonth[2]);c.IMSABBREVMONTHNAME4(b.SAPShortMonth[3]);c.IMSABBREVMONTHNAME5(b.SAPShortMonth[4]);c.IMSABBREVMONTHNAME6(b.SAPShortMonth[5]);c.IMSABBREVMONTHNAME7(b.SAPShortMonth[6]);c.IMSABBREVMONTHNAME8(b.SAPShortMonth[7]);c.IMSABBREVMONTHNAME9(b.SAPShortMonth[8]);c.IMSABBREVMONTHNAME10(b.SAPShortMonth[9]);c.IMSABBREVMONTHNAME11(b.SAPShortMonth[10]);c.IMSABBREVMONTHNAME12(b.SAPShortMonth[11])}if(b.SAPLongMonth){c.IMSMONTHNAME1(b.SAPLongMonth[0]);c.IMSMONTHNAME2(b.SAPLongMonth[1]);c.IMSMONTHNAME3(b.SAPLongMonth[2]);c.IMSMONTHNAME4(b.SAPLongMonth[3]);c.IMSMONTHNAME5(b.SAPLongMonth[4]);c.IMSMONTHNAME6(b.SAPLongMonth[5]);c.IMSMONTHNAME7(b.SAPLongMonth[6]);c.IMSMONTHNAME8(b.SAPLongMonth[7]);c.IMSMONTHNAME9(b.SAPLongMonth[8]);c.IMSMONTHNAME10(b.SAPLongMonth[9]);c.IMSMONTHNAME11(b.SAPLongMonth[10]);c.IMSMONTHNAME12(b.SAPLongMonth[11])}}})();(function(){sap.common.globalization.declare("sap.common.globalization.defaultFormat.DefaultDateTimeFormatLocaleFactory");sap.common.globalization.require("sap.common.globalization.defaultFormat.DefaultDateFormatLocaleFactory");sap.common.globalization.require("sap.common.globalization.GlobalizationDateConstant");sap.common.globalization.require("sap.common.globalization.numericFormat.FLocalization");var a=sap.common.globalization.defaultFormat;a.DefaultDateTimeFormatLocaleFactory=function(){a.DefaultDateTimeFormatLocaleFactory.superclass.constructor.apply(this);this.__className="sap.common.globalization.defaultFormat.DefaultDateTimeFormatLocaleFactory"};a.DefaultDateTimeFormatLocaleFactory=sap.common.globalization.extend(a.DefaultDateTimeFormatLocaleFactory,a.DefaultDateFormatLocaleFactory);a.DefaultDateTimeFormatLocaleFactory.prototype.getDefaultDateFormat=function(){return sap.common.globalization.GlobalizationDateConstant.getDefaultDateTimeFormat()};a.DefaultDateTimeFormatLocaleFactory.prototype.applySAPDateTokensAndSeparators=function(c){a.DefaultDateTimeFormatLocaleFactory.superclass.applySAPDateTokensAndSeparators(c);var b=sap.common.globalization.numericFormat.FLocalization.getInstance();if(c&&b&&b.SAPTimeSeparator){c.IMTimeSeparator(b.SAPTimeSeparator)}};a.DefaultDateTimeFormatLocaleFactory.prototype.getPredefinedDateParseLocaleString=function(){var c=a.DefaultDateTimeFormatLocaleFactory.superclass.getPredefinedDateParseLocaleString();var b=sap.common.globalization.GlobalizationDateConstant.getTimeSeparator();if(b&&c){c.IMTimeSeparator(b)}return c};a.DefaultDateTimeFormatLocaleFactory.prototype.getPredefinedDateDisplayLocaleString=function(){var d=a.DefaultDateTimeFormatLocaleFactory.superclass.getPredefinedDateDisplayLocaleString();var b=sap.common.globalization.GlobalizationDateConstant.getTimeSeparator();if(b&&d){d.IMTimeSeparator(b)}var c=sap.common.globalization.GlobalizationDateConstant.getAmPmToken();if(c&&d){d.IMAMTOKEN(c[0]);d.IMPMTOKEN(c[1])}return d}})();(function(){sap.common.globalization.declare("sap.common.globalization.defaultFormat.DefaultShortDateFormatLocaleFactory");sap.common.globalization.require("sap.common.globalization.defaultFormat.DefaultDateFormatLocaleFactory");sap.common.globalization.require("sap.common.globalization.GlobalizationDateConstant");sap.common.globalization.require("sap.common.globalization.numericFormat.FLocalization");var a=sap.common.globalization.defaultFormat;a.DefaultShortDateFormatLocaleFactory=function(){a.DefaultShortDateFormatLocaleFactory.superclass.constructor.apply(this);this.__className="sap.common.globalization.defaultFormat.DefaultShortDateFormatLocaleFactory"};a.DefaultShortDateFormatLocaleFactory=sap.common.globalization.extend(a.DefaultShortDateFormatLocaleFactory,a.DefaultDateFormatLocaleFactory);a.DefaultShortDateFormatLocaleFactory.prototype.getDefaultDateFormat=function(){return sap.common.globalization.GlobalizationDateConstant.getDefaultShorDateFormat()};a.DefaultShortDateFormatLocaleFactory.prototype.applySAPDateTokensAndSeparators=function(c){a.DefaultShortDateFormatLocaleFactory.superclass.applySAPDateTokensAndSeparators(c);var b=sap.common.globalization.numericFormat.FLocalization.getInstance();if(c&&b&&b.SAPDateSeparator){c.IMDateSeparator(b.SAPDateSeparator)}};a.DefaultShortDateFormatLocaleFactory.prototype.getPredefinedDateParseLocaleString=function(){var b=a.DefaultShortDateFormatLocaleFactory.superclass.getPredefinedDateParseLocaleString();var c=sap.common.globalization.GlobalizationDateConstant.getDateSeparator();if(c&&b){b.IMDateSeparator(c)}return b};a.DefaultShortDateFormatLocaleFactory.prototype.getPredefinedDateDisplayLocaleString=function(){var b=a.DefaultShortDateFormatLocaleFactory.superclass.getPredefinedDateDisplayLocaleString();var c=sap.common.globalization.GlobalizationDateConstant.getDateSeparator();if(c&&b){b.IMDateSeparator(c)}return b}})();(function(){sap.common.globalization.declare("sap.common.globalization.defaultFormat.BooleanDisplayLocaleInfo");sap.common.globalization.defaultFormat.BooleanDisplayLocaleInfo=function(){this.__className="sap.common.globalization.defaultFormat.BooleanDisplayLocaleInfo";this._trueString="";this._falseString=""};sap.common.globalization.defaultFormat.BooleanDisplayLocaleInfo.prototype.trueString=function(a){if(arguments.length>=1){this._trueString=a;return this}else{return this._trueString}};sap.common.globalization.defaultFormat.BooleanDisplayLocaleInfo.prototype.falseString=function(a){if(arguments.length>=1){this._falseString=a;return this}else{return this._falseString}}})();(function(){sap.common.globalization.declare("sap.common.globalization.defaultFormat.CustomDateFormatLocaleFactory");sap.common.globalization.require("sap.common.globalization.GlobalizationPreference");sap.common.globalization.require("sap.common.globalization.GlobalizationDateConstant");sap.common.globalization.require("sap.common.globalization.numericFormat.FLocalization");sap.common.globalization.require("sap.common.globalization.numericFormat.FDateForPVL");sap.common.globalization.require("sap.common.globalization.numericFormat.FDate");sap.common.globalization.require("sap.common.globalization.utils.StringUtil");var a=sap.common.globalization.defaultFormat;a.CustomDateFormatLocaleFactory=function(){this.__className="sap.common.globalization.defaultFormat.CustomDateFormatLocaleFactory";this._dateParseLocaleInfo=null;this._dateDisplayLocaleInfo=null};a.CustomDateFormatLocaleFactory._instance=null;a.CustomDateFormatLocaleFactory.getInstance=function(){if(!a.CustomDateFormatLocaleFactory._instance){a.CustomDateFormatLocaleFactory._instance=new a.CustomDateFormatLocaleFactory()}return a.CustomDateFormatLocaleFactory._instance};a.CustomDateFormatLocaleFactory.prototype.getDateParseLocaleInfo=function(){return sap.common.globalization.numericFormat.FLocalization.getInstance().getDateParseLocaleInfo()};a.CustomDateFormatLocaleFactory.prototype.getDateDisplayLocaleInfo=function(){return sap.common.globalization.numericFormat.FLocalization.getInstance().getDateDisplayLocaleInfo()};a.CustomDateFormatLocaleFactory.prototype.createFDate=function(){var b=sap.common.globalization.GlobalizationPreference.getInstance().pvl()&&!sap.common.globalization.utils.StringUtil.isBlankString(sap.common.globalization.GlobalizationPreference.getInstance().pvl());if(b){return new sap.common.globalization.numericFormat.FDateForPVL(this.getDateParseLocaleInfo(),this.getDateDisplayLocaleInfo())}else{return new sap.common.globalization.numericFormat.FDate(null,this.getDateDisplayLocaleInfo())}}})();(function(){sap.common.globalization.declare("sap.common.globalization.defaultFormat.CustomNumericFormatLocaleFactory");sap.common.globalization.require("sap.common.globalization.numericFormat.FLocalization");sap.common.globalization.require("sap.common.globalization.numericFormat.FNumber");sap.common.globalization.defaultFormat.CustomNumericFormatLocaleFactory=function(){this.__className="sap.common.globalization.defaultFormat.CustomNumericFormatLocaleFactory"};var a=sap.common.globalization.defaultFormat.CustomNumericFormatLocaleFactory;a._instance=null;a.getInstance=function(){if(!a._instance){a._instance=new sap.common.globalization.defaultFormat.CustomNumericFormatLocaleFactory()}return a._instance};a.prototype.getNumericParseLocaleInfo=function(){return sap.common.globalization.numericFormat.FLocalization.getInstance().numericParseLocaleInfo()};a.prototype.getNumericDisplayLocaleInfo=function(){return sap.common.globalization.numericFormat.FLocalization.getInstance().numericDisplayLocaleInfo()};a.prototype.createFNumber=function(){return new sap.common.globalization.numericFormat.FNumber(this.getNumericParseLocaleInfo(),this.getNumericDisplayLocaleInfo())}})();(function(){sap.common.globalization.declare("sap.common.globalization.defaultFormat.DateDisplayLocaleInfoImpl");sap.common.globalization.defaultFormat.DateDisplayLocaleInfoImpl=function(){this.__className="sap.common.globalization.defaultFormat.DateDisplayLocaleInfoImpl";this._IMDateSeparator=null;this._IMSMONTHNAME1=null;this._IMSMONTHNAME2=null;this._IMSMONTHNAME3=null;this._IMSMONTHNAME4=null;this._IMSMONTHNAME5=null;this._IMSMONTHNAME6=null;this._IMSMONTHNAME7=null;this._IMSMONTHNAME8=null;this._IMSMONTHNAME9=null;this._IMSMONTHNAME10=null;this._IMSMONTHNAME11=null;this._IMSMONTHNAME12=null;this._IMSABBREVMONTHNAME1=null;this._IMSABBREVMONTHNAME2=null;this._IMSABBREVMONTHNAME3=null;this._IMSABBREVMONTHNAME4=null;this._IMSABBREVMONTHNAME5=null;this._IMSABBREVMONTHNAME6=null;this._IMSABBREVMONTHNAME7=null;this._IMSABBREVMONTHNAME8=null;this._IMSABBREVMONTHNAME9=null;this._IMSABBREVMONTHNAME10=null;this._IMSABBREVMONTHNAME11=null;this._IMSABBREVMONTHNAME12=null;this._IMSDAYNAME1=null;this._IMSDAYNAME2=null;this._IMSDAYNAME3=null;this._IMSDAYNAME4=null;this._IMSDAYNAME5=null;this._IMSDAYNAME6=null;this._IMSDAYNAME7=null;this._IMSABBREVDAYNAME1=null;this._IMSABBREVDAYNAME2=null;this._IMSABBREVDAYNAME3=null;this._IMSABBREVDAYNAME4=null;this._IMSABBREVDAYNAME5=null;this._IMSABBREVDAYNAME6=null;this._IMSABBREVDAYNAME7=null;this._IMTimeSeparator=null;this._IMAMToken=null;this._IMPMToken=null;this._IMEraToken=null};var a=sap.common.globalization.defaultFormat.DateDisplayLocaleInfoImpl;a.prototype.IMDateSeparator=function(b){if(arguments.length>=1){this._IMDateSeparator=b}else{return this._IMDateSeparator}};a.prototype.IMSMONTHNAME1=function(b){if(arguments.length>=1){this._IMSMONTHNAME1=b}else{return this._IMSMONTHNAME1}};a.prototype.IMSMONTHNAME2=function(b){if(arguments.length>=1){this._IMSMONTHNAME2=b}else{return this._IMSMONTHNAME2}};a.prototype.IMSMONTHNAME3=function(b){if(arguments.length>=1){this._IMSMONTHNAME3=b}else{return this._IMSMONTHNAME3}};a.prototype.IMSMONTHNAME4=function(b){if(arguments.length>=1){this._IMSMONTHNAME4=b}else{return this._IMSMONTHNAME4}};a.prototype.IMSMONTHNAME5=function(b){if(arguments.length>=1){this._IMSMONTHNAME5=b}else{return this._IMSMONTHNAME5}};a.prototype.IMSMONTHNAME6=function(b){if(arguments.length>=1){this._IMSMONTHNAME6=b}else{return this._IMSMONTHNAME6}};a.prototype.IMSMONTHNAME7=function(b){if(arguments.length>=1){this._IMSMONTHNAME7=b}else{return this._IMSMONTHNAME7}};a.prototype.IMSMONTHNAME8=function(b){if(arguments.length>=1){this._IMSMONTHNAME8=b}else{return this._IMSMONTHNAME8}};a.prototype.IMSMONTHNAME9=function(b){if(arguments.length>=1){this._IMSMONTHNAME9=b}else{return this._IMSMONTHNAME9}};a.prototype.IMSMONTHNAME10=function(b){if(arguments.length>=1){this._IMSMONTHNAME10=b}else{return this._IMSMONTHNAME10}};a.prototype.IMSMONTHNAME11=function(b){if(arguments.length>=1){this._IMSMONTHNAME11=b}else{return this._IMSMONTHNAME11}};a.prototype.IMSMONTHNAME12=function(b){if(arguments.length>=1){this._IMSMONTHNAME12=b}else{return this._IMSMONTHNAME12}};a.prototype.IMSABBREVMONTHNAME1=function(b){if(arguments.length>=1){this._IMSABBREVMONTHNAME1=b}else{return this._IMSABBREVMONTHNAME1}};a.prototype.IMSABBREVMONTHNAME2=function(b){if(arguments.length>=1){this._IMSABBREVMONTHNAME2=b}else{return this._IMSABBREVMONTHNAME2}};a.prototype.IMSABBREVMONTHNAME3=function(b){if(arguments.length>=1){this._IMSABBREVMONTHNAME3=b}else{return this._IMSABBREVMONTHNAME3}};a.prototype.IMSABBREVMONTHNAME4=function(b){if(arguments.length>=1){this._IMSABBREVMONTHNAME4=b}else{return this._IMSABBREVMONTHNAME4}};a.prototype.IMSABBREVMONTHNAME5=function(b){if(arguments.length>=1){this._IMSABBREVMONTHNAME5=b}else{return this._IMSABBREVMONTHNAME5}};a.prototype.IMSABBREVMONTHNAME6=function(b){if(arguments.length>=1){this._IMSABBREVMONTHNAME6=b}else{return this._IMSABBREVMONTHNAME6}};a.prototype.IMSABBREVMONTHNAME7=function(b){if(arguments.length>=1){this._IMSABBREVMONTHNAME7=b}else{return this._IMSABBREVMONTHNAME7}};a.prototype.IMSABBREVMONTHNAME8=function(b){if(arguments.length>=1){this._IMSABBREVMONTHNAME8=b}else{return this._IMSABBREVMONTHNAME8}};a.prototype.IMSABBREVMONTHNAME9=function(b){if(arguments.length>=1){this._IMSABBREVMONTHNAME9=b}else{return this._IMSABBREVMONTHNAME9}};a.prototype.IMSABBREVMONTHNAME10=function(b){if(arguments.length>=1){this._IMSABBREVMONTHNAME10=b}else{return this._IMSABBREVMONTHNAME10}};a.prototype.IMSABBREVMONTHNAME11=function(b){if(arguments.length>=1){this._IMSABBREVMONTHNAME11=b}else{return this._IMSABBREVMONTHNAME11}};a.prototype.IMSABBREVMONTHNAME12=function(b){if(arguments.length>=1){this._IMSABBREVMONTHNAME12=b}else{return this._IMSABBREVMONTHNAME12}};a.prototype.IMSDAYNAME1=function(b){if(arguments.length>=1){this._IMSDAYNAME1=b}else{return this._IMSDAYNAME1}};a.prototype.IMSDAYNAME2=function(b){if(arguments.length>=1){this._IMSDAYNAME2=b}else{return this._IMSDAYNAME2}};a.prototype.IMSDAYNAME3=function(b){if(arguments.length>=1){this._IMSDAYNAME3=b}else{return this._IMSDAYNAME3}};a.prototype.IMSDAYNAME4=function(b){if(arguments.length>=1){this._IMSDAYNAME4=b}else{return this._IMSDAYNAME4}};a.prototype.IMSDAYNAME5=function(b){if(arguments.length>=1){this._IMSDAYNAME5=b}else{return this._IMSDAYNAME5}};a.prototype.IMSDAYNAME6=function(b){if(arguments.length>=1){this._IMSDAYNAME6=b}else{return this._IMSDAYNAME6}};a.prototype.IMSDAYNAME7=function(b){if(arguments.length>=1){this._IMSDAYNAME7=b}else{return this._IMSDAYNAME7}};a.prototype.IMSABBREVDAYNAME1=function(b){if(arguments.length>=1){this._IMSABBREVDAYNAME1=b}else{return this._IMSABBREVDAYNAME1}};a.prototype.IMSABBREVDAYNAME2=function(b){if(arguments.length>=1){this._IMSABBREVDAYNAME2=b}else{return this._IMSABBREVDAYNAME2}};a.prototype.IMSABBREVDAYNAME3=function(b){if(arguments.length>=1){this._IMSABBREVDAYNAME3=b}else{return this._IMSABBREVDAYNAME3}};a.prototype.IMSABBREVDAYNAME4=function(b){if(arguments.length>=1){this._IMSABBREVDAYNAME4=b}else{return this._IMSABBREVDAYNAME4}};a.prototype.IMSABBREVDAYNAME5=function(b){if(arguments.length>=1){this._IMSABBREVDAYNAME5=b}else{return this._IMSABBREVDAYNAME5}};a.prototype.IMSABBREVDAYNAME6=function(b){if(arguments.length>=1){this._IMSABBREVDAYNAME6=b}else{return this._IMSABBREVDAYNAME6}};a.prototype.IMSABBREVDAYNAME7=function(b){if(arguments.length>=1){this._IMSABBREVDAYNAME7=b}else{return this._IMSABBREVDAYNAME7}};a.prototype.IMTimeSeparator=function(b){if(arguments.length>=1){this._IMTimeSeparator=b}else{return this._IMTimeSeparator}};a.prototype.IMAMTOKEN=function(b){if(arguments.length>=1){this._IMAMToken=b}else{return this._IMAMToken}};a.prototype.IMPMTOKEN=function(b){if(arguments.length>=1){this._IMPMToken=b}else{return this._IMPMToken}};a.prototype.IMEraToken=function(b){if(arguments.length>=1){this._IMEraToken=b}else{return this._IMEraToken}}})();(function(){sap.common.globalization.declare("sap.common.globalization.defaultFormat.DateParseLocaleInfoImpl");sap.common.globalization.defaultFormat.DateParseLocaleInfoImpl=function(){this.__className="sap.common.globalization.defaultFormat.DateParseLocaleInfoImpl";this._IMDateSeparator=null;this._IMTimeSeparator=null};sap.common.globalization.defaultFormat.DateParseLocaleInfoImpl.prototype.IMDateSeparator=function(a){if(arguments.length>=1){this._IMDateSeparator=a}else{return this._IMDateSeparator}};sap.common.globalization.defaultFormat.DateParseLocaleInfoImpl.prototype.IMTimeSeparator=function(a){if(arguments.length>=1){this._IMTimeSeparator=a}else{return this._IMTimeSeparator}}})();(function(){sap.common.globalization.declare("sap.common.globalization.defaultFormat.DefaultBooleanFormatLocaleFactory");sap.common.globalization.require("sap.common.globalization.defaultFormat.BooleanDisplayLocaleInfo");sap.common.globalization.require("sap.common.globalization.GlobalizationBooleanConstant");sap.common.globalization.require("sap.common.globalization.defaultFormat.BooleanDisplayLocaleInfo");sap.common.globalization.defaultFormat.DefaultBooleanFormatLocaleFactory=function(){this.className="sap.common.globalization.defaultFormat.DefaultBooleanFormatLocaleFactory";this._displayLocale=null};var a=sap.common.globalization.defaultFormat.DefaultBooleanFormatLocaleFactory;a._instance=null;a.getInstance=function(){if(!a._instance){a._instance=new sap.common.globalization.defaultFormat.DefaultBooleanFormatLocaleFactory()}return a._instance};a.prototype.getBooleanDisplayLocaleInfo=function(){if(!this._displayLocale){this._displayLocale=new sap.common.globalization.defaultFormat.BooleanDisplayLocaleInfo();var b=sap.common.globalization.GlobalizationBooleanConstant.getBooleanStrings();if(b){this._displayLocale.trueString(b[0]);this._displayLocale.falseString(b[1])}}return this._displayLocale}})();(function(){sap.common.globalization.declare("sap.common.globalization.defaultFormat.DefaultNumericFormatLocaleFactory");sap.common.globalization.require("sap.common.globalization.defaultFormat.NumericParseLocaleInfoImpl");sap.common.globalization.require("sap.common.globalization.GlobalizationNumericConstant");sap.common.globalization.require("sap.common.globalization.numericFormat.FLocalization");sap.common.globalization.require("sap.common.globalization.defaultFormat.NumericDisplayLocaleInfoImpl");sap.common.globalization.require("sap.common.globalization.numericFormat.FDefaultNumber");sap.common.globalization.require("sap.common.globalization.GlobalizationNumericUtil");sap.common.globalization.require("sap.common.globalization.GlobalizationNumericConstant");sap.common.globalization.require("sap.common.globalization.numericFormat.TwoDigitGroupingStrategy");sap.common.globalization.defaultFormat.DefaultNumericFormatLocaleFactory=function(){this.__className="sap.common.globalization.defaultFormat.DefaultNumericFormatLocaleFactory.DefaultNumericFormatLocaleFactory";this._numericParseLocaleInfo=null;this._numericDisplayLocaleInfo=null};var a=sap.common.globalization.defaultFormat.DefaultNumericFormatLocaleFactory;a.prototype.getNumericParseLocaleInfo=function(){var b=sap.common.globalization;if(!this._numericParseLocaleInfo){this._numericParseLocaleInfo=new b.defaultFormat.NumericParseLocaleInfoImpl(b.GlobalizationNumericConstant.getParseThousandSeparator(),b.GlobalizationNumericConstant.getParseDecimalSeparator(),b.GlobalizationNumericConstant.getParseCurrencySymbol())}return this._numericParseLocaleInfo};a.prototype.getNumericDisplayLocaleInfo=function(){if(!this._numericDisplayLocaleInfo){var e=",";var d=".";var b=sap.common.globalization;if(b.numericFormat.FLocalization.getInstance().SAPThousandsSeparator){e=b.numericFormat.FLocalization.getInstance().SAPThousandsSeparator}else{if(b.GlobalizationNumericConstant.getDisplayThousandSeparator()){e=b.GlobalizationNumericConstant.getDisplayThousandSeparator()}}if(b.numericFormat.FLocalization.getInstance().SAPDecimalSeparator){d=b.numericFormat.FLocalization.getInstance().SAPDecimalSeparator}else{if(b.GlobalizationNumericConstant.getDisplayDecimalSeparator()){d=b.GlobalizationNumericConstant.getDisplayDecimalSeparator()}}var c=(b.numericFormat.FLocalization.getInstance().SAPCurrencySymbol?b.numericFormat.FLocalization.getInstance().SAPCurrencySymbol:this.displayCurrencySymbol());this._numericDisplayLocaleInfo=new b.defaultFormat.NumericDisplayLocaleInfoImpl(e,d,c)}return this._numericDisplayLocaleInfo};a.prototype.createFNumber=function(){var b=new sap.common.globalization.numericFormat.FDefaultNumber(this.getNumericParseLocaleInfo(),this.getNumericDisplayLocaleInfo());if(sap.common.globalization.GlobalizationNumericUtil.isTwoDigitGroupingCountry(sap.common.globalization.GlobalizationNumericConstant.getActualLocaleForDefaultNumberFormat())){b.groupingStrategy=sap.common.globalization.numericFormat.TwoDigitGroupingStrategy.instance()}return b};a.prototype.getDefaultNumericFormat=function(){if(sap.common.globalization.GlobalizationNumericConstant.getDefaultNumberFormat()){return sap.common.globalization.GlobalizationNumericConstant.getDefaultNumberFormat()}return"#,##0.###"};a.prototype.displayCurrencySymbol=function(){return""}})();(function(){sap.common.globalization.declare("sap.common.globalization.defaultFormat.DefaultTimeFormatLocaleFactory");sap.common.globalization.require("sap.common.globalization.defaultFormat.DefaultDateFormatLocaleFactory");sap.common.globalization.require("sap.common.globalization.GlobalizationDateConstant");sap.common.globalization.require("sap.common.globalization.defaultFormat.DateParseLocaleInfoImpl");sap.common.globalization.require("sap.common.globalization.defaultFormat.DateDisplayLocaleInfoImpl");sap.common.globalization.require("sap.common.globalization.numericFormat.FLocalization");var a=sap.common.globalization.defaultFormat;a.DefaultTimeFormatLocaleFactory=function(){a.DefaultTimeFormatLocaleFactory.superclass.constructor.apply(this);this.__className="sap.common.globalization.defaultFormat.DefaultTimeFormatLocaleFactory"};a.DefaultTimeFormatLocaleFactory=sap.common.globalization.extend(a.DefaultTimeFormatLocaleFactory,a.DefaultDateFormatLocaleFactory);a.DefaultTimeFormatLocaleFactory.prototype.getDefaultDateFormat=function(){return sap.common.globalization.GlobalizationDateConstant.getDefaultTimeFormat()};a.DefaultTimeFormatLocaleFactory.prototype.applySAPDateTokensAndSeparators=function(c){var b=sap.common.globalization.numericFormat.FLocalization.getInstance();if(c&&b&&b.SAPTimeSeparator){c.IMTimeSeparator(b.SAPTimeSeparator)}};a.DefaultTimeFormatLocaleFactory.prototype.getPredefinedDateParseLocaleString=function(){var c=new sap.common.globalization.defaultFormat.DateParseLocaleInfoImpl();var b=sap.common.globalization.GlobalizationDateConstant.getTimeSeparator();if(b&&c){c.IMTimeSeparator(b)}return c};a.DefaultTimeFormatLocaleFactory.prototype.getPredefinedDateDisplayLocaleString=function(){var d=new sap.common.globalization.defaultFormat.DateDisplayLocaleInfoImpl();var b=sap.common.globalization.GlobalizationDateConstant.getTimeSeparator();if(b&&d){d.IMTimeSeparator(b)}var c=sap.common.globalization.GlobalizationDateConstant.getAmPmToken();if(c&&d){d.IMAMTOKEN(c[0]);d.IMPMTOKEN(c[1])}return d}})();(function(){sap.common.globalization.declare("sap.common.globalization.defaultFormat.NumericDisplayLocaleInfoImpl");sap.common.globalization.defaultFormat.NumericDisplayLocaleInfoImpl=function(a,b,c){if(a){this._thousandsSeparator=a}else{this._thousandsSeparator=","}if(b){this._decimalSeparator=b}else{this._decimalSeparator="."}if(c){this._currencySymbol=c}else{this._currencySymbol=""}};sap.common.globalization.defaultFormat.NumericDisplayLocaleInfoImpl.prototype.thousandsSeparator=function(){return this._thousandsSeparator};sap.common.globalization.defaultFormat.NumericDisplayLocaleInfoImpl.prototype.decimalSeparator=function(){return this._decimalSeparator};sap.common.globalization.defaultFormat.NumericDisplayLocaleInfoImpl.prototype.currencySymbol=function(){return this._currencySymbol}})();(function(){sap.common.globalization.declare("sap.common.globalization.defaultFormat.NumericParseLocaleInfoImpl");sap.common.globalization.defaultFormat.NumericParseLocaleInfoImpl=function(a,b,c){if(a){this._thousandsSeparator=a}else{this._thousandsSeparator=","}if(b){this._decimalSeparator=b}else{this._decimalSeparator="."}if(c){this._currencySymbol=c}else{this._currencySymbol=""}};sap.common.globalization.defaultFormat.NumericParseLocaleInfoImpl.prototype.thousandsSeparator=function(){return this._thousandsSeparator};sap.common.globalization.defaultFormat.NumericParseLocaleInfoImpl.prototype.decimalSeparator=function(){return this._decimalSeparator};sap.common.globalization.defaultFormat.NumericParseLocaleInfoImpl.prototype.currencySymbol=function(){return this._currencySymbol}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FDateA");var a=sap.common.globalization.numericFormat;a.FDateA=function(b){this.__className="sap.common.globalization.numericFormat.FDateA";this._full=true;this._displayLocale=b};a.FDateA.prototype.parse=function(e,d){var c=0;var b=d.toLowerCase();if(b.substr(0,5)=="am/pm"){e.miltime=false;c=5}if(b.substr(0,3)=="a/p"){e.miltime=false;this._full=false;c=3}return c};a.FDateA.prototype.display=function(c){var b="";if(c.getHrs()>=12){if(this._full){b=this._displayLocale.IMPMTOKEN()?this._displayLocale.IMPMTOKEN():"PM"}else{b=this._displayLocale.IMPMTOKEN()?this._displayLocale.IMPMTOKEN():"P"}}else{if(this._full){b=this._displayLocale.IMAMTOKEN()?this._displayLocale.IMAMTOKEN():"AM"}else{b=this._displayLocale.IMAMTOKEN()?this._displayLocale.IMAMTOKEN():"A"}}return b}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FDateB");sap.common.globalization.require("sap.common.globalization.numericFormat.FDateM");sap.common.globalization.require("sap.common.globalization.numericFormat.FDateH");sap.common.globalization.require("sap.common.globalization.numericFormat.FDateS");var a=sap.common.globalization.numericFormat;a.FDateB=function(b){this.__className="sap.common.globalization.numericFormat.FDateB";this._displayLocaleInfo=b;this.mask=undefined;this.c="";this._tok={};this.initializeTokenMap()};a.FDateB.prototype.parse=function(f,e){var c=2;this.c=e.charAt(1);var d=this.createTokenFormatter(this._tok[this.c]);if(this.c=="M"||this.c=="m"){d.bminute=true}var b=d.parse(f,e.substring(1));if(b>0){this.mask=d;c+=b}return c};a.FDateB.prototype.display=function(c){var b;if(this.c=="S"||this.c=="s"){b=86400*c.serial}else{if(this.c=="M"||this.c=="m"){b=1440*c.serial}else{if(this.c=="H"||this.c=="h"){b=24*c.serial}}}this.mask.value=Math.floor(b);return this.mask.display(c)};a.FDateB.prototype.createTokenFormatter=function(b){var c=null;switch(b){case a.FDateM:c=new a.FDateM(this._displayLocaleInfo);break;case a.FDateH:c=new a.FDateH();break;case a.FDateS:c=new a.FDateS();break;default:}return c};a.FDateB.prototype.initializeTokenMap=function(){this._tok.M=a.FDateM;this._tok.H=a.FDateH;this._tok.S=a.FDateS;this._tok.m=a.FDateM;this._tok.h=a.FDateH;this._tok.s=a.FDateS}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FDateD");var a=sap.common.globalization.numericFormat;a.FDateD=function(b){this.__className="sap.common.globalization.numericFormat.FDateD";this._placeholders=0;this._displayLocaleInfo=b};a.FDateD.prototype.getPlaceholders=function(){return this._placeholders};a.FDateD.prototype.parse=function(d,c){var b=0;while(c.charAt(b)=="D"||c.charAt(b)=="d"){b++}if(b<=2){this._placeholders=b}else{if(b==3){this._placeholders=-1}else{if(b>=4){this._placeholders=-2}}}return b};a.FDateD.prototype.display=function(d){var c="";if(this._placeholders>=0){c+=d.getDate();while(c.length<this._placeholders){c="0"+c}}else{var b=d.getDay();if(this._placeholders==-1){c+=this.getShortDay(b)}else{c+=this.getDay(b)}}return c};a.FDateD.prototype.getDay=function(b){if(b==0){return this._displayLocaleInfo.IMSDAYNAME7()}if(b==1){return this._displayLocaleInfo.IMSDAYNAME1()}if(b==2){return this._displayLocaleInfo.IMSDAYNAME2()}if(b==3){return this._displayLocaleInfo.IMSDAYNAME3()}if(b==4){return this._displayLocaleInfo.IMSDAYNAME4()}if(b==5){return this._displayLocaleInfo.IMSDAYNAME5()}if(b==6||b==-1){return this._displayLocaleInfo.IMSDAYNAME6()}return this._displayLocaleInfo.IMSDAYNAME6()};a.FDateD.prototype.getShortDay=function(b){if(b==0){return this._displayLocaleInfo.IMSABBREVDAYNAME7().split(".")[0]}if(b==1){return this._displayLocaleInfo.IMSABBREVDAYNAME1().split(".")[0]}if(b==2){return this._displayLocaleInfo.IMSABBREVDAYNAME2().split(".")[0]}if(b==3){return this._displayLocaleInfo.IMSABBREVDAYNAME3().split(".")[0]}if(b==4){return this._displayLocaleInfo.IMSABBREVDAYNAME4().split(".")[0]}if(b==5){return this._displayLocaleInfo.IMSABBREVDAYNAME5().split(".")[0]}if(b==6||b==-1){return this._displayLocaleInfo.IMSABBREVDAYNAME6().split(".")[0]}return this._displayLocaleInfo.IMSABBREVDAYNAME6().split(".")[0]}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FDateH");var a=sap.common.globalization.numericFormat;a.FDateH=function(){this.__className="sap.common.globalization.numericFormat.FDateH";this.placeholders=1;this.number=0;this.value=NaN};sap.common.globalization.numericFormat.FDateH.prototype.parse=function(d,c){var b=0;this.number=d.HNum+1;d.HBool=true;d.HNum=this.number;while(c.charAt(b)=="H"||c.charAt(b)=="h"){b++}if(b>1){this.placeholders=2}return b};a.FDateH.prototype.display=function(d){var b;if(isNaN(this.value)){b=d.getHrs()}else{b=this.value}if(!d.miltime){if(this.number==d.HNum){if(b>11){b=b-12}if(b==0){b=12}}}var c=""+b;while(this.placeholders>c.length){c="0"+c}return c}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FDateM");var a=sap.common.globalization.numericFormat;a.FDateM=function(b){this.__className="sap.common.globalization.numericFormat.FDateM";this.bminute=false;this.placeholders=0;this.value=undefined;this._displayLocaleInfo=b};a.FDateM.prototype.parse=function(d,c){var b=0;while(c.charAt(b)=="M"||c.charAt(b)=="m"){b++}if(b<=2){if(d.HBool){this.bminute=true}d.HBool=false;this.placeholders=b}else{if(b==3){this.placeholders=-1}else{if(b==4){this.placeholders=-2}else{if(b==5){this.placeholders=-3}}}}return b};a.FDateM.prototype.display=function(g){var f="";if(this.placeholders>=0&&this.bminute){if(this.value==undefined){f+=g.getMin()}else{f+=this.value}while(f.length<this.placeholders){f="0"+f}}else{var d=g.getMonth();if(this.placeholders>=0){d++;f+=d;while(f.length<this.placeholders){f="0"+f}}else{var e=new Array(this._displayLocaleInfo.IMSMONTHNAME1(),this._displayLocaleInfo.IMSMONTHNAME2(),this._displayLocaleInfo.IMSMONTHNAME3(),this._displayLocaleInfo.IMSMONTHNAME4(),this._displayLocaleInfo.IMSMONTHNAME5(),this._displayLocaleInfo.IMSMONTHNAME6(),this._displayLocaleInfo.IMSMONTHNAME7(),this._displayLocaleInfo.IMSMONTHNAME8(),this._displayLocaleInfo.IMSMONTHNAME9(),this._displayLocaleInfo.IMSMONTHNAME10(),this._displayLocaleInfo.IMSMONTHNAME11(),this._displayLocaleInfo.IMSMONTHNAME12());var c=new Array(this._displayLocaleInfo.IMSABBREVMONTHNAME1(),this._displayLocaleInfo.IMSABBREVMONTHNAME2(),this._displayLocaleInfo.IMSABBREVMONTHNAME3(),this._displayLocaleInfo.IMSABBREVMONTHNAME4(),this._displayLocaleInfo.IMSABBREVMONTHNAME5(),this._displayLocaleInfo.IMSABBREVMONTHNAME6(),this._displayLocaleInfo.IMSABBREVMONTHNAME7(),this._displayLocaleInfo.IMSABBREVMONTHNAME8(),this._displayLocaleInfo.IMSABBREVMONTHNAME9(),this._displayLocaleInfo.IMSABBREVMONTHNAME10(),this._displayLocaleInfo.IMSABBREVMONTHNAME11(),this._displayLocaleInfo.IMSABBREVMONTHNAME12());if(this.placeholders==-1){f+=c[d]}else{if(this.placeholders==-3){f+=e[d].substring(0,1)}else{f+=e[d]}}}}return f}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FDateS");sap.common.globalization.require("sap.common.globalization.numericFormat.FLocalization");sap.common.globalization.numericFormat.FDateS=function(){this.__className="sap.common.globalization.numericFormat.FDateS";this.splaceholders=1;this.msplaceholders=0;this.value=undefined;this.IMDecimalSeparator=sap.common.globalization.numericFormat.FLocalization.getInstance().IMDecimalSeparator;this.ms=NaN};sap.common.globalization.numericFormat.FDateS.prototype.parse=function(g,f){var e=0;var c=g.mask;var b=c.length;for(var d=b-1;d>=0;d--){if(c[d].__className=="sap.common.globalization.numericFormat.FDateM"){c[d].bminute=true;break}}while(f.charAt(e)=="S"||f.charAt(e)=="s"){e++}if(e>1){this.splaceholders=2}if(f.charAt(e)==this.IMDecimalSeparator.charAt(0)&&f.charAt(e+1)=="0"){e++;while(f.charAt(e)=="0"){e++;this.msplaceholders++}if(this.msplaceholders>g.ms){g.ms=this.msplaceholders}}return e};sap.common.globalization.numericFormat.FDateS.prototype.display=function(d){var c;if(this.value==undefined){c=""+d.getSec()}else{c=""+this.value}while(this.splaceholders>c.length){c="0"+c}if(this.msplaceholders>0){var a=d.getMS()/Math.pow(10,(3-this.msplaceholders));if(this.msplaceholders<this.ms){a=Math.floor(a)}else{a=Math.round(a)}var b=""+a;while(b.length<this.msplaceholders){b="0"+b}c+=this.IMDecimalSeparator+b}return c}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FDateSep");sap.common.globalization.numericFormat.FDateSep=function(a,b){this.__className="sap.common.globalization.numericFormat.FDateSep";this._parseLocalInfo=a;this._displayLocaleInfo=b};sap.common.globalization.numericFormat.FDateSep.prototype.parse=function(c,b){var a=b.charAt(0);if(this._displayLocaleInfo.IMDateSeparator()!=null&&(a=="."||a=="/"||a=="-")){return 1}else{return 0}};sap.common.globalization.numericFormat.FDateSep.prototype.display=function(b){var a=this._displayLocaleInfo.IMDateSeparator();return a}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FDateY");sap.common.globalization.numericFormat.FDateY=function(){this.__className="sap.common.globalization.numericFormat.FDateY";this.placeholders=2};sap.common.globalization.numericFormat.FDateY.prototype.parse=function(c,b){var a=0;while(b.charAt(a)=="Y"||b.charAt(a)=="y"){a++}if(a>2){this.placeholders=4}return a};sap.common.globalization.numericFormat.FDateY.prototype.display=function(b){var a=""+b.getYear();if(this.placeholders<4){a=a.substring(2)}return a}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FText");sap.common.globalization.numericFormat.FText=function(){this.__className="sap.common.globalization.numericFormat.FText";this.color=NaN;this.format="";this.condnum=0;this.cond={};this.numAts=0;this.mask=new Array()};sap.common.globalization.numericFormat.FText.tokens="@";sap.common.globalization.numericFormat.FText.prototype.parse=function(b){var a=0;while(b.charAt(a)=="@"){a++}this.numAts=a;return a};sap.common.globalization.numericFormat.FText.prototype.display=function(a){var c="";for(var b=0;b<this.numAts;b++){c+=a.toString()}return c}})();(function(){sap.common.globalization.declare("sap.common.globalization.defaultFormat.DateDisplayLocaleInfoImpl");sap.common.globalization.defaultFormat.DateDisplayLocaleInfoImpl=function(){this.__className="sap.common.globalization.defaultFormat.DateDisplayLocaleInfoImpl";this._IMDateSeparator=null;this._IMSMONTHNAME1=null;this._IMSMONTHNAME2=null;this._IMSMONTHNAME3=null;this._IMSMONTHNAME4=null;this._IMSMONTHNAME5=null;this._IMSMONTHNAME6=null;this._IMSMONTHNAME7=null;this._IMSMONTHNAME8=null;this._IMSMONTHNAME9=null;this._IMSMONTHNAME10=null;this._IMSMONTHNAME11=null;this._IMSMONTHNAME12=null;this._IMSABBREVMONTHNAME1=null;this._IMSABBREVMONTHNAME2=null;this._IMSABBREVMONTHNAME3=null;this._IMSABBREVMONTHNAME4=null;this._IMSABBREVMONTHNAME5=null;this._IMSABBREVMONTHNAME6=null;this._IMSABBREVMONTHNAME7=null;this._IMSABBREVMONTHNAME8=null;this._IMSABBREVMONTHNAME9=null;this._IMSABBREVMONTHNAME10=null;this._IMSABBREVMONTHNAME11=null;this._IMSABBREVMONTHNAME12=null;this._IMSDAYNAME1=null;this._IMSDAYNAME2=null;this._IMSDAYNAME3=null;this._IMSDAYNAME4=null;this._IMSDAYNAME5=null;this._IMSDAYNAME6=null;this._IMSDAYNAME7=null;this._IMSABBREVDAYNAME1=null;this._IMSABBREVDAYNAME2=null;this._IMSABBREVDAYNAME3=null;this._IMSABBREVDAYNAME4=null;this._IMSABBREVDAYNAME5=null;this._IMSABBREVDAYNAME6=null;this._IMSABBREVDAYNAME7=null;this._IMTimeSeparator=null;this._IMAMToken=null;this._IMPMToken=null;this._IMEraToken=null};var a=sap.common.globalization.defaultFormat.DateDisplayLocaleInfoImpl;a.prototype.IMDateSeparator=function(b){if(arguments.length>=1){this._IMDateSeparator=b}else{return this._IMDateSeparator}};a.prototype.IMSMONTHNAME1=function(b){if(arguments.length>=1){this._IMSMONTHNAME1=b}else{return this._IMSMONTHNAME1}};a.prototype.IMSMONTHNAME2=function(b){if(arguments.length>=1){this._IMSMONTHNAME2=b}else{return this._IMSMONTHNAME2}};a.prototype.IMSMONTHNAME3=function(b){if(arguments.length>=1){this._IMSMONTHNAME3=b}else{return this._IMSMONTHNAME3}};a.prototype.IMSMONTHNAME4=function(b){if(arguments.length>=1){this._IMSMONTHNAME4=b}else{return this._IMSMONTHNAME4}};a.prototype.IMSMONTHNAME5=function(b){if(arguments.length>=1){this._IMSMONTHNAME5=b}else{return this._IMSMONTHNAME5}};a.prototype.IMSMONTHNAME6=function(b){if(arguments.length>=1){this._IMSMONTHNAME6=b}else{return this._IMSMONTHNAME6}};a.prototype.IMSMONTHNAME7=function(b){if(arguments.length>=1){this._IMSMONTHNAME7=b}else{return this._IMSMONTHNAME7}};a.prototype.IMSMONTHNAME8=function(b){if(arguments.length>=1){this._IMSMONTHNAME8=b}else{return this._IMSMONTHNAME8}};a.prototype.IMSMONTHNAME9=function(b){if(arguments.length>=1){this._IMSMONTHNAME9=b}else{return this._IMSMONTHNAME9}};a.prototype.IMSMONTHNAME10=function(b){if(arguments.length>=1){this._IMSMONTHNAME10=b}else{return this._IMSMONTHNAME10}};a.prototype.IMSMONTHNAME11=function(b){if(arguments.length>=1){this._IMSMONTHNAME11=b}else{return this._IMSMONTHNAME11}};a.prototype.IMSMONTHNAME12=function(b){if(arguments.length>=1){this._IMSMONTHNAME12=b}else{return this._IMSMONTHNAME12}};a.prototype.IMSABBREVMONTHNAME1=function(b){if(arguments.length>=1){this._IMSABBREVMONTHNAME1=b}else{return this._IMSABBREVMONTHNAME1}};a.prototype.IMSABBREVMONTHNAME2=function(b){if(arguments.length>=1){this._IMSABBREVMONTHNAME2=b}else{return this._IMSABBREVMONTHNAME2}};a.prototype.IMSABBREVMONTHNAME3=function(b){if(arguments.length>=1){this._IMSABBREVMONTHNAME3=b}else{return this._IMSABBREVMONTHNAME3}};a.prototype.IMSABBREVMONTHNAME4=function(b){if(arguments.length>=1){this._IMSABBREVMONTHNAME4=b}else{return this._IMSABBREVMONTHNAME4}};a.prototype.IMSABBREVMONTHNAME5=function(b){if(arguments.length>=1){this._IMSABBREVMONTHNAME5=b}else{return this._IMSABBREVMONTHNAME5}};a.prototype.IMSABBREVMONTHNAME6=function(b){if(arguments.length>=1){this._IMSABBREVMONTHNAME6=b}else{return this._IMSABBREVMONTHNAME6}};a.prototype.IMSABBREVMONTHNAME7=function(b){if(arguments.length>=1){this._IMSABBREVMONTHNAME7=b}else{return this._IMSABBREVMONTHNAME7}};a.prototype.IMSABBREVMONTHNAME8=function(b){if(arguments.length>=1){this._IMSABBREVMONTHNAME8=b}else{return this._IMSABBREVMONTHNAME8}};a.prototype.IMSABBREVMONTHNAME9=function(b){if(arguments.length>=1){this._IMSABBREVMONTHNAME9=b}else{return this._IMSABBREVMONTHNAME9}};a.prototype.IMSABBREVMONTHNAME10=function(b){if(arguments.length>=1){this._IMSABBREVMONTHNAME10=b}else{return this._IMSABBREVMONTHNAME10}};a.prototype.IMSABBREVMONTHNAME11=function(b){if(arguments.length>=1){this._IMSABBREVMONTHNAME11=b}else{return this._IMSABBREVMONTHNAME11}};a.prototype.IMSABBREVMONTHNAME12=function(b){if(arguments.length>=1){this._IMSABBREVMONTHNAME12=b}else{return this._IMSABBREVMONTHNAME12}};a.prototype.IMSDAYNAME1=function(b){if(arguments.length>=1){this._IMSDAYNAME1=b}else{return this._IMSDAYNAME1}};a.prototype.IMSDAYNAME2=function(b){if(arguments.length>=1){this._IMSDAYNAME2=b}else{return this._IMSDAYNAME2}};a.prototype.IMSDAYNAME3=function(b){if(arguments.length>=1){this._IMSDAYNAME3=b}else{return this._IMSDAYNAME3}};a.prototype.IMSDAYNAME4=function(b){if(arguments.length>=1){this._IMSDAYNAME4=b}else{return this._IMSDAYNAME4}};a.prototype.IMSDAYNAME5=function(b){if(arguments.length>=1){this._IMSDAYNAME5=b}else{return this._IMSDAYNAME5}};a.prototype.IMSDAYNAME6=function(b){if(arguments.length>=1){this._IMSDAYNAME6=b}else{return this._IMSDAYNAME6}};a.prototype.IMSDAYNAME7=function(b){if(arguments.length>=1){this._IMSDAYNAME7=b}else{return this._IMSDAYNAME7}};a.prototype.IMSABBREVDAYNAME1=function(b){if(arguments.length>=1){this._IMSABBREVDAYNAME1=b}else{return this._IMSABBREVDAYNAME1}};a.prototype.IMSABBREVDAYNAME2=function(b){if(arguments.length>=1){this._IMSABBREVDAYNAME2=b}else{return this._IMSABBREVDAYNAME2}};a.prototype.IMSABBREVDAYNAME3=function(b){if(arguments.length>=1){this._IMSABBREVDAYNAME3=b}else{return this._IMSABBREVDAYNAME3}};a.prototype.IMSABBREVDAYNAME4=function(b){if(arguments.length>=1){this._IMSABBREVDAYNAME4=b}else{return this._IMSABBREVDAYNAME4}};a.prototype.IMSABBREVDAYNAME5=function(b){if(arguments.length>=1){this._IMSABBREVDAYNAME5=b}else{return this._IMSABBREVDAYNAME5}};a.prototype.IMSABBREVDAYNAME6=function(b){if(arguments.length>=1){this._IMSABBREVDAYNAME6=b}else{return this._IMSABBREVDAYNAME6}};a.prototype.IMSABBREVDAYNAME7=function(b){if(arguments.length>=1){this._IMSABBREVDAYNAME7=b}else{return this._IMSABBREVDAYNAME7}};a.prototype.IMTimeSeparator=function(b){if(arguments.length>=1){this._IMTimeSeparator=b}else{return this._IMTimeSeparator}};a.prototype.IMAMTOKEN=function(b){if(arguments.length>=1){this._IMAMToken=b}else{return this._IMAMToken}};a.prototype.IMPMTOKEN=function(b){if(arguments.length>=1){this._IMPMToken=b}else{return this._IMPMToken}};a.prototype.IMEraToken=function(b){if(arguments.length>=1){this._IMEraToken=b}else{return this._IMEraToken}}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FDate");sap.common.globalization.require("sap.common.globalization.numericFormat.FDateM");sap.common.globalization.require("sap.common.globalization.numericFormat.FDateD");sap.common.globalization.require("sap.common.globalization.numericFormat.FDateY");sap.common.globalization.require("sap.common.globalization.numericFormat.FDateH");sap.common.globalization.require("sap.common.globalization.numericFormat.FDateS");sap.common.globalization.require("sap.common.globalization.numericFormat.FTimeSep");sap.common.globalization.require("sap.common.globalization.numericFormat.FDateA");sap.common.globalization.require("sap.common.globalization.numericFormat.FDateB");sap.common.globalization.require("sap.common.globalization.numericFormat.FDateSep");var a=sap.common.globalization.numericFormat;a.FDate=function(c,b){this.__className="sap.common.globalization.numericFormat.FDate";this.date;this.color;this.condnum;this.cond;this.tok={};this.HBool=false;this.serial=37500;this.format="";this.HNum=0;this.miltime=true;this.ms=0;this.mask=new Array();this._parseLocaleInfo=c;this._displayLocaleInfo=b;this._inputIsDateType=false;this.initializeTokenMap()};a.FDate.tokens="MDYHSAmdyhsa";a.FDate.prototype.parse=function(f){var g=f.charAt(0);if(g=="."){g=f.substring(0,2)}var e=this.tok[g];if(e==undefined){return 0}var d=this.createTokenFormatter(e);var b=d.parse(this,f);if(b>0){this.mask.push(d)}else{b=0}return b};a.FDate.prototype.display=function(d){if(d<0){return"###########################################"}this.setNumber(d);var c=this.mask;var b=c.length;var f="";for(var e=0;e<b;e++){if((typeof c[e])=="object"){f+=c[e].display(this)}else{f+=c[e]}}return f};a.FDate.prototype.getMaskClone=function(){if(this.mask){return this.mask.slice()}return[]};a.FDate.prototype.getYear=function(){if(this._inputIsDateType){return this.date.getFullYear()}if(this.serial>=0&&this.serial<1){return 1900}return this.date.getUTCFullYear()};a.FDate.prototype.getMonth=function(){if(this._inputIsDateType){return this.date.getMonth()}if(this.serial>=0&&this.serial<1){return 0}return this.date.getUTCMonth()};a.FDate.prototype.getDate=function(){if(this._inputIsDateType){return this.date.getDate()}if(this.serial>=0&&this.serial<1){return 0}if(this.serial==60){return 29}return this.date.getUTCDate()};a.FDate.prototype.getDay=function(){var b=this.date.getUTCDay();if(this.serial<60){b--}if(this._inputIsDateType){b=this.date.getDay()}return b};a.FDate.prototype.getHrs=function(){if(this._inputIsDateType){return this.date.getHours()}return this.date.getUTCHours()};a.FDate.prototype.getMin=function(){if(this._inputIsDateType){return this.date.getMinutes()}return this.date.getUTCMinutes()};a.FDate.prototype.getSec=function(){if(this._inputIsDateType){return this.date.getSeconds()}return this.date.getUTCSeconds()};a.FDate.prototype.getMS=function(){if(this._inputIsDateType){return this.date.getMilliseconds()}return this.date.getUTCMilliseconds()};a.FDate.prototype.setNumber=function(b){if(b instanceof Date){var e=new Date();e.setTime(b.getTime());this.date=e;this._inputIsDateType=true;this.serial=37500;return}this._inputIsDateType=false;this.serial=b;if(b<60){b++}var d=b*86400*1000;var c=d-(2209161600*1000);this.date=new Date(c);if(this.date.getUTCMilliseconds()>=500){this.date.setUTCMilliseconds(this.date.getUTCMilliseconds()+500)}};a.FDate.prototype.createTokenFormatter=function(b){var c=null;switch(b){case a.FDateM:c=new a.FDateM(this._displayLocaleInfo);break;case a.FDateD:c=new a.FDateD(this._displayLocaleInfo);break;case a.FDateY:c=new a.FDateY();break;case a.FDateH:c=new a.FDateH();break;case a.FDateS:c=new a.FDateS();break;case a.FDateSep:c=new a.FDateSep(this._parseLocaleInfo,this._displayLocaleInfo);break;case a.FTimeSep:c=new a.FTimeSep(this._parseLocaleInfo,this._displayLocaleInfo);break;case a.FDateA:c=new a.FDateA(this._displayLocaleInfo);break;case a.FDateB:c=new a.FDateB(this._displayLocaleInfo);break;default:}return c};a.FDate.prototype.initializeTokenMap=function(){this.tok.M=a.FDateM;this.tok.D=a.FDateD;this.tok.Y=a.FDateY;this.tok.H=a.FDateH;this.tok.S=a.FDateS;this.tok.A=a.FDateA;this.tok.m=a.FDateM;this.tok.d=a.FDateD;this.tok.y=a.FDateY;this.tok.h=a.FDateH;this.tok.s=a.FDateS;this.tok.a=a.FDateA;this.tok["["]=a.FDateB;this.tok["/"]=a.FDateSep;this.tok[".M"]=a.FDateSep;this.tok[".D"]=a.FDateSep;this.tok[".Y"]=a.FDateSep;this.tok["-"]=a.FDateSep;this.tok[".m"]=a.FTimeSep;this.tok[".h"]=a.FTimeSep;this.tok[".s"]=a.FTimeSep;this.tok[":"]=a.FTimeSep};a.FDate.prototype.toString=function(){var b="[FDate]\n";for(var c in this){b=b+c+" = "+this[c]+"\n"}return b}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FDateForPVL");sap.common.globalization.require("sap.common.globalization.numericFormat.FDefaultDateD");sap.common.globalization.require("sap.common.globalization.numericFormat.FDate");sap.common.globalization.numericFormat.FDateForPVL=function(c,b){sap.common.globalization.numericFormat.FDateForPVL.superclass.constructor.apply(this,[c,b]);this.__className="sap.common.globalization.numericFormat.FDateForPVL"};sap.common.globalization.numericFormat.FDateForPVL=sap.common.globalization.extend(sap.common.globalization.numericFormat.FDateForPVL,sap.common.globalization.numericFormat.FDate);var a=sap.common.globalization.numericFormat.FDateForPVL;a.prototype.createTokenFormatter=function(b){var c=null;if(b==sap.common.globalization.numericFormat.FDefaultDateD){c=new sap.common.globalization.numericFormat.FDefaultDateD(this._displayLocaleInfo)}else{c=a.superclass.createTokenFormatter.call(this,b)}return c};a.prototype.initializeTokenMap=function(){a.superclass.initializeTokenMap.apply(this);this.tok.d=sap.common.globalization.numericFormat.FDefaultDateD;this.tok.D=sap.common.globalization.numericFormat.FDefaultDateD}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FDefaultDateSep");sap.common.globalization.numericFormat.FDefaultDateSep=function(b,a){sap.common.globalization.numericFormat.FDefaultDateSep.superclass.constructor.call(this,b,a);this.__className="sap.common.globalization.numericFormat.FDefaultDateSep"};sap.common.globalization.numericFormat.FDefaultDateSep=sap.common.globalization.extend(sap.common.globalization.numericFormat.FDefaultDateSep,sap.common.globalization.numericFormat.FDateSep);sap.common.globalization.numericFormat.FDefaultDateSep.prototype.parse=function(e,d){var a=this._parseLocalInfo.IMDateSeparator();if(a){var c=a.length;var b=d.substr(0,c);if(b==a){return c}else{return 0}}return 0}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FDefaultDateH");sap.common.globalization.require("sap.common.globalization.numericFormat.FDateH");sap.common.globalization.numericFormat.FDefaultDateH=function(){sap.common.globalization.numericFormat.FDefaultDateH.superclass.constructor.apply(this);this.__className="sap.common.globalization.numericFormat.FDefaultDateH";this._is12HourStyle=false};sap.common.globalization.numericFormat.FDefaultDateH=sap.common.globalization.extend(sap.common.globalization.numericFormat.FDefaultDateH,sap.common.globalization.numericFormat.FDateH);sap.common.globalization.numericFormat.FDefaultDateH.prototype.parse=function(c,b){var a=0;this.number=c.HNum+1;c.HBool=true;c.HNum=this.number;this._is12HourStyle=true;while(b.charAt(a)=="H"||b.charAt(a)=="h"){if(b.charAt(a)=="H"){this._is12HourStyle=false}a++}if(a>1){this.placeholders=2}return a};sap.common.globalization.numericFormat.FDefaultDateH.prototype.display=function(c){var a;if(isNaN(this.value)){a=c.getHrs()}else{a=this.value}if(this._is12HourStyle){if(this.number==c.HNum){if(a>11){a=a-12}if(a==0){a=12}}}var b=""+a;while(this.placeholders>b.length){b="0"+b}return b}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FDefaultDateG");sap.common.globalization.require("sap.common.globalization.utils.StringUtil");sap.common.globalization.numericFormat.FDefaultDateG=function(a){this.__className="sap.common.globalization.numericFormat.FDefaultDateG";this._displayLocInfo=a;this._count=0};sap.common.globalization.numericFormat.FDefaultDateG.prototype.parse=function(c,b){if(b&&!sap.common.globalization.utils.StringUtil.isBlankString(b)){if(this._displayLocInfo&&this._displayLocInfo.IMEraToken()){this._count=0;var a=b.charAt(this._count);while(a=="G"){this._count++;a=b.charAt(this._count)}return this._count}}return 0};sap.common.globalization.numericFormat.FDefaultDateG.prototype.display=function(b){var a="";if(this._displayLocInfo&&this._displayLocInfo.IMEraToken()){switch(this._count){case 4:case 5:case 1:case 2:case 3:default:a=this._displayLocInfo.IMEraToken()}}return a}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FDefaultDateD");sap.common.globalization.require("sap.common.globalization.numericFormat.FDateD");var a=sap.common.globalization.numericFormat;sap.common.globalization.numericFormat.FDefaultDateD=function(b){sap.common.globalization.numericFormat.FDefaultDateD.superclass.constructor.call(this,b);this.__className="sap.common.globalization.numericFormat.FDefaultDateD"};sap.common.globalization.numericFormat.FDefaultDateD=sap.common.globalization.extend(sap.common.globalization.numericFormat.FDefaultDateD,sap.common.globalization.numericFormat.FDateD);a.FDefaultDateD.prototype.getShortDay=function(b){if(b==0){return this._displayLocaleInfo.IMSABBREVDAYNAME7()}if(b==1){return this._displayLocaleInfo.IMSABBREVDAYNAME1()}if(b==2){return this._displayLocaleInfo.IMSABBREVDAYNAME2()}if(b==3){return this._displayLocaleInfo.IMSABBREVDAYNAME3()}if(b==4){return this._displayLocaleInfo.IMSABBREVDAYNAME4()}if(b==5){return this._displayLocaleInfo.IMSABBREVDAYNAME5()}if(b==6||b==-1){return this._displayLocaleInfo.IMSABBREVDAYNAME6()}return this._displayLocaleInfo.IMSABBREVDAYNAME6()}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FDefaultDate");sap.common.globalization.require("sap.common.globalization.numericFormat.FDefaultDateD");sap.common.globalization.require("sap.common.globalization.numericFormat.FDefaultDateG");sap.common.globalization.require("sap.common.globalization.numericFormat.FDefaultDateH");sap.common.globalization.require("sap.common.globalization.numericFormat.FTimeSep");sap.common.globalization.require("sap.common.globalization.numericFormat.FDefaultDateSep");sap.common.globalization.require("sap.common.globalization.numericFormat.FDateM");sap.common.globalization.require("sap.common.globalization.numericFormat.FDateD");sap.common.globalization.require("sap.common.globalization.numericFormat.FDateY");sap.common.globalization.require("sap.common.globalization.numericFormat.FDateH");sap.common.globalization.require("sap.common.globalization.numericFormat.FDateS");sap.common.globalization.require("sap.common.globalization.numericFormat.FDateA");sap.common.globalization.require("sap.common.globalization.numericFormat.FDateB");sap.common.globalization.require("sap.common.globalization.numericFormat.FDateSep");sap.common.globalization.require("sap.common.globalization.numericFormat.FDefaultDateSep");sap.common.globalization.numericFormat.FDefaultDate=function(b,a){sap.common.globalization.numericFormat.FDefaultDate.superclass.constructor.apply(this,[b,a]);this.__className="sap.common.globalization.numericFormat.FDefaultDate"};sap.common.globalization.numericFormat.FDefaultDate=sap.common.globalization.extend(sap.common.globalization.numericFormat.FDefaultDate,sap.common.globalization.numericFormat.FDate);sap.common.globalization.numericFormat.FDefaultDate.prototype.createTokenFormatter=function(a){var c=sap.common.globalization.numericFormat;var b=null;switch(a){case c.FDateM:b=new c.FDateM(this._displayLocaleInfo);break;case c.FDefaultDateD:b=new c.FDefaultDateD(this._displayLocaleInfo);break;case c.FDateY:b=new c.FDateY();break;case c.FDefaultDateH:b=new c.FDefaultDateH();break;case c.FDateS:b=new c.FDateS();break;case c.FDefaultDateSep:b=new c.FDefaultDateSep(this._parseLocaleInfo,this._displayLocaleInfo);break;case c.FTimeSep:b=new c.FTimeSep(this._parseLocaleInfo,this._displayLocaleInfo);break;case c.FDateA:b=new c.FDateA(this._displayLocaleInfo);break;case c.FDateB:b=new c.FDateB(this._displayLocaleInfo);break;case c.FDefaultDateG:b=new c.FDefaultDateG(this._displayLocaleInfo);break;default:}return b};sap.common.globalization.numericFormat.FDefaultDate.prototype.initializeTokenMap=function(){var a=sap.common.globalization.numericFormat;this.tok.M=a.FDateM;this.tok.Y=a.FDateY;this.tok.S=a.FDateS;this.tok.A=a.FDateA;this.tok.m=a.FDateM;this.tok.y=a.FDateY;this.tok.s=a.FDateS;this.tok.a=a.FDateA;this.tok["["]=a.FDateB;this.tok.D=a.FDefaultDateD;this.tok.d=a.FDefaultDateD;this.tok.H=a.FDefaultDateH;this.tok.h=a.FDefaultDateH;if(this._parseLocaleInfo&&this._parseLocaleInfo.IMDateSeparator){if(this._parseLocaleInfo.IMDateSeparator()=="."){this.tok[".M"]=a.FDefaultDateSep;this.tok[".D"]=a.FDefaultDateSep;this.tok[".d"]=a.FDefaultDateSep;this.tok[".Y"]=a.FDefaultDateSep;this.tok[".y"]=a.FDefaultDateSep}else{this.tok[this._parseLocaleInfo.IMDateSeparator()]=a.FDefaultDateSep}}if(this._parseLocaleInfo&&this._parseLocaleInfo.IMTimeSeparator()){if(this._parseLocaleInfo.IMDateSeparator=="."){this.tok[".m"]=a.FTimeSep;this.tok[".h"]=a.FTimeSep;this.tok[".H"]=a.FTimeSep;this.tok[".s"]=a.FTimeSep;this.tok[".S"]=a.FTimeSep}else{this.tok[this._parseLocaleInfo.IMTimeSeparator()]=a.FTimeSep}}this.tok.G=a.FDefaultDateG}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.DefaultGroupingStrategy");sap.common.globalization.numericFormat.DefaultGroupingStrategy=function(){this.__className="sap.common.globalization.numericFormat.DefaultGroupingStrategy"};var a=sap.common.globalization.numericFormat.DefaultGroupingStrategy;a._instance=new sap.common.globalization.numericFormat.DefaultGroupingStrategy();a.prototype.nextGroupDigits=function(){return 2};a.instance=function(){return a._instance}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.Helper");sap.common.globalization.require("sap.common.globalization.numericFormat.FLocalization");sap.common.globalization.numericFormat.Helper.isThousandsSeparator=function(d,b,e){var e=e||null;var a=(e?e:sap.common.globalization.numericFormat.FLocalization.getInstance().IMThousandsSeparator());if(a.charAt(0)==" "){for(var c=b;c<d.length;++c){if(d.charAt(c)!=" "){break}}if(d.charAt(c)=="€"||d.charAt(c)=="г"||d.charAt(c)=="k"||d.charAt(c)=="S"||d.charAt(c)=="L"||d.charAt(c)=="m"||d.charAt(c)=="K"){return false}}return(d.charAt(b)==a.charAt(0))}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FCurr");sap.common.globalization.numericFormat.FCurr=function(b,a){this.__className="sap.common.globalization.numericFormat.FCurr";this.display="";this._parseLocaleInfo=b;this._displayLocaleInfo=a};sap.common.globalization.numericFormat.FCurr.prototype.parse=function(c,b){var a=this._parseLocaleInfo.currencySymbol();var d=this._displayLocaleInfo.currencySymbol();if(d!=null&&a!=null&&a!=d){c.currencyIndex=c.mask.length;this.display=d;return a.length}else{return 0}}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FNum0");sap.common.globalization.require("sap.common.globalization.numericFormat.Helper");sap.common.globalization.numericFormat.FNum0=function(a){this.__className="sap.common.globalization.numericFormat.FNum0";this._parseLocaleInfo=a;this.display="0"};sap.common.globalization.numericFormat.FNum0.prototype.parse=function(e,d){var b=1;if(sap.common.globalization.numericFormat.Helper.isThousandsSeparator(d,1,this._parseLocaleInfo.thousandsSeparator())){var f=d.charAt(2);if(f!="#"&&f!="?"&&f!="0"){if(!sap.common.globalization.numericFormat.Helper.isThousandsSeparator(d,2,this._parseLocaleInfo.thousandsSeparator())){e.scale=e.scale/1000}else{e.scale=e.scale/1000000}}else{e.bcomma=true}var a=1;while(sap.common.globalization.numericFormat.Helper.isThousandsSeparator(d,a++,this._parseLocaleInfo.thousandsSeparator())){b++}}return b}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FNumP");sap.common.globalization.numericFormat.FNumP=function(){this.__className="sap.common.globalization.numericFormat.FNumP";this.display="%"};sap.common.globalization.numericFormat.FNumP.prototype.parse=function(b,a){b.scale=b.scale*100;return -1}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FNumQ");sap.common.globalization.require("sap.common.globalization.numericFormat.Helper");sap.common.globalization.numericFormat.FNumQ=function(a){this.__className="sap.common.globalization.numericFormat.FNumQ";this._parseLocaleInfo=a;this.display=" "};sap.common.globalization.numericFormat.FNumQ.prototype.parse=function(e,d){var b=1;if(sap.common.globalization.numericFormat.Helper.isThousandsSeparator(d,1,this._parseLocaleInfo.thousandsSeparator())){var f=d.charAt(2);if(f!="#"&&f!="?"&&f!="0"&&!sap.common.globalization.numericFormat.Helper.isThousandsSeparator(d,2,this._parseLocaleInfo.thousandsSeparator())){e.scale=e.scale/1000}else{e.bcomma=true}var a=1;while(sap.common.globalization.numericFormat.Helper.isThousandsSeparator(d,a++,this._parseLocaleInfo.thousandsSeparator())){b++}}return b}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FNumS");sap.common.globalization.require("sap.common.globalization.numericFormat.Helper");sap.common.globalization.numericFormat.FNumS=function(a){this.__className="sap.common.globalization.numericFormat.FNumS";this._parseLocaleInfo=a;this.display=""};sap.common.globalization.numericFormat.FNumS.prototype.parse=function(e,d){var b=1;if(sap.common.globalization.numericFormat.Helper.isThousandsSeparator(d,1,this._parseLocaleInfo.thousandsSeparator())){var f=d.charAt(2);if(f!="#"&&f!="?"&&f!="0"){if(!sap.common.globalization.numericFormat.Helper.isThousandsSeparator(d,2,this._parseLocaleInfo.thousandsSeparator())){e.scale=e.scale/1000}else{e.scale=e.scale/1000000}}else{e.bcomma=true}var a=1;while(sap.common.globalization.numericFormat.Helper.isThousandsSeparator(d,a++,this._parseLocaleInfo.thousandsSeparator())){b++}}return b}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FPeriod");sap.common.globalization.require("sap.common.globalization.numericFormat.Helper");sap.common.globalization.numericFormat.FPeriod=function(b,a){this.__className="sap.common.globalization.numericFormat.FPeriod";this._parseLocaleInfo=b;this.display=a.decimalSeparator()};sap.common.globalization.numericFormat.FPeriod.prototype.parse=function(e,d){var b=-1;if(sap.common.globalization.numericFormat.Helper.isThousandsSeparator(d,1,this._parseLocaleInfo.thousandsSeparator())){var f=d.charAt(2);if(f!="#"&&f!="?"&&f!="0"&&!sap.common.globalization.numericFormat.Helper.isThousandsSeparator(d,2,this._parseLocaleInfo.thousandsSeparator())){e.scale=e.scale/1000}var a=1;while(sap.common.globalization.numericFormat.Helper.isThousandsSeparator(d,a++,this._parseLocaleInfo.thousandsSeparator())){b++}}if(e.period==-1){e.period=e.mask.length}return b}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FNumber");sap.common.globalization.numericFormat.FNumber=function(d,c){this.__className="sap.common.globalization.numericFormat.FNumber";this.scale=1;this.bcomma=false;this.bsign=true;this.period=-1;this.numfore=undefined;this.numaft=undefined;this.sign="";this.mask=new Array();this.mfore=new Array();this.maft=new Array();this.format=undefined;this.currencyIndex=-1;this._tok={};this._tok["#"]=sap.common.globalization.numericFormat.FNumS;this._tok["?"]=sap.common.globalization.numericFormat.FNumQ;this._tok["%"]=sap.common.globalization.numericFormat.FNumP;this._tok["0"]=sap.common.globalization.numericFormat.FNum0;this.condnum=0;this.cond={};var a=d.decimalSeparator();this._tok[a]=sap.common.globalization.numericFormat.FPeriod;this.IMDecimalSeparator=a;this.parseLocaleInfo=d;this.displayLocaleInfo=c;this.IMThousandsSeparator=c.thousandsSeparator();var b=this.parseLocaleInfo.currencySymbol();if(b){this._tok[b]=sap.common.globalization.numericFormat.FCurr}};sap.common.globalization.numericFormat.FNumber.tokens="#?%0";sap.common.globalization.numericFormat.FNumber.prototype.parse=function(f){if(this.format==null){this.format=f}var g=f.charAt(0);if(this._tok[g]==undefined||(g==this.IMDecimalSeparator&&(f.length>1&&f.charAt(1)!="#"&&f.charAt(1)!="0"))){return 0}var e=this.createTokenFormatter(this._tok[g]);var d=e.parse(this,f);if(this.period>1){var a=true}if(d>0){var b=this.mask.length;this.mask.push(e);if(this.currencyIndex!=b){if(this.period==-1){this.mfore.push(b)}else{this.maft.push(b)}}}else{if(d<0){this.mask.push(e);d=Math.abs(d)}else{d=0}}return d};sap.common.globalization.numericFormat.FNumber.prototype.display=function(k){if(typeof(k)!="number"){return k}if(isNaN(k)||!isFinite(k)){return k}if(this.mfore.length==0&&this.maft.length==0){return this.format}this.setNumber(k);var q=new Array();var e=this.mfore.length;var c=3;var m=this.period;var f=(m==-1)?(this.mask.length):m;var g;var o;var p;for(var h=e-1;h>=0;h--){m=this.mfore[h];for(var g=f-1;g>m;g--){p=this.mask[g];if((typeof p)=="object"){q.unshift(p.display)}else{q.unshift(p)}}if(this.numfore.length>0){if(this.bcomma){if(c--==0){q.unshift(this.IMThousandsSeparator);c=2}}o=this.numfore.length-1;q.unshift(this.numfore.charAt(o));this.numfore=this.numfore.substring(0,o)}else{var n=this.mask[m].display;if(n.length!=0){if(this.bcomma&&c--==0){q.unshift(this.IMThousandsSeparator);c=2}q.unshift(this.mask[m].display)}}f=m}if(this.numfore.length>0){if(this.bcomma){while(this.numfore.length>0){if(c--==0){q.unshift(this.IMThousandsSeparator);c=2}o=this.numfore.length-1;q.unshift(this.numfore.charAt(o));this.numfore=this.numfore.substring(0,o)}}else{q.unshift(this.numfore)}}p=this.mask;if(this.currencyIndex!=-1){h=0}for(g=f-1;g>=0;g--){if((typeof p[h])=="object"){q.unshift(this.mask[g].display)}else{q.unshift(this.mask[g])}}e=this.mask.length;h=(this.period==-1)?(e):(this.period);m=0;for(;h<e;h++){if((typeof p[h])=="object"){if(this.maft[m]==h){m++;if(this.numaft.length>0){q.push(this.numaft.charAt(0));this.numaft=this.numaft.substring(1)}else{q.push(p[h].display)}}else{q.push(p[h].display)}}else{q.push(p[h])}}var b;if(this.bsign){b=this.sign+q.join("")}else{b=q.join("")}return b};sap.common.globalization.numericFormat.FNumber.prototype.setNumber=function(c){c=c*this.scale;var a=this.maft.length;var e=Math.pow;var d=e(10,a);if(c<0){d*=-1}var f=c*d;f=Math.round(f);c=f/d;var b=c.toString().split(".");this.numfore=b[0];if(this.numfore.charAt(0)=="-"){this.sign="-";this.numfore=this.numfore.substring(1)}else{this.sign=""}if(this.numfore.charAt(0)=="0"){this.numfore=this.numfore.substring(1)}this.numaft=undefined;if(b.length<2){this.numaft=""}else{this.numaft=b[1]}};sap.common.globalization.numericFormat.FNumber.prototype.createTokenFormatter=function(a){var b=null;var c=sap.common.globalization.numericFormat;switch(a){case c.FNumS:b=new sap.common.globalization.numericFormat.FNumS(this.parseLocaleInfo);break;case c.FNumQ:b=new sap.common.globalization.numericFormat.FNumQ(this.parseLocaleInfo);break;case c.FNumP:b=new sap.common.globalization.numericFormat.FNumP();break;case c.FNum0:b=new sap.common.globalization.numericFormat.FNum0(this.parseLocaleInfo);break;case c.FPeriod:b=new sap.common.globalization.numericFormat.FPeriod(this.parseLocaleInfo,this.displayLocaleInfo);break;case c.FCurr:b=new sap.common.globalization.numericFormat.FCurr(this.parseLocaleInfo,this.displayLocaleInfo);break;default:}return b}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FDefaultNumber");sap.common.globalization.require("sap.common.globalization.numericFormat.FNumber");sap.common.globalization.require("sap.common.globalization.numericFormat.DefaultGroupingStrategy");sap.common.globalization.require("sap.common.globalization.numericFormat.FPeriod");sap.common.globalization.numericFormat.FDefaultNumber=function(b,a){sap.common.globalization.numericFormat.FDefaultNumber.superclass.constructor.apply(this,[b,a]);this.__className="sap.common.globalization.numericFormat.FDefaultDateNumber";this._groupingStrategy=sap.common.globalization.numericFormat.DefaultGroupingStrategy.instance()};sap.common.globalization.numericFormat.FDefaultNumber=sap.common.globalization.extend(sap.common.globalization.numericFormat.FDefaultNumber,sap.common.globalization.numericFormat.FNumber);sap.common.globalization.numericFormat.FDefaultNumber.prototype.display=function(m){if(typeof(m)!="number"){return m}if(isNaN(m)||!isFinite(m)){return m}if(this.mfore.length==0&&this.maft.length==0){return this.format}this.setNumber(m);var r=new Array();var e=this.mfore.length;var c=3;var n=this.period;var g=(n==-1)?(this.mask.length):n;var h;var p;var q;for(var k=e-1;k>=0;k--){n=this.mfore[k];for(h=g-1;h>n;h--){q=this.mask[h];if((typeof q)=="object"){r.unshift(q.display)}else{r.unshift(q)}}if(this.numfore.length>0){if(this.bcomma){if(c--==0){r.unshift(this.IMThousandsSeparator);c=this._groupingStrategy.nextGroupDigits()}}p=this.numfore.length-1;r.unshift(this.numfore.charAt(p));this.numfore=this.numfore.substring(0,p)}else{var o=this.mask[n].display;if(o.length!=0){if(this.bcomma&&c--==0){r.unshift(this.IMThousandsSeparator);c=this._groupingStrategy.nextGroupDigits()}r.unshift(this.mask[n].display)}}g=n}if(this.numfore.length>0){if(this.bcomma){while(this.numfore.length>0){if(c--==0){r.unshift(this.IMThousandsSeparator);c=this._groupingStrategy.nextGroupDigits()}p=this.numfore.length-1;r.unshift(this.numfore.charAt(p));this.numfore=this.numfore.substring(0,p)}}else{r.unshift(this.numfore)}}q=this.mask;if(this.currencyIndex!=-1){k=0}for(h=g-1;h>=0;h--){if((typeof q[k])=="object"){r.unshift(this.mask[h].display)}else{r.unshift(this.mask[h])}}e=this.mask.length;k=(this.period==-1)?(e):(this.period);n=0;var f=false;for(;k<e;k++){if((typeof q[k])=="object"){if(q[k].__className=="sap.common.globalization.numericFormat.FPeriod"&&!this.numaft){f=true;continue}if(this.maft[n]==k){n++;if(this.numaft.length>0){if(!f){r.push(this.numaft.charAt(0))}this.numaft=this.numaft.substring(1)}else{r.push(q[k].display)}}else{r.push(q[k].display)}}else{r.push(q[k])}}var b;if(this.bsign){b=this.sign+r.join("")}else{b=r.join("")}return b};sap.common.globalization.numericFormat.FDefaultNumber.prototype.groupingStrategy=function(a){if(this._groupingStrategy!=a){this._groupingStrategy=a}}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FT");sap.common.globalization.require("sap.common.globalization.utils.BaseUtils");sap.common.globalization.require("sap.common.globalization.numericFormat.FDate");sap.common.globalization.require("sap.common.globalization.numericFormat.FText");sap.common.globalization.require("sap.common.globalization.numericFormat.FNumber");sap.common.globalization.require("sap.common.globalization.defaultFormat.CustomDateFormatLocaleFactory");sap.common.globalization.require("sap.common.globalization.defaultFormat.CustomNumericFormatLocaleFactory");sap.common.globalization.numericFormat.FT=function(c,b){this.__className="sap.common.globalization.numericFormat.FT";this._hasCustomCondition=false;this.color=undefined;this.o=new Array();this._dateLocaleFactory=c?c:sap.common.globalization.defaultFormat.CustomDateFormatLocaleFactory.getInstance();this._numericLocaleFactory=b?b:sap.common.globalization.defaultFormat.CustomNumericFormatLocaleFactory.getInstance();this._isParsedSuccess=false};var a=sap.common.globalization.numericFormat.FT;a.ftarr=new Array();a._CONDITION_TOKENS="=<>";a._equals=function(d,c){return(d==c)};a._neq=function(d,c){return(d!=c)};a._gthan=function(d,c){return(d>c)};a._gte=function(d,c){return(d>=c)};a._lthan=function(d,c){return(d<c)};a._lte=function(d,c){return(d<=c)};a._CONDITIONS={"=":sap.common.globalization.numericFormat.FT._equals,"<>":sap.common.globalization.numericFormat.FT._neq,"<":sap.common.globalization.numericFormat.FT._lthan,"<=":sap.common.globalization.numericFormat.FT._lte,">":sap.common.globalization.numericFormat.FT._gthan,">=":sap.common.globalization.numericFormat.FT._gte};a._COLORS={black:0,blue:255,cyan:65535,green:65280,magenta:16711935,red:16711680,white:16777215,yellow:16776960};a.prototype._isNumeric=function(e){var d="#?%";var b=d.length;for(var c=0;c<b;c++){if(e.indexOf(d.charAt(c))!=-1){return true}}return false};a.prototype.isParsedSuccess=function(){return this._isParsedSuccess};a.prototype.parse=function(x){this._isParsedSuccess=false;this._hasCustomCondition=false;var z=x;var t=x.length;var B;var d=0;for(var w=0;w<t;w++){B=z.charAt(w);if(B=='"'){while(w<t){if(z.charAt(++w)=='"'&&z.charAt(w-1)!="\\"){break}}continue}if(B=="\\"||B=="_"||B=="*"){w++;continue}if(B==";"){if(this.o[d]==undefined){this.o[d]=new sap.common.globalization.numericFormat.FText()}this.o[d].format=z.substring(0,w);d++;z=z.substring(w+1);t=z.length;w=-1;continue}if(B=="["){var r="";while(z.charAt(++w)!="]"&&(w<t)){r+=z.charAt(w)}var A=r.length;var n=r.charAt(0);if(n=="s"||n=="m"||n=="h"){for(var v=1;v<A;v++){var k=r.charAt(v);if(n!=k){break}}if(v==A){if(this.o[d]==undefined){this.o[d]=this._dateLocaleFactory.createFDate()}}}}var D=sap.common.globalization.numericFormat.FDate.tokens.indexOf(B);if(sap.common.globalization.numericFormat.FDate.tokens.indexOf(B)!=-1&&!this._isNumeric(x)){if(this.o[d]==undefined){this.o[d]=this._dateLocaleFactory.createFDate()}this.o[d]=this._dateLocaleFactory.createFDate()}else{if(sap.common.globalization.numericFormat.FNumber.tokens.indexOf(B)!=-1){if(this.o[d]==undefined){this.o[d]=this._numericLocaleFactory.createFNumber();if(d==1){this.o[d].bsign=false}}}else{if(sap.common.globalization.numericFormat.FText.tokens.indexOf(B)!=-1){if(this.o[d]==undefined){this.o[d]=new sap.common.globalization.numericFormat.FText()}}}}}if(this.o[d]==undefined){this.o[d]=this._numericLocaleFactory.createFNumber()}else{this._isParsedSuccess=true}this.o[d].format=z;var g=this.o.length;for(var s=0;s<g;s++){var m=this.o[s];m.condnum=0;if(s==0){m.cond=sap.common.globalization.numericFormat.FT._gthan}else{if(s==1){m.cond=sap.common.globalization.numericFormat.FT._lthan}else{if(s==2){m.cond=sap.common.globalization.numericFormat.FT._equals}}}var C=m.mask;var h=false;z=m.format;t=z.length;for(var v=0;v<t;v++){B=z.charAt(v);if(B=='"'){h=!h;continue}if(B=="\\"){v++;B=z.charAt(v);C.push(B);continue}if(h){C.push(B);continue}if(B=="*"){v++;continue}if(B=="_"){v++;C.push(" ");continue}if(B=="["){n=z.charAt(v+1);k=z.charAt(v+2);if(n=="$"&&k!="-"){var y=z.indexOf("]",v+1);if(y!=-1){var u=z.substring(v+1,y);if(r.indexOf("-")!=-1){u=r.substring(1,r.indexOf("-"))}else{u=r.substring(1)}for(var b=0;b<u.length;++b){C.push(u.charAt(b))}v=y;continue}}else{r=z.substring(v+1);r=r.substring(0,r.indexOf("]")).toLowerCase();if(sap.common.globalization.numericFormat.FT._COLORS[r]!=undefined){m.color=sap.common.globalization.numericFormat.FT._COLORS[r];v+=r.length+1;continue}else{if(r=="h"||r=="m"||r=="s"){}else{var e=1;while(sap.common.globalization.numericFormat.FT._CONDITION_TOKENS.indexOf(r.charAt(e))!=-1){e++}var p=r.substring(0,e);if(sap.common.globalization.numericFormat.FT._CONDITIONS[p]!=undefined){m.cond=sap.common.globalization.numericFormat.FT._CONDITIONS[p];m.condnum=r.substring(e);v+=r.length+1;this._hasCustomCondition=true;continue}else{v+=r.length+1;continue}}}}}var E=m.parse(z.substring(v));if(E>0){v+=E-1}else{C.push(B)}}}};a.prototype.display=function(d){var f=this.o[0];var b=this.o.length;if(b>3&&sap.common.globalization.utils.BaseUtils.isString(d)){f=this.o[3]}else{if(this._hasCustomCondition&&b>0){if(b<=3){f=this.o[b-1]}else{f=this.o[2]}}for(var e=0;e<3&&e<b;e++){var c=this.o[e];if(c&&c.cond(d,c.condnum)){f=c;break}}}if(!isNaN(f.color)){this.color=f.color}else{this.color=undefined}return(f.display(d))};a.prototype.getNumericDisplayLoacleInfo=function(){return this._numericLocaleFactory.getNumericDisplayLocaleInfo()}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FTBoolean");sap.common.globalization.require("sap.common.globalization.defaultFormat.DefaultBooleanFormatLocaleFactory");sap.common.globalization.require("sap.common.globalization.NumericFormatManager;");sap.common.globalization.require("sap.common.globalization.numericFormat.FT");sap.common.globalization.require("sap.common.globalization.utils.BaseUtils");var a=sap.common.globalization.numericFormat;sap.common.globalization.numericFormat.FTBoolean=function(c,b){a.FTBoolean.superclass.constructor.apply(this,[c,b]);this.__className="sap.common.globalization.numericFormat.FTBoolean";c=c||null;b=b||null;this._booleanLocaleFactory=sap.common.globalization.defaultFormat.DefaultBooleanFormatLocaleFactory.getInstance()};a.FTBoolean.BOOLEAN_TOKEN="SAP_DEFAULT_BOOLEAN_FORMAT";a.FTBoolean=sap.common.globalization.extend(a.FTBoolean,a.FT);sap.common.globalization.numericFormat.FTBoolean.prototype.parse=function(b){if(b==a.FTBoolean.BOOLEAN_TOKEN){this.o[0]=this}else{this.o[0]=null}};sap.common.globalization.numericFormat.FTBoolean.prototype.display=function(b){var d=String(b);var c=this._booleanLocaleFactory.getBooleanDisplayLocaleInfo();if(c&&this.o[0].__className=="sap.common.globalization.numericFormat.FTBoolean"){if(sap.common.globalization.utils.BaseUtils.isBoolean(b)){d=b?c.trueString():c.falseString()}else{if(sap.common.globalization.utils.BaseUtils.isString(b)&&(String(b).toLowerCase()=="true"||String(b).toLowerCase()=="false")){d=String(b).toLowerCase()=="true"?c.trueString():c.falseString()}}}return d}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FTimeSep");sap.common.globalization.numericFormat.FTimeSep=function(b,a){this._parseLocale=b;this._displayLocale=a};sap.common.globalization.numericFormat.FTimeSep.prototype.parse=function(c,b){var a=b.charAt(0);if(this._displayLocale.IMTimeSeparator()!=null&&(a==":"||a==".")){return 1}else{return 0}};sap.common.globalization.numericFormat.FTimeSep.prototype.display=function(a){return this._displayLocale.IMTimeSeparator()}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FTUtil");sap.common.globalization.numericFormat.FTUtil.isBooleanFT=function(a){return a&&(a.__className=="sap.common.globalization.numericFormat.FTBoolean")};sap.common.globalization.numericFormat.FTUtil.isDate=function(a){return a&&a.o&&a.o.length>0&&(a.o[0].__className=="sap.common.globalization.numericFormat.FDate")}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.TwoDigitGroupingStrategy");sap.common.globalization.numericFormat.TwoDigitGroupingStrategy=function(){this.__className="sap.common.globalization.numericFormat.TwoDigitGroupingStrategy"};var a=sap.common.globalization.numericFormat.TwoDigitGroupingStrategy;a._instance=new sap.common.globalization.numericFormat.TwoDigitGroupingStrategy();a.prototype.nextGroupDigits=function(){return 1};a.instance=function(){return a._instance}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FDefaultCurrencyNumber");sap.common.globalization.require("sap.common.globalization.numericFormat.FNumber");sap.common.globalization.require("sap.common.globalization.numericFormat.DefaultGroupingStrategy");var a=sap.common.globalization.numericFormat;sap.common.globalization.numericFormat.FDefaultCurrencyNumber=function(c,b){sap.common.globalization.numericFormat.FDefaultCurrencyNumber.superclass.constructor.apply(this,[c,b]);this.__className="sap.common.globalization.numericFormat.FDefaultCurrencyNumber";this._groupingStrategy=a.DefaultGroupingStrategy.instance()};a.FDefaultCurrencyNumber=sap.common.globalization.extend(a.FDefaultCurrencyNumber,a.FNumber);a.FDefaultCurrencyNumber.prototype.display=function(k){if(typeof(k)!="number"){return k}if(isNaN(k)||!isFinite(k)){return k}if(this.mfore.length==0&&this.maft.length==0){return this.format}this.setNumber(k);var q=new Array();var e=this.mfore.length;var c=3;var m=this.period;var f=(m==-1)?(this.mask.length):m;var g;var o;var p;for(var h=e-1;h>=0;h--){m=this.mfore[h];for(g=f-1;g>m;g--){p=this.mask[g];if((typeof p)=="object"){q.unshift(p.display)}else{q.unshift(p)}}if(this.numfore.length>0){if(this.bcomma){if(c--==0){q.unshift(this.IMThousandsSeparator);c=this._groupingStrategy.nextGroupDigits()}}o=this.numfore.length-1;q.unshift(this.numfore.charAt(o));this.numfore=this.numfore.substring(0,o)}else{var n=this.mask[m].display;if(n.length!=0){if(this.bcomma&&c--==0){q.unshift(this.IMThousandsSeparator);c=this._groupingStrategy.nextGroupDigits()}q.unshift(this.mask[m].display)}}f=m}if(this.numfore.length>0){if(this.bcomma){while(this.numfore.length>0){if(c--==0){q.unshift(this.IMThousandsSeparator);c=this._groupingStrategy.nextGroupDigits()}o=this.numfore.length-1;q.unshift(this.numfore.charAt(o));this.numfore=this.numfore.substring(0,o)}}else{q.unshift(this.numfore)}}p=this.mask;if(this.currencyIndex!=-1){h=0}for(g=f-1;g>=0;g--){if((typeof this.mask[g])=="object"){q.unshift(this.mask[g].display)}else{q.unshift(this.mask[g])}}e=this.mask.length;h=(this.period==-1)?(e):(this.period);m=0;for(;h<e;h++){if((typeof p[h])=="object"){if(this.maft[m]==h){m++;if(this.numaft.length>0){q.push(this.numaft.charAt(0));this.numaft=this.numaft.substring(1)}else{q.push(p[h].display)}}else{q.push(p[h].display)}}else{q.push(p[h])}}var b;if(this.bsign){b=this.sign+q.join("")}else{b=q.join("")}return b};a.FDefaultCurrencyNumber.prototype.groupingStrategy=function(b){if(this._groupingStrategy!=b){this._groupingStrategy=b}}})();(function(){sap.common.globalization.declare("sap.common.globalization.defaultFormat.DefaultCurrencyFormatLocaleFactory");sap.common.globalization.require("sap.common.globalization.defaultFormat.DefaultNumericFormatLocaleFactory");sap.common.globalization.require("sap.common.globalization.GlobalizationNumericConstant");sap.common.globalization.require("sap.common.globalization.numericFormat.FDefaultCurrencyNumber");sap.common.globalization.require("sap.common.globalization.numericFormat.TwoDigitGroupingStrategy");sap.common.globalization.require("sap.common.globalization.GlobalizationNumericUtil");sap.common.globalization.defaultFormat.DefaultCurrencyFormatLocaleFactory=function(b){sap.common.globalization.defaultFormat.DefaultCurrencyFormatLocaleFactory.superclass.constructor.apply(this,[b]);this.__className="sap.common.globalization.defaultFormat.DefaultCurrencyFormatLocaleFactory";this._displayCurrencySymbol=null;if(sap.common.globalization.defaultFormat.DefaultCurrencyFormatLocaleFactory.isDefaultCurrencyFormat(b)){this._parseCurrencySymbol(b)}};var a=sap.common.globalization.defaultFormat;a.DefaultCurrencyFormatLocaleFactory=sap.common.globalization.extend(a.DefaultCurrencyFormatLocaleFactory,a.DefaultNumericFormatLocaleFactory);a.DefaultCurrencyFormatLocaleFactory.REG_DEFAULT_CURRENCY_FORMAT=new RegExp('^SAP_DEFAULT_CURRENCY_FORMAT(;".*")?$',"i");a.DefaultCurrencyFormatLocaleFactory.isDefaultCurrencyFormat=function(b){return a.DefaultCurrencyFormatLocaleFactory.REG_DEFAULT_CURRENCY_FORMAT.test(b)};a.DefaultCurrencyFormatLocaleFactory.prototype.getDefaultCurrencyFormat=function(){return sap.common.globalization.GlobalizationNumericConstant.getDefaultCurrencyFormat()};a.DefaultCurrencyFormatLocaleFactory.prototype._parseCurrencySymbol=function(b){if("SAP_DEFAULT_CURRENCY_FORMAT"==b){this._displayCurrencySymbol=""}else{this._displayCurrencySymbol=b.slice(29,b.length-1)}};a.DefaultCurrencyFormatLocaleFactory.prototype.createFNumber=function(){var b=new sap.common.globalization.numericFormat.FDefaultCurrencyNumber(this.getNumericParseLocaleInfo(),this.getNumericDisplayLocaleInfo());if(sap.common.globalization.GlobalizationNumericUtil.isTwoDigitGroupingCountry(sap.common.globalization.GlobalizationNumericConstant.getActualLocaleForDefaultCurrencyFormat())){b._groupingStrategy=sap.common.globalization.numericFormat.TwoDigitGroupingStrategy.instance()}return b};a.DefaultCurrencyFormatLocaleFactory.prototype.displayCurrencySymbol=function(){return this._displayCurrencySymbol}})();(function() {
	if (!Array.prototype.indexOf) {
		Array.prototype.indexOf = function(searchElement /* , fromIndex */) {
			"use strict";
			if (this == null) {
				throw new TypeError();
			}
			var t = Object(this);
			var len = t.length >>> 0;
			if (len === 0) {
				return -1;
			}
			var n = 0;
			if (arguments.length > 0) {
				n = Number(arguments[1]);
				if (n != n) { // shortcut for verifying if it's NaN
					n = 0;
				} else if (n != 0 && n != Infinity && n != -Infinity) {
					n = (n > 0 || -1) * Math.floor(Math.abs(n));
				}
			}
			if (n >= len) {
				return -1;
			}
			var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
			for (; k < len; k++) {
				if (k in t && t[k] === searchElement) {
					return k;
				}
			}
			return -1;
		}
	}

	if (!Array.prototype.lastIndexOf) {
		Array.prototype.lastIndexOf = function(searchElement /* , fromIndex */) {
			"use strict";

			if (this == null)
				throw new TypeError();

			var t = Object(this);
			var len = t.length >>> 0;
			if (len === 0)
				return -1;

			var n = len;
			if (arguments.length > 1) {
				n = Number(arguments[1]);
				if (n != n)
					n = 0;
				else if (n != 0 && n != (1 / 0) && n != -(1 / 0))
					n = (n > 0 || -1) * Math.floor(Math.abs(n));
			}

			var k = n >= 0 ? Math.min(n, len - 1) : len - Math.abs(n);

			for (; k >= 0; k--) {
				if (k in t && t[k] === searchElement)
					return k;
			}
			return -1;
		};
	}

	if (!Array.prototype.filter) {
		Array.prototype.filter = function(fun /* , thisp */) {
			"use strict";

			if (this == null)
				throw new TypeError();

			var t = Object(this);
			var len = t.length >>> 0;
			if (typeof fun != "function")
				throw new TypeError();

			var res = [];
			var thisp = arguments[1];
			for ( var i = 0; i < len; i++) {
				if (i in t) {
					var val = t[i]; // in case fun mutates this
					if (fun.call(thisp, val, i, t))
						res.push(val);
				}
			}

			return res;
		};
	}

	// Production steps of ECMA-262, Edition 5, 15.4.4.18
	// Reference: http://es5.github.com/#x15.4.4.18
	if (!Array.prototype.forEach) {

		Array.prototype.forEach = function(callback, thisArg) {

			var T, k;

			if (this == null) {
				throw new TypeError("this is null or not defined");
			}

			// 1. Let O be the result of calling ToObject passing the |this|
			// value as the argument.
			var O = Object(this);

			// 2. Let lenValue be the result of calling the Get internal method
			// of O with the argument "length".
			// 3. Let len be ToUint32(lenValue).
			var len = O.length >>> 0; // Hack to convert O.length to a UInt32

			// 4. If IsCallable(callback) is false, throw a TypeError exception.
			// See: http://es5.github.com/#x9.11
			if ({}.toString.call(callback) != "[object Function]") {
				throw new TypeError(callback + " is not a function");
			}

			// 5. If thisArg was supplied, let T be thisArg; else let T be
			// undefined.
			if (thisArg) {
				T = thisArg;
			}

			// 6. Let k be 0
			k = 0;

			// 7. Repeat, while k < len
			while (k < len) {

				var kValue;

				// a. Let Pk be ToString(k).
				// This is implicit for LHS operands of the in operator
				// b. Let kPresent be the result of calling the HasProperty
				// internal method of O with argument Pk.
				// This step can be combined with c
				// c. If kPresent is true, then
				if (k in O) {

					// i. Let kValue be the result of calling the Get internal
					// method of O with argument Pk.
					kValue = O[k];

					// ii. Call the Call internal method of callback with T as
					// the this value and
					// argument list containing kValue, k, and O.
					callback.call(T, kValue, k, O);
				}
				// d. Increase k by 1.
				k++;
			}
			// 8. return undefined
		};
	}

	if (!Array.prototype.every) {
		Array.prototype.every = function(fun /* , thisp */) {
			"use strict";

			if (this == null)
				throw new TypeError();

			var t = Object(this);
			var len = t.length >>> 0;
			if (typeof fun != "function")
				throw new TypeError();

			var thisp = arguments[1];
			for ( var i = 0; i < len; i++) {
				if (i in t && !fun.call(thisp, t[i], i, t))
					return false;
			}

			return true;
		};
	}

	// Production steps of ECMA-262, Edition 5, 15.4.4.19
	// Reference: http://es5.github.com/#x15.4.4.19
	if (!Array.prototype.map) {
		Array.prototype.map = function(callback, thisArg) {

			var T, A, k;

			if (this == null) {
				throw new TypeError(" this is null or not defined");
			}

			// 1. Let O be the result of calling ToObject passing the |this|
			// value as the argument.
			var O = Object(this);

			// 2. Let lenValue be the result of calling the Get internal method
			// of O with the argument "length".
			// 3. Let len be ToUint32(lenValue).
			var len = O.length >>> 0;

			// 4. If IsCallable(callback) is false, throw a TypeError exception.
			// See: http://es5.github.com/#x9.11
			if ({}.toString.call(callback) != "[object Function]") {
				throw new TypeError(callback + " is not a function");
			}

			// 5. If thisArg was supplied, let T be thisArg; else let T be
			// undefined.
			if (thisArg) {
				T = thisArg;
			}

			// 6. Let A be a new array created as if by the expression new
			// Array(len) where Array is
			// the standard built-in constructor with that name and len is the
			// value of len.
			A = new Array(len);

			// 7. Let k be 0
			k = 0;

			// 8. Repeat, while k < len
			while (k < len) {

				var kValue, mappedValue;

				// a. Let Pk be ToString(k).
				// This is implicit for LHS operands of the in operator
				// b. Let kPresent be the result of calling the HasProperty
				// internal method of O with argument Pk.
				// This step can be combined with c
				// c. If kPresent is true, then
				if (k in O) {

					// i. Let kValue be the result of calling the Get internal
					// method of O with argument Pk.
					kValue = O[k];

					// ii. Let mappedValue be the result of calling the Call
					// internal method of callback
					// with T as the this value and argument list containing
					// kValue, k, and O.
					mappedValue = callback.call(T, kValue, k, O);

					// iii. Call the DefineOwnProperty internal method of A with
					// arguments
					// Pk, Property Descriptor {Value: mappedValue, Writable:
					// true, Enumerable: true, Configurable: true},
					// and false.

					// In browsers that support Object.defineProperty, use the
					// following:
					// Object.defineProperty(A, Pk, { value: mappedValue,
					// writable: true, enumerable: true, configurable: true });

					// For best browser support, use the following:
					A[k] = mappedValue;
				}
				// d. Increase k by 1.
				k++;
			}

			// 9. return A
			return A;
		};
	}

	if (!Array.prototype.some) {
		Array.prototype.some = function(fun /* , thisp */) {
			"use strict";

			if (this == null)
				throw new TypeError();

			var t = Object(this);
			var len = t.length >>> 0;
			if (typeof fun != "function")
				throw new TypeError();

			var thisp = arguments[1];
			for ( var i = 0; i < len; i++) {
				if (i in t && fun.call(thisp, t[i], i, t))
					return true;
			}

			return false;
		};
	}

	if (!Array.prototype.reduce) {
		Array.prototype.reduce = function reduce(accumulator) {
			if (this === null || this === undefined)
				throw new TypeError("Object is null or undefined");
			var i = 0, l = this.length >> 0, curr;

			if (typeof accumulator !== "function") // ES5 : "If
				// IsCallable(callbackfn) is
				// false, throw a TypeError
				// exception."
				throw new TypeError("First argument is not callable");

			if (arguments.length < 2) {
				if (l === 0)
					throw new TypeError("Array length is 0 and no second argument");
				curr = this[0];
				i = 1; // start accumulating at the second element
			} else
				curr = arguments[1];

			while (i < l) {
				if (i in this)
					curr = accumulator.call(undefined, curr, this[i], i, this);
				++i;
			}

			return curr;
		};
	}

	if (!Array.prototype.reduceRight) {
		Array.prototype.reduceRight = function(callbackfn /* , initialValue */) {
			"use strict";

			if (this == null)
				throw new TypeError();

			var t = Object(this);
			var len = t.length >>> 0;
			if (typeof callbackfn != "function")
				throw new TypeError();

			// no value to return if no initial value, empty array
			if (len === 0 && arguments.length === 1)
				throw new TypeError();

			var k = len - 1;
			var accumulator;
			if (arguments.length >= 2) {
				accumulator = arguments[1];
			} else {
				do {
					if (k in this) {
						accumulator = this[k--];
						break;
					}

					// if array contains no values, no initial value to return
					if (--k < 0)
						throw new TypeError();
				} while (true);
			}

			while (k >= 0) {
				if (k in t)
					accumulator = callbackfn.call(undefined, accumulator, t[k], k, t);
				k--;
			}

			return accumulator;
		};
	}

	if (!Function.prototype.bind) {
		Function.prototype.bind = function(oThis) {
			if (typeof this !== "function") {
				// closest thing possible to the ECMAScript 5 internal
				// IsCallable function
				throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
			}

			var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, fNOP = function() {
			}, fBound = function() {
				return fToBind.apply(this instanceof fNOP ? this : oThis, aArgs.concat(Array.prototype.slice
						.call(arguments)));
			};

			fNOP.prototype = this.prototype;
			fBound.prototype = new fNOP();

			return fBound;
		};
	}

	if (!Object.create) {
		// this is the polyfill implementation covers the main use case
		Object.create = function(o) {
			if (arguments.length > 1) {
				throw new Error('Object.create implementation only accepts the first parameter.');
			}
			function F() {
			}
			F.prototype = o;
			return new F();
		};
	}

	function defineProperties(obj, properties) {
		// this is the polyfill implementation covers the main use case
		function convertToDescriptor(desc) {
			function hasProperty(obj, prop) {
				return Object.prototype.hasOwnProperty.call(obj, prop);
			}

			function isCallable(v) {
				// NB: modify as necessary if other values than functions are
				// callable.
				return typeof v === "function";
			}

			if (typeof desc !== "object" || desc === null)
				throw new TypeError("bad desc");

			var d = {};
			if (hasProperty(desc, "enumerable"))
				d.enumerable = !!obj.enumerable;
			if (hasProperty(desc, "configurable"))
				d.configurable = !!obj.configurable;
			if (hasProperty(desc, "value"))
				d.value = obj.value;
			if (hasProperty(desc, "writable"))
				d.writable = !!desc.writable;
			if (hasProperty(desc, "get")) {
				var g = desc.get;
				if (!isCallable(g) && g !== "undefined")
					throw new TypeError("bad get");
				d.get = g;
			}
			if (hasProperty(desc, "set")) {
				var s = desc.set;
				if (!isCallable(s) && s !== "undefined")
					throw new TypeError("bad set");
				d.set = s;
			}

			if (("get" in d || "set" in d) && ("value" in d || "writable" in d))
				throw new TypeError("identity-confused descriptor");

			return d;
		}

		if (typeof obj !== "object" || obj === null)
			throw new TypeError("bad obj");

		properties = Object(properties);
		var keys = Object.keys(properties);
		var descs = [];
		for ( var i = 0; i < keys.length; i++)
			descs.push([ keys[i], convertToDescriptor(properties[keys[i]]) ]);
		for ( var i = 0; i < descs.length; i++)
			Object.defineProperty(obj, descs[i][0], descs[i][1]);

		return obj;
	}

	if (!Object.keys) {
		Object.keys = (function() {
			var hasOwnProperty = Object.prototype.hasOwnProperty, hasDontEnumBug = !({
				toString : null
			}).propertyIsEnumerable('toString'), dontEnums = [ 'toString', 'toLocaleString', 'valueOf',
					'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor' ], dontEnumsLength = dontEnums.length

			return function(obj) {
				if (typeof obj !== 'object' && typeof obj !== 'function' || obj === null)
					throw new TypeError('Object.keys called on non-object')

				var result = []

				for ( var prop in obj) {
					if (hasOwnProperty.call(obj, prop))
						result.push(prop)
				}

				if (hasDontEnumBug) {
					for ( var i = 0; i < dontEnumsLength; i++) {
						if (hasOwnProperty.call(obj, dontEnums[i]))
							result.push(dontEnums[i])
					}
				}
				return result
			}
		})()
	}

	if (typeof Object.getPrototypeOf !== "function") {
		if (typeof "test".__proto__ === "object") {
			Object.getPrototypeOf = function(object) {
				return object.__proto__;
			};
		} else {
			Object.getPrototypeOf = function(object) {
				// May break if the constructor has been tampered with
				return object.constructor.prototype;
			};
		}
	}

	if (!String.prototype.trim) {
		String.prototype.trim = function() {
			return this.replace(/^\s+|\s+$/g, '');
		};
	}

})();(function(global, undefined){

    if(global.define !== undefined && global.define.amd !== undefined){
        return;
    }
    function eachProp(obj, func) {
        var prop;
        for (prop in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, prop)) {
                func(obj[prop], prop);
            }
        }
    }
    function objectExtend(base, obj){
        eachProp(obj, function(v, k){
            //TODO deep clone
            base[k] = v;
        })
    }
    function Deferred(func){
        var tuples = [
                // action, add listener, listener list, final state
                [ "resolve", "done", [], "resolved" ],
                [ "reject", "fail", [], "rejected" ]
            ];
        var state = "pending",
        deferred = {},
        promise = {
                state: function() {
                    return state;
                },
                then: function( /* fnDone, fnFail, fnProgress */ ) {
                    var fns = arguments;
                    return Deferred(function( newDefer ) {
                        eachProp( tuples, function( tuple, i ) {
                            var action = tuple[ 0 ],
                                fn = (typeof fns[ i ] === "function" ) && fns[ i ];
                            // deferred[ done | fail ] for forwarding actions to newDefer
                            deferred[ tuple[1] ](function() {
                                var returned = fn && fn.apply( this, arguments );
                                if ( returned && typeof returned.promise === "function" ) {
                                    returned.promise()
                                        .done( newDefer.resolve )
                                        .fail( newDefer.reject );
                                } else {
                                    newDefer[ action + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
                                }
                            });
                        });
                        fns = null;
                    }).promise();
                },
                // Get a promise for this deferred
                // If obj is provided, the promise aspect is added to the object
                promise: function( obj ) {
                    return obj != null ? objectExtend( obj, promise ) : promise;
                }
            }
        // Add list-specific methods
        eachProp( tuples, function( tuple, i ) {
            var listeners = tuple[ 2 ],
                stateString = tuple[ 3 ];

            // promise[ done | fail | progress ]
            promise[ tuple[1] ] = function(func){
                listeners.push(func);
            };

            // Handle state
            if ( stateString ) {
                
                listeners.push(function() {
                    // state = [ resolved | rejected ]
                    state = stateString;

                // [ reject_list | resolve_list ].disable;
                    tuples[ i ^ 1 ][ 2 ] = [];
                });
            }

            // deferred[ resolve | reject | notify ]
            deferred[ tuple[0] ] = function() {
                deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
                return this;
            };
            deferred[ tuple[0] + "With" ] = function() {
                while(listeners.length !== 0){
                    (listeners.shift()).apply(arguments[0], arguments[1]);
                }
                return this;
            };
        });
        // Make the deferred a promise
        promise.promise( deferred );

        // Call given func if any
        if ( func ) {
            func.call( deferred, deferred );
        }

        // All done!
        return deferred;
    }
    
    var registry = {},
        //defined = {},
        config = {
            waitSeconds : 3
        };
    function getModule(qname){
        if(!registry[qname]){
            registry[qname] = new Module(qname);
        }
        return registry[qname];
    }
    function Module(qname){
        this.qname = qname;
        this.inited = false;
        this.enabled = false;
        this.settled = false;
        this.exported = false;
        this.failed = false;
        this.startTime = +new Date;
        this.check();  
    }
    
    Module.prototype = {
        "init" : function(deps, factory, enable){
            if(this.initing || this.inited){
                return this;
            }
            this.initing = true;
            //copy deps array
            this.deps = this.deps || (deps === undefined ? undefined : deps.slice(0));
            this.factory = this.factory || factory;
            this.depCount = this.deps.length;
            if(enable || this.enabled){
                this.resolve();
            }
            this.initing = false;
            this.inited = true;
            return this;
        },
        "enable" : function(){
            if(!this.settled){
                if(this.inited){
                    this.resolve();
                }else{
                    this.enabled = true;
                }
            }
            return this;
        },
        "exports" : function(){
            //only setup once
            if(!this.exported){
                this._exports = this.setup();
            }
            return this._exports;
        },
        "setup" : function(){
            if(!this.settled){
                return;
            }
            this.exported = true;
            if(typeof this.factory === "object"){
                return this.factory;
            }
            return this.factory.apply(this, this.deps.map(function(dep,i){
                return dep.exports();
            }));
        },
        "check" : function(){
            var mod = this, timeout = config.waitSeconds && (+new Date -this.startTime) > config.waitSeconds*1000;
            if(this.inited){
                return;
            }
            if(timeout){
                this.failed = true;
                this.deferred && this.deferred.reject(this.qname+" not found");
                return;
            }
            setTimeout(function(){mod.check();},100);
        },
        "resolve" : function(){
            var mod = this;
            if(this.depCount === 0){
                this.settled = true;
                this.emit();
                return;
            }
            this.deps.forEach(function(dep,i){

                getModule(dep).enable().wait().then(function(dep){
                    this.deps[i] = dep;
                    this.depCount -= 1;
                    if(this.depCount === 0){
                        this.settled = true;
                        this.emit();
                    }
                }.bind(mod), function(msg){
                    throw msg?(msg +" for " + this.qname):(dep + "not found for" + this.qname);
                }.bind(mod));
            });
        },
        "wait" : function(){
            var mod = this;
            if(!this.settled){
                this.deferred = this.deferred || new Deferred();
                return this.deferred;
            }else{
                //already enabled, call callback directly
                return {
                    then : function(cb, errback){
                        if(mod.settled){
                            cb && cb(mod);
                        }else{
                            errback && errback(mod);
                        }
                    },
                    done : function(cb){
                        if(mod.settled){
                            cb && cb(mod);
                        }
                    },
                    fail : function(cb){
                        if(mod.failed){
                            cb && cb(mod);
                        }
                    }
                }
            }
        },
        "emit" : function(){
            registry[this.qname] = this;
            var mod = this;
            this.deferred&&this.deferred.resolve(mod);

        }
    }

    function define(/*qname, deps, factory*/){
        var qname = arguments[0], 
            deps = arguments[1],
            factory = arguments[2];
        if(Object.prototype.toString.call(deps) !== "[object Array]"){
            factory = deps;
            deps = [];
        }
        if(!(qname in registry)){
            registry[qname] = (new Module(qname)).init(deps, factory);
        }else{
            registry[qname].init(deps, factory);
        }
    }
    define.amd = {
        vendor:"SAP Visualization"
    };
    var anonyModNo = 0;
    function require(/*deps, callback, errback*/){
        var deps = arguments[0],
            callback = arguments[1],
            errback = arguments[2];
        if(typeof deps === "string" && callback === undefined){
            var res = getModule(deps).enable().exports();
            /*if(res === undefined){
                throw "module "+ deps + " not defined yet";
            }*/
            return res;
        }
        if(Object.prototype.toString.call(deps) === "[object Object]"){
            //require.config not implemented
            return;
        }
        var rmod = new Module(("@r"+(anonyModNo++))).init(deps, callback, true);
        rmod.wait().then(function(mod){
            //make sure the main function been evaluated.
            mod.exports();
        });
    }
    require.toUrl = function(url){
        //baseUrl is always ./
        return url;
    }
    global.define = define;
    global.require = require;
})(this);(function(global) {

    function isModuleReady(moduleName) {
        var temp = global, nameParts = moduleName.split("."), i = 0;
        while (i < nameParts.length && temp !== undefined) {
            temp = temp[nameParts[i++]]
        }
        return temp !== undefined;
    }
    function getModuleByQname(qname){
        var nameParts = qname.split("."), res = global;
        for ( i = 0; i < nameParts.length; i++) {
            res = res[nameParts[i]];
        }
        return res;
    }
    function apiDef(apiname, def) {
        var res = global, i, nameParts = apiname.split("."), len = nameParts.length;
        nameParts.reduce(function(p, c, i) {
            p[c] = p[c] || (i < len - 1 || !def ? {} : def);
            return p[c];
        }, global);
        return getModuleByQname(apiname);
    }

    //private container
    apiDef("sap.viz.extapi.manifest._queue", {
        viz:{
            registerList:[],
            unregisterList:[]
        },
        module:{
            registerList:[],
            unregisterList:[]
        },
        template:{
            registerList:[],
            unregisterList:[],
            configMap : {}
        },
        language:{
            registerList:[]
        }
    });
    var manifestDefQueue = sap.viz.extapi.manifest._queue;
    
    function genManifestFuncOnModule(moduleQname, funcname, queue){
        return function(item){
            if (isModuleReady(moduleQname)) {
                getModuleByQname(moduleQname)[funcname](item);
            } else {
                queue&&queue.push(item);
            }
        }
    }
    
    function pushItemToQueue(queue){
    	return function(item){
    		queue&&queue.push(item);
    	}
    }
     
    apiDef("sap.viz.extapi.env.Template", {
        register : function(templateDef) {
            var configMap = manifestDefQueue.template.configMap;
            configMap[templateDef.id] = configMap[templateDef.id] || [];
            configMap[templateDef.id].push(templateDef);
        }
    });
    apiDef("sap.viz.extapi.env.Language", {
        register : pushItemToQueue(manifestDefQueue.language.registerList)
    });
    apiDef("sap.viz.extapi.manifest.Viz", {
        register : pushItemToQueue(manifestDefQueue.viz.registerList),
        unregister : pushItemToQueue(manifestDefQueue.viz.unregisterList)
    });
    apiDef("sap.viz.extapi.manifest.Module", {
        register : pushItemToQueue(manifestDefQueue.module.registerList),
        unregister : pushItemToQueue(manifestDefQueue.module.unregisterList)
    });
    // make sure sap.viz.api namespace exists, it is used for VERSION in all in one build
	apiDef("sap.viz.api");
	
	apiDef("sap.viz.extapi.core");
})(this);

define('sap/viz/base/utils/TypeUtils',[],
function Setup() {
	var class2type = {
		'[object Boolean]' : 'boolean',
		'[object Number]' : 'number',
		'[object String]' : 'string',
		'[object Function]' : 'function',
		'[object Array]' : 'array',
		'[object Date]' : 'date',
		'[object RegExp]' : 'regexp',
		'[object Object]' : 'object'
	};

	var hasOwn = Object.prototype.hasOwnProperty;
	// Used for trimming whitespace
	var rdigit = /\d/;

	var type = function(obj) {
		return obj == null ? String(obj) : class2type[Object.prototype.toString.call(obj)] || "object";
	};

	/**
	 * Type Utilities for common variable type related tasks
	 * 
	 * @name sap.viz.base.utils.TypeUtils
	 * @class
	 */
	var typeUtils = {

		/**
		 * Returns a boolean value indicating whether the parameter is of type
		 * function
		 * 
		 * @param {object}
		 * @returns {boolean}
		 */
		// See test/unit/core.js for details concerning isFunction.
		// Since version 1.3, DOM methods and functions like alert
		// aren't supported. They return false on IE (#2968).
		isFunction : function(obj) {
			return type(obj) === "function";
		},

		/**
		 * Returns a boolean value indicating whether the parameter is of type
		 * array
		 * 
		 * @param {object}
		 * @returns {boolean}
		 */
		isArray : Array.isArray || function(obj) {
			return type(obj) === "array";
		},

		/**
		 * Returns a boolean value indicating whether the parameter is of type
		 * string
		 * 
		 * @param {object}
		 * @returns {boolean}
		 */
		isString : function(obj) {
			return type(obj) === "string";
		},

		/**
		 * Returns a boolean value indicating whether the parameter is a
		 * non-empty string
		 * 
		 * @param {object}
		 * @returns {boolean}
		 */
		isNonEmptyString : function(obj) {
			return this.isString(obj) && obj.length !== 0;
		},


		/**
		 * Returns a boolean value indicating whether the parameter is NaN
		 * 
		 * @param {object}
		 * @returns {boolean}
		 */
		isNaN : function(obj) {
			return obj === null || obj === undefined || !rdigit.test(obj) || isNaN(obj);
		},

		/**
		 * Returns a boolean value indicating whether the parameter is a number
		 * 
		 * @param {object}
		 * @returns {boolean} Caution: isNumber(Infinity) returns false.
		 */
		isNumber : function(n) {
			return !typeUtils.isNaN(parseFloat(n)) && isFinite(n);
		},

		/**
		 * Returns a boolean value indicating whether the parameter is defined
		 * 
		 * @param {object}
		 * @returns {boolean}
		 */
		isDefined : function(v) {
			return typeof (v) !== 'undefined';
		},

		/**
		 * Returns a boolean value indicating whether the parameter is undefined
		 * 
		 * @param {object}
		 * @returns {boolean}
		 */
		isUndefined : function(v) {
			return typeof (v) === 'undefined';
		},

		/**
		 * Returns a boolean value indicating whether the parameter is a plain
		 * object
		 * 
		 * @param {object}
		 * @returns {boolean} Caution: A plain object is an object that has no
		 *          prototype method and no parent class. Null, undefined, DOM
		 *          nodes and window object are not considered as plain object.
		 */
		isPlainObject : function(obj) {
			// Must be an Object.
			// Because of IE, we also have to check the presence of the
			// constructor property.
			// Make sure that DOM nodes and window objects don't pass through,
			// as well
			if (!obj || type(obj) !== "object" || obj.nodeType
					|| (obj && typeof obj === "object" && "setInterval" in obj)) {
				return false;
			}

			// Not own constructor property must be Object
			if (obj.constructor && !hasOwn.call(obj, "constructor")
					&& !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
				return false;
			}

			// Own properties are enumerated firstly, so to speed up,
			// if last one is own, then all properties are own.

			var key;
			for (key in obj) {
			}

			return key === undefined || hasOwn.call(obj, key);
		},

		/**
		 * Returns a boolean value indicating whether the parameter is an empty
		 * object
		 * 
		 * @param {object}
		 * @returns {boolean} Caution: An empty is a plain object without any
		 *          properties.
		 */
		isEmptyObject : function(obj) {
			for ( var name in obj) {
				return false;
			}
			return typeUtils.isPlainObject(obj);
		},

		equals : function(x, y) {
		    var p;
			if (x === y){
				return true;
			}
			if (!(x instanceof Object) || !(y instanceof Object) || (x.constructor !== y.constructor)){
				return false;
			}
				
			for (p in x) {
				if (!x.hasOwnProperty(p))
					continue;
				if (!y.hasOwnProperty(p))
					return false;
				if (x[p] === y[p])
					continue;
				if (typeof (x[p]) !== "object" || !typeUtils.equals(x[p], y[p]))
					return false;
			}

			for (p in y) {
				if (y.hasOwnProperty(p) && !x.hasOwnProperty(p)){
					return false;
				}
			}
			return true;
		},
		
		 /**
	       * Returns a boolean value indicating whether the parameter is undefined or null
	       *
	       * @param {object}
	       * @returns {boolean}
	       */
	    isExist : function(o) {
	      if ((typeof (o) === 'undefined') || (o === null)) {
	        return false;
	      }
	      return true;
	    }
	};

	return typeUtils;
});
define('sap/viz/base/Logger',[],
function Setup() {
    var noop = function() {
    };
    Date.now = Date.now ||
    function() {
        return +new Date();
    };
    function getLevel(){
        return this.threshold;
    }
    function setLevel(level){
        if(typeof level ==="string")
            this.threshold = levelStr2Int(level);
        else if(typeof level === "number")
            this.threshold = level;
    }
    
	/**
	 * Append log message  into the browse console.
	 * 
	 * @name ConsoleAppender
	 * @property  {Number} threshold  The log level number.
	 * @property  {DefaultLayout} layout  The log layout format class.
	 * @property {function} print The console output function.
	 * @method  ConsoleAppender#doAppend
	 * @method  ConsoleAppender#setLayout
	 * @method  ConsoleAppender#getLevel
	 * @method  ConsoleAppender#setLevel
	 */
    var ConsoleAppender = function() {
        this.threshold = Logger.LEVEL.INFO;
        this.layout = new Logger.DefaultLayout();
        this.print = typeof console !== undefined ? function(msg) {
            console.log(msg);
        } : noop;
    };
    ConsoleAppender.prototype = {
        doAppend : function(logTime, logLevel, logCate, logMsg) {
            this.print(this.layout.format(logTime, logLevel, logCate, logMsg));
        },
        setLayout : function(layout) {
            layout.format && (this.layout = layout);
        },
        getLevel : getLevel,
        setLevel : setLevel
    };
    
	/**
	 * The default layout class  ConsoleAppender as console format.
	 * 
	 * @name DefaultLayout
	 */ 
    var DefaultLayout = function() {
        // this.df = Logger.dateFormatter;
    };
    DefaultLayout.prototype.format = function(logTime, logLevel, logCate, logMsg) {
        return "[" + logTime + "]" + "[" + getLevelStr(logLevel) + "]" + "[" + (logCate || "main") + "]-" + logMsg;
    };
    
	/**
	 * Append log message on the DIV page.
	 * 
	 * @name DivAppender
	 * @property  {Number} threshold  The log level number.
	 * @property  {HTMLLayout} layout  The log layout format class.
	 * @property {<Div>} div The html div tag to display the log message.
	 * @method  DivAppender#doAppend
	 * @method  DivAppender#getLevel
	 * @method  DivAppender#setLevel
	 */
    var DivAppender = function(div) {
//        if(!$) {  //remove jQuery dependency.
//            throw "need jQuery";
//        }
        this.threshold = Logger.LEVEL.INFO;
//        this.divSl = $(div);  //remove jQuery dependency.
		this.div = div;
        this.layout = new HTMLLayout();
    };
    DivAppender.prototype = {
        getLevel : getLevel,
        setLevel : setLevel,
        doAppend : function(logTime, logLevel, logCate, logMsg) {
//            this.divSl.append(this.layout.format(logTime, logLevel, logCate, logMsg));
			this.div.appendChild(this.layout.format(logTime, logLevel, logCate, logMsg));
        }
    };
    
	/**
	 * The layout class specified for DivAppender as html page format.
	 * 
	 * @name HTMLLayout
	 */ 
    var HTMLLayout = function() {
        // this.df = Logger.dateFormatter;
    };
    HTMLLayout.prototype = {
        getStyle : function(logLevel) {
            var style;
            if(logLevel === Logger.LEVEL.ERROR) {
                style = 'color:red';
            } else if(logLevel === Logger.LEVEL.WARN) {
                style = 'color:orange';
            } else if(logLevel === Logger.LEVEL.DEBUG) {
                style = 'color:green';
            } else if(logLevel === Logger.LEVEL.TRACE) {
                style = 'color:green';
            } else if(logLevel === Logger.LEVEL.INFO) {
                style = 'color:grey';
            } else {
                style = 'color:yellow';
            }
            return style;
        },
        format : function(logTime, logLevel, logCate, logMsg) {
            return "<div style=\"" + this.getStyle(logLevel) + "\">[" + logTime + "]" + "[" + getLevelStr(logLevel) + "][" + (logCate || "main") + "]-" + logMsg + "</div>";
        }
    };
    var FifoBuffer = function() {
        this.array = [];
    };

    FifoBuffer.prototype = {

        /**
         * @param {Object} obj any object added to buffer
         */
        push : function(obj) {
            this.array[this.array.length] = obj;
            return this.array.length;
        },
        /**
         * @return first putted in Object
         */
        pull : function() {
            if(this.array.length > 0) {
                var firstItem = this.array[0];
                for(var i = 0; i < this.array.length - 1; i++) {
                    this.array[i] = this.array[i + 1];
                }
                this.array.length = this.array.length - 1;
                return firstItem;
            }
            return null;
        },
        length : function() {
            return this.array.length;
        }
    };
	/**
	 * Append log message to a remote file via ajax call.
	 * 
	 * @name AjaxAppender
	 * @property  {Number} threshold  The log level number.
	 * @property  {String} loggingUrl The ajax call url.
	 * @property  {Boolean} isInProgress  The process state of ajax call.
	 * @property  {Number} bufferSize  Once the log messages reaches the number, it will perform to send ajax call.
	 * @property  {Number} timeout  The delayed time to send the ajax call request.
	 * @property  {Arrary} loggingEventMap  The array stored the log messages.
	 * @property  {JSONLayout} layout  The specified layout for AjaxAppender.
	 * @property  {Arrary} loggingEventMap  The array stored the log messages.
	 * @property  {httpRequest} httpRequest  The httpRequest to send ajax call.
	 * @method  AjaxAppender#doAppend
	 * @method  AjaxAppender#getLevel
	 * @method  AjaxAppender#setLevel
	 * @method  AjaxAppender#send
	 * @method  AjaxAppender#onReadyStateChanged
	 * @method  AjaxAppender#getXmlHttpRequest
	 */
    
    var AjaxAppender = function(url) {
        this.loggingUrl = url;
        this.isInProgress = false;
        this.threshold = Logger.LEVEL.INFO;
        this.bufferSize = 20;
        this.timeout = 2000;
        this.loggingEventMap = [];
        this.layout = new Logger.JSONLayout();
        this.httpRequest = null;
        this.timer = undefined;
    };
    function tryAppend() {
        var appender = this;
        if(this.isInProgress === true) {
            setTimeout(function() {
                tryAppend.call(appender);
            }, 100);
        }else{
            this.send();
        }
    }


    AjaxAppender.prototype = {
        getLevel : getLevel,
        setLevel : setLevel,
        doAppend : function(logTime, logLevel, logCate, logMsg) {
            this.loggingEventMap.push([logTime, logLevel, logCate, logMsg]);
            if(this.loggingEventMap.length <= this.bufferSize || this.isInProgress === true) {
                var appender = this;
                if(this.timer === undefined) {
                    this.timer = setTimeout(function() {
                        tryAppend.call(appender);
                    }, 100);
                }
            }

            if(this.loggingEventMap.length >= this.bufferSize && this.isInProgress === false) {
                //if bufferSize is reached send the events and reset current bufferSize
                if(this.timer !== undefined)
                    clearTimeout(this.timer);
                this.send();
            }
        },
        send : function() {
            if(this.loggingEventMap.length > 0) {
                this.isInProgress = true;
                var a = [];
                var loggingEvent;
                for(var i = 0, lml = this.loggingEventMap.length; i < lml && i < this.bufferSize; i++) {
                    loggingEvent = this.loggingEventMap.shift();
                    a.push(this.layout.format(loggingEvent[0], loggingEvent[1], loggingEvent[2], loggingEvent[3]));
                }

                var content = this.layout.getHeader();
                content += a.join(this.layout.getSeparator());
                content += this.layout.getFooter();

                var appender = this;
                if(this.httpRequest === null) {
                    this.httpRequest = this.getXmlHttpRequest();
                }
                this.httpRequest.onreadystatechange = function() {
                    appender.onReadyStateChanged.call(appender);
                };

                this.httpRequest.open("POST", this.loggingUrl, true);
                // set the request headers.
                this.httpRequest.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
                this.httpRequest.setRequestHeader("Content-length", content.length);
                //this.httpRequest.setRequestHeader("Content-type", this.layout.getContentType());
                this.httpRequest.send(content);
                appender = this;

                try {
                    setTimeout(function() {
                        appender.httpRequest.onreadystatechange = function() {
                        };
                        appender.httpRequest.abort();
                        //this.httpRequest = null;
                        appender.isInProgress = false;

                        if(appender.loggingEventMap.length > 0) {
                            appender.send();
                        }
                    }, this.timeout);
                } catch (e) {
                }
            }
        },
        onReadyStateChanged : function() {
            var req = this.httpRequest;
            if(this.httpRequest.readyState !== 4) {
                return;
            }

            var success = (( typeof req.status === "undefined") || req.status === 0 || (req.status >= 200 && req.status < 300));

            if(success) {

                //ready sending data
                this.isInProgress = false;

            } else {
            }
        },
        getXmlHttpRequest : function() {

            var httpRequest = false;

            try {
                if(window.XMLHttpRequest) {// Mozilla, Safari, IE7...
                    httpRequest = new XMLHttpRequest();
                    if(httpRequest.overrideMimeType) {
                        httpRequest.overrideMimeType(this.layout.getContentType());
                    }
                } else if(window.ActiveXObject) {// IE
                    try {
                        httpRequest = new ActiveXObject("Msxml2.XMLHTTP");
                    } catch (e) {
                        httpRequest = new ActiveXObject("Microsoft.XMLHTTP");
                    }
                }
            } catch (e) {
                httpRequest = false;
            }

            if(!httpRequest) {
                throw "browser don't support AJAX";
            }

            return httpRequest;
        }
    };
    
	/**
	 * The layout class specified for AjaxAppender as JSON format.
	 * 
	 * @name JSONLayout
	 */   
    var JSONLayout = function() {

    };
    JSONLayout.prototype = {
        /**
         * Implement this method to create your own layout format.
         * @param {Log4js.LoggingEvent} loggingEvent loggingEvent to format
         * @return formatted String
         * @type String
         */
        format : function(logTime, logLevel, logCate, logMsg) {

            var jsonString = "{\n \"LoggingEvent\": {\n";
            jsonString += "\t\"category\": \"" + (logCate || "main") + "\",\n";
            jsonString += "\t\"level\": \"" + getLevelStr(logLevel) + "\",\n";
            jsonString += "\t\"message\": \"" + logMsg + "\",\n";
            // jsonString += "\t\"referer\": \"" + referer + "\",\n";
            // jsonString += "\t\"useragent\": \"" + useragent + "\",\n";
            jsonString += "\t\"timestamp\": \"" + logTime + "\"\n";
            jsonString += "}\n}";

            return jsonString;
        },
        /**
         * Returns the content type output by this layout.
         * @return The base class returns "text/xml".
         * @type String
         */
        getContentType : function() {
            return "text/json";
        },
        /**
         * @return Returns the header for the layout format. The base class returns null.
         * @type String
         */
        getHeader : function() {
            var useragent = "unknown";
            try {
                useragent = navigator.userAgent;
            } catch(e) {
                useragent = "unknown";
            }

            var referer = "unknown";
            try {
                referer = location.href;
            } catch(e) {
                referer = "unknown";
            }
            return "{" + "\"ClientInfo\" : {\n" + "\t\"useragent\": \"" + useragent + "\",\n" + "\t\"referer\": \"" + referer + "\"\n},\n" + "\"VizLogger\": [\n";
        },
        /**
         * @return Returns the footer for the layout format. The base class returns null.
         * @type String
         */
        getFooter : function() {
            return "\n]}";
        },
        getSeparator : function() {
            return ",\n";
        }
    };

    /**
     * Get the XMLHttpRequest object independent of browser.
     * @private
     */
    var XMLLayout = function() {
        // this.df = Logger.dateFormatter;
    };
    XMLLayout.prototype = {
        format : function(logTime, logLevel, logCate, logMsg) {

            var content = "<vizLogger:event category=\"";
            content += (logCate || "main") + "\" level=\"";
            content += getLevelStr(logLevel) + "\" timestamp=\"";
            content += logTime + "\">\n";
            content += "\t<vizLogger:message><![CDATA[" + this.escapeCdata(logMsg) + "]]></vizLogger:message>\n";
            content += "</vizLogger:event>";

            return content;
        },
        /**
         * Returns the content type output by this layout.
         * @return The base class returns "text/xml".
         * @type String
         */
        getContentType : function() {
            return "text/xml";
        },
        /**
         * @return Returns the header for the layout format. The base class returns null.
         * @type String
         */
        getHeader : function() {
            var useragent = "unknown";
            try {
                useragent = navigator.userAgent;
            } catch(e) {
                useragent = "unknown";
            }

            var referer = "unknown";
            try {
                referer = location.href;
            } catch(e) {
                referer = "unknown";
            }
            return "<vizLogger:eventSet useragent=\"" + useragent + "\" referer=\"" + referer.replace(/&/g, "&amp;") + "\">\n";
        },
        /**
         * @return Returns the footer for the layout format. The base class returns null.
         * @type String
         */
        getFooter : function() {
            return "</vizLogger:eventSet>\n";
        },
        getSeparator : function() {
            return "\n";
        },
        /**
         * Escape Cdata messages
         * @param str {String} message to escape
         * @return {String} the escaped message
         * @private
         */
        escapeCdata : function(str) {
            return str.replace(/\]\]>/, "]]>]]&gt;<![CDATA[");
        }
    };

    function getLevelStr(levelInt) {
        switch(levelInt) {
            case Logger.LEVEL.TRACE:
                return "TRACE";
            case Logger.LEVEL.DEBUG:
                return "DEBUG";
            case Logger.LEVEL.INFO:
                return "INFO";
            case Logger.LEVEL.WARN:
                return "WARN";
            case Logger.LEVEL.ERROR:
                return "ERROR";
        }
    }
    function levelStr2Int(levelStr) {
        switch(levelStr.toLowerCase()){
            case "trace":
                return Logger.LEVEL.TRACE;
            case "debug":
                return Logger.LEVEL.DEBUG;
            case "info":
                return Logger.LEVEL.INFO;
            case "warn":
                return Logger.LEVEL.WARN;
            case "error":
                return Logger.LEVEL.ERROR;
        }
    }
    var enabled = false;
    var paused = false;
    var MaxBufferSize = 2000;
    var doLog = function(level, category, message, loggerLevel) {
    	for(appenderKey in appenders) {
             if(appenders.hasOwnProperty(appenderKey)) {
                 appender = appenders[appenderKey];
				 var PnRAppender = appender.hasOwnProperty('profiling') && level <=levelSetting.DEBUG; // pnr Appender (reference to sap.viz.base.utils.log.Analyzer), pnr default level is DEBUG.
                 if(PnRAppender || (appender.threshold >= loggerLevel && level >=appender.threshold )) // ONLY appender.threshold >= loggerLevel
                {
                	 appender.doAppend(Date.now(), level, category, message);
                }
             }
         }
    };
    var awakeThenLog = function(level, category, message) {
        resume();
        doLog(level, category, message);
    };
    var log = noop;
    var pause = function() {
        paused = true;
        log = awakeThenLog;
    };
    var resume = function() {
        paused = false;
        log = doLog;
    };
    // id for appender
    var id = 0;
    var nextId = function() {
        return id++;
    };
    var appenders = {};
    /*
     * singleton Logger
     *
     */
    var levelSetting = {
            TRACE : 5000,
            DEBUG : 10000,
            INFO : 20000,
            WARN : 30000,
            ERROR : 40000,
            NO : Number.MAX_VALUE
        };
    var Logger = {
        LEVEL :levelSetting,
        isEnabled : function() {
            return enabled;
        },
        enable : function() {
            log = doLog;
            enabled = true;
        },
        disable : function() {
            log = noop;
            enabled = false;
        },
        toggleEnable : function() {
            if(enabled)
                this.disable();
            else
                this.enable();
        },
        addAppender : function(/*[key,] appender*/) {
            var _nextId = nextId();
            var key, appender;
            if(arguments.length === 1) {
                key = _nextId;
                appender = arguments[0];
            } else if(arguments.length >= 2) {
                key = arguments[0];
                appender = arguments[1];
            }
            if( typeof appender === "object" && appender.doAppend) {
                if(appenders[key] !== undefined)
                    return;
                appenders[key] = appender;
                return key;
            }

        },
        setAppenders : function(apds) {
            appenders = [];
            for(var i = 0, l = apds.length; i < l; i++) {
                var appender = apds[i];
                if(appender.appenderKey)
                    this.addAppender(appender.appenderKey, appender.appender);
                else
                    this.addAppender(appender.appender);
            }
        },
        removeAppender : function(key) {
            if(appenders[key] === undefined){
                return false;
            }else{
                return ( delete appenders[key]);
            }
        },
        getAppender : function(key) {
            return appenders[key];
        },
        getAppenders: function(){
        	var appenderArray = [];
        	if(appenders){
        		
        		for(var key in appenders){
        			if(appenders.hasOwnProperty(key)){
        				var item = appenders[key];
        				appenderArray.push(item);
        			}
        		}
        	}
        	return appenderArray;
        },
        ConsoleAppender : ConsoleAppender,
        DivAppender : DivAppender,
        AjaxAppender : AjaxAppender,
        //[time][level][category]-message [yyyy-MM-ddThh:mm:ss:ms][INFO][function1]-this is a piece of log.
        DefaultLayout : DefaultLayout,
        HTMLLayout : HTMLLayout,
        XMLLayout : XMLLayout,
        JSONLayout : JSONLayout,
        level: levelSetting.INFO, // default log level.
        trace : function(message, category) {
            log(Logger.LEVEL.TRACE, category, message, this.level);
        },
        debug : function(message, category) {
            log(Logger.LEVEL.DEBUG, category, message, this.level);
        },
        info : function(message, category) {
            log(Logger.LEVEL.INFO, category, message, this.level);
        },
        warn : function(message, category) {
            log(Logger.LEVEL.WARN, category, message, this.level);
        },
        error : function(message, category) {
            log(Logger.LEVEL.ERROR, category, message, this.level);
        }
    };
    appenders["[default]"] = new Logger.ConsoleAppender();
    return Logger;
});
define('sap/viz/base/utils/FunctionUtils',['sap/viz/base/utils/TypeUtils', 'sap/viz/base/Logger'],
function Setup(TypeUtils, Logger) {
	var msgparas = /\{(\d+)\}/g;
	var ArraySlice = Array.prototype.slice
	function emptyFn() {
	}

	function error(msg) {
		var args = arguments;
		if (args[0]) {
			var msg = args[0].replace(msgparas, function(m, n) {
				return args[parseInt(n) + 1];
			});
			Logger.error(msg);
			throw msg;
		} else {
			Logger.error('Unknown error!');
			throw 'Unknown error!';
		}
	}

	function createCallChain() {
		var callChain = [];
		function ChainedFunc() {
			for ( var i = 0, len = callChain.length; i < len; i++) {
				callChain[i].apply(this, arguments);
			}
		}
		function buildChain() {
			for ( var i = 0, len = arguments.length; i < len; i++) {
				if (TypeUtils.isFunction(arguments[i])) {
					callChain.push(arguments[i]);
				} else {
					 Logger.error('Could not create call chain for non-function object');
					 throw 'Could not create call chain for non-function object';
				}
			}
		}
		ChainedFunc.chain = function() {
			return createCallChain.apply(null, [].concat(callChain, ArraySlice.call(arguments)));
		};
		buildChain.apply(null, arguments);
		return ChainedFunc;
	}

	var funcUtils = {
		/**
		 * empty function
		 * 
		 * @name sap.viz.base.utils.FunctionUtils#noop
		 * @function
		 */
		noop : emptyFn,

		/**
		 * Function throwing unsupported exception with constant error message,
		 * or make a new function which could throw exception with specified
		 * error message
		 * 
		 * @name sap.viz.base.utils.FunctionUtils#unsupported
		 * @function
		 * 
		 * @param {String}
		 *            (msg)
		 * @return {Function}
		 * @throw {Error}
		 */
		unsupported : function(msg) {
			if (arguments.length) {
				return function() {
					throw new Error(msg || 'Unsupported function!');
				};
			} else
				throw new Error('Unsupported function!');
		},

		/**
		 * function throwing unimplemented exception
		 * 
		 * @name sap.viz.base.utils.FunctionUtils#unimplemented
		 * @function
		 */
		unimplemented : function(msg) {
			if (arguments.length) {
				return function() {
					throw new Error(msg || 'Unimplemented function!');
				};
			} else
				throw new Error('Unimplemented function!');
		},

		/**
		 * function throwing error
		 * 
		 * @name sap.viz.base.utils.FunctionUtils#error
		 * @param {String}
		 *            msg the error message
		 * @function
		 */
		error : error,

		/**
		 * Return a number comparator for ascendent sorting
		 * 
		 * @param a
		 * @param b
		 * @returns todo
		 */
		ascending : function(a, b) {
			return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
		},
		/**
		 * Return a number comparator for descendent sorting
		 * 
		 * @param a
		 * @param b
		 * @returns todo
		 */
		descending : function(a, b) {
			return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
		},

		createCallChain : createCallChain
	};

	return funcUtils;
});
define('sap/viz/base/Class',['sap/viz/base/utils/FunctionUtils','sap/viz/base/utils/TypeUtils'],
function Setup(FuncUtils, TypeUtils) {
	// inspired by http://ejohn.org/blog/simple-javascript-inheritance/
	var fnTest = /xyz/.test(function() {
		xyz;
	}) ? /\b_super\b/ : /.*/;
	var callChain = FuncUtils.createCallChain;
	function zeroClass() {
	}

	function extend(ext) {
		var _super = zeroClass.prototype = this.prototype;
		var subclass = this.chain ? this.chain(ext.constructor) : callChain(this, ext.constructor);
		var proto = subclass.prototype = new zeroClass();
		proto.constructor = subclass;
		delete ext.constructor;
		var fn;
		for ( var f in ext) {
			fn = ext[f];
			proto[f] = typeof fn === 'function' && typeof _super[f] === 'function' && fnTest.test(fn) ? (function(name,
					func) {
				return function() {
					this._super = _super[name];
					var ret = func.apply(this, arguments);
					return ret;
				};
			})(f, fn) : fn;
		}
		subclass.extend = extend;
		return subclass;
	}

	/**
	 * Define a class, make it extensible. The parameter could be an existing
	 * constructor or a Class config object.
	 * 
	 * <pre>
	 * {
	 * 		constructor : function(){...},
	 * 		method1		: function(){...},
	 * 		method2		: function(){...},
	 * 		...
	 * 		methodn		: function(){...}
	 * }
	 * </pre>
	 * 
	 * @param {Function|Object}
	 *            clazz constructor or an Class config object
	 * @returns {Function} the class
	 */
	function define(clazz) {
		if (typeof clazz === 'function') {
			clazz.extend = extend;
			return clazz;
		} else {
			var constructor = clazz.constructor || function() {
			}, proto = constructor.prototype;
			for ( var f in clazz) {
				if (clazz.hasOwnProperty(f)) {
					proto[f] = clazz[f];
				}
			}
			constructor.extend = extend;
			return constructor;
		}
	}
	return {
		define : define,
		extend : extend
	};
});
define('sap/viz/data/description/DataContainer',['sap/viz/base/Class'],
 function Setup(Class){
	var DataContainer = Class.define({
		constructor : function(uid){
			this._uId = uid; 
			this._isFake = false;
			this._infos = null;
		},
		getId : function(){
			return this._uId;
		},
		fake : function(_){
			if (!arguments.length){
				return this._isFake;
			}
			this._isFake = _;
		},
		infos : function(_){
			if (!arguments.length){
				return this._infos;
			}
			this._infos = _;
		} 
	});
	return DataContainer;
 });
define('sap/viz/base/utils/ObjectUtils',['sap/viz/base/utils/TypeUtils','sap/viz/base/utils/FunctionUtils'],
function Setup(TypeUtils, FuncUtils) {
	// JSON RegExp
	rvalidchars = /^[\],:{}\s]*$/, rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
			rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
			rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;

	/**
	 * Frequently used object utilities
	 * 
	 * @name sap.viz.base.utils.ObjectUtils
	 * @class
	 */
	var objUtils = {
		// Copy from jQuery
		extend : function() {
			var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;

			// Handle a deep copy situation
			if (typeof target === "boolean") {
				deep = target;
				target = arguments[1] || {};
				// skip the boolean and the target
				i = 2;
			}

			// Handle case when target is a string or something (possible in
			// deep
			// copy)
			if (typeof target !== "object" && !TypeUtils.isFunction(target)) {
				target = {};
			}

			// extend jQuery itself if only one argument is passed
			if (length === i) {
				target = this;
				--i;
			}

			for (; i < length; i++) {
				// Only deal with non-null/undefined values
				if ((options = arguments[i]) != null) {
					// Extend the base object
					for (name in options) {
						src = target[name];
						copy = options[name];

						// Prevent never-ending loop
						if (target === copy) {
							continue;
						}

						// Recurse if we're merging plain objects or arrays
						if (deep && copy && (TypeUtils.isPlainObject(copy) || (copyIsArray = TypeUtils.isArray(copy)))) {
							if (copyIsArray) {
								copyIsArray = false;
								clone = src && TypeUtils.isArray(src) ? src : [];

							} else {
								clone = src && TypeUtils.isPlainObject(src) ? src : {};
							}
							// Never move original objects, clone them
							target[name] = objUtils.extend(deep, clone, copy);
							// Don't bring in undefined values
						} else if (copy !== undefined) {
							target[name] = copy;
						}
					}
				}
			}
			// Return the modified object
			return target;
		},

		// args is for internal usage only
		each : function(object, callback, args) {
			var name, i = 0, length = object.length, isObj = length === undefined || TypeUtils.isFunction(object);

			if (args) {
				if (isObj) {
					for (name in object) {
						if (callback.apply(object[name], args) === false) {
							break;
						}
					}
				} else {
					for (; i < length;) {
						if (callback.apply(object[i++], args) === false) {
							break;
						}
					}
				}

				// A special, fast, case for the most common use of each
			} else {
				if (isObj) {
					for (name in object) {
						if (callback.call(object[name], name, object[name]) === false) {
							break;
						}
					}
				} else {
					for ( var value = object[0]; i < length && callback.call(value, i, value) !== false; value = object[++i]) {
					}
				}
			}
			return object;
		},

		parseJSON : function(data) {
			if (typeof data !== "string" || !data) {
				return null;
			}

			// Make sure leading/trailing whitespace is removed (IE can't handle
			// it)
			data = data.trim();

			// Make sure the incoming data is actual JSON
			// Logic borrowed from http://json.org/json2.js
			if (rvalidchars.test(data.replace(rvalidescape, "@").replace(rvalidtokens, "]").replace(rvalidbraces, ""))) {

				// Try to use the native JSON parser first
				return window && window.JSON && window.JSON.parse ? window.JSON.parse(data) : (new Function("return "
						+ data))();

			} else {
				TypeUtils.error("Invalid JSON: " + data);
			}
		},

		/**
		 * Generate a guid
		 * 
		 * @name sap.viz.base.utils.ObjectUtils#guid
		 * @function
		 * @return {String}
		 */
		guid : function() {// guid generator
			return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
				var r = Math.random() * 16 | 0, v = c == 'x' ? r : r & 0x3 | 0x8;
				return v.toString(16);
			});
		},
		
		clone : function (obj) {
            if ( typeof (obj) !== 'object')
                return obj;
            if (obj === null)
                return obj;
            var o = obj.constructor === Array ? [] : {};
            for (var i in obj) {
                o[i] = typeof obj[i] === "object" ? arguments.callee.call(null, obj[i]) : obj[i];
            }
            return o;
        },
	};
	return objUtils;
});
define('sap/viz/data/description/MeasureValues',['sap/viz/base/utils/ObjectUtils','sap/viz/data/description/DataContainer'],
 function Setup(ObjUtils, DataContainer){
   
   /**
    * @private
    * @name sap.viz.data.description.MeasureValues
    */
     var MeasureValues = DataContainer.extend({
      
       /** 
        * @constructor
        * @param uid    identifier of measure values, usually name
        * @param values 
        */
       constructor : function ( uid, values ) {
           this._values = values;
       },
       
         getValues : function(){
           return this._values;
         }
    
    });
     
     
     
     return MeasureValues;
});
define('sap/viz/Locale',[],
function Setup(LangManager, FormatManager) {
  var locale = 'en',  listeners = [];
    
  function onLocaleChanged(locale) {
    listeners.forEach(function(listener) {
      listener.fn.apply(listener.scope, [locale]);
    });
  }
  
  var Locale = 
    /** @lends sap.viz.Locale */
  {    /**
           * @constructs
           */
          constructor : function(){
            return;
          },
          
          /**
           * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead. You can use sap.viz.api.env.Locale.set/get instead.
           * @param {String}
           *       locale
           * 
           * @returns {Object} {@link sap.viz.Locale}
           * @example <caption>Live Demo:</caption> 
           * {@link http://shg-ci-web.dhcp.pgdev.sap.corp/snippet_platform_api/#009215|Try this}. 
           */
          locale : function(loc){
            if(!arguments.length){
              return locale;
            }
            locale = loc;
            onLocaleChanged(locale);
            return Locale;
          },
          
          /**
           * Add a listener which will be executed when current language is changed.
           * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead. You can use sap.viz.extapi.env.Locale.addListener instead.
           * @param {Object}
           *          listener
           * @param {Function}
           *          listener.fn the listener function
           * @param {Object}
           *          listener.scope the "this" object in the listener function
           * 
           * @returns {Object} {@link sap.viz.Locale}
           * @example <caption>Live Demo:</caption> 
           * {@link http://shg-ci-web.dhcp.pgdev.sap.corp/snippet_platform_api/#004807|Try this}. 
           */
          addListener : function(listener) {
              listeners.push(listener);
              return Locale;
           },
           
           /**
            * Remove the listener.
            * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead. You can use sap.viz.extapi.env.Locale.removeListener instead.
            * @param {Object} listener
            *          the listener reference
            * 
            * @returns {Object} {@link sap.viz.Locale}
            * @example <caption>Live Demo:</caption> 
            * {@link  http://shg-ci-web.dhcp.pgdev.sap.corp/snippet_platform_api/#004807|Try this}. 
            */
           removeListener : function(listener) {
             var index = listeners.indexOf(listener);
             if (index !== -1){
				listeners.splice(index, 1);
             }
             return Locale;
           }
  };
  
  return Locale;
});
define('sap/viz/lang/LangMessageUtil',[],
function Setup() {

  var number2IDS = {
		  
		  // ERROR start with 50000.
		  50000:'IDS_ERROR_DIMENSION_NOT_ZERO' , 
		  50001:'IDS_ERROR_DIMENSION_WRONG_COUNT', 
		  50002:'IDS_ERROR_DIMENSION_WRONG_LABELS_COUNT', 
		  50003:'IDS_ERROR_WRONG_VALUES_COUNT_IN_AA2', 
		  50004:'IDS_ERROR_WRONG_VALUES_COUNT_IN_AA1',  
		  50005:'IDS_ERROR_NOT_MEET_NUMBER_OF_FEED', 
		  50006:'IDS_ERROR_WRONG_FEED_TYPE', 
		  50007:'IDS_ERROR_WRONG_FEED_TYPE_IN_DEFINTION', 
		  50008:'IDS_ERROR_WRONG_AXIS_INDEX', 
		  50009:'IDS_ERROR_WRONG_MEASURE_AXIS_INDEX', 
		  50010:'IDS_ERROR_INVALID_FEEDING', 
		  50011:'IDS_ERROR_NO_FEED_ID', 
		  50012:'IDS_ERROR_INVALID_FEEDING_NUMBER', 
		  50013:'IDS_ERROR_NO_AXIS', 
		  50014:'IDS_ERROR_FEED_NOT_ACCEPT_DATA',  
		  50015:'IDS_ERROR_NOT_FIND_MEASURE_GROUP', 
		  50016:'IDS_ERROR_NOT_ACCEPT', 
		  50017:'IDS_ERROR_INVALID_BINDING', 
		  50018:'IDS_ERROR_NOT_FIND_FEED_DEFINITION', 
		  50019:'IDS_ERROR_WRONG_TYPE', 
		  50020:'IDS_ERROR_NOT_SUPPORTED', 
		  50021:'IDS_ERROR_NOT_DETERMINE_AXIS_INDEX', 
		  50022:'IDS_ERROR_NOT_ACCEPT_2_OR_MORE_AXES', 
		  50023:'IDS_ERROR_AXIS_INDEX_SHOULD_BE_1_OR_2', 
		  50024:'IDS_ERROR_NOT_DETERMINE_DEMENSION', 
		  50025:'IDS_ERROR_UNKNOWN_STATE', 
		  50026:'IDS_ERROR_INVALID_PATH_DEFINITION', 
		  50027:'IDS_ERROR_NODE_NOT_IN_SAME_ROOT', 
		  50028:'IDS_ERROR_NOT_ADD_SELF_AS_CHILD', 
		  50029:'IDS_ERROR_NOT_ADD_ANCESTOR_AS_CHILD', 
		  50030:'IDS_ERROR_NOT_CHILD_NODE_INSERT', 
		  50031:'IDS_ERROR_NODE_IS_NOT_CHILD_OF_THIS_NODE', 
		  50032:'IDS_ERROR_SELECTOR_NOT_NULL', 
		  50033:'IDS_ERROR_NOT_FIND_JQUERY', 
		  50034:'IDS_ERROR_NEED_SPECIFY_OPTIONS_TO_INITIALIZE', 
		  50035:'IDS_ERROR_NEED_SPECIFY_HOLDER_FOR_VISUALIZATION', 
		  50036:'IDS_ERROR_NOT_INITIALIZE_WITHOUT_UICONTROLLER', 
		  50037:'IDS_ERROR_NEED_PROVIDE_CONTAINER_FOR_FRAME', 
		  50038:'IDS_ERROR_CATEGORY_NAME_NOT_EMPTY', 
		  50039:'IDS_ERROR_CATEGORY_FACTORY_MUST_BE_FUNCTION', 
		  50040:'IDS_ERROR_EXIST_CATEGORY_NAME', 
		  50041:'IDS_ERROR_NOT_REGISTER_UNDEFINED_OBJECT', 
		  50042:'IDS_ERROR_NOT_REGISTER_WITHOUT_VALID_ID', 
		  50043:'IDS_ERROR_UNKNOWN_ERROR',
		  50044:'IDS_ERROR_NOT_CREATE_CHAIN_FOR_NON_FUNCTION_OBJECT',
		  50045:'IDS_ERROR_AXIS_ALREADY_EXIST',
		  50046: 'IDS_ERROR_CAN_NOT_FIND_CATEGORY',
		  50047: 'IDS_ERROR_ALREADY_EXIST_IN_CATEGORY',
		  50048:'IDS_ERROR_LOADING_TEMPLATE_FAIL',
		  50049:'IDS_ERROR_PARSE_ERROR_EXPECT_TO',
		  50050:'IDS_ERROR_FLATTABLE_FEED_DEF_FIELD_INDEX_MISSING',
		  50051:'IDS_ERROR_FLATTABLE_MANNUAL_FEED_WRONG_BINDING',
		  50052:'IDS_ERROR_FLATTABLE_INVALID_DATA_PARAM',
		  
		  
		  // warning
		  40000:'IDS_WARN_PARAMETER_NOT_CORRECT',
		  40001:'IDS_WARN_LOCALE_NOT_CORRECT'
		  
  };
  
  var IDS2Number = null;
  /**
   * create a map for message key to message code.
   */
  function getIDS2NumberMapping(){
	  if(IDS2Number == null && number2IDS){
		  IDS2Number = {};
		  for(var num in number2IDS){
			  if(number2IDS.hasOwnProperty(num)){
				  IDS2Number[number2IDS[num]] = num;
			  }
		  }
	  }
	  return IDS2Number;
		  
  };
  var langMessageUtil = {
	      /**
	       * Register number/IDS pair for message globalization.
	       * 
	       * @param {Number}
	       *          message code.
	       * @param {String}
	       *          the key string of message content.
	       */
		  register: function(number, IDS){
			  if(IDS2Number === null){
				  IDS2Number = getIDS2NumberMapping();
			  }
			  if(number2IDS && number2IDS.hasOwnProperty(number) === false  && IDS2Number.hasOwnProperty(IDS) === false){
				  number2IDS[number] = IDS;
				  IDS2Number[IDS] = number; 
			  }else{
			  // TODO: handle the number or IDS exists.
			  }
		  },
		  
	      /**
	       * Get the message key by message code.
	       * 
	       * @param {Number}
	       *          message code.
	       * @returns {String}
	       *          the key string of message content.
	       */
		  getIDSByNumber: function(num){
			  if(number2IDS && number2IDS.hasOwnProperty(num)){
				  return number2IDS[num];
			  }else{
				  return undefined;
			  }
		  },
		  
	      /**
	       * Get the message code by message key.
	       * 
	       * @param {String}
	       *          message key.
	       * @returns {number}
	       *          message code.
	       */
		  getNumberByIDS: function(IDS){
			  if(IDS2Number ===null){
				  IDS2Number = getIDS2NumberMapping();
			  }
			  if(IDS2Number && IDS2Number.hasOwnProperty(IDS)){
				  return IDS2Number[IDS];
			  }else{
				  return undefined;
			  }
		  }
  };
  return langMessageUtil;
});

define('sap/viz/base/utils/ResouceBundleUtils',[],
function Setup() {
	var ResouceBundleUtils = {
			/**
			 * substitute the localized string for resource bundle.
			 * @private 
			 * @example
			 * 		ResouceBundleUtils.replace('The ID {0} is not a valid number', 'NOT_NUMBER')
			 * @returns {String} replacedString
			 */
			substitute: function(str/*String*/, rest/*Array*/){
		        if (str == null) return '';
		        
		        if(!rest){
		        	rest = [];
		        }
		        var len = rest.length;
		        for (var i = 0; i < len; i++){
		            str = str.replace(new RegExp("\\{"+i+"\\}", "g"), rest[i]);
		        }
		        return str;
			},
			
	};
	return ResouceBundleUtils;
});
define('sap/viz/lang/langManager',['sap/viz/base/utils/FunctionUtils','sap/viz/base/utils/ObjectUtils','sap/viz/base/utils/TypeUtils',
'sap/viz/Locale', 'sap/viz/lang/LangMessageUtil', 'sap/viz/base/utils/ResouceBundleUtils'],
function Setup(FunctionUtils, ObjectUtils, TypeUtils, Locale, LangMessageUtil, ResouceBundleUtils) {

  function loadResource(url,  cb, onError) {
    var head = document.getElementsByTagName("head")[0] || document.documentElement;
    var script = document.createElement("script");
    script.type = 'text/javascript';
    script.src = url;

    var done = false;
    script.onload = script.onreadystatechange = function() {
      if (!done && (!this.readyState || this.readyState === "loaded" || this.readyState === "complete")) {
        done = true;
        script.onload = script.onreadystatechange = null;
        if (head && script.parentNode) {
          head.removeChild(script);
        }
        cb();
      }
    };
    if (script.addEventListener) {
      script.addEventListener('error', function() {
        //clear script
        script.onload = script.onreadystatechange = null;
        if(script.parentNode){
            script.parentNode.removeChild(script);
        }
        //call error callback
        onError();
      }, true);
    }

    head.insertBefore(script, head.firstChild);
  }
  
  function loadResources(loadPath, index, id, cb, onError ){
    if(index < loadPath.length){
      var url = loadPath[index] + 'language_' + id + '.js';
      var done = function(){
        loadResources(loadPath, index+1, id, cb, onError);
      };
      loadResource(url, done, done);
    }else{
      //FIXME (by eddy.zeng) temporary change, since we're using require.js in jsonp, 
      //delay call callback to make sure jsonp content evaluated before trying to get language content from setting map.
        setTimeout(function() {
            var c_language = get(id);
            if (c_language) {
                cb(c_language);
            } else {
                onError();
            }
        }, 4); 
    }
  }
  function initialLanguageMap(){
      
      var map = d3.map();
      //3 for ar
      map.set("ar_AE","ar");
      map.set("ar_EG","ar");
      map.set("ar_SA","ar");
      //1 for bg
      map.set("bg_BG","bg");
      //1 for ca
      map.set("ca_ES","ca");
      //1 for cs
      map.set("cs_CZ","cs");
      //1 for da
      map.set("da_DK","da");
      //5 for de
      map.set("de_CH","de");
      map.set("de_AT","de");
      map.set("de_BE","de");
      map.set("de_LU","de");
      map.set("de_DE","de");
      //2 for el
      map.set("el_CY","el");
      map.set("el_GR","el");
      //14 for en
      map.set("en_AU","en");
      map.set("en_CA","en");
      map.set("en_GB","en");
      map.set("en_HK","en");
      map.set("en_ID","en");
      map.set("en_IE","en");
      map.set("en_IN","en");
      map.set("en_IS","en");
      map.set("en_MY","en");
      map.set("en_NZ","en");
      map.set("en_PH","en");
      map.set("en_SG","en");
      map.set("en_US","en");
      map.set("en_ZA","en");
      //9 for es
      map.set("es_AR","es");
      map.set("es_BO","es");
      map.set("es_CL","es");
      map.set("es_CO","es");
      map.set("es_ES","es");
      map.set("es_MX","es");
      map.set("es_PE","es");
      map.set("es_UY","es");
      map.set("es_VE","es");
      //1 for et
      map.set("et_EE","et");
      //1 for fa
      map.set("fa_IR","fa");
      //1 for fi
    map.set("fi_FI","fi");
    //5 for fr
    map.set("fr_BE","fr");
    map.set("fr_CA","fr");
    map.set("fr_CH","fr");
    map.set("fr_FR","fr");
    map.set("fr_LU","fr");
    //1 for iw
    map.set("he_IL","iw");
    //1for hr
    map.set("hr_HR","hr");
    //1 for hu
    map.set("hu_HU","hu");
    //2 for it
    map.set("it_CH","it");
      map.set("it_IT","it");
      //1 for ja
    map.set("ja_JP","ja");
    //1 for ko
    map.set("ko_KR","ko");
    //1 for lt
    map.set("lt_LT","lt");
    //1 for lv
    map.set("lv_LV","lv");
    //2 for nl
    map.set("nl_BE","nl");
      map.set("nl_NL","nl");
      //1 for no
      map.set("nn_NO","no");
      //1 for pl
      map.set("pl_PL","pl");
      //2 for pt
      map.set("pt_BR","pt");
      map.set("pt_PT","pt");
      //1 for ro
      map.set("ro_RO","ro");
      //3 for ru
      map.set("ru_KZ","ru");
      map.set("ru_RU","ru");
      map.set("ru_UA","ru");
      //2 for sr
      map.set("sh_ME","sr");
      map.set("sh_RS","sr");
      //1 for sk
      map.set("sk_SK","sk");
      //1 for sl
      map.set("sl_SL","sl");
      //1 for sv
      map.set("sv_SE","sv");
      //1 for th 
      map.set("th_TH","th");
      //1 for tk
      map.set("tr_CY","tk");
      map.set("tr_TR","tk");
      //1 for uk
      map.set("uk_UA","uk");
      //1 for vi
      map.set("vi_VI","vi");
      //1 for zh_TW
      map.set("zf_TW","zh_TW");
      //2 for zh_Cn
      map.set("zh_CN","zh_CN");
      map.set("zh_HK","zh_CN");

      //
      map.set("ar","ar");
      map.set("bg","bg");
      map.set("ca","ca");
      map.set("cs","cs");
      map.set("da","da");
      map.set("de","de");
      map.set("el","el");
      map.set("en","en");
      map.set("es","es");
      map.set("et","et");
      map.set("fi","fi");
      map.set("fr","fr");
      map.set("iw","iw");
      map.set("hr","hr");
      map.set("hu","hu");
      map.set("it","it");
      map.set("ja","ja");
      map.set("ko","ko");
      map.set("lt","lt");
      map.set("lv","lv");
      map.set("nl","nl");
      map.set("no","no");
      map.set("pl","pl");
      map.set("pt","pt");
      map.set("ro","ro");
      map.set("ru","ru");
      map.set("sr","sr");
      map.set("sk","sk");
      map.set("sl","sl");
      map.set("sv","sv");
      map.set("th","th");
      map.set("tk","tk");
    map.set("uk","uk");
    map.set("vi","vi");
    map.set("zh_TW","zh_TW");
    //
      return map;
       
  }
  var listeners = [];
  var languageMap = initialLanguageMap();
  
  function onLocaleChanged(cb, hasFailedCallback) {
    listeners.forEach(function(listener) {
      listener.fn.apply(listener.scope, [ currentLanguage ]);
    });
    // fail to load language will be handled by failedCallback, 
    if(cb && (hasFailedCallback === undefined || hasFailedCallback === false)) {
      cb(currentId);
    }
  }
   
  function onLangChanged(id,callback){
	  currentId=id;
	  currentLanguage=languageSetting[id];
	  onLocaleChanged(callback);
  }
  
  function get(id){
    return languageSetting[id];
  }
  //take in register queue
  function takeinDefQueue(){
	if(!window.sap||!sap.viz||!sap.viz.extapi) return;   
    var langs = sap.viz.extapi.manifest._queue.language.registerList;
	if(!langs){
	    return;
	}
	Array.prototype.forEach.call(langs,function(lang){
	  manager.register(lang);
	});
  };
  var languageSetting = {};
  

  var currentLanguage = languageSetting['dev'] = {IDS_DEFAULTMND:"All Measures",IDS_DEFAULTCHARTTITLE:"Title of Chart",IDS_ISNOVALUE:"No value",IDS_BARCHART:"Bar Chart",IDS_COMBINATIONCHART:"Combined Column Line Chart",IDS_DUALBARCHART:"Bar Chart with 2 X-Axes",IDS_DUALCOMBINATIONCHART:"Combined Column Line Chart with 2 Y-Axes",IDS_DUALHORIZONTALCOMBINATIONCHART:"Combined Bar Line Chart with 2 X-Axes",IDS_DUALHORIZONTALLINECHART:"Horizontal Line Chart with 2 X-Axes",IDS_DIUALLINECHART:"Line Chart with 2 Y-Axes",IDS_DUALPERCENTAGESTACKEDBARCHART:"100% Stacked Bar Chart with 2 X-Axes",IDS_DUALSTACKEDVERTICALBARCHART:"Stacked Column Chart with 2 Y-Axes",IDS_DUALPERCENTAGESTACKEDVERTICALBARCHART:"100% Stacked Column Chart with 2 Y-Axes",IDS_DUALSTACKEDBARCHART:"Stacked Bar Chart with 2 X-Axes",IDS_DUALVERTICALBARCHART:"Column Chart with 2 Y-Axes",IDS_HORIZONTALBOXPLOTCHART:"Horizontal Box Plot",IDS_HORIZONTALCOMBINATIONCHART:"Combined Bar Line Chart",IDS_HORIZONTALLINECHART:"Horizontal Line Chart",IDS_HORIZONTALWATERFALLCHART:"Horizontal Waterfall Chart",IDS_HORIZONTALSTACKEDWATERFALL:"Horizontal Stacked Waterfall Chart",IDS_LINECHART:"Line Chart",IDS_PERCENTAGESTACKEDBARCHART:"100% Stacked Bar Chart",IDS_PERCENTAGESTACKEDVERTICALBARCHART:"100% Stacked Column Chart",IDS_SPARKLINECHART:"Spark Line Chart (POC)",IDS_STACKEDBARCHART:"Stacked Bar Chart",IDS_STACKEDVERTICALBARCHART:"Stacked Column Chart",IDS_STACKEDWATERFALLCHART:"Stacked Waterfall Chart",IDS_VARIANTBARCHART:"Variant Bar Chart (POC)",IDS_VERTICALBARCHART:"Column Chart",IDS_VERTICALBOXPLOTCHART:"Box Plot",IDS_WATERFALLCHART:"Waterfall Chart",IDS_DONUTCHART:"Donut Chart",IDS_PIECHART:"Pie Chart",IDS_BASEBUBBLECHART:"Base Scatter Chart",IDS_BUBBLECHART:"Bubble Chart",IDS_SCATTERCHART:"Scatter Plot",IDS_BASECHART:"Base Chart",IDS_BASEHORIZONTALCHART:"Base horizontal XY Chart",IDS_BASEVERTICALCHART:"Base Vertical XY Chart",IDS_BASEMULTIPLECHART:"Base Multiple Chart",IDS_BASEMULTIPLEXYCHART:"Base Multiple XY Chart",IDS_BASESINGLECHART:"Base Single Chart",IDS_HEATMAPCHART:"Heat Map",IDS_TREEMAPCHART:"Tree Map",IDS_MULTIBARCHART:"Multiple Bar Chart",IDS_MULTIBUBBLECHART:"Multiple Bubble Chart",IDS_MULTIDONUTCHART:"Multiple Donut Chart",IDS_MULTIDUALBARCHART:"Multiple Bar Chart with 2 X-Axes",IDS_MULTIDUALHORIZONTALLINECHART:"Multiple Horizontal Line Chart with 2 X-Axes",IDS_MULTIDUALLINECHART:"Multiple Line Chart with 2 Y-Axes",IDS_MULTIDUALPERCENTAGESTACKEDBARCHART:"Multiple 100% Stacked Bar Chart with 2 X-Axes",IDS_MULTIDUALPERCENTAGESTACKEDVERTICALBARCHART:"Multiple 100% Stacked Column Chart with 2 Y-Axes",IDS_MULTIDUALSTACKEDBARCHART:"Multiple Stacked Bar Chart with 2 X-Axes",IDS_MULTIDUALSTACKEDVERTICALBARCHART:"Multiple Stacked Column Chart with 2 Y-Axes",IDS_MULTIDUALVERTICALBARCHART:"Multiple Column Chart with 2 Y-Axes",IDS_MULTIHORIZONTALLINECHART:"Multiple Horizontal Line Chart",IDS_MULTILINECHART:"Multiple Line Chart",IDS_MULTIPERCENTAGESTACKEDBARCHART:"Multiple 100% Stacked Bar Chart",IDS_MULTIPERCENTAGESTACKEDVERTICALBARCHART:"Multiple 100% Stacked Column Chart",IDS_MULTIPIECHART:"Multiple Pie Chart",IDS_MULTISCATTERCHART:"Multiple Scatter Plot",IDS_MULTISTACKEDBARCHART:"Multiple Stacked Bar Chart",IDS_MULTISTACKEDVERTICALBARCHART:"Multiple Stacked Column Chart",IDS_MULTIVERTICALBARCHART:"Multiple Column Chart",IDS_MULTIRADARCHART:"Multiple Radar Chart",IDS_RADARCHART:"Radar Chart",IDS_SCATTERMATRIXCHART:"Scatter Matrix Chart",IDS_TAGCLOUDCHART:"Tag Cloud",IDS_MEKKOCHART:"Mekko chart",IDS_HORIZONTALMEKKOCHART:"Horizontal Mekko Chart",IDS_PERCENTAGEMEKKOCHART:"100% Mekko Chart",IDS_PERCENTAGEHORIZONTALMEKKOCHART:"100% Horizontal Mekko Chart",IDS_AREACHART:"Area Chart",IDS_PERCENTAGEAREACHART:"100% Area Chart",IDS_HORIZONTALAREACHART:"Horizontal Area Chart",IDS_PERCENTAGEHORIZONTALAREACHART:"100% Horizontal Area Chart",IDS_MULTIAREACHART:"Multiple Area Chart",IDS_MULTIHORIZONTALAREACHART:"Multiple Horizontal Area Chart",IDS_MULTIPERCENTAGEAREACHART:"Multiple 100% Area Chart",IDS_MULTIPERCENTAGEHORIZONTALAREACHART:"Multiple 100% Horizontal Area Chart",IDS_3D_BAR:"3D Bar Chart",IDS_3D_COLUMN:"3D Column Chart",IDS_PIEWITHDEPTHCHART:"Pie With Depth Chart",IDS_DONUTWITHDEPTHCHART:"Donut With Depth Chart",IDS_MULTIPIEWITHDEPTHCHART:"Multiple Pie With Depth Chart", IDS_MULTIDONUTWITHDEPTHCHART:"Multiple Donut With Depth Chart", IDS_REGIONCOLOR:"Region Color",IDS_PRIMARYVALUES:"Primary Values",IDS_SECONDARYVALUES:"Secondary Values",IDS_AXISLABELS:"Axis Labels",IDS_RECTANGLETITLE:"Rectangle Title",IDS_RECTANGLEWEIGHT:"Rectangle Weight",IDS_RECTANGLECOLOR:"Rectangle Color",IDS_TAGNAME:"Tags Name",IDS_TAGWEIGHT:"Tags Weight",IDS_TAGFAMILY:"Tags Family",IDS_CATEGORYAXIS:"Axis Labels Category",IDS_REGIONSHAPE:"Region Shape",IDS_BUBBLEWIDTH:"Bubble Width",IDS_BUBBLEHEIGHT:"Bubble Height",IDS_RADARAXES:"Radar Axes",IDS_RADARAXESVALUE:"Radar Axes Values",IDS_PIESECTORCOLORNAME:"Sector Color",IDS_PIESECTORSIZE:"Sector Size",IDS_PIEDEPTHSIZE:"Depth Size",IDS_MAINLABELAXISNAME:"Main Category Axis",IDS_SECONDARYAXISLABELNAME:"Secondary Category Axis",IDS_SELECTABILITY:"selectability",IDS_PRIMARYVALUECOLORPALETTE:"primaryValuesColorPalette",IDS_SECONDARYVALUESCOLORPALETTE:"secondaryValuesColorPalette",IDS_DRAWINGEFFECT:"drawingEffect",IDS_TOOLTIPVISIBLE:"tooltipVisible",IDS_ENABLEROUNDCORNER:"enableRoundCorner",IDS_ANIMATION:"animation",IDS_DATALOADING:"dataLoading",IDS_DATAUPDATING:"dataUpdating",IDS_BAR:"bar",IDS_LINE:"line",IDS_WIDTH:"width",IDS_HOVERLINEVISIBLE:"hoverlineVisible",IDS_MARKER:"marker",IDS_VISIBLE:"visible",IDS_SHAPE:"shape",IDS_SIZE:"size",IDS_HEADERVISIBLE:"headerVisible",IDS_AXISVISIBLE:"axisVisible",IDS_GRIDVISIBLE:"gridVisible",IDS_COLUMNSEQUENCE:"columnSequence",IDS_COLUMNCONFIG:"columnConfig",IDS_STARTCOLUMN:"startColumn",IDS_LABEL:"label",IDS_VALUEFORMAT:"valueFormat",IDS_ENDCOLUMN:"endColumn",IDS_HIGHCOLUMN:"highColumn",IDS_LOWCOLUMN:"lowColumn",IDS_LINECONFIG:"lineConfig",IDS_MARKERS:"markers",IDS_FILLVISIBLE:"fillVisible",IDS_REFINEVISIBLE:"reflineVisible",IDS_MODE:"mode",IDS_TITLE:"title",IDS_TEXT:"text",IDS_GRIDLINE:"gridline",IDS_SHOWFIRSTLINE:"showFirstLine",IDS_TYPE:"type",IDS_FORMAT:"format",IDS_POSITION:"position",IDS_BORDER:"border",IDS_STARTCOLOR:"startcolor",IDS_ENDCOLOR:"endcolor"};
  var currentId = 'dev', defaultLanguage = 'en';
  var manager = 
    /** @lends sap.viz.lang.langManager */
  {    /**
       * @constructs
       */
      constructor : function(){
        return;
      },
      /**
       * The file paths of language folder. 
       * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead. You can use sap.viz.api.env.Resource.path instead.
       * @default ["../../../resources/langs/charts/", "../../../resources/langs/sdk"], by default it contains charts and sdk language resource.
       * if only contains sap.viz.skd, only reset loadPath for sdk.
       */
      loadPath : ["../../../resources/langs/charts/", "../../../resources/langs/sdk/"],
       /**
       * Return current applied language Id.
       * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead.
       * @returns {String}
       * @example <caption>Live Demo:</caption> 
       * {@link http://shg-ci-web.dhcp.pgdev.sap.corp/snippet_platform_api/#000349|Try this}. 
       */
      current : function() {
          return currentId;
      },
      
      /**
       * Register new language.
       * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead. You ca nuse sap.viz.extapi.env.Language.register instead.
       * @param {Object...}
       * 
       * @returns {Object} {@link sap.viz.lang.langManager}
       */
      register : function(obj) {
          languageSetting[obj.id] = ObjectUtils.extend(true, languageSetting[obj.id], obj.value);
          return manager;
      },
      

		/**
		 * Apply(switch) language.
                 * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead. You ca nuse sap.viz.api.env.Language.set instead.
		 * @param {String}
		 *          id the language id
		 * @param {Function}
		 *          [callback] the call back function. 
		 *
		 * @returns {Object} {@link sap.viz.lang.langManager}
         * @example <caption>Live Demo:</caption> 
         * {@link http://shg-ci-web.dhcp.pgdev.sap.corp/snippet_platform_api/#001023|Try this}. 
		 */
      apply : function(id, callback, failedCallback) {
        if(id){
          takeinDefQueue();
          id = languageMap.get(id);
          loadResources(manager.loadPath, 0, id, function(){onLangChanged(id,callback);
          }, function(){
            loadResources(manager.loadPath, 0, defaultLanguage, function(){
              currentId = defaultLanguage;
              currentLanguage = languageSetting[defaultLanguage];
              var hasFailedCallback = false;
              // callback is called for backend compatibility if there is no failedCallback, if failedCallBack is specified, callback will not run
              if(failedCallback) {
			      failedCallback(currentId, 'Loading language ' + currentId + ' failed.');
			      hasFailedCallback = true;
			  }
			  onLocaleChanged(callback, hasFailedCallback);
              FunctionUtils.error('Loading language {0} failed.', id);
            }, function(){
               currentId = 'dev', currentLanguage = languageSetting['dev'];
               var hasFailedCallback = false;
               if(failedCallback) {
			      failedCallback(currentId, 'Loading language ' + currentId + ' failed.');
			      hasFailedCallback = true;
			   }
			   onLocaleChanged(callback, hasFailedCallback);
               FunctionUtils.error('Loading language {0}, {1} failed.', id, defaultLanguage);
            });
            
          });
        }
         return manager;
      },
      
      /**
       * Get globalization value.
       * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead. You ca nuse sap.viz.api.env.Language.get instead.
       * @param {String} 
       *       id of labels
       * 
       * @returns {String}  globalization value
       */
      get: function(ids){
        if(currentLanguage[ids]){
          return currentLanguage[ids];
        }
        return languageSetting['dev'][ids];
      },
      
      
      /**
       * Get log id and globalization log message.
       * @ignore
       * 
       * @param {...Object} 
       *       key of log message
       *       variables in the log message
       * @example    
       * 		// return Invalid feeding: the correct number  is 2.   
       * 		getLogMessage('IDS_ERROR_INVALID_FEEDING_NUMBER', 2);
       *			
       * @returns {String}  log id and globalization log message.
      */
      getLogMessage: function(){
    	 if(!arguments || arguments.length<1)
    		 return undefined;
    	 var argsNum = arguments.length;
    	 if(argsNum>=1){
	    	 var ids =arguments[0];
	    	 
	    	 var message = null;
	    	 var num = null;
	    	 if(LangMessageUtil)
	    		 num = LangMessageUtil.getNumberByIDS(ids);
	        if(currentLanguage[ids]){
	        	message =  currentLanguage[ids];
	        }else{
	        	message = languageSetting['dev'][ids];
	        }
	        
	        // Substitute the resouce boundle
	        // e.g: ('Invalid feeding: the correct number  is {0}.', '2')
	        if(argsNum>1){
	        	message = ResouceBundleUtils.substitute(message, Array.prototype.slice.call(arguments, 1));	
	        }

	        if(num ===null){
	        	return message;
	        }else{
	        	return '[' + num + '] - ' +  message;
	        }
        }
      },      
      

      
      
      /**
       * Get log globalization message value by ID.
       * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead.
       * @param {Number} 
       *       message code.
       * 
       * @returns {String}  globalization log message value
       */
      getLogMessageByID: function(num){
    	  var value = null;
    	  var ids =null;
    	  if(LangMessageUtil)
    		  ids = LangMessageUtil.getIDSByNumber(num);
    	  if(ids)
    	  {
    		  if(currentLanguage[ids]){
    			  value =  currentLanguage[ids];
	          }else{
	        	  value =  languageSetting['dev'][ids];
	          }
    	  }
    	  if(value === null)
    		  FunctionUtils.error('Not exist the log ID {0}.', num);
    	  return value;
      },
      
      /**
       * Add language folder path before load language file if the language folder is not default.
       * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead. You can use sap.viz.api.env.Resource.path instead.
       * @param {String} 
       *       folder of language files.
       * 
       * @returns {Arrary}  all folders of language files.
       */
      addLanguageFolder: function(folder){
    	  manager.loadPath.push(folder);
    	  return manager.loadPath;
      },
      
      
      /**
       * Add a listener which will be executed when current language is changed.
       * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead. You ca nuse sap.viz.extapi.env.Language.addListener instead.
       * @param {Object}
       *          listener
       * @param {Function}
       *          listener.fn the listener function
       * @param {Object}
       *          listener.scope the "this" object in the listener function
       * 
       * @returns {Object} {@link sap.viz.lang.langManager}
       * @example <caption>Live Demo:</caption> 
       * {@link http://shg-ci-web.dhcp.pgdev.sap.corp/snippet_platform_api/#000349|Try this}. 
       */
      addListener : function(listener) {
          listeners.push(listener);
          return manager;
       },
       
       /**
       * Remove the listener.
       * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead. You ca nuse sap.viz.extapi.env.Language.removeListener instead.
       * @param {Object} listener
       *          the listener reference
       * 
       * @returns {Object} {@link sap.viz.lang.langManager}
       * @example <caption>Live Demo:</caption> 
       * {@link http://shg-ci-web.dhcp.pgdev.sap.corp/snippet_platform_api/#000349|Try this}. 
       */
      removeListener : function(listener) {
        var index = listeners.indexOf(listener);
        if (index !== -1){
          listeners.splice(index, 1);
        }
        return manager;
      }
  };
  takeinDefQueue();
  Locale.addListener({
    fn:function(locale, callback){
      manager.apply(locale, callback);
    },
    scope:manager
  });
  return manager;
});

define('sap/viz/data/description/MeasureValuesGroup',['sap/viz/data/description/MeasureValues','sap/viz/base/utils/FunctionUtils', 'sap/viz/lang/langManager'],
 function Setup(MeasureValues, FunctionUtils, langManager){
   
   var MeasureValuesGroup = function(data){
       this._measureValues = [];
       this.init(data);
   };
   
   MeasureValuesGroup.prototype.init = function(data){
     
       for(var i = 0; i < data.length; i++){
           this._measureValues[i] = new MeasureValues(data[i]["name"], data[i]["values"]);
           this._measureValues[i].fake(data[i]["isFake"] ? data[i]["isFake"] : false);
           this._measureValues[i].infos(data[i]["infos"] ? data[i]["infos"] : null);
       }
   };
   
   MeasureValuesGroup.prototype.getMeasureValues = function(){
       return this._measureValues;
   };
   
   MeasureValuesGroup.prototype.getType = function(){
       return "measureValuesGroup";
   };
   
   MeasureValuesGroup.prototype.validate  = function(labels){
       
      var measures, value, i, j;
      if (!arguments.length){
        var label = [1,1];
        measures = this.getMeasureValues();
        for(i = 0; i < measures.length;i++){
          value = measures[i].getValues();
          if(i === 0){
           if(value.length !== label[1]){
              FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_WRONG_VALUES_COUNT_IN_AA2',measures[i].getId(), label[1]));
           }
           
           label[0] = value[0].length;
           
          }else{
            if(value.length !== label[1]){
               FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_WRONG_VALUES_COUNT_IN_AA2', measures[i].getId(), label[1]));
            }
            
            for(j = 0; j < value.length; j++){
              if(value[j].length !== label[0] ){
                 FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_WRONG_VALUES_COUNT_IN_AA1', measures[i].getId(),label[0] ));
              }
            }  
          }
          
        }
        
        return label;
        
      }else{
        measures = this.getMeasureValues();
        for(i = 0; i < measures.length;i++){
          value = measures[i].getValues();
          if(value.length !== labels[1]){
             FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_WRONG_VALUES_COUNT_IN_AA2', measures[i].getId(), labels[1]));
          }
          
          for(j = 0; j < value.length; j++){
            if(value[j].length !== labels[0] ){
               FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_WRONG_VALUES_COUNT_IN_AA2',measures[i].getId(), labels[0] ));
            }
          }
        }
      }
     
   };
   
   MeasureValuesGroup.prototype.hasFakeData = function(){
      var measures = this.getMeasureValues();
      for(var i = 0; i < measures.length;i++){
        if(measures[i].fake()){
           return true;
        }
      }
      
      return false;
   };
   
   return MeasureValuesGroup;
 });
define('sap/viz/data/description/DimensionLabels',['sap/viz/base/utils/ObjectUtils','sap/viz/data/description/DataContainer'],
function Setup(ObjUtils, DataContainer){
   
  
     var DimensionLabels = DataContainer.extend({
      
       /**
          * @name sap.viz.data.description.DimensionLabels
          * @param   uid    identifier of dimension labels, usually name 
        */
      
       constructor : function ( uid, type, values ) {
           this._type = type;
           this._values = values;
       },
       
       getValues : function(){
           return this._values;
       },
         
       getType : function(){
           return this._type;
       }
       
    });
     
     
     return DimensionLabels;
  });
define('sap/viz/data/description/AnalysisAxis',['sap/viz/data/description/DimensionLabels','sap/viz/base/utils/FunctionUtils','sap/viz/base/utils/TypeUtils', 'sap/viz/lang/langManager'],
 function Setup(DimensionLabels, FunctionUtils, TypeUtils, langManager){
   
   var AnalysisAxis = function(data){
     this._dimensionLabels = [];
     this.init(data);
    
   };
   
   AnalysisAxis.prototype.init = function(data){
     
       for(var i = 0; i < data.length; i++){
         this._dimensionLabels[i] = new DimensionLabels(data[i]["name"], data[i]["type"]? data[i]["type"] : "Dimension",
                                                    data[i]["values"] );
         
         this._dimensionLabels[i].fake( data[i]["isFake"] ? data[i]["isFake"] : false);
         this._dimensionLabels[i].infos( data[i]["infos"] ? data[i]["infos"] : null);
       }
   };
   
   AnalysisAxis.prototype.getDimensionLabels = function(){
     return this._dimensionLabels;
   };
   
   AnalysisAxis.prototype.getType = function(){
     return "analysisAxis";
   };
   
   AnalysisAxis.prototype.validate  = function(){
      
      var labels = 1;
      var dimensions = this.getDimensionLabels();
      if (dimensions.length === 0){
        FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_DIMENSION_NOT_ZERO'));
      }
      for(var i = 0; i < dimensions.length;i++){
        if(i === 0){
           labels = dimensions[i].getValues().length;
           if(TypeUtils.isExist(dimensions[i].infos()) && labels !== dimensions[i].infos().length){
              FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_DIMENSION_WRONG_COUNT', dimensions[i].getId()));
           }
        }
        else{
         if(labels !== dimensions[i].getValues().length){
            FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_DIMENSION_WRONG_LABELS_COUNT', dimensions[i].getId()));
         }
         
         if(TypeUtils.isExist(dimensions[i].infos()) && labels !== dimensions[i].infos().length){
                FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_DIMENSION_WRONG_COUNT', dimensions[i].getId()));
         }
        }
      }
      
      return labels;
     
   };
   
   AnalysisAxis.prototype.hasFakeData = function(){
      var dimensions = this.getDimensionLabels();
      for(var i = 0; i < dimensions.length;i++){
        if(dimensions[i].fake()){
           return true;
        }
      }
      
      return false;
   };
   
   return AnalysisAxis;
 });
define('sap/viz/data/feed/feed',['sap/viz/base/utils/FunctionUtils'],
 function Setup(FunctionUtils){
   
   return function(feedId, feedName, type, min, max, aaIndex, acceptMND, mgIndex, maxStackedDims, minStackedDims){
     
         var _feedId = feedId;
         var _feedName = feedName;
         var _type = type;
         var _min = min;
         var _max = max;
         var _aaIndex = aaIndex;
         var _acceptMND = acceptMND;
         var _mgIndex = mgIndex;
         var _maxStackedDims = maxStackedDims;
         var _minStackedDims = minStackedDims;
         
         var _data = [];
     
       function feed() {
         return feed;
       }
       
       feed.feedId = function(_){  
         if (!arguments.length){
             return _feedId;
         }
        
         _feedId = _;
         
         return feed;
       };
       
       feed.feedName = function(_){
         if (!arguments.length){
             return _feedName;
         }
         
         _feedName = _; 
         
         return feed;
       };
       
       feed.type = function(_){
         if (!arguments.length){
             return _type;
         }
         
        _type = _;
        
        return feed;
       };
       
       feed.min = function(_){    
         if (!arguments.length){
            return _min;     
         }
     
         _min =  _;
         return feed;
       };
       
       feed.max = function(_){
         if (!arguments.length){
             return _max;
         }
         
         
         _max = _;
         
         return feed; 
       };
       
       feed.analysisAxisIndex = function(_){
         if (!arguments.length){
             return _aaIndex;  
         }
         
         
         _aaIndex = _;
         
         return feed;
       };
      
       feed.measureGroupIndex = function(_){
         if (!arguments.length){
             return _mgIndex;
         }
         
         _mgIndex = _;
         
         return feed;
       };
       
       feed.acceptMND = function(_){
         if (!arguments.length){
             return _acceptMND;  
         }
         
         
         _acceptMND = _;
         
         return feed;
       };
       
       feed.maxStackedDims = function(_){
         if (!arguments.length){
             return _maxStackedDims;
         }
         
         _maxStackedDims = _;
         
         return feed;
       };
       feed.minStackedDims = function(_){
         if (!arguments.length){
             return _minStackedDims;
         }
         
         _minStackedDims = _;
         
         return feed;
       };
       
       feed.data = function(_){
         if (!arguments.length){
             return _data;
         }
         
         _data = _;
         
         return feed;
       };
       
       
       feed.addData = function(_){
         _data.push(_);
         return feed;
       };
       
       feed.getMeasureNames = function(){
         
         var mgIndex  =  _mgIndex - 1;
         var measureNames = [];
         for(var i = 0; i < _data.length; i++){
             measureNames.push({'val':_data[i]['name'],'ctx': {'mg': mgIndex, 'mi': i}});
         }
         
         return measureNames;
       };
       
         feed.getMeasureValues = function(){
         var values = [];
         if(_data.length > 0){
            return _data[0].getMeasureValues();
         }
         
         return values;
           
       };
       
         feed.getMeasureCount = function(){
            return _data.length;
       };
     
       /**
        * @returns check if the feed has been feeded MND
        */
       feed.hasMNDFeeded = function(){
          
          var data = feed.data();
          for(var i = 0; i < data.length; i++){
            if(data[i].getType() === "measureNamesDimension"){
               return true;
            }
          }
          
          return false;
       };
       
       feed.hasFeeded = function(){
          return feed.data().length > 0 ?  true : false;
       };
       
       feed.getIndex = function(){
          return feed.analysisAxisIndex() ? feed.analysisAxisIndex() : feed.measureGroupIndex();
       };
       
       feed.getDataCount = function(){
         if(feed.type() === "Dimension"){
            return feed.data().length;
         }
         else{
            return feed.data().length > 0 ? feed.data()[0].getMeasureValues().length : 0; 
         }
          
       };
       
     return feed;
   };
  
 });
define('sap/viz/data/feed/feeder',
		[ 'sap/viz/data/feed/feed', 'sap/viz/base/utils/FunctionUtils',
				'sap/viz/base/utils/TypeUtils',
				'sap/viz/data/description/DimensionLabels',
				'sap/viz/lang/langManager' ],
		function Setup(Feed, FunctionUtils, TypeUtils, DimensionLabels,
				langManager) {

			return function(feedDefs, crossTableDS, feedingInfo) {

				var FEED_D = 'Dimension';
				var FEED_M = 'Measure';

				var FEEDID = "feedId";

				var BINDTO = "binding";
				var TYPE = "type";
				var INDEX = "index";

				var _aaMap = []; // analysis axis index to feed map,
									// _aamap[0] point to feed of axis 1
				var _mgMap = []; // measure group index to feed map,
									// _mgMap[0] point to feed of measure value
									// group 1
				var _feeds = [];
				var _feedsMap = {};

				var _aaBindingInfo = [];

				function feeder() {

					return feeder;
				}

				feeder.init = function() {
					initFeeds(feedDefs);

					// TODO separate validation and init
					if (crossTableDS) {
						if (feedingInfo) {
							manualFeed(crossTableDS, feedingInfo);
						} else {
							autoFeed(crossTableDS);
						}

						feeder.checkValid();
					}
				};

				/**
				 * @returns {feed}
				 */
				feeder.getFeeds = function() {
					return _feeds;
				};

				/**
				 * @param feedId
				 *            feed id
				 * 
				 * @returns {feed} undefined if no feed matched
				 * 
				 */
				feeder.findFeed = function(feedId) {
					return _feedsMap[feedId];
				};

				feeder.getAnalysisAxisIndex = function(feed) {

					for ( var i = 0; i < _aaMap.length; i++) {
						if (_aaMap[i] === feed) {
							return i;
						}
					}

				};

				feeder.getMeasureValuesGroupIndex = function(feed) {

					for ( var i = 0; i < _mgMap.length; i++) {
						if (_mgMap[i] === feed) {
							return i;
						}
					}

				};

				/**
				 * TODO: add description
				 */
				feeder.getMeasureValuesGroupFeeds = function() {

					return _mgMap;
				};

				/**
				 * Check if meta data and raw data are matched. If not match,
				 * throw exception
				 */
				feeder.checkValid = function() {
					for ( var i = 0; i < _feeds.length; i++) {
						var feed = _feeds[i];
						var dataLength;
						if (feed.type() === "Dimension") {
							dataLength = feed.getDataCount();
							if (dataLength < feed.min()
									|| (feed.max() !== Number.POSITIVE_INFINITY && dataLength > feed
											.max())) {
								FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_NOT_MEET_NUMBER_OF_FEED', feed.feedId()));
							}

						} else if (feed.type() === "Measure") {
							dataLength = feed.getDataCount();
							if (dataLength < feed.min()
									|| (feed.max() !== Number.POSITIVE_INFINITY && dataLength > feed
											.max())) {
								FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_NOT_MEET_NUMBER_OF_FEED', feed.feedId()));
							}

						} else {
							FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_WRONG_FEED_TYPE', feed.feedId()));
						}

					}

				};

				feeder.getBindingInfo = function() {

					return _aaBindingInfo;
				};

				/**
				 * TODO: add desc
				 */
				function initFeeds(feedDefinitions) {
					if (TypeUtils.isArray(feedDefinitions)) {

						var dimensonNumber = 0;

						for ( var i = 0; i < feedDefinitions.length; i++) {

							var feedType = feedDefinitions[i]['type'];
							var aaIndex = feedDefinitions[i]['aaIndex'];
							var feedId = feedDefinitions[i]['id'];

							if (feedType !== FEED_D && feedType !== FEED_M) {
								FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_WRONG_FEED_TYPE_IN_DEFINTION', feedDefinitions[i]['id']));
							}

							if (feedDefinitions[i]['type'] === FEED_D) {
								if (feedDefinitions[i]['aaIndex'] <= 0) {
									FunctionUtils .error(langManager .getLogMessage('IDS_ERROR_WRONG_AXIS_INDEX', feedDefinitions[i]['id'] ));
								}

								dimensonNumber++;
							}

							if (feedDefinitions[i]['type'] === FEED_M) {
								if (feedDefinitions[i]['mgIndex'] <= 0) {
									FunctionUtils .error(langManager .getLogMessage('IDS_ERROR_WRONG_MEASURE_AXIS_INDEX',  feedDefinitions[i]['id']));
								}

							}

							var arrayLength = _feeds.push(Feed(feedId,
									feedDefinitions[i]['name'], feedType,
									feedDefinitions[i]['min'],
									feedDefinitions[i]['max'], aaIndex,
									feedDefinitions[i]['acceptMND'],
									feedDefinitions[i]['mgIndex'],
									feedDefinitions[i]['maxStackedDims'],
									feedDefinitions[i]['minStackedDims']));

							_feedsMap[feedId] = _feeds[arrayLength - 1];

						}

						for (i = 0; i < dimensonNumber; i++) {
							_aaBindingInfo[i] = false;
						}
					}

				}

				function autoFeed(crosstableDS) {
					var axes = crosstableDS.getAnalysisAxisCount();
					var feed;
					for ( var i = 0; i < axes; i++) {
						feed = searchFeed(_feeds, FEED_D, i + 1);
						if (feed) {
							var axis = crosstableDS.getAnalysisAxisByIdx(i);
							if (TypeUtils.isExist(feed.maxStackedDims())
									&& axis.getDimensionLabels().length > feed
											.maxStackedDims()) {
								FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_INVALID_FEEDING', feed.feedId()));
							}
							if (TypeUtils.isExist(feed.minStackedDims())
									&& axis.getDimensionLabels().length < feed
											.minStackedDims()) {
								FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_INVALID_FEEDING', feed.feedId()));
							}

							_aaMap[i] = feed;
							_aaBindingInfo[i] = true;
							feed.addData(axis);
						}
					}

					var mvgs = crosstableDS.getMeasureValuesGroupCount();
					for (i = 0; i < mvgs; i++) {
						feed = searchFeed(_feeds, FEED_M, i + 1);
						if (feed) {
							_mgMap[i] = feed;
							feed.addData(crosstableDS
									.getMeasureValuesGroupByIdx(i));
						}

					}
				}

				function searchFeed(feeds, type, index) {
					for ( var i = 0; i < feeds.length; i++) {
						if (feeds[i].type() === type
								&& feeds[i].getIndex() === index) {
							return feeds[i];
						}
					}

					return null;
				}

				function manualFeed(crosstableDS, feedList) {
					var dataLength;
					for ( var i = 0; i < feedList.length; i++) {
						var feeding = feedList[i];
						var feedId = feeding[FEEDID];
						if (!feedId) {
							FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_NO_FEED_ID'));
						}

						var feed = _feedsMap[feedId];
						if (!feed) {
							FunctionUtils.error(langManager .getLogMessage('IDS_ERROR_INVALID_FEEDING_NUMBER',feedId));
						}

						var bindings = feeding[BINDTO];
						for ( var j = 0; j < bindings.length; j++) {
							var type = bindings[j][TYPE];
							var index = bindings[j][INDEX];

							if (type === "analysisAxis") {
								var aa = crosstableDS
										.getAnalysisAxisByIdx(index - 1);
								if (!aa) {
									FunctionUtils.error(langManager .getLogMessage('IDS_ERROR_NO_AXIS', index, feedId));
								}

								if (TypeUtils.isExist(feed.maxStackedDims())
										&& aa.getDimensionLabels().length > feed
												.maxStackedDims()) {
									FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_INVALID_FEEDING', feedId));
								}
								if (TypeUtils.isExist(feed.minStackedDims())
										&& aa.getDimensionLabels().length < feed
												.minStackedDims()) {
									FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_INVALID_FEEDING', feedId));
								}

								dataLength = feed.getDataCount();
								if (feed.max() !== Number.POSITIVE_INFINITY
										&& dataLength >= feed.max()) {
									FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_FEED_NOT_ACCEPT_DATA', feedId));
								}

								feed.addData(aa);
								_aaMap[index - 1] = feed;
								_aaBindingInfo[feed.getIndex() - 1] = true;

							} else if (type === "measureValuesGroup") {

								var mvg = crosstableDS
										.getMeasureValuesGroupByIdx(index - 1);
								if (!mvg) {
									FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_NOT_FIND_MEASURE_GROUP', index, feedId));
								}

								dataLength = feed.getDataCount();
								if (feed.max() !== Number.POSITIVE_INFINITY
										&& dataLength >= feed.max()) {
									FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_FEED_NOT_ACCEPT_DATA', feedId));
								}

								feed.addData(mvg);
								_mgMap[feed.getIndex() - 1] = feed;

							} else if (type === "measureNamesDimension") {
								if (feed.acceptMND() < 0) {
									FunctionUtils
											.error(langManager
													.getLogMessage('IDS_ERROR_NOT_ACCEPT')
													+ " MeasureNamesDimension "
													+ feedId
													+ " "
													+ langManager
															.get('IDS_FEED'));
								}

								dataLength = feed.getDataCount();
								if (feed.max() !== Number.POSITIVE_INFINITY
										&& dataLength >= feed.max()) {
									FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_FEED_NOT_ACCEPT_DATA', feedId));
								}

								feed.addData(new DimensionLabels("",
										"measureNamesDimension", ""));

							} else {
								FunctionUtils
										.error(langManager
												.getLogMessage('IDS_ERROR_INVALID_BINDING'));
							}
						}

					}

				}

				feeder.init();

				return feeder;
			};

		});
define('sap/viz/data/info/Handler',['sap/viz/base/utils/ObjectUtils','sap/viz/base/utils/TypeUtils'],
function Setup(ObjectUtils, TypeUtils) {
  var ANALYSISAXIS = "analysisAxis";
  var MEASUREVALUESGROUP = "measureValuesGroup";
  var handler = {};
  var _handlers = {};
  /*
   {
   'analysisAxis': [{
   'index': 1,
   'data': [{
   'name': 'Product',
   'values': ['Car', 'Truck', 'Motorcycle', 'Bicycle']
   }]
   }, {
   'index' : 2,
   'data': [{
   'name': 'Country',
   'values': ['China', 'USA']
   }, {
   'name': 'Year',
   'values': ['2001', '2001']
   }]
   }],
   'measureValuesGroup': [{
   'index': 1,
   'data': [{
   'name': 'Profit',
   'values': [[25, 136, 23, 116], [58, 128, 43, 73]]
   }, {
   'name': 'Revenue',
   'values': [[50, 236, 43, 126], [158, 228, 143, 183]]
   }]
   }]};
   * */
  
  function findInJson(jsondata, targetname){
    var anax = jsondata[ANALYSISAXIS].concat(jsondata[MEASUREVALUESGROUP]);
    var ret = [];
    anax.forEach(function(ana, idx){
      var anad = ana.data;
      anad.forEach(function(d, didx){
        if(d.name === targetname){
          ret.push(d);
        }
      }, this);
    }, this);
    return ret;
  }
  var valueinfo = {
    'type' : 'valueinfo',
    /**
     *This function is only used by ZEN-waterfall chart which does not meet other regular charts' valueinfo requirements. More details about this, please ask Fei Christy.
     * example: 
          var ds = new CrosstableDataset();
          ds.data({
            'analysisAxis' : [ {
              'index' : 1,
              'data' : [ {
                'type' : 'Dimension',
                'name' : 'Country',
                'values' : [ 'C1', 'C2', 'C1-C2 total', 'C3', 'Total' ]
              } ]
            }, {
              'index' : 2,
              'data' : [ {
                'type' : 'Dimension',
                'name' : 'Region',
                'values' : [ 'Asia', 'Europe' ]
              } ]
            } ],
            'measureValuesGroup' : [ {
              'index' : 1,
              'data' : [ {
                'type' : 'Measure',
                'name' : 'Profit',
                'values' : [ [ 10, 10, 20, -40, -20], [ 22, -20, 2, 50, 52] ]
              } ]
            } ]
          });
          ds.info({
              'type' : 'valueinfo',
              'value' : [undefined,undefined,{'isTotal' : true}, undefined, {'isTotal' : true}] 
            });
     * result:
          the value of 'ds._crosstableDataset._dataSet.measureValuesGroup[0].data[0].infos' is: 
          [[{'valueinfo': undefined}, {'valueinfo': undefined}, {'valueinfo': {'isTotal' : true}}, {'valueinfo': undefined}, {'valueinfo': {'isTotal' : true}}
            ],[
            {'valueinfo': undefined}, {'valueinfo': undefined}, {'valueinfo': {'isTotal' : true}}, {'valueinfo': undefined}, {'valueinfo': {'isTotal' : true}}
            ]
          ]
     */
    'process' : function(value, jsondata){
      var i, iLen, j, jLen, k, kLen, m, mLen;
      var iterate, mgValue, mg, dValues, measureGroups = jsondata[MEASUREVALUESGROUP];
      for (i = 0, iLen = value.length; i < iLen; i++) {
        iterate = value[i];
        if (iterate !== undefined) {
          for (j = 0, jLen = measureGroups.length; j < jLen; j++) {
            mg = measureGroups[j];
            mgValue = mg.data;
            for (k = 0, kLen = mgValue.length; k < kLen; k++) {
              dValues = mgValue[k];
              if (!dValues.infos) {
                dValues.infos = [];
              }
              for (m = 0, mLen = dValues.values.length; m < mLen; m++) {
                if (!dValues.infos[m]) {
                  dValues.infos[m] = [];
                }
                if (!dValues.infos[m][i]) {
                  dValues.infos[m][i] = {};
                }
                dValues.infos[m][i][valueinfo.type] = iterate;
              }
            }
          }
        }
      }
//      var iterate, dname, finds, d, dvalue;
//      var i, iLen, j, jLen, k, kLen, m, mLen;
//      for(i = 0, iLen = value.length; i < iLen; i++) {
//        iterate = value[i];
//        dname = iterate.name;
//        finds = findInJson(jsondata, dname);
//        for(j = 0, jLen = finds.length; j < jLen; j++){
//          d = finds[j];
//          if (iterate.value) {
//            if (!d.infos) {
//              d.infos = [];
//            }
//            for(k = 0, kLen = d.values.length; k < kLen; k++){
//              d.infos[k] = [];
//              dvalue = d.values[k];
//              for(m = 0, mLen = dvalue.length; m < mLen; m++){
//                if(d.infos[k][m] === undefined){
//                  d.infos[k][m] = {};
//                }
//                d.infos[k][m][valueinfo.type] = iterate.value[k][m];
//              }
//            }
//          }
//        }
//      }
    },
    'merge' : function(jsondata){

    }, 

    'remove' : function(jsondata) {
      measureInfoRemove(valueinfo.type, jsondata);
    }
  };  

  /**
   * [26-Feb-2013 Nick]
   * Default selection is bind with data model, it has the similar mechanism as custom label has.
   */
  
    var defaultSelection = {
    'type' : 'defaultSelection',
    'process' : function(info, data) {
      var iterate;
      var aa1, aa2, len;
      var hasAA2 = (data[ANALYSISAXIS] &&  data[ANALYSISAXIS][1]) ? true : false;
      var aa1Length = data[ANALYSISAXIS] ? data[ANALYSISAXIS][0].data[0].values.length : data[MEASUREVALUESGROUP][0].data[0].values[0].length, 
          aa2Length = hasAA2 ? data[ANALYSISAXIS][1].data[0].values.length : 1;
      var i, m, n;
      var defaultSelectionInfo, temp;

      for (i = 0, len = info.length; i < len; i++) {
        aa1 = new Array(aa1Length), aa2 = new Array(aa2Length);
        defaultSelectionInfo = [];
        iterate = info[i];
        AAContextConstructor(data, iterate, aa1, aa2);
        // if analysis axis 2 does not exit, we think it is selected by default.
        if (!hasAA2) {
          aa2[0] = true;
        }
        // Construct a two-dimensional array, which is aa2.length * aa1.length. Each member is a object like:
        //    'defaultSelection' : {
        //        isSelected : false,
        //        index : i
        //      }
        // According to aa1 and aa2 arrays, the 'isSelected' of corresponding object is changed from false to true.
        for (m = 0; m < aa2.length; m++) {
          temp = [];
          for (n = 0; n < aa1.length; n++) {
            var ctxObj = {
              'defaultSelection' : {
                isSelected : false,
                index : i
              }
            };
            if (aa2[m] && aa1[n]) {
              ctxObj.defaultSelection.isSelected = true;
            }
            temp.push(ctxObj);
          }
          defaultSelectionInfo.push(temp);
        }
        // Attach the default selection object to each data object.
        MGContextConstructor(data, iterate, defaultSelectionInfo);
      }

    },
  
  'remove' : function(jsondata) {
    measureInfoRemove(defaultSelection.type, jsondata);
  },
    'merge' : function(jsondata){}
  };
  
  function measureInfoRemove(infoName, jsondata) {
    var iterate, d, dvalue, value = jsondata[MEASUREVALUESGROUP];
    if (!value || !TypeUtils.isArray(value)) {
        return;
      }
    var i, iLen, j, jLen, k, kLen, m, mLen;
    var stillHasInfo = false;
    for (i = 0, iLen = value.length; i < iLen; i++) {
      iterate = value[i].data;
      for (j = 0, jLen = iterate.length; j < jLen; j++) {
        d = iterate[j];
        if (d.infos) {
          stillHasInfo = false;
          for (k = 0, kLen = d.infos.length; k < kLen; k++) {
            dvalue = d.infos[k];
            for (m = 0, mLen = dvalue.length; m < mLen; m++) {
              if (dvalue[m]) {
                delete dvalue[m][infoName];
                if (TypeUtils.isEmptyObject(dvalue[m])) {
                  dvalue[m] = undefined;
                } else {
                  stillHasInfo = true;
                }
              }
            }
          }
        }
        if (!stillHasInfo) {
          delete d.infos;
        }
      }
    }
  }
  
  /**
   * [26-Feb-2013 Nick] 
   * This function is to process which elements are selected in analysis axises 1 and 2.
   * aa1 is the array that records which elements are selected in analysis axis 1.
   * aa2 is the array that records which elements are selected in analysis axis 2.
   */
  function AAContextConstructor(jsondata, target, aa1, aa2){
    var analysisAxis = jsondata[ANALYSISAXIS];
    if(!analysisAxis){
      for(var index = 0; index < aa1.length; index++){
        aa1[index] = true;
      }
      return;
    }
    analysisAxis.forEach(function(ana, idx){
		var anad = ana.data;
		
		anad.forEach(function(d, didx){
			var value = target[d.name];
			for(var i=0; i<d.values.length; i++){
				var isMatch = (value === '*' || (value !== null && d.values[i] === value ));
				if( isMatch ){
					if(didx === 0){
						if(ana.index === 1){
							aa1[i] = true;
						}else{
							aa2[i] = true;
						}
					}else{
						if(ana.index === 1){
							if(aa1[i] !== true){
								aa1[i] = undefined;
							}
						}else{
							if(aa2[i] !== true){
								aa2[i] = undefined;
							}
						}
					}
				}else{
					if(ana.index === 1){
						aa1[i] = undefined;
					}else{
						aa2[i] = undefined;
					}
				}
				}
			}, this);
		}, this);
  }
  
  /**
   * [26-Feb-2013 Nick] 
   * This function is to process which elements are selected in measures.
   */
  function MGContextConstructor(jsondata, target, defaultSelectionInfo) {
    var measureGroup = jsondata[MEASUREVALUESGROUP];
    var unSelectionInfo = [], temp, m, n;
    for (m = 0; m < defaultSelectionInfo.length; m++) {
      temp = [];
      for (n = 0; n < defaultSelectionInfo[m].length; n++) {
        var ctxObj = {
          'defaultSelection' : {
            isSelected : false
          }
        };
        temp.push(ctxObj);
      }
      unSelectionInfo.push(temp);
    }
    measureGroup.forEach(function(ana, idx) {
      var anad = ana.data;
      var i, j, selectedTarget;
      anad.forEach(function(d, didx) {
        if (d.name === target['Measure']) {
          selectedTarget = defaultSelectionInfo;
        } else {
          selectedTarget = unSelectionInfo;
        }
        if (!d.infos) {
          d.infos = selectedTarget;
        } else {
          for (i = 0; i < selectedTarget.length; i++) {
            var aa1 = selectedTarget[i];
            var daa1 = d.infos[i];
            for (j = 0; j < aa1.length; j++) {
              var alreadySelected = daa1[j]['defaultSelection'].isSelected;
              if (!alreadySelected) {
                daa1[j]['defaultSelection'] = aa1[j]['defaultSelection'];
              }
            }
          }
        }
      }, this);
    }, this);
  }
  
  var customlabel = {
    'type' : 'customlabel',
    /*'value': [{
     'name': 'Country', //dimension name
     'mapping': {'CHN', {'type': 'url', 'val': 'http://xxxx/xxxx.png'},
     'GER', {'type': 'string', 'val': 'Germany'},
     'FRA', {'type': 'string', 'val': 'France'}} //support both string and url
     }] //you can have several mappings, it will be merged inside crosstable dataset. no info will be created (existed will be deleted) if the mapping value is same as the original value.*/
    'process' : function(value, jsondata) {
      var iterate, dname, finds, mapping, m, dvalues, mappingfound, removeinfo;
      for(var i = 0, len = value.length; i < len; i++) {
        iterate = value[i];
        dname = iterate.name;
        finds = findInJson(jsondata, dname);
        finds.forEach(function(d, tdidx) {
          //if no infos exist, create one, delete it if no info found
          mappingfound = false;
          if(!d.infos){
            removeinfo = true;
            d.infos = [];
          }
          
          dvalues = d.values;          
          mapping = iterate.mapping;
          dvalues.forEach(function(v, idx) {
            if(mapping[v]){
              if(mapping[v].type === 'string' && mapping[v].val === v){
                //we won't create mapping for it. existing mapping should be deleted
                if(d.infos[idx]){
                  delete d.infos[idx][customlabel.type];
                  //if it becomes empty, set it to undefined
                  if(TypeUtils.isEmptyObject(d.infos[idx])){
                    d.infos[idx] = undefined;
                  }
                }else{
                  //https://tipjira.pgdev.sap.corp/browse/BITVIZA-1181
                  //if current value happens to be the last value, we won't create anything for it
                  //then d.infos will be shorter than d.values which is not allowed
                  //so here we should create something for it.
                  d.infos[idx] = undefined; 
                } 
              }else{
                mappingfound = true;
                d.infos[idx] = d.infos[idx] ? d.infos[idx] : {};
                d.infos[idx][customlabel.type] = mapping[v];  
              }
            }else{
              if(!d.infos[idx]){
                d.infos[idx] = undefined;
              }
            }  
          }, this);

          if(removeinfo && !mappingfound){
            delete d.infos;
          }
        }, this);
      }
    },
    
    'merge' : function(jsondata){
      var ret = {};
      ret.type = customlabel.type;
      ret.value = [];
      var anax = jsondata[ANALYSISAXIS];
      if (!anax || !TypeUtils.isArray(anax)) {
        return;
      }
      var found;
      anax.forEach(function(ana, idx){
        var anad = ana.data;
        anad.forEach(function(d, didx){
          if(d.infos){
            var dmapping = {};
            dmapping.name = d.name;
            dmapping.mapping = {};
            found = false;
            d.infos.forEach(function(dinfo, dinfoidx){
              if(dinfo && dinfo[customlabel.type]){
                found = true;
                dmapping.mapping[d.values[dinfoidx]] = dinfo[customlabel.type];
              }
            }, this);
            if(found){
              ret.value.push(dmapping);
            }
          }
        }, this);
      }, this);
      if(ret.value.length > 0){
        return ret;
      }  
    },
    
    'remove' : function(jsondata){
      var anax = jsondata[ANALYSISAXIS];
      var stillHasInfo = false;
      anax.forEach(function(ana, idx){
        var anad = ana.data;
        anad.forEach(function(d, didx){
          if(d.infos){
            stillHasInfo = false;
            d.infos.forEach(function(dinfo, dinfoidx){
              if(dinfo){
                delete dinfo[customlabel.type];
                if(TypeUtils.isEmptyObject(dinfo)){
                  d.infos[dinfoidx] = undefined;
                }else{
                  stillHasInfo = true;
                }
              }
            }, this);
            if(!stillHasInfo){
              delete d.infos;
            }
          }
        }, this);
      }, this);
    }
  };

  handler.register = function(hndl) {
    _handlers[hndl.type] = hndl;
  };

  handler.get = function(type) {
    return _handlers[type];
  };
  
  /*
   * call each handler to extract corresponding info to an object and return
   */
  handler.mergeInfo = function(jsondata){
    var iter, ret = [], mr;
    for(var type in _handlers){
      if(_handlers.hasOwnProperty(type)){
        iter = _handlers[type];
        mr = iter.merge(jsondata);
        if(mr){
          //return a copy, intend to use ObjectUtils as we want to deep copy the array
          ret.push(ObjectUtils.extend(true, {}, mr));
        }
      }
    }
    return ret;
  };
  
  handler.register(customlabel);
  handler.register(defaultSelection);
  handler.register(valueinfo);
  
  return handler;

});
define('sap/viz/data/info/CrosstableHandler',['sap/viz/base/utils/TypeUtils', 'sap/viz/base/utils/ObjectUtils'],
function Setup (TypeUtils, ObjectUtils) {
	var ANALYSISAXIS = "analysisAxis";
	var MEASUREVALUESGROUP = "measureValuesGroup";
	var handler = {};
	var internalHandlers = {}; // for internal use and don't support info.get function
	var externalHandlers = {}; // for external use and support info.get function
	
	handler.register = function(hndl, isExternal) {
		if (isExternal) {
			externalHandlers[hndl.type] = hndl;
		} else {
			internalHandlers[hndl.type] = hndl;
		}
	};
	
	handler.get = function(type) {
		if (externalHandlers[type]) {
			return externalHandlers[type];
		} else {
			return internalHandlers[type];
		}
	};
	
	handler.getExternal = function(type) {
		if (externalHandlers[type]) {
			return externalHandlers[type];
		}
	};
	
	handler.mergeInfo = function(jsondata){
		var ret = [];
		for(var type in externalHandlers){
			if(externalHandlers.hasOwnProperty(type)){
				var hndl = externalHandlers[type];
				var mr = {};
				mr.type = hndl.type;
				mr.info = hndl.info;
				if(mr.info !== "undefined"){
				//return a copy, intend to use ObjectUtils as we want to deep copy the array
					ret.push(ObjectUtils.clone(mr));
				}
			}
		}
		return ret;
	};
	
	handler.initInfo = function () {
		for(var type in externalHandlers){
			var hndl = externalHandlers[type];
			hndl.info = "undefined";
		}
	}
	var additionalData = {
		'type': "additionalData",
		'info': "undefined",
		/*
		info : [{
			name : "<dimension_name>",
			// Match dimension member's 1D Array structure
			infoValues : [{
				featureId : "<featureId1>",
				isTotal : true
			}, {
				featureId : "<featureId2>",
				isTotal : false
			}]
		}, {
			name : "<rangeure_name>",
			// Match rangeure value's 2D Array structure
			infoValues : [[{
				adata1 : "<adata1>",
				adata2 : true
			}, {
				adata1 : "<adata2>",
				adata2 : false
			}], [{
				adata1 : "<adata3>",
				adata2 : true
			}, {
				adata1 : "<adata4>",
				adata2 : false
			}]]
		}]
		*/
		'process': function (info, jsondata, dimensions, measures) {
			if (!info.hasOwnProperty('info')) {
				return;
			}
			var _info = ObjectUtils.clone(info.info);
			additionalData.info = ObjectUtils.clone(info.info);
			if (_info === undefined || (TypeUtils.isArray(_info) && _info.length === 0)) {
				removeInfo(additionalData.type, jsondata, dimensions, measures);
				return;
			} else if (!TypeUtils.isArray(_info)) {
				return;
			}
			removeInfo(additionalData.type, jsondata, dimensions, measures);
			var found = false;
			for (var i = 0; i < _info.length; i++) {
				found = false;
				for (var j = 0; j < dimensions.length; j++) {
					if (dimensions[j].name === _info[i].name) {
						var index = dimensions[j].index;
						var loc = dimensions[j].location;
						if (!_info[i].hasOwnProperty('infoValues')) {
							break;
						} else if (_info[i].infoValues === undefined) {
							_info[i].infoValues = [];
						} else if (!TypeUtils.isArray(_info[i].infoValues)) {
							break;
						}
						setDimensionInfoValues(jsondata[ANALYSISAXIS][index].data[loc], _info[i].infoValues, additionalData.type);
						found = true;
						break;
					}
				}
				if (found) {
					continue;
				}
				for (var j = 0; j < measures.length; j++) {
					if (measures[j].name === _info[i].name) {
						var index = measures[j].index;
						var loc = measures[j].location;
						if (!_info[i].hasOwnProperty('infoValues')) {
							break;
						} else if (_info[i].infoValues === undefined) {
							_info[i].infoValues = [];
						} else if (!TypeUtils.isArray(_info[i].infoValues)) {
							break;
						}
						setMeasureInfoValues(jsondata[MEASUREVALUESGROUP][index].data[loc], _info[i].infoValues, additionalData.type);
						break;
					}
				}
			}
		}
	};
	
	var customlabel = {
		'type': "customlabel",
		/*
		info : [{
			name : "<dimension_name>",
			// INTERNAL usage for customlabel only
			infoMappings : {
				"CHN" : {
					type : "String",
					val : "China"
				},
				"US" : {
					type : "url",
					val : "http://aa.bb.cc"
				}
			} 
		}]
		*/
		'process': function (info, jsondata) {
			var _info = info.info;
			if (_info === undefined || !TypeUtils.isArray(_info)) {
				return;
			}
			if (jsondata[ANALYSISAXIS] === undefined) {
				return;
			}
			var iterate, dname, finds, mapping, m, dvalues, mappingfound, removeinfo;
			for(var i = 0, len = _info.length; i < len; i++) {
				iterate = _info[i];
				dname = iterate.name;
				finds = findInJson(jsondata, dname);
				finds.forEach(function(d, tdidx) {
					//if no infos exist, create one, delete it if no info found
					mappingfound = false;
					if(!d.infos){
						removeinfo = true;
						d.infos = [];
					}
					
					dvalues = d.values;          
					mapping = iterate.infoMappings;
					dvalues.forEach(function(v, idx) {
						if(mapping[v]){
							if(mapping[v].type === 'string' && mapping[v].val === v){
								//we won't create mapping for it. existing mapping should be deleted
								if(d.infos[idx]){
									delete d.infos[idx][customlabel.type];
								//if it becomes empty, set it to undefined
									if(TypeUtils.isEmptyObject(d.infos[idx])){
										d.infos[idx] = undefined;
									}
								}else{
									//https://tipjira.pgdev.sap.corp/browse/BITVIZA-1181
									//if current value happens to be the last value, we won't create anything for it
									//then d.infos will be shorter than d.values which is not allowed
									//so here we should create something for it.
									d.infos[idx] = undefined; 
								} 
							}else{
								mappingfound = true;
								d.infos[idx] = d.infos[idx] ? d.infos[idx] : {};
								d.infos[idx][customlabel.type] = mapping[v];  
							}
						}else{
							if(!d.infos[idx]){
								d.infos[idx] = undefined;
							}
						}
					}, this);

					if(removeinfo && !mappingfound){
						delete d.infos;
					}
				}, this);
			}
		}
	};
	function findInJson(jsondata, targetname){
		var anax = jsondata[ANALYSISAXIS];
		if (jsondata[MEASUREVALUESGROUP] !== undefined) {
			anax = jsondata[ANALYSISAXIS].concat(jsondata[MEASUREVALUESGROUP]);
		}
		var ret = [];
		anax.forEach(function(ana, idx){
			var anad = ana.data;
			anad.forEach(function(d, didx){
				if(d.name === targetname){
					ret.push(d);
				}
			}, this);
		}, this);
		return ret;
	}
	function setDimensionInfoValues (destination, infoValues, infoType) {
		// no need to new a infos for empty info values
		if (destination['infos'] === undefined && (TypeUtils.isArray(infoValues) && infoValues.length === 0)) {
			return;
		}
		if (destination['infos'] === undefined) {
			destination.infos = [];
		}
		var infos = destination.infos;
		var dataLength = destination.values.length;
		for (var i = 0; i < dataLength; i++) {
			if (infos[i] === undefined && infoValues[i] !== undefined) {
				infos[i] = {};
			}
			if (infos[i] === undefined && infoValues[i] === undefined) {
				infos[i] = undefined;
				continue;
			}
			if (infos[i] !== undefined) {
				infos[i][infoType] = infoValues[i];
				if (infos[i][infoType] === undefined) {
					delete(infos[i][infoType]);
				}
			}
			if (TypeUtils.isEmptyObject(infos[i])) {
				infos[i] = undefined;
			}
		}
	}
	function setMeasureInfoValues (destination, infoValues, infoType) {
		// no need to new a infos for empty info values
		if (destination['infos'] === undefined && (TypeUtils.isArray(infoValues) && infoValues.length === 0)) {
			return;
		}
		if (destination['infos'] === undefined) {
			destination.infos = [];
		}
		var infos = destination.infos;
		var dataLength = destination.values.length;
		var dataWidth = destination.values[0].length;
		for (var i = 0; i < dataLength; i++) {
			if (infos[i] === undefined && infoValues[i] !== undefined) {
				infos[i] = [];
			}
			if (infos[i] === undefined && (infoValues[i] === undefined || infoValues[i] === null)) {
				infos[i] = infoValues[i];
				continue;
			}
			if (infos[i] !== undefined && (infoValues[i] === undefined || infoValues[i] === null)) {
				for (var j = 0; j < dataWidth; j++) {
					if (infos[i][j] !== undefined && infos[i][j][infoType] !== undefined) {
						infos[i][j][infoType] = infoValues[i];
						if (infoValues[i] === undefined) {
							delete(infos[i][j][infoType]);
						}
					}
					if (TypeUtils.isEmptyObject(infos[i][j])) {
						infos[i][j] = undefined;
					}
				}
				continue;
			}
			for (var j = 0; j < dataWidth; j++) {
				if (infos[i][j] === undefined && infoValues[i][j] !== undefined) {
					infos[i][j] = {};
				}
				if (infos[i][j] === undefined && infoValues[i][j] === undefined) {
					infos[i][j] = undefined;
				}
				if (infos[i][j] !== undefined) {
					infos[i][j][infoType] = infoValues[i][j];
				}
				if (infos[i][j] !== undefined && infos[i][j][infoType] === undefined) {
					delete(infos[i][j][infoType]);
				}
				if (TypeUtils.isEmptyObject(infos[i][j])) {
					infos[i][j] = undefined;
				}
			}
		}
	}
	function removeInfo (infoType, jsondata, dimensions, measures) {
		for (var i = 0; i < dimensions.length; i++) {
			var index = dimensions[i].index;
			var loc = dimensions[i].location;
			setDimensionInfoValues(jsondata[ANALYSISAXIS][index].data[loc], [], additionalData.type);
		}
		for (var i = 0; i < measures.length; i++) {
			var index = measures[i].index;
			var loc = measures[i].location;
			setMeasureInfoValues(jsondata[MEASUREVALUESGROUP][index].data[loc], [], additionalData.type);
		}
	}
	handler.register(additionalData, true);
	handler.register(customlabel);
	
	return handler;
});
define('sap/viz/data/CrosstableDataset',['sap/viz/data/feed/feeder','sap/viz/base/utils/TypeUtils','sap/viz/base/utils/FunctionUtils','sap/viz/base/utils/ObjectUtils',
'sap/viz/data/description/AnalysisAxis','sap/viz/data/description/MeasureValuesGroup',
'sap/viz/data/info/Handler', 'sap/viz/data/info/CrosstableHandler', 'sap/viz/lang/langManager'],
 function Setup(Feeder, TypeUtils, FunctionUtils, ObjectUtils, AnalysisAxis, MeasureValuesGroup, Handler, CrosstableHandler){
 
   var TYPE   =    'type';
   var NAME   =    'name';
   var VALUES =    'values';
   
   var FEEDID =  'feedId';
   var MND    =  'MeasureNamesDimension';
   
   var ANALYSISAXIS = "analysisAxis";
   var MEASUREVALUESGROUP = "measureValuesGroup";
      
   function getMeasureValueDataPointCount(measureValue){
         var values = measureValue.getValues();
     
         return values.length > 0 ? values.length * values[0].length : 0;
   }
   
   /**
    * @name sap.viz.data.CrosstableDataset
    * @constructor
     */
   function crossTableDataSet(){
        this._analysisAxis = [];
        this._measureValuesGroup = [];
        this._dataSet = {};
		this._measures = [];
		this._dimensions = [];
        this._emptyDataset = false;
   }
   
   /**
    * Get/set data
    * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead. You can use sap.viz.api.data.CrosstableDataset.data  instead.
    * @name sap.viz.data.CrosstableDataset#data
    * @param data
    *        data with metaData and rawData
    * @returns {Object} {@link sap.viz.data.CrosstableDataset}
    * @example <caption>Live Demo:</caption> 
    * {@link http://shg-ci-web.dhcp.pgdev.sap.corp/snippet_platform_api/#006474|Try this}. 
    */
   crossTableDataSet.prototype.data = function(data){
     if(!arguments.length){
       return this._dataSet;
     }
     this._analysisAxis = [];
     this._measureValuesGroup = [];
	 this._measures = [];
	 this._dimensions = [];
     this._dataSet = data;
     this.init(this._dataSet);
	 this._measures = this.getMetaNames(data, MEASUREVALUESGROUP);
	 this._dimensions = this.getMetaNames(data, ANALYSISAXIS);
	 this.initInfo();
     return this;
   };
   
   //@deprecated
   crossTableDataSet.prototype.setData = function(in_data){
     this.data(in_data);
   };
   /**
    * Get all dimension/ measure names from data
	* @param data : data with metaData and rawData
	* @param range : ANALYSISAXIS/ MEASUREVALUESGROUP
	* @returns {[Object]}: array of names of all dimesions/ measures
	*			Object : {name:  "<dimension_name>"/  "<measure_name>", index: <number>, location: <number>}
	*/
	crossTableDataSet.prototype.getMetaNames = function (data, range) {
		if (data == undefined) {
			return;
		}
		var ret = [];
		var range = data[range];
		if (range === undefined || !TypeUtils.isArray(range)) {
			return ret;
		}
		for (var i = 0; i < range.length; i++) {
			var rangeData = range[i].data;
			if (rangeData === undefined || !TypeUtils.isArray(rangeData)) {
				continue;
			}
			for (var j = 0; j < rangeData.length; j++) {
				if (rangeData[j].name !== undefined) {
					var obj = {'name': rangeData[j].name, 'index': i, 'location': j};
					ret.push(obj);
				}
			}
		}
		return ret;
	}
	/**
    * Get all dimension/ measure names from data
	* @param data : data with metaData and rawData
	* @param range : ANALYSISAXIS/ MEASUREVALUESGROUP
	* @returns {[Object]}: array of names of all dimesions/ measures
	*			Object : {name:  "<dimension_name>"/  "<measure_name>", index: <number>, location: <number>}
	*/
	crossTableDataSet.prototype.initInfo = function () {
		CrosstableHandler.initInfo();
	}
   /**
    * Get/Set additional info for the crosstable dataset
    * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead.  You can use sap.viz.api.data.CrosstableDataset.info instead.
    * @name sap.viz.data.CrosstableDataset#info
    * @returns {Object} return a copy of current additional info if no param provided
   */
   crossTableDataSet.prototype.info = function(info){
	 // only call get function for new handler
     if(!arguments.length){
       return CrosstableHandler.mergeInfo(this._dataSet);
     }
     
     if(info !== undefined){
		if (info.type && info.value) { // call old info handler
			var handler = Handler.get(info.type);
			if(handler){
				handler.process(info.value, this._dataSet);
			}
		} else if (TypeUtils.isArray(info)) { // call new info handler
			var crosstableHandler;
			for (var i = 0; i < info.length; i++) {
				crosstableHandler = CrosstableHandler.get(info[i].type);
				if (crosstableHandler) {
					crosstableHandler.process(info[i], this._dataSet, this._dimensions, this._measures);
				}
			}
		} else if (TypeUtils.isString(info)) { // call new info handler get function with infotype
			var crosstableHandler = CrosstableHandler.getExternal(info);
			var reInfo = {};
			var ret = [];
			if (crosstableHandler !== undefined && crosstableHandler.info !== "undefined") {
				reInfo.type = crosstableHandler.type;
				reInfo.info = crosstableHandler.info;
				ret.push(ObjectUtils.clone(reInfo));
			}
			return ret;
		}
       //Jimmy, 12/28/2012, AnalysisAxis reads info reference from this._dataset.
       //here the reference may be deleted (in clearInfo) and recreated(here), to make sure AnalysisAxis
       //still can get the right infos, we recreate them.
       //or we can optimize it to save infos in analysisAxis and merge them when we get data and info?
      this._analysisAxis = [];
      this._measureValuesGroup = [];
      this.init(this._dataSet);
     }
     return this;
   };
   
    /**
      clear specific additional info for the crosstable dataset
      @param {String}type "customlabel"||"geo" 
    */
    crossTableDataSet.prototype.clearInfo = function(type){
      if(type){
       var handler = Handler.get(type);
       if(handler){
         handler.remove(this._dataSet);
       }
      }
      return this;  
    };
   
   crossTableDataSet.prototype.init = function(data){
      // removed check for measureValuesGroup for tree map doesn't have it
      if(!data || (!data[ANALYSISAXIS] && !data[MEASUREVALUESGROUP])){
       //FIX ME Remove when multihandler is available
       return;// FunctionUtils.error("dataset is empty or invalid");
      }
      var aaLabels = [1,1];

      
      var axes = data[ANALYSISAXIS];
      var i = 0;
      var mvgs, mvg, mv;
      if(axes){
        if(axes.length > 2){
         FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_NOT_ACCEPT_2_OR_MORE_AXES'));
        }
        
        for(;i < axes.length; i++){
          var axis = axes[i];
          var axisIndex = axis["index"];
          if(axisIndex !== 1 && axisIndex !== 2){
           FunctionUtils.error(langManger.get('IDS_ERROR_AXIS_INDEX_SHOULD_BE_1_OR_2'));
          }
          
          if(this._analysisAxis[axisIndex - 1]){
           FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_AXIS_ALREADY_EXIST', axisIndex));
          }
          
          var aa = new AnalysisAxis(axis["data"]);
          aaLabels[axisIndex - 1] = aa.validate();
          this._analysisAxis[axisIndex - 1] = aa;
          
        }
        
       //TODO handle if only meta data exist in data set when layout
       if(aaLabels[0] === 0){
          aaLabels[1] = 0;
          this._emptyDataset = true;
       }

        mvgs = data[MEASUREVALUESGROUP];
        // to handle tree chart without measurevaluegroup, but not know what chart is going to be filled, should we give a warning for the empty measurevaluegroup?
        if (!mvgs) {
            return;
        }
        for(i = 0;i < mvgs.length; i++){
          mvg = mvgs[i];
          var mvgIndex = mvg["index"];
          if(this._measureValuesGroup[mvgIndex - 1]){
            FunctionUtils.error("MeausreValuesGroup " + mvgIndex + " " + langManager.get('IDS_ALREADY_EXISTS'));
          }
          
          mv =  new MeasureValuesGroup(mvg["data"]);
          mv.validate(aaLabels);
          this._measureValuesGroup[mvgIndex - 1] = mv;
        }
      }else{ // no axes case
        
        mvgs = data[MEASUREVALUESGROUP];
        for(i = 0;i < mvgs.length; i++){
          mvg = mvgs[i];
          mv =  new MeasureValuesGroup(mvg["data"]);
          if(i === 0){
            aaLabels = mv.validate();
          }  
          else{
            mv.validate(aaLabels);
          }
          
          this._measureValuesGroup[mvg["index"] - 1] = mv;
        }
      }
      
      
   };
   
   /**
    * @name sap.viz.data.CrosstableDataset#getAnalysisAxisCount
    * @ignore 
    */
   crossTableDataSet.prototype.getAnalysisAxisCount = function(){
      return this._analysisAxis.length;    
   };
   
   /**
    * @name sap.viz.data.CrosstableDataset#getAnalysisAxisByIdx
    * @ignore
    * @param index 
    */
   crossTableDataSet.prototype.getAnalysisAxisByIdx = function(index){
     return this._analysisAxis[index];
   };
   
   /**
    * @name sap.viz.data.CrosstableDataset#getMeasureValuesGroupCount
    * @ignore 
    */
   crossTableDataSet.prototype.getMeasureValuesGroupCount = function(){
      return this._measureValuesGroup.length;    
   };
   
   /**
    * @name sap.viz.data.CrosstableDataset#getMeasureValuesGroupByIdx
    * @ignore
    * @param index 
    */
   crossTableDataSet.prototype.getMeasureValuesGroupByIdx = function(index){
     return this._measureValuesGroup[index];
   };
   
   /**
      * @name sap.viz.data.CrosstableDataset#hasFakeData
      * @ignore
      */
   crossTableDataSet.prototype.hasFakeData = function(){
     for(var i = 0; i < this._measureValuesGroup.length; i++){
       if(this._measureValuesGroup[i].hasFakeData()){
        return true;
       }
     }
     
     for(i = 0; i < this._analysisAxis.length; i++){
       if(this._analysisAxis[i].hasFakeData()){
        return true;
       }
     }
     
     return false;
   };
   
   /**
      * @name sap.viz.data.CrosstableDataset#getDataPointCount
      * @ignore
      */
   crossTableDataSet.prototype.getDataPointCount = function(){
     
     var dpCount = 0;
     // to handle tree chart to accept dataset without measureValuesGroup
     var mvDpCount = 0;
     if (this._measureValuesGroup.length) {
        mvDpCount = getMeasureValueDataPointCount(this._measureValuesGroup[0].getMeasureValues()[0]);
     }
     
     for(var i = 0; i < this._measureValuesGroup.length; i++){
       dpCount +=  mvDpCount * this._measureValuesGroup[i].getMeasureValues().length;
     }
     
     return dpCount;
   };
   
    /**
      * @name sap.viz.data.CrosstableDataset#isEmptyDataSet
      * @ignore
    */
   crossTableDataSet.prototype.isEmptyDataset = function(){
      return this._emptyDataset;
   };
   
    return crossTableDataSet;
 });
define('sap/viz/data/info/FlatTableInfoHandler',[],function(){
	var _handler = {};
	var handler = {};
	
	var geoInfoHandler = {
		'process':function(infoSet, infoData){
			if(infoData.type != 'geo'){
				return;
			}
			if(infoSet == null){
				infoSet = {};
			}
			infoSet[infoData.type] = infoData.info;
			return infoSet;
		},
		'find':function(infoset, rowIndex, selectedColumnIndexes){
			var geoInfos = infoset['geo'];
			var geoInfo = geoInfos[rowIndex];
			var infoResult;
			if(geoInfo==null){
				return;
			}
			for(var i = 0; i < selectedColumnIndexes.length; ++i){
				var colIndex = selectedColumnIndexes[i];
				if(geoInfo[colIndex]!=null){
					if(infoResult == null){
						infoResult = [];
					}
					infoResult[colIndex] = geoInfo[colIndex];
				}
			}
			return infoResult;
		}
	};
	
	var additionalDataInfoHandler = {
		'process':function(infoSet, infoData){
			if(infoData.type != 'additionalData'){
				return;
			}
			if(infoSet == null){
				infoSet = {};
			}
			infoSet[infoData.type] = infoData.info;
			return infoSet;
		},
		'find':function(infoset, rowIndex, selectedColumnIndexes){
			var additionalDataInfos = infoset['additionalData'];
			var additionalDataInfo = additionalDataInfos[rowIndex];
			var infoResult;
			if(additionalDataInfo==null){
				return;
			}
			for(var i = 0; i < selectedColumnIndexes.length; ++i){
				var colIndex = selectedColumnIndexes[i];
				if(additionalDataInfo[colIndex]!=null){
					if(infoResult == null){
						infoResult = [];
					}
					infoResult[colIndex] = additionalDataInfo[colIndex];
				}
			}
			return infoResult;
		}
	};
	
	handler.get = function(type){
		return _handler[type];
	};
	
	handler.register = function(type, handler){
		_handler[type] = handler;
	};
	
	handler.register('geo', geoInfoHandler);
	handler.register('additionalData', additionalDataInfoHandler);
	
	return handler;
});
define('sap/viz/data/FlatTableDataset',['sap/viz/base/utils/TypeUtils','sap/viz/base/utils/ObjectUtils', 'sap/viz/data/info/FlatTableInfoHandler',
        'sap/viz/base/utils/FunctionUtils','sap/viz/lang/langManager'], function (util,ObjectUtils, FlatTableInfoHandler,FunctionUtils,langManager) {
	var colName = 'fields';
	var rowName = "data";
	var contextIdName = "_contextId";
	var measureTypeName = "measure";
	var dimesionTypeName = "dim";
	var sematicTypeName = "semanticType";
	function generateContextId(data) {
		//TODO, return in case contextId is already generated.
		var cols = data.metadata[colName];
		var rows = data[rowName];
		var initialId = 0;
		cols.push({
			id : contextIdName,
			name : contextIdName
		});
		
		var contextIdIndex = cols.length-1;

		for (var i = 0; i < rows.length; i++) {
			if(util.isArray(rows[i])){
				rows[i][contextIdIndex] = initialId++;
			}else{
				rows[i][contextIdName] = initialId++;
			}
		}
	}
	/**
	 * @constructor
	 * Constructor of flat table dataset.
	 * @param data, example:
	 * 			{
	 * 				metadata:{
	 * 					fields:[{
	 *     					id: 'Year',
	 *     	    			semanticType: 'dim'
	 *     	    		},{
	 *     	    			id: 'Profit',
	 *     	    			semanticType: 'measure'
	 *     	    		}],
	 * 					summary:{}
	 * 				},
	 * 				data:[
	 * 					[2001,100000],
	 * 					[2002,200000]
	 * 				],
	 * 				info:[	//optional
	 * 					{}
	 * 				]
	 * 			}
	 */
	var FlatTableDataset = function (dataset) {
		this._dataset = ObjectUtils.clone(dataset);
		this._data = this._dataset[rowName];
		this._table = undefined;
		this._infoset = {};
		generateContextId(this._dataset);
		if (this._dataset.info != null) {
			this.info(this._dataset.info);
		}
	};
	/**
	 * Get/set for the property data.
	 * @param value {Object}:
	 * example {
	 * 		metadata:{},
	 * 		data:[]
	 * }
	 * @returns {Object} instance of FlatTableDataset
	 */
	FlatTableDataset.prototype.data = function (value) {
		if(value!=null){
			if(value.metadata==null||value.data == null){
				FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_FLATTABLE_INVALID_DATA_PARAM'));
			}
			this._dataset = ObjectUtils.clone(value);
			this._data = this._dataset[rowName];
			this._table = null;
			generateContextId(this._dataset);
			return this;
		}
		return {metadata:ObjectUtils.clone(this._dataset.metadata), data:ObjectUtils.clone(this._dataset.data)};
	};
	/**
	 * get the data of specified column
	 * @param id {String} id of column
	 * @returns {Array}
	 */
	FlatTableDataset.prototype.getMetadata = function (id) {
		var cols = this._dataset.metadata[colName];
		var query = JSLINQ(cols).Where(function (item) {
				return item.id === id;
			}).Select(function (item) {
				return item;
			});
		return query.items;
	};
	
	/**
	 * Get the meta data of the field of the specified index
	 * @param index {Number}
	 * @returns
	 */
	FlatTableDataset.prototype.getMetadataByIndex = function(index){
		return this._dataset.metadata[colName][index];
	};
	
	FlatTableDataset.prototype._getColumnIdOfSemanticType = function (semanticType) {
		var cols = this._dataset.metadata[colName];
		var result = [];
		var length = cols.length;
		for (var i = 0; i < length; ++i) {
			var col = cols[i];
			if (col[sematicTypeName] === semanticType) {
				result.push(col.id);
			}
		}
		return result;
	};
	/**
	 * get the column id of measures
	 * @returns {Array}
	 */
	FlatTableDataset.prototype.getMeasures = function () {
		return this._getColumnIdOfSemanticType(measureTypeName);
	};
	/**
	 * get the column id of dimensions
	 * @returns {Array}
	 */
	FlatTableDataset.prototype.getDimensions = function () {
		return this._getColumnIdOfSemanticType(dimesionTypeName);
	};
	/**
	 * Transform the data into an object table
	 * @returns {Array} the data in the object table format
	 */
	FlatTableDataset.prototype.getTable = function () {
		if (this._table != null) {
			return this._table;
		}
		var cols = this._dataset.metadata[colName];
		var rows = this._data;
		var result = [];
		for (var i = 0; i < rows.length; ++i) {
			var item = {};
			for (var j = 0; j < cols.length; ++j) {
				item[cols[j].id] = rows[i][j];
			}
			result.push(item);
		}
		this._table = result;
		return this._table;
	};
	/**
	 * get the specified row item of some specified type
	 * @param rowIndex {Number} the index of the row you want to get
	 * @returns {Array|Object}
	 */
	FlatTableDataset.prototype.getRow = function (rowIndex) {
		var row = this._data[rowIndex];
		if(row==null){
			return;
		}
		return row.slice(0);
	};
	
	/**
	 * set a new row to the dataset with its specified row index.
	 * @param {Number} rowIndex 
	 * @param {Array} rowItem 
	 */
	FlatTableDataset.prototype.setRow = function (rowIndex, rowItem) {
		var numCols = this._dataset.metadata[colName].length;
		var rowData = {};
		var rawRowData = [];
		if (util.isArray(rowItem)) {
			for (var i = 0; i < numCols-1; ++i) {
				colId = this._dataset.metadata[colName][i].id;
				rowData[colId] = rowItem[i];
				rawRowData[i] = rowItem[i];
			}
			rowData[contextIdName] = this._data[rowIndex][numCols-1];
			rawRowData[numCols-1] = this._data[rowIndex][numCols-1];
		} else {
			//TODO error handle for format error
			return;
		}
		this._data[rowIndex] = rawRowData;
		if (this._table) {
			this._table[rowIndex] = rowData;
		}
	};
	FlatTableDataset.prototype._getInfoOfSelectedColumnsByRowIndex = function (selectedColumnIndexes, rowIndex) {
		var result = null;
		for (var infoType in this._infoset) {
			var info = this._infoset[infoType];
			var infoResult = null;
			if(info == null){
				continue;
			}
			var handler = FlatTableInfoHandler.get(infoType);
			if(handler!=null && util.isFunction(handler.find)){
				infoResult = handler.find(this._infoset, rowIndex, selectedColumnIndexes);
			}
			if (result == null && infoResult != null) {
				result = {};
			}
			if (result != null) {
				result[infoType] = infoResult;
			}
		}
		return result;
	};
	
	FlatTableDataset.prototype._getAllColumnIds = function(){
		var cols = this._dataset.metadata[colName];
		var result = [];
		var length = cols.length;
		for (var i = 0; i < length; ++i) {
			result.push(cols[i].id);
		}
		return result;
	};
	
	/**
	 * seleted the data of specified columns
	 * @param selectedColumns :['columnId1','columnId2']
	 * @return {Array} clone of the this._data or its subset
	 */
	FlatTableDataset.prototype.dataInFields = function (selectedColumns) {
		if (selectedColumns == null || selectedColumns.length == 0) {
			return this._data.slice(0);
		} else {
			var rowData = this._data;
			var hasInfo = this._infoset != null;
			var result = [];
			var selectedColumnIndexes = [];
			var allColumnIds = this._getAllColumnIds();
			
			for(var i = 0; i < selectedColumns.length; ++i){
				selectedColumnIndexes.push(allColumnIds.indexOf(selectedColumns[i]));
			}
			
			for (var i = 0; i < rowData.length; ++i) {
				var data = new Array(allColumnIds.length);
				var info = null;
				for (var j = 0; j < selectedColumnIndexes.length; ++j) {
					var colIndex = selectedColumnIndexes[j];
					var dataValue = rowData[i][colIndex];
					if(util.isPlainObject(dataValue)){
						data[colIndex] = ObjectUtils.extend(true, {}, dataValue);
					}else if(util.isArray(dataValue)){
						data[colIndex] = dataValue.slice(0);
					}else{
						data[colIndex] = dataValue;
					}
				}
				info = this._getInfoOfSelectedColumnsByRowIndex(selectedColumnIndexes, i);
				result.push({
					data : data,
					info : info
				});
			}
			return result;
		}
	};
	
	/**
	 * Get/set for the info.
	 * @param {String|Array of Object} value
	 */
	FlatTableDataset.prototype.info = function (value) {
		if(value == null){
			var result = [];
			if(this._infoset['additionalData']!=null){
				result.push({
					type:'additionalData',
					info:this._infoset['additionalData']
				});
			}
			return result;
		}else if(util.isString(value)){
			return [{type:value, info:this._infoset[value]}];
		}else if(util.isArray(value)){
			for(var i=0; i < value.length; ++i){
				var infoData = value[i];
				var handler = FlatTableInfoHandler.get(infoData.type);
				if(handler!=null&&util.isFunction(handler.process)){
					this._infoset = handler.process(this._infoset, infoData);
				}
			}
			return this;
		}
		
	};
	return FlatTableDataset;
});

define('sap/viz/manifest',['sap/viz/base/utils/TypeUtils','sap/viz/base/utils/FunctionUtils','sap/viz/base/utils/ObjectUtils', 'sap/viz/lang/langManager', 'sap/viz/base/Logger'],
function Setup(TypeUtils, FunctionUtils, ObjectUtils,langManager, Logger) {
  /**
   * <pre>
   * Manifest is an internal collection to store all definitions/configurations.
   * There are three built-in categories:
   *      feeds: store definitions of all feed groups
   *      module: store definitions of all modules
   *      viz: store definitions of all charts
   * </pre>
   * @module sap.viz.manifest
   * @example <caption>Sample Code:</caption>
   * var Manifest = sap.viz.manifest;
   * @ignore
   */

  var manifest = {};
  /**
   * <pre>
   * register a new category in manifest.
   * Once a category is registered, you can access it by Manifest[name] or Manifest.name
   * </pre>
   * @method sap.viz.manifest#registerCategory
   * @param {String}name name of the new category
   * @param {Function} factory optional and if provided,it will become "item factory function" of this category
   * @param {Object} factoryThisObj optional and if provided, it will become the object executed by item factory function
   * @returns {[Object] category} the new category {link sap.viz.manifest.xxxcategory} 
   * @example <caption>Sample Code:</caption>
   * manifest.registerCategory("feeds", function(obj) {
   *
   * var feeds = {};
   *  obj.feeds.forEach(function(o) {
   *    feeds[o.id] = o;
   *  });
   *
   * Object.defineProperty(obj, "feedsMap", {
   *    value : feeds,
   *    writable : false,
   *    enumerable : false,
   *    configurable : false
   *  });
   *
   *  return obj;
   * });
   * @ignore
   */
  manifest.registerCategory = function(name, factory, factoryThisObj) {
    if (!TypeUtils.isNonEmptyString(name)) {
      FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_CATEGORY_NAME_NOT_EMPTY'));
    }

    if (factory && !TypeUtils.isFunction(factory)) {
      FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_CATEGORY_FACTORY_MUST_BE_FUNCTION'));
    }

    if (manifest.hasOwnProperty(name)) {
      FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_EXIST_CATEGORY_NAME', name));
    }

    var collection = d3.map();
    /**
     * xxx represents feeds, module and viz. The three categories have been registered into manifest and could provide some common APIs. 
     * @class sap.viz.manifest.xxx
     * @ignore
     */
    var category = {
        /**
           * Load an item from category by id.</br>
           * </br>
           * If the item is a Built-in_Manifest_Objects, it will provide some other APIs.Please see the corresponding object in Built-in_Manifest_Objects.</br>
           * @see Built-in_Manifest_Objects
           * @method sap.viz.manifest.xxx#get
           * @param {String} id the id of item
           * @param {Object} throwErrorIfNull optional, a exception type
           * @returns {Object} the item loaded from category by id
           * @example <caption>Sample Code:</caption>
           * var moduleFeeds =  manifest.feeds.get(id);//xxx represents feeds
           * var barModule = manifest.module.get(barId);//xxx represents module
           * var lineChart = manifest.viz.get(lineChartId);//xxx represents viz
           * @ignore
           */
      get : function(id, throwErrorIfNull) {
        var manifest = this;
        function fetchqueue(){
            var queue = sap.viz.extapi.manifest._queue[name];
            if(!queue){
                return;
            }
            if(queue["registerList"]){
                queue["registerList"].forEach(function(item){
                    manifest.register(item);
                });
                queue["registerList"]=[];
            }
            if(queue["unregisterList"]){
                queue["unregisterList"].forEach(function(item){
                    manifest.unregister(item);
                });
                queue["unregisterList"]=[];
            }
        }
        fetchqueue();
        var result = collection.get(id);
        if (result === undefined && throwErrorIfNull) {
          FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_CAN_NOT_FIND_CATEGORY'), id, name);
        }
        
        if(result && result["__needParsed__"] === true){
          var isAbstract = result["abstract"] === true;
          result = ObjectUtils
              .extend(true, null, result.base !== undefined ? category.get(
                  result.base, true) : null, result);
  
          Object.defineProperty(result, "abstract", {
            value : isAbstract,
            enumerable : false
          });
  
          if (factory && !isAbstract) {
            factory.call(factoryThisObj, result, manifest);
          }
          
          delete result["__needParsed__"];
          collection.set(id, result);
        }
        return result;
      },
      
      getAll : function() {
		return collection.values();
      },
      
      getManifest : function() {
		if (arguments.length === 1 && TypeUtils.isString(arguments[0])) {
			return new Array(category.get(arguments[0]));
		} else if (arguments.length === 2 && TypeUtils.isString(arguments[0]) && (typeof arguments[1] === "boolean")) {
			return new Array(category.get(arguments[0], arguments[1]));
		} else if (arguments.length === 0) {
			return category.getAll();
		} else {
			Logger.warn(langManager.getLogMessage('IDS_WARN_PARAMETER_NOT_CORRECT'));
			return;
		}      	
      },
      
      /**
       * <pre>
       * Iterate whole category execute callback function for every item which has been registered into xxx. 
       * </pre>
       * @method sap.viz.manifest.xxx#each
       * @param {Function} callback a callback function will be executed for every item.This function must accept two parameters.The first one is an object and the second one is the id.
       * @param {Object} thisObj optional and default value is obj self
       * @return {Object} manifest
       * @example <caption>Sample Code:</caption>
       * manifest.xxx.each(function(obj, id){
       *   .... 
       * });
       * @ignore
       */
      each : function(callback, thisObj) {
        collection.forEach(function(id) {
          callback.call(thisObj, category.get(id), id);
        });
        return manifest;
      },
      
      /**
       * unregister the item with specified id from category
       * @method sap.viz.manifest.xxx#unregister
       * @param {String} id id of the item being unregistered
       * @return {Object} the removed module Object
       * @example <caption>Sample Code:</caption>
       * manifest.module.unregister('sap.viz.modules.bar');
       * @ignore
       */
      unregister : function (id) {
        var ret;
        if(TypeUtils.isExist(id)){
          ret = collection.get(id);
          collection.remove(id);
        }
        return ret;
      },
      
      /**
       * Register an item into category
       * @method sap.viz.manifest.xxx#register 
       * @param {Object} newItems variable parameters, at least need one item to be registered into category
       * @return {Object} manifest
       * @example <caption>Sample Code:</caption>
       * manifest.viz.register(chartOne);//xxx represents viz
       * ....
       * manifest.viz.register(chartOne,chartTwo,chartThree);
       * ....
       * manifest.module.register(tooltip);//xxx represents module
       * @ignore
       */
      register : function() {
        Array.prototype.forEach.call(arguments, function(obj) {
          if (TypeUtils.isUndefined(obj)) {
            FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_NOT_REGISTER_UNDEFINED_OBJECT'));
          }

          var idStr = obj.id;

          if (!TypeUtils.isNonEmptyString(idStr)) {
            FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_NOT_REGISTER_WITHOUT_VALID_ID'));
          }

          if (collection.has(idStr)) {
            FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_ALREADY_EXIST_IN_CATEGORY', idStr, name));
          }
          
          obj["__needParsed__"] = true;          

          collection.set(idStr, obj);
        });

        return manifest;
      }
    };

    manifest[name] = category;
    return category;
  };
  
  /**
   * unregister category with the specified category name
   * @param {String} cname name of the category to be unregistered
   * @returns {Boolean} true if successfully deleted 
   * @ignore
   */
  manifest.unregisterCategory = function (cname){
    return cname in manifest && delete manifest[cname];
  };
  
  /**
   * {@link sap.viz.manifest.feeds} is a category which have been registered into manifest. It could provide some common APIs. 
   * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead. You can use sap.viz.api.manifest.Feed instead.
   * @class sap.viz.manifest.feeds
   */
  /**
  * Load an item from {@link sap.viz.manifest.feeds}  by id.</br>
  * </br>
  * The item loaded from {@link sap.viz.manifest.feeds} will provide some API.</br>
  * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead. You can use sap.viz.api.manifest.Feed.get instead.
  * @method sap.viz.manifest.feeds#get
  * @param {String} id the id of item
  * @param {Object} throwErrorIfNull optional, a exception type
  * @returns {Object} {@link Built-in_Manifest_Objects.feedsManifest}
  * @example <caption>Sample Code:</caption>
  * var moduleFeeds =  manifest.feeds.get(id);
  */
  /**
  * 
    * Iterate whole {@link sap.viz.manifest.feeds} category execute callback function for every item which has been registered into {@link sap.viz.manifest.feeds}. 
  * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead.

  * @method sap.viz.manifest.feeds#each
  * @param {Function} callback a callback function will be executed for every item.This function must accept two parameters.The first one is an object and the second one is the id.
  * @param {Object} thisObj optional and default value is obj self
  * @return {Object} {@link sap.viz.manifest.feeds}
  * @example <caption>Sample Code:</caption>
  * 
  * manifest.feeds.each(function(obj, id){
  *   .... 
  * });
  */
  /**
   * Register an item into {@link sap.viz.manifest.feeds} category
   * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead. You can use sap.viz.extapi.manifest.Feed.register instead.
   * @method sap.viz.manifest.feeds#register 
   * @param {Object} newItems variable parameters, at least need one item to be registered into category
   * @return {Object} {@link sap.viz.manifest.feeds}
   * @example <caption>Sample Code:</caption>
   * manifest.feeds.register(chartOneFeeds);
   * manifest.feeds.register(chartTwoFeeds,chartThreeFeeds);
   */
  
  /**
   * unregister an item from {@link sap.viz.manifest.feeds} category
   * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead. You can use sap.viz.extapi.manifest.Feed.unregister instead.
   * @method sap.viz.manifest.feeds#unregister 
   * @param {String} id id of the feed being unregistered
   * @return {Object} the removed feed object {@link sap.viz.manifest.feeds}
   * @example <caption>Sample Code:</caption>
   * manifest.feeds.unregister('CHART_FEED_ID');
   */

   /**
   * {@link sap.viz.manifest.viz} is a category which have been registered into manifest. It could provide some common APIs. 
   * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead. You can use sap.viz.api.manifest.Viz instead.
   * @class sap.viz.manifest.viz
   */
  /**
  * Load an item from {@link sap.viz.manifest.viz}  by id.</br>
  * </br>
  * The item loaded from {@link sap.viz.manifest.viz} will provide some API.</br>
  * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead. You can use sap.viz.api.manifest.Viz.get instead.
  * @method sap.viz.manifest.viz#get
  * @param {String} id the id of item
  * @param {Object} throwErrorIfNull optional, a exception type
  * @returns {Object} {@link Built-in_Manifest_Objects.vizManifest}
  * @example <caption>Sample Code:</caption>
  * var lineChart =  manifest.viz.get(lineChartId);
  */
  /**
  * 
    * Iterate whole {@link sap.viz.manifest.viz} category execute callback function for every item which has been registered into {@link sap.viz.manifest.viz}. 
  * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead.
  * @method sap.viz.manifest.viz#each
  * @param {Function} callback a callback function will be executed for every item.This function must accept two parameters.The first one is an object and the second one is the id.
  * @param {Object} thisObj optional and default value is obj self
  * @return {Object} {@link sap.viz.manifest.viz}
  * @example <caption>Sample Code:</caption>
  * manifest.viz.each(function(obj, id){
  *   .... 
  * });
  */
  /**
   * Register an item into {@link sap.viz.manifest.viz} category
   * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead. You can use sap.viz.extapi.manifest.Viz.register instead.
   * @method sap.viz.manifest.viz#register 
   * @param {Object} newItems variable parameters, at least need one item to be registered into category
   * @return {Object} {@link sap.viz.manifest.viz}
   * @example <caption>Sample Code:</caption>
   * manifest.viz.register(lineChart);
   * manifest.viz.register(pieChart,radarChart);
   */
  
  /**
   * unregister an item from {@link sap.viz.manifest.viz} category
   * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead. You can use sap.viz.extapi.manifest.Viz.unregister instead.
   * @method sap.viz.manifest.viz#unregister 
   * @param {String} id id of the viz being unregistered
   * @return {Object} the removed viz object {@link sap.viz.manifest.viz}
   * @example <caption>Sample Code:</caption>
   * manifest.viz.unregister('viz/bar');
   */

   /**
   * {@link sap.viz.manifest.module} is a category which have been registered into manifest. It could provide some common APIs. 
   * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead. You can use sap.viz.api.manifest.Module instead.
   * @class sap.viz.manifest.module
   */
  /**
  * Load an item from {@link sap.viz.manifest.module}  by id.</br>
  * </br>
  * The item loaded from {@link sap.viz.manifest.module} will provide some API.</br>
  * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead. You can use sap.viz.api.manifest.Module.get instead.
  * @method sap.viz.manifest.module#get
  * @param {String} id the id of item
  * @param {Object} throwErrorIfNull optional, a exception type
  * @returns {Object} {@link Built-in_Manifest_Objects.moduleManifest}
  * @example <caption>Sample Code:</caption>
  * var lineModule =  manifest.viz.get(lineModuleId);
  */
  /**
  * 
    * Iterate whole {@link sap.viz.manifest.module} category execute callback function for every item which has been registered into {@link sap.viz.manifest.module}. 
  * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead.
  * @method sap.viz.manifest.module#each
  * @param {Function} callback a callback function will be executed for every item.This function must accept two parameters.The first one is an object and the second one is the id.
  * @param {Object} thisObj optional and default value is obj self
  * @return {Object} {@link sap.viz.manifest.module}
  * @example <caption>Sample Code:</caption>
  * manifest.module.each(function(obj, id){
  *   .... 
  * });
  */
  /**
   * Register an item into {@link sap.viz.manifest.module} category
   * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead. You can use sap.viz.extapi.manifest.Module.register instead.
   * @method sap.viz.manifest.module#register 
   * @param {Object} newItems variable parameters, at least need one item to be registered into category
   * @return {Object} {@link sap.viz.manifest.module}
   * @example <caption>Sample Code:</caption>
   * manifest.module.register(lineModule);
   * manifest.module.register(pieModule,radarModule);
   */

  /**
   * unregister an item from {@link sap.viz.manifest.module} category
   * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead. You can use sap.viz.extapi.manifest.Module.unregister instead.
   * @method sap.viz.manifest.module#unregister 
   * @param {String} id id of the module being unregistered
   * @return {Object} the removed module object {@link sap.viz.manifest.module}
   * @example <caption>Sample Code:</caption>
   * manifest.module.unregister('sap.viz.modules.bar');
   */
  return manifest;
});
define('sap/viz/TemplateManager',['sap/viz/manifest','sap/viz/base/utils/FunctionUtils','sap/viz/base/utils/TypeUtils','sap/viz/base/utils/ObjectUtils', 'sap/viz/lang/langManager'], 
function Setup(manifest, FunctionUtils, TypeUtils, ObjectUtils, langManager) {

  function loadResource( url, cb, onError, templateId ) {
    var head = document.getElementsByTagName("head")[0] || document.documentElement;
    var script = document.createElement("script");
    script.type = 'text/javascript';
    script.src = url;

    var done = false;
    script.onload = script.onreadystatechange = function() {
      if ( !done && (!this.readyState || this.readyState === "loaded" || this.readyState === "complete") ) {
        done = true;
        cleanScript(script);
        cb();
      }
    };
    if ( script.addEventListener ) {
      script.addEventListener('error', function() {
        cleanScript(script);
        if (onError) {
        	onError(templateId, 'Loading template ' + templateId + ' failed.');
        }
      }, true);
    }

    head.insertBefore(script, head.firstChild);
  }

  function load(templateId, cb, failedCallback) {
      var resourceCount = 0;
      function done(){
          resourceCount-=1;
          if(resourceCount===0){
              var template = get(templateId);
              if ( template ) {
                cb(template);
              } else {
                  evaluateTemplateModule(templateId, cb, function(){
                  	if(failedCallback) {
			      		failedCallback(templateId, 'Loading template ' + templateId + ' failed.');
			  		}
                    FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_LOADING_TEMPLATE_FAIL', templateId));
                  });
              }
          }
      }
      Array.prototype.forEach.call(manager.loadPath,function(){
          resourceCount += 1;
      });
      Array.prototype.forEach.call(manager.loadPath, function(path){
          loadResource(path+"/"+templateId+"/template.js", done, failedCallback, templateId);
      });
  }

  function cleanScript( script ) {
    script.onload = script.onreadystatechange = null;
    if(script.parentNode){
        script.parentNode.removeChild(script);
    }
  }
    var templateCategory = manifest.registerCategory("template", function(obj) {
        var css = obj.css;
        if (!TypeUtils.isString(css)) {
            var text = "";
            for (var selector in css) {
                if (css.hasOwnProperty(selector)) {
                    text += selector + "{";
                    var declaration = css[selector];
                    for (var name in declaration) {
                        if (declaration.hasOwnProperty(name)) {
                            text += name + ":" + declaration[name] + ";";
                        }
                    }
                    text += "}";
                }
            }
            obj.css = text;
        }
        Object.defineProperties(obj, {
            props : {
                value : function(vizId) {
                    var properties = obj.properties;
                    if (properties) {
                        return properties[vizId];
                    }
                }
            }
        });
        return obj;
    });

    var current;

    function get(id) {
        return templateCategory.get(id);
    }
    function takeinDefQueue(id){
        var templateConfigs = [], templates = sap.viz.extapi.manifest._queue.template.configMap, registered=!!get(id);
        if(!templates||!templates[id]){
            return;
        }
        Array.prototype.forEach.call(templates[id],function(template){
            if(!registered){
                manager.register(template);
                registered = true;
            }else{
                manager.extend(id, template);
            } 
        });
    }
    function evaluateTemplateModule(id, cb, errorback){
        takeinDefQueue(id);

        var template = get(id);
        if (template && cb) {
            cb(template);
        }else if(errorback){
            errorback();
        }

    }
                
    function onTemplateChanged(template, cb, thisObj) {
        current = template;
        if (cb) {
            cb.call(thisObj, current);
        }
    }

    var defaultTemplateId = "default", defaultTemplate = {
        id : defaultTemplateId,
        name : "Default"
    };
    var manager =
    /** @lends sap.viz.TemplateManager */
    {
        /**
         * @constructs
         */
        constructor : function() {
            return;
        },
        /**
         * The file paths of templates folder. {@link sap.viz.TemplateManager} will discover available templates in this
         * folder.
         * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead. You can use sap.viz.api.env.Resource.path instead.
         * @default ["../../../resources/templates"]
         
         * @example <caption>Live Demo:</caption> 
         * {@link  http://shg-ci-web.dhcp.pgdev.sap.corp/snippet_platform_api/#008190|Try this}. 
         */
        loadPath : ["../../../resources/templates"],
        /**
         * Return current applied template.
         * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead. You can use sap.viz.extapi.env.Template.current instead.
         * @returns {Object} the manifest of template
         */
        current : function() {
            return current;
        },
        /**
         * Apply(switch) a template.
         * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead. You can use sap.viz.api.env.Template.set instead.
         * @param {String}
         *          id the template id
         * @param {Function}
         *          [cb] the call back function. It will be executed after template is applied successfully with current
         *          template as parameter. *
         * @param {Object}
         *          [thisObj] "this" object during calling call back function.
         *
         * @returns {Object} {@link sap.viz.TemplateManager}
         *
         * @example <caption>Live Demo:</caption> 
         * {@link http://shg-ci-web.dhcp.pgdev.sap.corp/snippet_platform_api/#008190|Try this}. 
         */
        apply : function(id, cb, thisObj, failedCallback) {
            //TODO quick fix, refactor later
            takeinDefQueue(id);
            var template = get(id);
            if (!template) {
                load(id, function( template ) {
                    onTemplateChanged(template, cb, thisObj);
                }, failedCallback);
            } else {
                onTemplateChanged(template, cb, thisObj);
            }

            return manager;
        },
        /**
         * Register new templates.
         * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead. You can use sap.viz.extapi.env.Template.register instead.
         * @param {Object...}
         *          templates the template descriptors(may be multiple).
         *
         * @returns {Object} {@link sap.viz.TemplateManager}
         * @example <caption>Live Demo:</caption> 
         * {@link http://shg-ci-web.dhcp.pgdev.sap.corp/snippet_platform_api/#008831|Try this}. 
         */
        register : function() {
            templateCategory.register.apply(templateCategory, arguments);
            return manager;
        },
        /**
         * Extend/modify an existing template.
         * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead. You can use sap.viz.extapi.env.Template.register instead.
         * @param {String}
         *          id the template id
         * @param {Object}
         *          obj the extended part.
         *
         * @returns {Object} {@link sap.viz.TemplateManager}         
         */
        extend : function(id, obj) {
            
            var template = templateCategory.get(id);
            function mixin(template){
                ObjectUtils.extend(true, template.properties, obj.properties);
                template.css += obj.css || "";
            }
            if(!template){
                //in case not evaluated
                evaluateTemplateModule(id, mixin);          
            }else{
                mixin(template);
            }
            return manager;
        }
    };
    delete manager.constructor;

    var apiProp = {
        writable : false,
        configurable : false
    };
    Object.defineProperties(manager, {
        current : apiProp,
        apply : apiProp,
        register : apiProp
    });

    manager.register(defaultTemplate);
    current = get(defaultTemplateId);
    return manager;
}); 

define('sap/viz/base/utils/log/Analyzer',['sap/viz/base/Logger'],
function Setup(LOG) {
  function Stack() {
    this.stac = [];

    this.pop = function() {
      return this.stac.pop();
    };

    this.push = function(item) {
      this.stac.push(item);
    };

    this.peek = function() {
      return this.stac[this.stac.length - 1];
    };
  }

  /*
   * return {
   *   'usedJSHeapSize' : [OPTIONAL] int
   *   'totalJSHeapSize' : [OPTIONAL] int
   *   'flag' : string
   * }
   */
  function parseProfilingMsg(msg) {
    //[18403120][24402304][767557632]Render: layout
    var ret = {};
    var exp = /\[\d+\]/g;
    var exp2 = /\d+/;
    var exp3 = /[^\d\[\]]+/;
    var heapsize = msg.match(exp);
    if(heapsize) {
      ret.usedJSHeapSize = heapsize[0].match(exp2)[0];
      ret.totalJSHeapSize = heapsize[1].match(exp2)[0];
    }
    ret.flag = msg.match(exp3)[0];
    return ret;
  }
  
  /*
   * return {
   *   'name': string,
   *   'client': string,
   *   'info' : Array
   * }
   */
  function parseContextMsg(msg) {
    //"[Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.22 (KHTML, like Gecko) Chrome/25.0.1364.152 Safari/537.22]creation:3:16:0"
    //[useragent]contextname:[:additional values]
    var ret = {};
    var exp = /\[.+\]/;
    var exp2 = /\]:.+$/;
    ret.client = msg.match(exp)[0];
    var ctxMatch = msg.match(exp2);
    if(ctxMatch){
      var ctxa = ctxMatch[0].split(':');
      ret.name = ctxa[1];
      ctxa.shift();
      ctxa.shift();
      ret.info = ctxa;
    }
    return ret;
  }
  
  //TODO FIXME @Eddy CHANGE TO STRING
    var threshold = LOG.LEVEL.DEBUG;
    var msgs = [];
    var layout = null;
  var Analyzer = {
    // add property threshold to adapt new log framework and each appender needs a threshold property
    threshold: threshold,
    doAppend : function(logTime, logLevel, logCate, logMsg) {
      msgs.push([logTime, logLevel, logCate, logMsg]);
    },
    setLayout : function(layout) {
      return layout.format && (this.layout = layout);
    },
    getLevel : function() {
      return threshold;
    },
    setLevel : function(level) {
      threshold = level;
    },
    
    reset : function(){
      msgs = [];
    },
    
    pnrProfiling: function(msg){
        //chrome supports window.performance.memory, we include it in profile message
        if(window && window.performance && window.performance.memory){
          var m = window.performance.memory;
          msg = '[' + m.usedJSHeapSize + '][' + m.totalJSHeapSize + '][' + m.jsHeapSizeLimit + ']' + msg;
        }
        LOG.debug(msg, 'PROFILING');
     },
     
    pnrContext: function(msg){
        //try to get as many env contexts as possible
        if(window && window.navigator){
          msg = "[" + window.navigator.userAgent + "]" + msg;
        }
        LOG.debug(msg, 'CONTEXT');
      }, 
    
    profiling : function() {
      //TODO FIXME @Eddy flush support
      LOG.disable();//disable to flush
      
      var pfs = new Stack();
      var pfa = [];
      var msg, pmsg, ctxmsg, peek, pop, currentPF;
      
      for(var i = 0, len = msgs.length; i < len; i++) {
        //typical msg:
        //[1362633819088][DEBUG][PROFILING]-[18403120][24402304][767557632]Render: layout
        //[1362633819099][DEBUG][PROFILING]-[18786948][24402304][767557632]Render: layout
        msg = msgs[i];
        //check context
        if(msg[2] === 'CONTEXT'){
          ctxmsg = parseContextMsg(msg[3]);
          currentPF = {
            ctx: {
              name: ctxmsg.name,
              client: ctxmsg.client,
              info: ctxmsg.info
            },
            data : []
          };
          pfa.push(currentPF);
        }else if(msg[2] === 'PROFILING') {
          pmsg = parseProfilingMsg(msg[3]);
          peek = pfs.peek();
          if(peek && peek.flag === pmsg.flag) {
            pop = pfs.pop();
            currentPF.data.push([pop.flag, msg[0] - pop.time, pop.time, msg[0], pmsg.usedJSHeapSize - pop.heapSizeUsed, pmsg.totalJSHeapSize - pop.heapSizeTotal, pmsg.usedJSHeapSize, pmsg.totalJSHeapSize]);
          } else {
            pfs.push({
              'flag' : pmsg.flag,
              'time' : msg[0],
              'heapSizeUsed' : pmsg.usedJSHeapSize,
              'heapSizeTotal' : pmsg.totalJSHeapSize
            });
          }
        }
      }
      
      LOG.enable();
      
      return pfa;
    }
  };

  return Analyzer;
});
define('sap/viz/env',['sap/viz/base/utils/TypeUtils','sap/viz/base/Logger','sap/viz/Locale',
'sap/viz/base/utils/log/Analyzer', 'sap/viz/base/utils/ObjectUtils'],
function Setup(TypeUtils, LOG, Locale, analyzer, ObjectUtils) {
    var _setLogLevel = function(_level) {
        if(TypeUtils.isExist(_level)) {
            LOG.setLevel(_level);
        }
    };
    var _initLogger = function(options) {
        if(!options) {
            return;
        }
            
        if(options.enable) {
            LOG.enable();
        }
           
        if(!options.appenders){
            //no customize appenders, we'll use default appender
            if(options.level){
              //FIXME @Eddy, allow set level with string
              //FIXME and only for debug, trace we will use analyzer as appender
              //otherwise we set this level to default appender
              LOG.setAppenders([{appenderKey: 'sap.viz.util.analyzer', appender: analyzer}]);
            }
            return;
        }
        //if user set appenders, we remove default appender
        LOG.setAppenders([]);   
        for(var i = 0, l = options.appenders.length; i < l; i++) {
            var appender = options.appenders[i];
            if(appender.appenderKey) {
                 LOG.addAppender(appender.appenderKey, appender.appender);    
            }
               
            else {
                 LOG.addAppender(appender.appender);
            }
               
        }
        // LOG.addAppender('analyzerAppender', new AnalyzerAppender());
        // LOG.addAppender("ajaxApp", new LOG.AjaxAppender("http://localhost:8800"));
        // LOG.getAppender("ajaxApp").setLevel(LOG.LEVEL.DEBUG);
        //LOG.getAppender("[default]").setLevel(_level);
    };
    
    var _initLocal = function(options, callback){
      Locale.locale(options.locale, callback);
    };
    
    var setting = {};

    var env =
    /**
     * @lends sap.viz.Environment
     */
    {
        /**
         * @constructs
         */
        constructor : function() {

        },
        /**
         * initialize visualization environment
	 * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead.
         * @param {Object}
         *            option {locale:'en_US'}
         *
         */
        initialize : function(option, callback) {
          if (!option) {
              return;  
          }
            _initLogger(option.log);
            if (option.locale){
              _initLocal(option, callback);
            } else {
                   if(callback) {
                       callback.call();
                   }
            }
            
            setting = ObjectUtils.extend(true, {}, setting, option);
            // _setLogLevel(option.log);
        },
        
        /**
         * get Environment setting.
         * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead.
         * @return {Object}
         *            option {locale:'en_US'}
         *
         */
        getEnvSetting : function(){
            return setting;
        },

        /**
         * @ignore
         * @param enable
         */
        setLoggerEnable : function(enable) {
            if(enable === true) {
                 LOG.enable();
            }
               
            else if(enable === false) {
                 LOG.disable();    
            }
               
        },
        
        /**
         * @ignore
         * @returns TODO: add desc
         */
        addLogAppender : function() {
            if(arguments.length === 1) {
                return LOG.addAppender(arguments[0]);
            }
                
            else if(arguments.length === 2) {
                return LOG.addAppender(arguments[0], arguments[1]);
            }
               
        },
        
        /**
         * @ignore
         * @param key
         * @returns TODO: add desc
         */
        removeLogAppender : function(key) {
            return LOG.removeAppender(key);
        }
    };

    return env;
});
define('sap/viz/config',['sap/viz/base/utils/FunctionUtils', 'sap/viz/env'],
function Setup(FunctionUtils, env) {
  
  var configs = {};
  
  var enableCanvg = false; 
  
  var manager = {
      
      constructor : function(){
        return;
      },
      
      enableCanvg : function(_) {
          if(!arguments.length){
            //get option from environment.
            return (env.getEnvSetting().enableCanvg !== undefined) ? env.getEnvSetting().enableCanvg : enableCanvg ;
          }
          enableCanvg = _;
          return manager;
      },
      
      register : function(obj) {
          if(configs.hasOwnProperty(obj.id)){
            return;
          }
          configs[obj.id] = obj.value;
          return manager;
      },
        
      get: function(ids){
        if(configs.hasOwnProperty(ids)){
          return configs[ids];
        }
      },
      
      getConfigs : function() {
          return configs;
      }
  };
  
  return manager;
});
define('sap/viz/data/MultiAxesDataAdapter',['sap/viz/base/utils/TypeUtils','sap/viz/base/utils/FunctionUtils'],
function Setup(TypeUtils, FunctionUtils){


   /**
    * @name sap.viz.data.MultiAxesDataAdapter
    * @constructor
    * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead.
      */
   function MultiAxesDataAdapter(bindingInfo){
     this._bindingInfo = bindingInfo;
     this._aa  = [];
     this._mg  = [];
     this._fakeData = false;
     this._dataPointCount = 0;
     this._emptyDataset = false;
   }
   
   /**
    * @name sap.viz.data.MultiAxesDataAdapter#addAnalysisAxis
    * @function
    * @param {Object} aa
    * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead.
    */
   MultiAxesDataAdapter.prototype.addAnalysisAxis = function(aa){
        if(aa){
           this._aa.push(aa);
        }
   };
   
   /**
    * @name sap.viz.data.MultiAxesDataAdapter#addMeasureValuesGroup
    * @function 
    * @param {Object} mg
    * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead.	
    */
   MultiAxesDataAdapter.prototype.addMeasureValuesGroup = function(mg){
        if(mg){
          this._mg.push(mg);
        }
   };
   
   /**
    * @name sap.viz.data.MultiAxesDataAdapter#getAnalysisAxisDataByIdx
    * @function 
    * @param {Object} index
    * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead.	
    */
   MultiAxesDataAdapter.prototype.getAnalysisAxisDataByIdx = function(idx){
     if(!arguments.length){
        return this._aa;
     }
     
     for(var i = 0; i < this._aa.length; i++){
       if(this._aa[i].index === idx){
          return this._aa[i];
       }
     }
     
     return null;
   };
   
   /**
    * @name sap.viz.data.MultiAxesDataAdapter#getMeasureValuesGroupDataByIdx
    * @function 
    * @param {Object} index
    * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead.	
    */
   MultiAxesDataAdapter.prototype.getMeasureValuesGroupDataByIdx = function(idx){
     if(!arguments.length){
        return this._mg;
     }
     
     for(var i = 0; i < this._mg.length; i++){
       if(this._mg[i].index === idx){
          return this._mg[i];
       }
     }
     
     return null;
   };
   
   MultiAxesDataAdapter.prototype.createDataAdapterForModule = function(ctx){
     
      var subDataAdapter = new MultiAxesDataAdapter();
      var i;
      if(ctx && ctx.aa){
        for(i = 0; i < ctx.aa.length; i++){
          var aa = this.getAnalysisAxisDataByIdx(ctx.aa[i] - 1);
          if(aa){
             subDataAdapter.addAnalysisAxis({index:i, values: aa.values});
          }
        } 
      }
      
      if(ctx && ctx.mg){
        for(i = 0; i < ctx.mg.length; i++){
          var mg = this.getMeasureValuesGroupDataByIdx(ctx.mg[i] - 1);
          if(mg){
             subDataAdapter.addMeasureValuesGroup({index: i, values: mg.values});
          }
        }
      }
      
      return subDataAdapter;
     
   };
   
   MultiAxesDataAdapter.prototype.getBindingInfo = function(){
        return this._bindingInfo;
   };
   
   MultiAxesDataAdapter.prototype.fakeData = function(_){
     if (!arguments.length){
         return this._fakeData;
     }
     
     this._fakeData = _;
   };
   

   MultiAxesDataAdapter.prototype.dataPointCount = function(_){
     if (!arguments.length){
       return this._dataPointCount;
     }
     
     this._dataPointCount = _;
   };
   
   MultiAxesDataAdapter.prototype.emptyDataset = function(_){
     if (!arguments.length){
         return this._emptyDataset;
     }
     
     this._emptyDataset = _;
   };
   
   return MultiAxesDataAdapter;
   
});
define('sap/viz/base/utils/Objects',['sap/viz/base/utils/TypeUtils'],
function Setup(TypeUtils) {
    
	var objects = {
	    // copy from sap.viz.base.utils.ObjectUtils.extend
	    // in this version, when target is array, just use src replace target
	    extend : function() {
	      var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;

	      // Handle a deep copy situation
	      if (typeof target === "boolean") {
	        deep = target;
	        target = arguments[1] || {};
	        // skip the boolean and the target
	        i = 2;
	      }

	      // Handle case when target is a string or something (possible in
	      // deep
	      // copy)
	      if (typeof target !== "object" && !TypeUtils.isFunction(target)) {
	        target = {};
	      }

	      // extend itself if only one argument is passed
	      if (length === i) {
	        target = this;
	        --i;
	      }

	      for (; i < length; i++) {
	        // Only deal with non-null/undefined values
	        if ((options = arguments[i]) !== null) {
	          // Extend the base object
	          for (name in options) {
	            if (options.hasOwnProperty(name)){
	              src = target[name];
	              copy = options[name];

	              // Prevent never-ending loop
	              if (target === copy) {
	                continue;
	              }

	              // Recurse if we're merging plain objects or arrays
	              // in this version, when target is array, just src replace target
	              if (deep && copy && (TypeUtils.isPlainObject(copy))) {
	                if (copyIsArray) {
	                  copyIsArray = false;
	                  clone = src && TypeUtils.isArray(src) ? src : [];

	                } else {
	                  clone = src && TypeUtils.isPlainObject(src) ? src : {};
	                }
	                // Never move original objects, clone them
	                target[name] = objects.extend(deep, clone, copy);
	                // Don't bring in undefined values
	              } else if (copy !== undefined) {
	                target[name] = copy;
	              }              
	            }
	          }
	        }
	      }
	      // Return the modified object
	      return target;
	    },    
	    equal: function (objA, objB){
	      if(typeof arguments[0] !== typeof arguments[1]){
	        return false;
	      }
	      if (objA === undefined){
	        if (objB !== undefined){
	          return false;
	        }
	      }
	      if (objA === null){
	        if (objB !== null){
	          return false;
	        }
	      }
	      if(objA instanceof Array){
	        if (!(objB instanceof Array)){
	          return false;
	        }
	        if(objA.length !== objB.length){
	          return false;
	        }
	        var arrayEqualResult = true;
	        for(var i = 0; i < objA.length; i++){
	          if(typeof objA[i] !== typeof objB[i]){
	            return false;
	          }
	          if(typeof objA[i] === 'boolean' || typeof objA[i] === 'number' || typeof objA[i] === 'string' || typeof objA[i] === 'undefined' || objA[i] === null){
	            arrayEqualResult = (objA[i] === objB[i]);
	          }
	          else if(objA[i] instanceof Object){
	            arrayEqualResult = this.equal(objA[i] , objB[i]);
	          }
	          else{
	            return false;
	          }
	          if(!arrayEqualResult){
	            return false;
	          }
	        }
	        return true;
	      }
	      if(objA instanceof Object && objB instanceof Object && typeof objA !== 'function' && typeof objB !== 'function'){
	        if (objB === null || objB instanceof Array){
	          return false;
	        }
	        var attrLenA = 0, attrLenB = 0;
	        var attr;
	        for(attr in objA){
	          if (objA.hasOwnProperty(attr)){
	            if(typeof objA[attr] === 'boolean' || typeof objA[attr] === 'number' || typeof objB[attr] === 'string' || typeof objA[attr] === 'undefined' || objA[attr] === null){
	              if(objA[attr] !== objB[attr]){
	                return false;
	              }
	            }
	            else{
	              if(!this.equal(objA[attr], objB[attr])){
	                return false;
	              }
	            }
	            attrLenA++;
	          }
	        }
	        for(attr in objB){
	         if(objB.hasOwnProperty(attr)){
	           attrLenB++;
	         }
	        }
	        if(attrLenA !== attrLenB){
	          return false;
	        }
	        return true;
	      }
	      return objA === objB;
	    }
	};
	return objects;
});
define('sap/viz/format/XCFormat',['sap/viz/base/utils/Objects'],
function Setup(Objects) {
	
	var NF = {
			format: function(value){
				return value;
			},
			locale: function(){
				
			},
			DEFAULT_FORMAT_DATE_TIME : '',
			DEFAULT_FORMAT_TIME : '',
			DEFAULT_FORMAT_SHORT_DATE : '',
			DEFAULT_FORMAT_LONG_DATE : '',
			DEFAULT_FORMAT_NUMBER : '',
			DEFAULT_FORMAT_BOOLEAN : ''
	}, snf = null, locale = 'en';
	
	if(window.sap && sap.common && sap.common.globalization && sap.common.globalization.NumericFormatManager){
		snf = sap.common.globalization.NumericFormatManager;
		
		NF = Objects.extend( true, NF, {
			
			format : function(value, pattern){
				return snf.formatToText(value, pattern, true); // we always try to convert number to string
			},
			
			locale : function(_){
				if(!arguments.length){
					return locale;
				}
				locale = _;
				snf.setPVL(locale);
				
				//reset default format string
				NF.DEFAULT_FORMAT_DATE_TIME = snf.DEFAULT_FORMAT_DATE_TIME;
				NF.DEFAULT_FORMAT_TIME = snf.DEFAULT_FORMAT_TIME;
				NF.DEFAULT_FORMAT_SHORT_DATE = snf.DEFAULT_FORMAT_SHORT_DATE;
				NF.DEFAULT_FORMAT_LONG_DATE = snf.DEFAULT_FORMAT_LONG_DATE;
				NF.DEFAULT_FORMAT_NUMBER = snf.DEFAULT_FORMAT_NUMBER;
				NF.DEFAULT_FORMAT_BOOLEAN = snf.DEFAULT_FORMAT_BOOLEAN;
			},
			
			DEFAULT_FORMAT_DATE_TIME : snf.DEFAULT_FORMAT_DATE_TIME,
			DEFAULT_FORMAT_TIME : snf.DEFAULT_FORMAT_TIME,
			DEFAULT_FORMAT_SHORT_DATE : snf.DEFAULT_FORMAT_SHORT_DATE,
			DEFAULT_FORMAT_LONG_DATE : snf.DEFAULT_FORMAT_LONG_DATE,
			DEFAULT_FORMAT_NUMBER : snf.DEFAULT_FORMAT_NUMBER,
			DEFAULT_FORMAT_BOOLEAN : snf.DEFAULT_FORMAT_BOOLEAN
			
		});
	}
	
	return NF;
});
define('sap/viz/format/FormatManager',['sap/viz/base/utils/TypeUtils','sap/viz/format/XCFormat','sap/viz/Locale'],
function Setup(TypeUtil, XCFormat, Locale) {

  var locale = 'en', formatUtil = XCFormat, props = null;
  
  var FM = 
     /** @lends sap.viz.format.FormatManager */
  {
       /**
           * @constructs
          */
      constructor : function(){
        return;
      },
      
      /**
           * Apply a locale
           * 
           * @param {String}
           *       locale
           * 
           * @returns {Object} {@link sap.viz.format.FormatManager}
           * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead.		   
           */
      apply : function(_){
        locale = _;
        formatUtil.locale(locale);
      },
      
      /**
           * format a string
           * 
           * @param {String}
           *       value
           * 
           * @param {String}
           *       pattern
           * 
           * @returns {Object} {@link sap.viz.format.FormatManager}
           * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead.		   
           */
      format : function(value, pattern){
        return formatUtil.format(value, pattern);
      },
      
      /**
           * set/get format function
           * 
           * @param {Function}
           *       func
           * 
           * @returns {Object} {@link sap.viz.format.FormatManager}
	* @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead.
           */
      formatFunc : function(_){
        if(!arguments.length){
          return formatUtil;
        }
        formatUtil = _;
      },
      
      /**
         * default data time format. It will changed by locale. 
        */
      DEFAULT_FORMAT_DATE_TIME : formatUtil.DEFAULT_FORMAT_DATE_TIME,
      /**
         * default time format. It will changed by locale. 
        */
      DEFAULT_FORMAT_TIME : formatUtil.DEFAULT_FORMAT_TIME,
      /**
         * default short data format. It will changed by locale. 
        */
      DEFAULT_FORMAT_SHORT_DATE : formatUtil.DEFAULT_FORMAT_SHORT_DATE,
      /**
         * default long data format. It will changed by locale. 
        */
      DEFAULT_FORMAT_LONG_DATE : formatUtil.DEFAULT_FORMAT_LONG_DATE,
      /**
         * default number format. It will changed by locale. 
        */
      DEFAULT_FORMAT_NUMBER : formatUtil.DEFAULT_FORMAT_NUMBER,
      /**
         * default boolean format. It will changed by locale. 
        */
      DEFAULT_FORMAT_BOOLEAN : formatUtil.DEFAULT_FORMAT_BOOLEAN
  };
  
  Locale.addListener({
    fn:function(locale){
      FM.apply(locale);
    },
    scope: FM
  });
  
  return FM;
});
define('sap/viz/data/handler/MeasureDataHandler',['sap/viz/base/utils/FunctionUtils', 'sap/viz/lang/langManager'],

function Setup(FunctionUtils){
  
  var MeasureValuesDataHandler = {
      
      makeMeasureValues: function(ctx, mvg, axisIndex, maxAxisNumber, matchMeasure){
          
          var values = [];
          for(var i = 0; i < mvg.values.length; i++){
              if(matchMeasure && i !== ctx.path.mi){
                 continue;
              }
            
              var value = {};
              var mv = mvg.values[i];
              var rows = mv["rows"];
              value["col"] = mv["col"];
              if(ctx){
                 value["rows"] = this.createMeasureValues(ctx, rows, axisIndex, maxAxisNumber);
              }else{
                value["rows"] = this.createMeasureValuesWithoutCtx(rows, axisIndex, maxAxisNumber);
              }
          
              values.push(value);
           }
          
          return values;
        },
       
        /**
         * Create Measure values without context
         *   
         * @param rows
         * @param axisIndex
         * @returns {Array}
         */
        createMeasureValuesWithoutCtx_1_2 : function(rows, axisIndex){
          var values = [], j, row;
          if(axisIndex[0] === 1){
             row = [];
             for(j = 0; j < rows[0].length; j++){
               row.push(rows[0][j]);
             }   
             values.push(row);
           
          }else if(axisIndex[0] === 2){     
             for(j = 0; j < rows[0].length; j++){
               row = [];
               row.push(rows[0][j]);
               values.push(row);
             }   
          }else{
             FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_NOT_SUPPORTED'));
         } 
          
          return values;
        },
        
        createMeasureValuesWithoutCtx_1_3 : function(rows, axisIndex){
           var values = [], j, row;
           if(axisIndex[0] === 1){
              row = [];
              for(j = 0; j < rows[0].length; j++){
                  row.push(rows[0][j]);
           }   
              
           values.push([row]);
           
         }else if(axisIndex[0] === 2){
              row = [];
              for(j = 0; j < rows[0].length; j++){
                  row.push([rows[0][j]]);
              }
              
              values.push(row);
              
         }else if(axisIndex[0] === 3){   
               for(j = 0; j < rows[0].length; j++){
                   row = [];
                   row.push([rows[0][j]]);
                   values.push(row);
               }
         }else{
           FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_NOT_SUPPORTED'));
         }  
           
         return values;
         
        },
        
        createMeasureValuesWithoutCtx : function(rows, axisIndex, maxAxisNumber){
           if(axisIndex.length === 1){
             if(maxAxisNumber === 1 || maxAxisNumber === 2){
                return this.createMeasureValuesWithoutCtx_1_2(rows, axisIndex); 
             }else if(maxAxisNumber === 3){
                return this.createMeasureValuesWithoutCtx_1_3(rows, axisIndex);
             }else{
                FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_NOT_SUPPORTED'));
             }
           }else if(axisIndex.length === 2){
             if(maxAxisNumber === 2){
                return rows;
             }
             else if(maxAxisNumber === 3){
                return this.createMeasureValues_2_3(rows, axisIndex); 
             }else{
                FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_NOT_SUPPORTED'));
             } 
             
           }else{
             FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_NOT_SUPPORTED'));
           }
           
           FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_NOT_SUPPORTED'));
      },
      
      /**
         * Create Measure values without context
         *   
         * @param rows
         * @param axisIndex
         * @returns {Array}
         */
        createMeasureValues_1_2 : function(ctx, rows, axisIndex){
          var values = [], j, row;
           if(axisIndex[0] === 1){
              row = [];
              for(j = 0; j < rows.length; j++){
                  row.push(rows[j][ctx.path.dii]);
              } 
              
           values.push(row);
           
         }else if(axisIndex[0] === 2){
           
           for(j = 0; j < rows.length; j++){
             row = [];
             row.push(rows[j][ctx.path.dii]);
             values.push(row);
           }  
           
         }else{
           FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_NOT_SUPPORTED'));
         } 
          
          return values;
        },
        
        createMeasureValues_1_3 : function(ctx, rows, axisIndex){
          var values = [], j, row;
          if(axisIndex[0] === 1){
             
           row = [];
           for(j = 0; j < rows.length; j++){
             row.push(rows[j][ctx.path.dii]);
           }   
           values.push([row]);
           
         }else if(axisIndex[0] === 2){
           row = [];
           for(j = 0; j < rows.length; j++){
             
             row.push([rows[j][ctx.path.dii]]);
             
           }  
           values.push(row);
           
         }else if(axisIndex[0] === 3){
           
           for(j = 0; j < rows.length; j++){
             row = [];
             row.push([rows[j][ctx.path.dii]]);
             values.push(row);
           }
           
         }else{
           FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_NOT_SUPPORTED'));
         }
           
           return values;
        },
      
      createMeasureValues : function(ctx, rows, axisIndex, maxAxisNumber){
         var values = [];
         if(axisIndex.length === 1){
             if(maxAxisNumber === 1 || maxAxisNumber === 2){
              return this.createMeasureValues_1_2(ctx, rows, axisIndex); 
             }else if(maxAxisNumber === 3){
               return this.createMeasureValues_1_3(ctx, rows, axisIndex);
             }else{
                FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_NOT_SUPPORTED'));
             }
         }else if(axisIndex.length === 2){
             if(maxAxisNumber === 2){
                return rows;
             }else if(maxAxisNumber === 3){
                return this.createMeasureValues_2_3(rows, axisIndex);
             }else{
              FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_NOT_SUPPORTED'));
             }
         }else{
             FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_NOT_SUPPORTED'));
         }
           
         
           return values;
      },
     
        createMeasureValues_2_3 : function(rows, axisIndex){
          var i ,j, values;
          if(axisIndex[0] === 1 && axisIndex[1] === 2){
            return [rows];
          }else if(axisIndex[0] === 1 && axisIndex[1] === 3){
            values = [];
            for(i = 0 ; i < rows.length; i++){
                values.push([rows[i]]);
            }
            return values;
            
          }else if(axisIndex[0] === 2 && axisIndex[1] === 3){
            values = [];
            for(i = 0 ; i < rows.length; i++){
              var value = [];
              var cols = rows[i];
              for(j = 0; j < cols.length; j++){
                var col = cols[j];
                value.push([col]);
              }
              values.push(value);
            }
            
            return values;
          }else{
            FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_NOT_SUPPORTED'));
          }
        }
        
     };
  
  return MeasureValuesDataHandler;
});
define('sap/viz/data/handler/SingleChartDataHandler',['sap/viz/base/utils/FunctionUtils','sap/viz/data/MultiAxesDataAdapter','sap/viz/data/handler/MeasureDataHandler', 'sap/viz/lang/langManager'],
 function Setup(FunctionUtils, MultiAxesDataAdapter, MeasureDataHandler, langManager){
   
   
   function initMeasureValueAxisIndex(bindingInfo){
     
      //axis 1 has been feeded with crosstable
      if(bindingInfo[0] === true){
       if(bindingInfo[1] === true){
          return [1 ,2];
       }
       else if(bindingInfo[2] === true){
        // pass crosstable data to module if module accpet more than 2 axis feed
          return [1, 2];
       }
       else if(bindingInfo[3] === true){// Multi Radar, aa 4 could not be feeded
          FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_NOT_SUPPORTED'));
       }
       else{
          return [1];
       }
      }else if(bindingInfo[1] === true){
       if(bindingInfo[2] === true){
          //pass crosstable data to module if module accpet more than 2 axis feed
          return [1,2];
       }
       else if(bindingInfo[3] === true){
          FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_NOT_SUPPORTED'));
       }
       else{
         //pass crosstable data to module if module accpet more than 2 axis feed
         if(bindingInfo.length > 2){
            return [1];
         }
         else{
            return [2];
         }
       }
      }else if(bindingInfo[2] === true){
        if(bindingInfo[3] === true){
           FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_NOT_SUPPORTED'));
        }
        else{
         //pass crosstable data to module if module accpet more than 2 axis feed
         return [1];
        }
      }else{
        for(var i = 0; i< bindingInfo.length;i++){
          if(bindingInfo[i] === true){
            FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_NOT_DETERMINE_AXIS_INDEX'));
          }
        }
        //all false
        return [1];
      }
       
      FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_NOT_DETERMINE_AXIS_INDEX'));
     
    } 
   
   function SinngleChartDataHandler(dataAdapter){
        this._dataAdapter =  dataAdapter;
   }
   
   SinngleChartDataHandler.prototype.getDataAdapter = function(){
      if(this._dataAdapter.getBindingInfo===undefined||this._dataAdapter.getBindingInfo() === null || this._dataAdapter.getBindingInfo() === undefined ){
         return this._dataAdapter;
      }
      else{
         return this.getChartDataAdapter();
      }
   };
   
   SinngleChartDataHandler.prototype.getChartDataAdapter = function(){
      var measureAxisIndex = initMeasureValueAxisIndex(this._dataAdapter.getBindingInfo());
      var aa = this._dataAdapter.getAnalysisAxisDataByIdx();
      var mg = this._dataAdapter.getMeasureValuesGroupDataByIdx();
      var dataAdapter = new MultiAxesDataAdapter();
      for(var i = 0; i < aa.length; i++){
        var axis = aa[i];
        dataAdapter.addAnalysisAxis({index: axis.index, values: axis.values});
      }
      
      for(i = 0; i < mg.length; i++){
        var mvg = mg[i];
        dataAdapter.addMeasureValuesGroup({index:mvg.index, values: MeasureDataHandler.makeMeasureValues(null, mvg, measureAxisIndex, 2, false)});
      }
      
      return dataAdapter;
   };
   
   return SinngleChartDataHandler;
 });
define( "jquery", [], function () { return jQuery; } );

define('sap/viz/util/Objects',['sap/viz/base/utils/TypeUtils'],
function Setup(TypeUtils) {

  var objects = {
    // returns an array of the plot's parent nodes, in the same order as the "plots" array
    getPlotNodes : function(plots) {
      var nodes = [];
      for (var i = 0, len = plots.length; i < len; i++) {
        if (plots[i].parent()) {
          nodes.push(plots[i].parent().node());
        }
      }
      return nodes;
    },

    // returns the index of the plot (in the "plots" array) that contains the target element
    // nodes is optional and should contain the container elements for the plots
    plotIndexContainingTarget : function(plots, target, nodes) {
      var n = target,
        plotNodes = nodes || this.getPlotNodes(plots),
        idx;

      for (; n && n.ownerSVGElement; n = n.parentNode) {
        idx = plotNodes.indexOf(n);
        if (idx !== -1) {
          return idx;
        }
      }

      return -1;
    },

    // returns the plot module object that contains the target element
    plotContainingTarget : function(plots, target, nodes) {
      var plotIdx = this.plotIndexContainingTarget(plots, target, nodes);

      if (plotIdx !== -1) {
        return plots[plotIdx];
      }

      return null;
    },
        
    isLabelArea : function(classname, selectionMode)
    {
        var isAxisLabelArea = false;
        if(classname && classname.indexOf('v-labelarea') >= 0)//find it
        {
          if(selectionMode !== 'single')
          {
              //do not have label selection in 'single'
              isAxisLabelArea = true;
          }
        }
        return isAxisLabelArea;
    },
    
    size : function(obj){
      var ret = 0;
      //here we want to filter both undefined and null
      /*jshint eqnull:true */
      if (obj != null){
        if (obj.length === +obj.length){
          ret = obj.length;
        }else{
          for(var i in obj){
            if(obj.hasOwnProperty(i)){
              ret++;
            }
          }
        }
      }
      return ret;
    },

    normalizeNumbersCeil : function(obj)
    {
        for(var prop in obj)
        {
            if(obj.hasOwnProperty(prop))
            {
                if((typeof obj[prop]) === "number")
                {
                    //we do not use toFixed, because toFixed makes 5.54 to 5.5, but we need 5.6
                    var standard = 100000000;
                    var tempInt = Math.ceil(obj[prop] * standard);
                    obj[prop] = tempInt/standard;
                }
            }
        }
    }
    
  };
  return objects;
});
define('sap/viz/base/utils/log/LogUtil',['sap/viz/base/Logger'],
function Setup(LOG){
  var ret = {
    'profiling' : function(msg){
      //chrome supports window.performance.memory, we include it in profile message
      if(window && window.performance && window.performance.memory){
        var m = window.performance.memory;
        msg = '[' + m.usedJSHeapSize + '][' + m.totalJSHeapSize + '][' + m.jsHeapSizeLimit + ']' + msg;
      }
      LOG.debug(msg, 'PROFILING');
    },
    
    'context' : function(msg){
      //try to get as many env contexts as possible
      if(window && window.navigator){
        msg = "[" + window.navigator.userAgent + "]" + msg;
      }
      LOG.debug(msg, 'CONTEXT');
    }
  };
  return ret;
});
define('sap/viz/base/Observable',['sap/viz/base/Class','sap/viz/base/utils/TypeUtils'],
function Setup(Class, TypeUtils) {
	var ArraySlice = Array.prototype.slice, ObjectGetPrototypeOf = Object.getPrototypeOf;
	function addEvents(/* event1, event2,...,eventn */) {
		var es = this._events, en, len = arguments.length;
		while (--len >= 0) {
			if (!es.hasOwnProperty(en = arguments[len])) {
				es[en] = [];
			}
		}
	}

	var Observable = Class.define({
		/**
		 * To utilize observable object, You have to extend your object from it,
		 * and set the 'events' property as Array of event name to the
		 * constructor
		 * 
		 * @name sap.viz.base.utils.Observable
		 * @constructor
		 */
		constructor : function(option) {
			this._events = {};
			var c = this, t;
			while ((c = ObjectGetPrototypeOf(c)).constructor !== Object) {
				if ((t = c.events) && t.length) {
					addEvents.apply(this, t);
				}
			}
			if (option) {
				if (t = option.listeners) {
					this.on(t);
					delete option.listeners;
				}
			}
		},

		/**
		 * Add events that could be monitored
		 * 
		 * @name sap.viz.base.utils.Observable#addEvents
		 * @function
		 * @parameter {String|String|...} event1,event2,event3... variable
		 *            length arguments of String
		 */
		addEvents : addEvents,
		/**
		 * Get the supported events
		 * 
		 * @name sap.viz.base.utils.Observable#getSupportedEvents
		 * @function
		 * @return {Array} an array of event names
		 */
		getSupportedEvents : function() {
			return this._events.key();
		},

		/**
		 * Add event listeners
		 * 
		 * @name sap.viz.base.utils.Observable#on
		 * @function
		 * @param {String|Object}
		 *            eventName the event to be monitored, or a object which key
		 *            is eventName and value is corresponding listener
		 * @param {Function}
		 *            [listener] the function to be triggered when event is
		 *            fired
		 * @param {String}
		 *            [category] optional string to give the listener a
		 *            category, could be used in removing listener
		 */
		on : function(event, listener, category) {
			if (arguments.length >= 1) {
				if (arguments.length > 1) {
					var t = {};
					t[event] = listener;
					event = t;
				}
				for ( var en in event) {
					if (listener = this._events[en]) {
						event[en]['category'] = category;
						listener.push(event[en]);
					}
				}
			}
			return this;
		},

		/**
		 * Check whether the listener is listening on the event
		 * 
		 * @name sap.viz.base.utils.Observable#isListening
		 * @function
		 * @param {String}
		 *            eventName the eventName to which the listener is
		 *            monitoring
		 * @param {Function}
		 *            listener the listener to find
		 * 
		 * @returns {Boolean}
		 */
		isListening : function(eventName, listener) {
			if (eventName = this._events[eventName]) {
				return eventName.indexOf(listener) > -1;
			}
			return false;
		},

		/**
		 * Remove the registered listener for given event, if no listener
		 * function specified, all listeners registered will be removed, instead
		 * to specify listener function, it can also accept a string to indicate
		 * category of listener, in this case only listeners in the given
		 * category will be removed
		 * 
		 * @name sap.viz.base.utils.Observable#un
		 * @function
		 * @param {String}
		 *            eventName the eventName to which the listener is
		 *            monitoring
		 * @param {Function|String}
		 *            (listener) the listener to find or a string to indicate
		 *            the category of listener
		 */
		un : function(eventName, fn) {
			if (arguments.length === 1) {
				var es = this._events;
				if (es.hasOwnProperty(eventName)) {
					es[eventName] = [];
				}
			} else if (arguments.length === 2) {
				var event = this._events[eventName];
				if (event) {
					if (typeof fn === 'function') {
						var idx;
						while ((idx = event.indexOf(fn)) > -1) {
							event.splice(idx, 1);
						}
					} else {
						var len = event.length;
						while (len--) {
							if (event[len].category === fn) {
								event.splice(len, 1);
							}
						}
					}
				}
			}
		},

		/**
		 * Purge all listeners registered on the observable object
		 * 
		 * @name sap.viz.base.utils.Observable#purgeListeners
		 * @function
		 * @param {String}
		 *            eventName the eventName to which the listener is
		 *            monitoring
		 * @returns {Boolean}
		 */
		purgeListeners : function() {
			var es = this._events;
			for ( var e in es) {
				es[e] = [];
			}
		},

		/**
		 * Fire an event
		 * 
		 * @name sap.viz.base.utils.Observable#fireEvent
		 * @function
		 * @param {String}
		 *            eventName name of the event to be fired
		 * @param {Object}
		 *            args additional arguments passed to listener
		 */
		fireEvent : function(eventName) {
			var args = ArraySlice.call(arguments, 1);
			if (eventName = this._events[eventName]) {
				for ( var i = 0, len = eventName.length; i < len; i++) {
					eventName[i].apply(this, args);
				}
			}
		}
	});

	return Observable;
});
define('sap/viz/mvc/ThemeManager',['sap/viz/base/utils/ObjectUtils','sap/viz/base/Observable'],
function Setup(ObjUtils, Observable) {
	/**
	 * A global theme manager
	 * 
	 * @class sap.viz.mvc.ThemeManager
	 */
	var ThemeManager = new (Observable.extend(
	{
		events : [ 'defaultThemeChanged', 'themeSettingChanged' ],
		constructor : function(options) {
			this._themeReg = {};
		},
		/**
		 * Get or set the global default theme
		 * 
		 * @name sap.viz.mvc.ThemeManager#defaultTheme
		 * @function
		 * @param {String}
		 *            [theme] the name of the default theme.
		 * @return {String} the name of the current default theme
		 */
		defaultTheme : function(theme) {
			if (theme !== undefined) {
				if (this._defaultTheme !== theme && this.hasThemeInstalled(theme)) {
					var old = this._defaultTheme;
					this._defaultTheme = theme;
					this.fireEvent('defaultThemeChanged', old, theme);
				}
				return this;
			}
			return this._defaultTheme;
		},
		/**
		 * Check whether the theme has already been installed.
		 * 
		 * @name sap.viz.mvc.ThemeManager#hasThemeInstalled
		 * @function
		 * @param {String}
		 *            theme the name of the theme.
		 * @return {Boolean}
		 */
		hasThemeInstalled : function(theme) {
			return this._themeReg.hasOwnProperty(theme);
		},
		/**
		 * Install a new theme, if it's been already installed, nothing happens.
		 * 
		 * @name sap.viz.mvc.ThemeManager#installTheme
		 * @function
		 * @param {String}
		 *            name the name of the new theme
		 * @param {Object}
		 *            settings the settings of the theme
		 */
		installTheme : function(name, settings) {
			if (!this._themeReg.hasOwnProperty(name)) {
				this._themeReg[name] = ObjUtils.extend({}, settings);
			}
		},
		/**
		 * Get the settings of given theme.
		 * 
		 * @name sap.viz.mvc.ThemeManager#getThemeSettings
		 * @function
		 * @param {String}
		 *            theme the name of the theme.
		 * @return {Object} the settings of the theme
		 */
		getThemeSettings : function(theme) {
			if (this._themeReg.hasOwnProperty(theme)) {
				return ObjUtils.extend({}, this._themeReg[theme]);
			}
		},
		/**
		 * Update a value of a given theme's property, will fire
		 * <b>themeSettingChanged</b> event if succeed.
		 * 
		 * @name sap.viz.mvc.ThemeManager#updateThemeSetting
		 * @function
		 * @param {String}
		 *            theme the name of the theme.
		 * @param {String}
		 *            key the key whose value to be updated.
		 * @param {String}
		 *            value the new value of the key
		 */
		updateThemeSetting : function(theme, key, value) {
			if (this._themeReg.hasOwnProperty(theme)) {
				var old = this._themeReg[theme][key];
				this._themeReg[theme][key] = value;
				this.fireEvent('themeSettingChanged', theme, key, old, value);
			}
		}
	}))();
	return ThemeManager;
});
define('sap/viz/mvc/ImageManager',['sap/viz/base/utils/FunctionUtils'],
function Setup(FuncUtils) {
	/**
	 * The image object
	 * 
	 * @name sap.viz.mvc.Image
	 * @constructor
	 */
	var img = function(htmlImageElement) {
		this._imgEl = htmlImageElement;
	};

	/**
	 * Return the underlying htmlImageElement
	 * 
	 * @name sap.viz.mvc.Image#getBitmap
	 * @function
	 * @returns {HtmlImageElement}
	 */
	img.prototype.getBitmap = function() {
		return this._imgEl;
	};

	/**
	 * Get or set the visual width of the image
	 * 
	 * @name sap.viz.mvc.Image#width
	 * @param {undefined|Number}
	 *            width the new width of the image
	 * @returns {this|Number} when in set mode the return will be the image
	 *          object itself; in get mode the return will be the width
	 */
	img.prototype.width = function(width) {
		if (width !== undefined) {
			this._imgEl.width = width;
			return this;
		}
		return this._imgEl.width;
	};

	/**
	 * Get or set the visual height of the image
	 * 
	 * @name sap.viz.mvc.Image#height
	 * @param {undefined|Number}
	 *            height the new height of the image
	 * @returns {this|Number} when in set mode the return will be the image
	 *          object itself; in get mode the return will be the height
	 */
	img.prototype.height = function(height) {
		if (height !== undefined) {
			this._imgEl.height = height;
			return this;
		}
		return this._imgEl.height;
	};

	/**
	 * Get the intrinsic height of the image
	 * 
	 * @name sap.viz.mvc.Image#intrinsicHeight
	 * @returns {Number}
	 */
	img.prototype.intrinsicHeight = function() {
		return this._imgEl.naturalHeight;
	};

	/**
	 * Get the intrinsic width of the image
	 * 
	 * @name sap.viz.mvc.Image#intrinsicWidth
	 * @returns {Number}
	 */
	img.prototype.intrinsicWidth = function() {
		return this._imgEl.naturalWidth;
	};

	/**
	 * Get the url of the image
	 * 
	 * @name sap.viz.mvc.Image#url
	 * @returns {String} the url of the image
	 */
	img.prototype.url = function() {
		return this._imgEl.src;
	};

	var _imageCache = {};
	var _id2src = {};
	var _src2ids = {};

	/**
	 * This class defines global shared image manager used for loading external
	 * image. The loading process is asynchronously. The loaded images are
	 * indentified by src urls internally, and can shared within the all viz
	 * application. You must assign an id when loading an image. You can
	 * retrieve the loaded image by id only. the same image can be assigned
	 * multiple ids.
	 * 
	 * @name sap.viz.mvc.ImageManager
	 * @class
	 */
	var ImageManager = {
		/**
		 * Load an image designated by URL. The loading is asynchronized, the
		 * image will be available when the onComplete is called
		 * 
		 * @param {String}
		 *            id the caller-provided Id of the image to be loaded and
		 *            retrieved later.
		 * @param {String}
		 *            url the url of the image to be loaded
		 * @param {Function}
		 *            [onComplete], the on complete callback. the single
		 *            argument is of type boolean indicating the if loaded
		 *            successful
		 */
		loadImage : function(id, url, onComplete) {
			if (id && url) {
				onComplete = onComplete || FuncUtils.noop;
				if (_id2src.hasOwnProperty(id)) {
					if (_imageCache[_id2src[id]]) {
						onComplete(true);
						return;
					}
				}
				var imgEl = new Image();
				imgEl.onabort = imgEl.onerror = function() {
					onComplete(false, {
						id : id,
						url : url
					});
				};
				imgEl.onload = function() {
					var src = imgEl.src;
					if (!_imageCache.hasOwnProperty(src)) {
						var imgObj = new img(imgEl);
						_id2src[id] = src;
						_src2ids[src] = {
							ids : {
								id : id
							},
							length : 1
						};
						_imageCache[src] = imgObj;
					} else {
						_id2src[id] = imgEl.src;
						_src2ids[src].ids[id] = id;
						_src2ids[src].length++;
					}
					onComplete(true, {
						id : id,
						url : url
					});
				}.bind(this);
				imgEl.src = url;
			}
		},
		/**
		 * Load an array of images concurrently. The loading is asynchronized,
		 * the images will be available when the onComplete is called
		 * 
		 * @param {Object[]}
		 *            urls the array of the image url to be loaded. The urls
		 *            should follow the format:
		 * 
		 * <pre>
		 * [ {
		 * 	id : 'IMAGE_ID',
		 * 	url : 'IMAGE_URL'
		 * } ]
		 * </pre>
		 * 
		 * @param {Function}
		 *            [onComplete] the on-complete function callback. the single
		 *            argument is of type boolean indicating the if loaded
		 *            successful
		 */
		loadImages : function(urls, onProgress, onComplete) {
			onProgress = onProgress || FuncUtils.noop;
			onComplete = onComplete || FuncUtils.noop;
			var total = urls.length;
			if (total == 0) {
				onComplete(true);
			} else {
				var count = 0;
				var _stepFunction = function(isSuccessful, imgInfo) {
					count++;
					if (count < total) {
						onProgress(count / total, isSuccessful, imgInfo);
					} else {
						onComplete(true, imgInfo);
					}
				};
				for ( var i = 0, len = urls.length; i < len; i++) {
					ImageManager.loadImage(urls[i].id, urls[i].url, _stepFunction);
				}
			}
		},

		/**
		 * Check if the image has been loaded
		 * 
		 * @param {String}
		 *            id the id of the image to be checked
		 * @returns {Boolean}
		 */
		hasImage : function(id) {
			return _id2src.hasOwnProperty(id);
		},

		/**
		 * Get the loaded image by its id, the caller has to ensure the image is
		 * loaded
		 * 
		 * @param {String}
		 *            id the id of the image to get
		 * @returns {sap.viz.mvc.Image}
		 */
		getImage : function(id) {
			if (_id2src.hasOwnProperty(id)) {
				return _imageCache[_id2src[id]];
			}
		},

		/**
		 * Remove the loaded image from internal cache
		 * 
		 * @param {String}
		 *            id the id of the image
		 */
		disposeImage : function(id) {
			if (_id2src.hasOwnProperty(id)) {
				var src = _id2src[id];
				delete _id2src[id];
				delete _src2ids[src].ids[id];
				_src2ids[src].length--;
				if (!_src2ids[src].length) {
					delete _src2ids[src];
					delete _imageCache[src];
				}
			}
		}
	};
	return ImageManager;
});
define('sap/viz/base/utils/DomUtils',[],
function Setup() {
//	
	var expando = ( '' + Math.random() ).replace( /\D/g, "" ), cache = {/*listener, data*/}, guid = 1;
	var DomWrapper = function(elem) {
		if (arguments.length !==1) {
			throw new Error('One and only one argument is expected.');
		}
		if (typeof elem === 'string') {
			if (elem.length < 2 || elem.charAt(0) !== '#') {
				throw new Error('Only support id selector, please start with #');
			}
			var id = elem.substring(1);
			elem = document.getElementById(id);
//			if (!elem) throw new Error("Can't get an element with id = " + id);
		} else if (typeof elem.jquery === 'string') {
			elem = elem[0];
		}
		if (elem && !elem.nodeType) {
			throw new Error("The argument passed in must be an HTML node.");
		}
		this.elem = elem;
	};
	var utils = {
		css: function(elem, name, value) {
			if (typeof name === 'object') {
				for (var key in name) {
					this.css(elem, key, name[key]);
				}
				return;
			}
			//convert name to camelname
			name = name.replace(/^-ms-/, "ms-").replace(/-([\da-z])/gi, function(all, letter) {
				return ( letter + "" ).toUpperCase();
			});
			if (value === undefined) { //get css value
				var ret, 
					style = elem.style;
				if (window.getComputedStyle) {
					var computed = window.getComputedStyle(elem, null);
					// getPropertyValue is only needed for .css('filter') in IE9, see #12537
					ret = computed.getPropertyValue( name ) || computed[ name ];	
					if (ret === '') {
						if ( !utils.contains(elem.ownerDocument, elem) ){ //a doesn't contain b
							ret = style[name];
						}
					}
				} else if (document.documentElement.currentStyle) {
					ret = elem.currentStyle && elem.currentStyle[name];
					if (ret === null && style && style[name])
						ret = style[name];
				}
				return ret;
			}
			//set css value
			if (typeof name === 'object') {
				for (var key in name) {
					this.css(elem, key, name[key]);
				}
			} else {
				if (!isNaN(value))
					value += 'px';
				elem.style[name] = value;
			}
		},		
		getWindow: function( elem ) {
			return elem !== null && elem == elem.window ?
				elem :
				elem.nodeType === 9 ?
					elem.defaultView || elem.parentWindow :
					false;
		},
		contains: function ( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && adown.contains && adown.contains(bup) );
		},
		bodyOffset: function( body ) {
			var top = body.offsetTop,
				left = body.offsetLeft;
	
			if ( body.offsetTop !== 1 ) { //jQuery.support.doesNotIncludeMarginInBodyOffset
				top  += parseFloat( utils.css(body, "marginTop") ) || 0;
				left += parseFloat( utils.css(body, "marginLeft") ) || 0;
			}
	
			return { top: top, left: left };
		}	
	};
	DomWrapper.prototype = {
		constructor: DomWrapper, 
		get: function(idx) {
			if (idx !== 0) throw new Error("Only get(0) is supported");
			return this.elem;
		},
		css: function(name, value) {
			var ret = utils.css(this.elem, name, value);
			if (value === undefined && typeof name !== 'object') return ret;
			return this;
		},
		/*
		 * Note: the logic of computing width & height in jQuery is very complicated, mainly deal with window and document,
		 * here we call css only to get its value because in most cases we don't query width & height of window or document
		 * 
		 */
		width: function(value) { 
			if (this.elem == this.elem.window || this.elem.nodeType === 9) {
				throw new Error("this method does not support window or document");
			}
			if (arguments.length === 0) {
				var val = this.css('width'),
					num = parseFloat(val);
				return isNaN(num) ? 0 : num;
			}
			return this.css('width', value);
		},
		height: function(value) {
			if (this.elem == this.elem.window || this.elem.nodeType === 9) {
				throw new Error("this method does not support window or document");
			}
			if (arguments.length === 0) {
				var val = this.css('height'),
					num = parseFloat(val);
				return isNaN(num) ? 0 : num;
			}
			return this.css('height', value);
		},
		offset: function() {
			if (arguments.length) throw new Error("Don't support set offset.");
			var docElem, body, win, clientTop, clientLeft, scrollTop, scrollLeft,
				box = { top: 0, left: 0 },
				elem = this.elem,
				doc = elem && elem.ownerDocument;
		
			if ( !doc ) {
				return;
			}
		
			if ( (body = doc.body) === elem ) {
				return utils.bodyOffset( elem );
			}
		
			docElem = doc.documentElement;
		
			// Make sure it's not a disconnected DOM node
			if ( !utils.contains( docElem, elem ) ) {
				return box;
			}
		
			// If we don't have gBCR, just use 0,0 rather than error
			// BlackBerry 5, iOS 3 (original iPhone)
			if ( typeof elem.getBoundingClientRect !== "undefined" ) {
				box = elem.getBoundingClientRect();
			}
			win = utils.getWindow( doc );
			clientTop  = docElem.clientTop  || body.clientTop  || 0;
			clientLeft = docElem.clientLeft || body.clientLeft || 0;
			scrollTop  = win.pageYOffset || docElem.scrollTop;
			scrollLeft = win.pageXOffset || docElem.scrollLeft;
			return {
				top: box.top  + scrollTop  - clientTop,
				left: box.left + scrollLeft - clientLeft
			};			
		},
		attr: function(name, value) {
			if (arguments.length === 1) {
				return this.elem.getAttribute(name);
			} else if (arguments.length === 2){
				this.elem.setAttribute(name, value);
				return this;
			} else {
				throw new Error('Illegal argument number = ' + arguments.length);
			}
		},
//		append: function(child) {
//			if (child instanceof this.constructor) child = child.elem;
//			this.elem.appendChild(child);
//		},
//		prepend: function(newElem) {
//			if (newElem instanceof this.constructor) newElem = newElem.elem;
//			this.elem.insertBefore(newElem, this.elem.firstChild);
//		},
//		insertBefore: function(newElem) {
//			if (newElem instanceof this.constructor) newElem = newElem.elem;
//			if (this.elem.parentNode) {
//				this.elem.parentNode.insertBefore(newElem, this.elem);
//			}
//		},
//		insertAfter: function(newElem) {
//			if (newElem instanceof this.constructor) newElem = newElem.elem;
//			if (this.elem.parentNode) {
//				this.elem.parentNode.insertAfter(newElem, this.elem);
//			}
//		},
		detach: function() {
			if (this.elem && this.elem.parentNode) 
				this.elem.parentNode.removeChild(this.elem);
			this.elem = undefined;
		},
		parent: function() {
			var cur = this.elem;
			while (cur && cur.nodeType !== 9) {
				cur = cur.parentNode;
				if (!cur || cur.nodeType === 1) {
					break;
				}
			}
			return DomUtils(cur);
		},
		offsetParent: function () {
		    function nodeName( elem, name ) {
                return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
            }
            return (function() {
                var offsetParent = this.offsetParent || document.documentElement;
                while ( offsetParent && ( !nodeName( offsetParent, "html" ) && (new DomWrapper(offsetParent)).css("position") === "static" ) ) {
                    offsetParent = offsetParent.offsetParent;
                }
                return offsetParent || document.documentElement;
            }).call(this.elem);
        },
		length: function() {
			return this.elem ? 1 : 0;
		},
		prev: function() {
			do {
				this.elem = this.elem.previousSibling;
			} while (this.elem && this.elem.nodeType !== 1);
			return this;
		},
		next: function() {
			do {
				this.elem = this.elem.nextSibling;
			} while (this.elem && this.elem.nodeType !== 1);
			return this;
		},
		bind: function(type, fn) {
			if (typeof type !== 'string' || typeof fn !== 'function' || arguments.length !== 2) {
				throw new Error('Invalid arguments, you must pass in two arguments, ' +
						'the first one is event type in string, ' +
						'and the second one is a function.');
			}
			// Don't attach events to text/comment nodes 
			if ( this.elem.nodeType === 3 || this.elem.nodeType === 8 ) {
				return;
			}			
			var elem = this.elem,
				id = elem[expando] || (elem[expando] = guid++),
				listener = (cache[id] || (cache[id] = {})).listener;
			if (!listener) {
				listener = cache[id].listener = (function() {
					var handlers = {};
					var listener = function(event) {
						var fns = handlers[event.type];
						if (!fns) {
							return;
						}
						for (var i = 0; i < fns.length; i++) {
							var ret = fns[i].apply(elem, arguments);
							if (ret === false) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					};
					listener.addHandler = function(type, fn) {
						var fns = handlers[type] || (handlers[type] = []);
						fns.push(fn);
					};
					listener.removeHandler = function(type, fn) {
						if (fn === undefined) {
							delete handlers[type];
						} else {
							var fns = handlers[type],
								idx = fns ? fns.indexOf(fn) : -1;
							if (fns && idx >= 0) {
								fns.splice(idx, 1);
								if (fns.length === 0) delete handlers[type];
							}
						}
					};
					listener.clean = function() {
					  var ret = [];
						for (var type in handlers) {
						  ret.push(type);
							delete handlers[type];
						}
						return ret;
					};
					listener.listeningType = function(type) {
						return handlers[type] !== undefined;
					};
					listener.isEmpty = function(typeToBeCheck) {
					  if (arguments.length === 0){
					    for (var type in handlers) {
                return false;
              }
              return true;  
					  }else{
					    return handlers[typeToBeCheck] === undefined;
					  }
						
					};
					
					return listener;
				})();
			}
			if (!listener.listeningType(type)) {
				if (elem.addEventListener) {
					elem.addEventListener(type, listener, false);
				} else if (elem.attachEvent) {
					elem.attachEvent("on" + type, listener);
				}
			}
			listener.addHandler(type, fn);
		},
		unbind: function(type, fn) {
			if ((arguments.length > 0 && typeof type !== 'string') || arguments.length > 2 || (arguments.length ===2 && typeof fn !== 'function')) {
				throw new Error('Invalid arguments, you must pass in one or two arguments, ' +
						'the first one (mandatory) is event type in string, ' +
						'and the second one (optional) is a function.');
			}
			var elem = this.elem,
				id = elem[expando],
				listener = id ? (cache[id] && cache[id].listener) : undefined;
			if (!listener) return;
			var typeToBeChecked;
			if (arguments.length === 0) {//remove all events;
				typeToBeChecked = listener.clean();
			} else {
				listener.removeHandler(type, fn);
				typeToBeChecked = [type];
			}
			for(var i = 0, len = typeToBeChecked.length; i < len; i++){
			  var typeIter = typeToBeChecked[i];
  			if (listener.isEmpty(typeIter)) {
          if (elem.removeEventListener) {
            elem.removeEventListener(typeIter, listener, false);
          } else if (elem.detachEvent) {
            elem.detachEvent("on" + typeIter, listener);
          }
        }  
			}
			if (listener.isEmpty()) {
			  delete cache[id].listener;
			}
		},
		data: function(name, value) {
			var elem = this.elem,
				id = elem[expando] || (elem[expando] = guid++),
				data = (cache[id] || (cache[id] = {})).data;
			if (value === undefined && !data) return;
			if (typeof data !== 'object') {
				data = cache[id].data = {};
			}
			if (typeof name === 'object') {
				for (var key in name) {
					this.data(key, name[key]);
				}
				return this;
			}
			if (value === undefined) { //get
				return data[name];
			}
			data[name] = value;
			return this;
		},
		removeData: function(name) {
			var elem = this.elem,
				id = elem[expando];
			if (!id || !cache[id]) return;
			var data = cache[id].data;
			if (!data || !data[name]) return;
			delete data[name];
			//delete data if it's empty
			var empty = true;
			for (var i in data) {
				empty = false;
				break;
			}
			if (empty) {
				delete cache[id].data;
			}
			//delete cache if it's empty
			empty = true;
			for (var i in cache[id]) {
				empty = false;
				break;
			}
			if (empty) {
				delete cache[id];
			}
		}
	};
	var DomUtils = function(elem) {
//		if (elem instanceof DomWrapper) return elem;
		var wrapper = new DomWrapper(elem);
		return wrapper;
	};
	return (DomUtils);
});
define('sap/viz/base/UADetector',[],

function Setup() {
	var devicePixRatio = window.devicePixelRatio || 1;
	var versionSearchString;
	var searchString = function(data) {
		for ( var i = 0; i < data.length; i++) {
			var dataString = data[i].string;
			var dataProp = data[i].prop;
			versionSearchString = data[i].versionSearch || data[i].identity;
			if (dataString) {
				if (dataString.indexOf(data[i].subString) != -1) {
					return data[i].identity;
				}
			} else if (dataProp) {
				return data[i].identity;
			}
		}
	};
	var seps = [ ';', ' ' ];
	var searchVersion = function(dataString) {
		var index = dataString.indexOf(versionSearchString);
		if (index == -1)
			return;
		var versionStr = dataString.substring(index + versionSearchString.length + 1);
		var i = 0, l = seps.length, sepIndex = -1;
		while (sepIndex === -1 && i < l)
			sepIndex = versionStr.indexOf(seps[i++]);
		if (sepIndex !== -1)
			versionStr = versionStr.slice(0, sepIndex);
		return versionStr;
	};
	var dataBrowser = [ {
		string : navigator.userAgent,
		subString : "Chrome",
		identity : "Chrome"
	}, {
		string : navigator.userAgent,
		subString : "OmniWeb",
		versionSearch : "OmniWeb/",
		identity : "OmniWeb"
	}, {
		string : navigator.userAgent,
		subString : "Safari",
		identity : "Safari",
		versionSearch : "Version"
	}, {
		string : navigator.userAgent,
		subString : "Apple",
		identity : "UIWebView",
		versionSearch : "AppleWebKit"
	}, {
		prop : window.opera,
		identity : "Opera",
		versionSearch : "Version"
	}, {
		string : navigator.vendor,
		subString : "iCab",
		identity : "iCab"
	}, {
		string : navigator.vendor,
		subString : "KDE",
		identity : "Konqueror"
	}, {
		string : navigator.userAgent,
		subString : "Firefox",
		identity : "Firefox"
	}, {
		string : navigator.vendor,
		subString : "Camino",
		identity : "Camino"
	}, {// for newer Netscapes (6+)
		string : navigator.userAgent,
		subString : "Netscape",
		identity : "Netscape"
	}, {
		string : navigator.userAgent,
		subString : "MSIE",
		identity : "Explorer",
		versionSearch : "MSIE"
	}, {
		string : navigator.userAgent,
		subString : "Gecko",
		identity : "Mozilla",
		versionSearch : "rv"
	}, {// for older Netscapes (4-)
		string : navigator.userAgent,
		subString : "Mozilla",
		identity : "Netscape",
		versionSearch : "Mozilla"
	} ];

	var dataOS = [ {
		string : navigator.platform,
		subString : "Win",
		identity : "Windows"
	}, {
		string : navigator.platform,
		subString : "Mac",
		identity : "Mac"
	}, {
		string : navigator.userAgent,
		subString : "iPhone",
		identity : "iPhone/iPod"
	}, {
		string : navigator.userAgent,
		subString : "iPad",
		identity : "iPad"
	}, {
		string : navigator.platform,
		subString : "Linux",
		identity : "Linux"
	} ];

	var dataRenderEngine = [ {
		string : navigator.userAgent,
		subString : "Presto",
		identity : "Presto"
	}, {
		string : navigator.userAgent,
		subString : "KHTML",
		identity : "KHTML"
	}, {
		string : navigator.userAgent,
		subString : "Gecko",
		identity : "Gecko"
	}, {
		string : navigator.userAgent,
		subString : "Trident",
		identity : "Trident"
	} ];
	
	var dataMobile = [{
		string : navigator.userAgent,
		subString : 'Android',
		identity : 'Android',
	}, {
		string : navigator.userAgent,
		subString : 'iPhone',
		identity : 'iPhone'
	}, {
		string : navigator.userAgent,
		subString : 'iPad',
		identity : 'iPad'
	} ];
	
	var _userAgent = searchString(dataBrowser) || "An unknown browser", _version = searchVersion(navigator.userAgent)
			|| searchVersion(navigator.appVersion) || "an unknown version", _isIE = searchString(dataBrowser) === "Explorer", _isFirefox = searchString(dataBrowser) === 'Firefox', _isChrome = searchString(dataBrowser) === 'Chrome', _isSafari = searchString(dataBrowser) === 'Safari', _isUIWebView = searchString(dataBrowser) === 'UIWebView', _os = searchString(dataOS)
			|| "an unknown OS", _renderEngine = searchString(dataRenderEngine) || "An unknown RenderEngine",  _mobile = searchString(dataMobile);
	var UADetector = {
		userAgent : function() {
			return _userAgent;
		},
		version : function() {
			return _version;
		},
		isIE : function() {
			return _isIE;
		},
		isFirefox : function() {
			return _isFirefox;
		},
		isChrome : function() {
			return _isChrome;
		},
		isSafari : function() {
			return _isSafari;
		},
		isUIWebView : function() {
			return _isUIWebView;
		},
		os : function() {
			return _os;
		},
		devicePixelRatio : function() {
			return devicePixRatio;
		},
		renderEngine : function() {
			return _renderEngine;
		},
		isMobile : function(){
			return _mobile !== undefined;
		}
	};
	return (UADetector);
});
define('sap/viz/base/utils/LinkedHashSet',['sap/viz/base/utils/FunctionUtils','sap/viz/base/utils/TypeUtils'],
function Setup(FuncUtils, TypeUtils) {

	function hasNextInOrder() {
		this._cursor = this._cursor.next;
		return this._cursor !== this._sentinel;
	}

	function hasNextInReverse() {
		this._cursor = this._cursor.prev;
		return this._cursor !== this._sentinel;
	}
	/**
	 * Iterator for LinkedHashSet, to get an iterator for a linked hash Set
	 * instance, use {@link sap.viz.base.utils.LinkedHashSet#iterator}
	 * 
	 * @name sap.viz.base.utils.LinkedHashSet.Iterator
	 * @constructor
	 */
	function Iterator(lhs, reverseOrder) {
		this._lhs = lhs;
		this._sentinel = this._lhs._head;
		this._cursor = this._sentinel;
		if (reverseOrder) {
			this.hasNext = hasNextInReverse;
		} else {
			this.hasNext = hasNextInOrder;
		}
	}

	var proto = Iterator.prototype;

	/**
	 * Check and move to the next item
	 * 
	 * @name sap.viz.base.utils.LinkedHashSet.Iterator#hasNext
	 * @function
	 * @returns {Boolean}
	 */
	proto.hasNext = FuncUtils.noop;

	/**
	 * Get the next item, should be used in cooperated with
	 * {@link sap.viz.base.utils.LinkedHashSet#hasNext}
	 * 
	 * @name sap.viz.base.utils.LinkedHashSet.Iterator#next
	 * @function
	 * @returns {undefined|Object}
	 */
	proto.next = function() {
		return this._cursor.value;
	};

	/**
	 * Remove the current item from LinkedHashSet, this method is supposed to be
	 * called only once during each iteration, otherwise the internal state will
	 * get broken.
	 * 
	 * @name sap.viz.base.utils.LinkedHashSet.Iterator#remove
	 * @function
	 */
	proto.remove = function() {
		// move the cursor back one step
		if (this._cursor !== this._sentinel) {
			var item = this._cursor.value;
			this._cursor = this._cursor.prev;
			return this._lhs.remove(item);
		}
	};

	/**
	 * Create an empty LinedHashSet, most of the time you have to specify a
	 * hasher function used to calculate the hash value of each added item. The
	 * default implementation just uses the string representation of the item.
	 * 
	 * @name sap.viz.base.utils.LinedHashSet
	 * @constructor
	 * @param {Function}
	 *            (hasher) function used to calculate the hash value of each
	 *            added item, default is String.
	 */
	var LinedHashSet = function(hasher) {
		this._hash = hasher || String;
		this._head = {
			value : undefined,
			next : undefined,
			prev : undefined
		};
		this._map = {};
		this._length = 0;
		this._head.next = this._head.prev = this._head;
	};
	proto = LinedHashSet.prototype;

	/**
	 * Add one item to the set. Old item with same hash will be replaced and
	 * returned.
	 * 
	 * @name sap.viz.base.utils.LinedHashSet#add
	 * @function
	 * @param {Object}
	 *            item the item to be added
	 * @returns {null|Object} old item if exists.
	 */
	proto.add = function(item) {
		var m = this._map;
		var ret = null;
		var key = this._hash(item);
		if (!m.hasOwnProperty(key)) {
			var node = {
				prev : null,
				value : item,
				next : null
			}, head = this._head, last = head.prev;
			m[key] = head.prev = node;
			node.prev = last;
			node.next = head;
			last.next = node;
			this._length++;
		} else {
			ret = m[key].value;
			m[key].value = item;
		}
		return ret;
	};
	/**
	 * Add items from another LinkedHashSet, the two hash set must share same
	 * hash function.
	 * 
	 * @name sap.viz.base.utils.LinedHashSet#addAll
	 * @function
	 * @param {sap.viz.base.utils.LinedHashSet}
	 *            other another LinedHashSet
	 * @returns {[]} array of replaced items
	 */
	proto.addAll = function(other) {
		var itr = LinedHashSet.iterator();
		var ret = [], added;
		while (itr.hasNext()) {
			if (added = this.add(itr.next()))
				ret.push(added);
		}
		return ret;
	};

	/**
	 * Insert item before other existing one, if the item exists, it will be
	 * removed first and insert then.
	 * 
	 * @name sap.viz.base.utils.LinedHashSet#insertBefore
	 * @function
	 * @param {Object}
	 *            item the item to be inserted
	 * @param {Object}
	 *            before target item
	 * @returns {Object} the value just inserted
	 */
	proto.insertBefore = function(item, before) {
		var m = this._map, hash = this._hash;
		var key = hash(item), beforeKey = hash(before);
		if (m.hasOwnProperty(beforeKey) && beforeKey !== key) {
			if (m.hasOwnProperty(key)) {
				this.remove(item);
			}
			var nnode = {
				prev : null,
				value : item,
				next : null
			};
			var bnode = m[beforeKey];
			nnode.prev = bnode.prev;
			bnode.prev.next = nnode;
			nnode.next = bnode;
			bnode.prev = nnode;
			m[key] = nnode;
			this._length++;
			return item;
		}
	};

	/**
	 * Insert item after other existing one, if the item exists, it will be
	 * removed first and insert then.
	 * 
	 * @name sap.viz.base.utils.LinedHashSet#insertAfter
	 * @function
	 * @param {Object}
	 *            item the item to be inserted
	 * @param {Object}
	 *            after target item
	 * @returns {Object} the value just inserted
	 */
	proto.insertAfter = function(item, after) {
		var m = this._map, hash = this._hash;
		var key = hash(item), afterKey = hash(after);
		if (m.hasOwnProperty(afterKey) && afterKey !== key) {
			if (m.hasOwnProperty(key)) {
				this.remove(item);
			}
			var nnode = {
				prev : null,
				value : item,
				next : null
			};
			var anode = m[afterKey];
			nnode.prev = anode;
			nnode.next = anode.next;
			anode.next.prev = nnode;
			anode.next = nnode;
			m[key] = nnode;
			this._length++;
			return item;
		}
	};

	/**
	 * Replace the existing item with given item, if the given item exists, it
	 * will be removed first.
	 * 
	 * @name sap.viz.base.utils.LinedHashSet#replace
	 * @function
	 * @param {Object}
	 *            item the given item
	 * @param {Object}
	 *            target target item to be replaced
	 * @returns {Object} the item replaced
	 */
	proto.replace = function(item, target) {
		var m = this._map, hash = this._hash;
		var key = hash(item), targetKey = hash(target);
		if (m.hasOwnProperty(targetKey) && targetKey !== key) {
			if (m.hasOwnProperty(key)) {
				this.remove(item);
			}
			var nnode = {
				prev : null,
				value : item,
				next : null
			};
			var rnode = m[targetKey];
			nnode.prev = rnode.prev;
			nnode.next = rnode.next;
			rnode.prev.next = nnode;
			rnode.next.prev = nnode;
			m[key] = nnode;
			delete m[targetKey];
			return rnode.value;
		}
	};
	/**
	 * Get first added item. If set is empty, undefined will be returned.
	 * 
	 * @name sap.viz.base.utils.LinedHashSet#first
	 * @function
	 * 
	 * @returns {undefined|Object}
	 */
	proto.first = function() {
		return this._head.next.value;
	};
	/**
	 * Get last added item. If set is empty, undefined will be returned.
	 * 
	 * @name sap.viz.base.utils.LinedHashSet#last
	 * @function
	 * 
	 * @returns {undefined|Object}
	 */
	proto.last = function() {
		return this._head.prev.value;
	};

	/**
	 * Get item next to the item specified, If the specified item doesn't exist
	 * or is the last one or the set is empty, undefined will be returned.
	 * 
	 * @name sap.viz.base.utils.LinedHashSet#next
	 * @function
	 * @param {Object}
	 *            item
	 * @returns {undefined|Object}
	 */
	proto.next = function(item) {
		var ret;
		if (ret = this._map[this._hash(item)]) {
			return ret.next.value;
		}
		return ret;
	};
	/**
	 * Get item previous to the item specified, If the specified item doesn't
	 * exist or is the first one or the set is empty, undefined will be
	 * returned.
	 * 
	 * @name sap.viz.base.utils.LinedHashSet#prev
	 * @function
	 * @param {Object}
	 *            item
	 * @returns {undefined|Object}
	 */
	proto.prev = function(item) {
		var ret;
		if (ret = this._map[this._hash(item)]) {
			return ret.prev.value;
		}
		return ret;
	};

	/**
	 * Move the specified item to the first of the linked list.
	 * 
	 * @name sap.viz.base.utils.LinedHashSet#moveToFirst
	 * @function
	 * @param {Object}
	 *            item
	 */
	proto.moveToFirst = function(item) {
		var node;
		if (node = this._map[this._hash(item)]) {
			var first = this._head.next;
			if (first !== node) {
				node.prev.next = node.next;
				node.next.prev = node.prev;

				node.next = first;
				node.prev = first.prev;
				first.prev.next = node;
				first.prev = node;
			}
		}
	};

	/**
	 * Move the specified item to the last of the linked list.
	 * 
	 * @name sap.viz.base.utils.LinedHashSet#moveToLast
	 * @function
	 * @param {Object}
	 *            item
	 */
	proto.moveToLast = function(item) {
		var node;
		if (node = this._map[this._hash(item)]) {
			var last = this._head.prev;
			if (last !== node) {
				node.prev.next = node.next;
				node.next.prev = node.prev;

				node.prev = last;
				node.next = last.next;
				last.next.prev = node;
				last.next = node;
			}
		}
	};

	/**
	 * A convenient method to get the item for given hash
	 * 
	 * @name sap.viz.base.utils.LinedHashSet#has
	 * @function
	 * @param {String}
	 *            hash
	 * @returns {Boolean}
	 */
	proto.getByHash = function(hash) {
		var ret = this._map[hash];
		return ret ? ret.value : undefined;
	};

	/**
	 * Check the containment of the specified item
	 * 
	 * @name sap.viz.base.utils.LinedHashSet#has
	 * @function
	 * @param {Object}
	 *            item
	 * @returns {Boolean}
	 */
	proto.has = function(item) {
		return this._map.hasOwnProperty(this._hash(item));
	};
	/**
	 * Remove the item from the set, if the item is not in the set, Null will be
	 * returned.
	 * 
	 * @name sap.viz.base.utils.LinedHashSet#remove
	 * @function
	 * @param {Object}
	 *            item
	 * @returns {Null|Object} the removed item
	 */
	proto.remove = function(item) {
		var m = this._map, key = this._hash(item);
		var ret = null;
		if (m.hasOwnProperty(key)) {
			var node = m[key];
			ret = node.value;

			node.prev.next = node.next;
			node.next.prev = node.prev;

			delete m[key];
			this._length--;
		}
		return ret;
	};
	/**
	 * Remove all items from the set
	 * 
	 * @name sap.viz.base.utils.LinedHashSet#purgeAll
	 * @function
	 */
	proto.purgeAll = function() {
		this._map = {};
		// reset the sentinel
		this._head.next = this._head.prev = this._head;
		this._length = 0;
	};
	/**
	 * Whether the set is empty
	 * 
	 * @name sap.viz.base.utils.LinedHashSet#isEmpty
	 * @function
	 * 
	 * @returns {Boolean}
	 */
	proto.isEmpty = function() {
		return this._length === 0;
	};
	/**
	 * Length of the set
	 * 
	 * @name sap.viz.base.utils.LinedHashSet#length
	 * @function
	 * @returns {Integer}
	 */
	proto.length = function() {
		return this._length;
	};
	/**
	 * Get the iterator of the set
	 * 
	 * @name sap.viz.base.utils.LinedHashSet#iterator
	 * @function
	 * @param {Boolean}
	 *            reverseOrder whether iterate in reverse order
	 * @returns {sap.viz.base.utils.LinedHashSet.Iterator}
	 */
	proto.iterator = function(reverseOrder) {
		return new Iterator(this, reverseOrder || false);
	};

	/**
	 * Return the contents of the set as an array, the order conforms to the
	 * traversal order.
	 * 
	 * @name sap.viz.base.utils.LinedHashSet#items
	 * @function
	 * 
	 * @returns {Array}
	 */
	proto.items = function() {
		var ret = [], c = head = this._head;
		while ((c = c.next) !== head) {
			ret.push(c.value);
		}
		return ret;
	};
	return LinedHashSet;
});
define('sap/viz/mvc/GestureDetector',['sap/viz/base/Class','sap/viz/base/utils/FunctionUtils'],
function Setup(Class, FuncUtils) {
	var noop = FuncUtils.noop;
	/**
	 * Possible State. Gesture Detector is ready to detect gesture
	 * 
	 * @name sap.viz.mvc.GestureDetector.TransitionState#Possible
	 * @field
	 * 
	 */
	var Possible = 0;
	/**
	 * Began State. Gesture Detector is ready to detect continuous gesture
	 * 
	 * @name sap.viz.mvc.GestureDetector.TransitionState#Began
	 * @field
	 * 
	 */
	var Began = 1;
	/**
	 * Began State. Gesture Detector is continuous to detect continuous gesture
	 * 
	 * @name sap.viz.mvc.GestureDetector.TransitionState#Changed
	 * @field
	 * 
	 */
	var Changed = 2;
	/**
	 * Recognized State. Discrete Gesture is detected
	 * 
	 * @name sap.viz.mvc.GestureDetector.TransitionState#Recognized
	 * @field
	 * 
	 */
	var Recognized = 3; // Recognized == Ended
	/**
	 * Ended State. Continuous Gesture is detected
	 * 
	 * @name sap.viz.mvc.GestureDetector.TransitionState#Ended
	 * @field
	 * 
	 */
	var Ended = 3;
	/**
	 * Ended State. Continuous Gesture is stop to detected
	 * 
	 * @name sap.viz.mvc.GestureDetector.TransitionState#Canceled
	 * @field
	 * 
	 */
	var Canceled = 4;
	/**
	 * Ended State. Detector fails to detect in current touch sequence
	 * 
	 * @name sap.viz.mvc.GestureDetector.TransitionState#Failed
	 * @field
	 * 
	 */
	var Failed = 5;

	var GestureDetector = Class
			.define({
				/**
				 * The base abstract gesture detector class
				 * 
				 * @name sap.viz.mvc.GestureDetector
				 * @constructor
				 */
				constructor : function() {
					this._grEnabled = true;
					this._grTouchTotal = 0;
					this._grTouchTracker = {};
					this._grActions = [];
					this._grCancelTouches = true;
					var state = Possible;
					Object.defineProperties(this, {
						'state' : {
							get : function() {
								return state;
							},
							set : function(value) {
								switch (value) {
								case Possible:
									state = Possible;
									break;
								case Began:
									state = Began;
									this._grActions.forEach(function(action, i) {
										action(this);
									}, this);
									break;
								case Changed:
									if (state === Began) {
										state = Changed;
									}
									this._grActions.forEach(function(action, i) {
										action(this);
									}, this);
									break;
								case Canceled:
									state = Canceled;
									this._grActions.forEach(function(action, i) {
										action(this);
									}, this);
									break;
								case Failed:
									state = Failed;
									break;
								case Ended:
								case Recognized:
									state = value;
									this._grActions.forEach(function(action, i) {
										action(this);
									}, this);
									break;
								}
							}
						},
						'watchedComponent' : {
							value : undefined,
							writable : true,
							enumerable : true
						}
					});
				},

				/**
				 * Add gesture function callback which will get triggered when
				 * gesture is detected. One function instance could only be
				 * added once. The returned value indicates whether the adding
				 * is succeed.
				 * 
				 * @name sap.viz.mvc.GestureDetector#addGestureAction
				 * @function
				 * @param {Function}
				 *            actionFn
				 * @returns {Boolean}
				 */
				addGestureAction : function(actionFn) {
					var actions = this._grActions;
					if (actions.indexOf(actionFn) === -1) {
						actions.push(actionFn);
						return true;
					}
					return false;
				},

				/**
				 * Remove a previous added gesture function callback, the
				 * returned value indicates whether the removing is succeed.
				 * 
				 * @name sap.viz.mvc.GestureDetector#removeGestureAction
				 * @function
				 * @param {Function}
				 *            actionFn, the function to be removed.
				 * @returns {Boolean}
				 */
				removeGestureAction : function(actionFn) {
					var actions = this._grActions, i = actions.indexOf(actionFn);
					if (i > -1) {
						actions.splice(i, 1);
						return true;
					}
					return false;
				},

				/**
				 * Get the location of the gesture, the location is calculated
				 * as the average of the locations of all touches on the screen.
				 * Caution: This function only return meaningful point value IF
				 * and ONLY IF the current state of this gesture detector is in
				 * one of the <b>Recognizing</b> states, a.k.a Began, Changed,
				 * Canceled, Ended, Recognized, otherwise undefined will return.
				 * 
				 * @function
				 * @returns {POINT}
				 */
				globalLocOfGesture : function() {
					var state = this.state;
					if (this._grEnabled
							&& (state === Began || state === Changed || state === Canceled || state === Ended || state === Recognized)) {
						var count = 0;
						var ttracker = this._grTouchTracker, p;
						var x = y = 0;
						for ( var tId in ttracker) {
							p = ttracker[tId].globalXY;
							x += p.x;
							y += p.y;
							count++;
						}
						if (count) {
							return {
								x : x / count,
								y : y / count
							};
						}
					}
				},

				/**
				 * Return an array of identifier of the touches currently
				 * involved in the gesture detection, Caution: This function
				 * only return meaningful array of touches IF and ONLY IF the
				 * current state of this gesture detector is in one of the
				 * <b>Recognizing</b> states, a.k.a Began, Canceled, Ended,
				 * Recognized, otherwise empty array will return.
				 * 
				 * @function
				 * @returns {Array}
				 */
				involvedTouchePoints : function() {
					var ret = [], state = this.state;
					if (this._grEnabled
							&& (state === Began || state === Changed || state === Canceled || state === Ended || state === Recognized)) {
						var ttracker = this._grTouchTracker;
						for ( var tId in ttracker) {
							if(ttracker[tId].globalXY !== undefined){
								ret.push(ttracker[tId].globalXY);
							}
								
						}
					}
					return ret;
				},

				/**
				 * Get the average position of all the touchs on the screen
				 * 
				 * @function
				 * @returns {POINT}
				 */
				globalLocOfTouchPoints : function() {
					var count = 0;
					var ttracker = this._grTouchTracker, p;
					var x = y = 0;
					for ( var tId in ttracker) {
						p = ttracker[tId].globalXY;
						x += p.x;
						y += p.y;
						count++;
					}
					if (count) {
						return {
							x : x / count,
							y : y / count
						};
					}
				},

				/**
				 * Return the number of touches currently on the screen
				 * 
				 * @function
				 * @returns {Number}
				 */
				totalTouches : function() {
					return this._grTouchTotal;
				},

				/**
				 * Get or set whether needs to cancel previous events of the
				 * touches when a gesture detected. Default is yes. The related
				 * logic like bookkeeping of the canceled touches among several
				 * gesture detectors, are currently implemented outside of
				 * gesture detector.
				 * 
				 * @function
				 * @returns {Boolean|this}
				 */
				cancelTouches : function(cancel) {
					if (arguments.length) {
						this._grCancelTouches = cancel ? true : false;
						return this;
					} else {
						return this._grCancelTouches;
					}
				},
				/**
				 * Get or set the <b>enable</b> status of the gesture detector.
				 * If the gesture detector is in detecting a continuous gesture,
				 * it will immediately transit to <b>canceled</b> state.
				 * Default is yes.
				 * 
				 * @function
				 * @returns {Boolean|this}
				 */
				enable : function(enable) {
					if (arguments.length) {
						enable = enable ? true : false;
						if (this._grEnabled !== enable) {
							this._grEnabled = enable;
							if (!enable) {
								if (this.state === Began || this.state === Canceled) {
									this.state = Canceled;
								} else {
									this.state = Failed;
								}
							}
						}
						return this;
					} else {
						return this._grEnabled;
					}
				},

				/**
				 * Process the touch start event of a touch sequence. This
				 * method is not intent to be overridden and is supposed to be
				 * called by the user.
				 * 
				 * @name sap.viz.mvc.GestureDetector#touchBegin
				 * @function
				 * @param {DOMTouchEvent}
				 *            touchStartEvent
				 */
				touchBegin : function(touchStartEvent) {
					var newTouches = touchStartEvent.changedTouches;
					var ttracker = this._grTouchTracker;
					var ownerComp = this.watchedComponent;
					var pagePosition = ownerComp.pagePosition();
					for ( var i = 0, t, len = newTouches.length; i < len; i++) {
						t = newTouches.item(i);
						ttracker[t.identifier] = {
							globalXY : ownerComp.pointTo({
								x : t.pageX - pagePosition.x,
								y : t.pageY - pagePosition.y
							})
						};
						this._grTouchTotal++;
					}
					if (this._grEnabled && (this.state === Possible || this.state === Began || this.state === Changed)) {
						this.doTouchBegin(touchStartEvent);
					}
				},
				/**
				 * Process the touch move event of a touch sequence. This method
				 * is not intent to be overridden and is supposed to be called by
				 * the user.
				 * 
				 * 
				 * @name sap.viz.mvc.GestureDetector#touchMove
				 * @function
				 * @param {DOMTouchEvent}
				 *            touchMoveEvent
				 */
				touchMove : function(touchMoveEvent) {
					if (this._grEnabled && (this.state === Possible || this.state === Began || this.state === Changed)) {
						var movedTouches = touchMoveEvent.changedTouches;
						var ownerComp = this.watchedComponent;
						var pagePosition = ownerComp.pagePosition();
						var ttracker = this._grTouchTracker;
						for ( var i = 0, t, len = movedTouches.length; i < len; i++) {
							t = movedTouches.item(i);
							if (ttracker[t.identifier]) {
								ttracker[t.identifier].globalXY = ownerComp.pointTo({
									x : t.pageX - pagePosition.x,
									y : t.pageY - pagePosition.y
								});
							}
						}
						this.doTouchMove(touchMoveEvent);
					}
				},
				/**
				 * Process the touch end event of a touch sequence. This method
				 * is not intent to be overridden and is supposed to be called by
				 * the user.
				 * 
				 * 
				 * @name sap.viz.mvc.GestureDetector#touchEnd
				 * @function
				 * @param {DOMTouchEvent}
				 *            touchEndEvent
				 */
				touchEnd : function(touchEndEvent) {
					var endedTouches = touchEndEvent.changedTouches;
					var ttracker = this._grTouchTracker;
					var ownerComp = this.watchedComponent;
					var pagePosition = ownerComp.pagePosition();
					for ( var i = 0, t, tId, track, len = endedTouches.length; i < len; i++) {
						t = endedTouches.item(i);
						tId = t.identifier;
						if (track = ttracker[tId]) {
							track.globalXY = ownerComp.pointTo({
								x : t.pageX - pagePosition.x,
								y : t.pageY - pagePosition.y
							});
							this._grTouchTotal--;
						}
					}
					if (this._grEnabled && (this.state === Possible || this.state === Began || this.state === Changed)) {
						this.doTouchEnd(touchEndEvent);
					}
					// Reset the detector only when all fingers lifted and in
					// 'ending' state
					if (!this._grTouchTotal
							&& (this.state === Recognized || this.state === Failed || this.state === Canceled)) {
						this.reset();
					}
				},
				/**
				 * Process the touch cancel event of a touch sequence. This
				 * method is not intent to be override and is supposed to be
				 * called by the user.
				 * 
				 * 
				 * @name sap.viz.mvc.GestureDetector#touchCancel
				 * @function
				 * @param {DOMTouchEvent}
				 *            touchCancelEvent
				 */
				touchCancel : function(touchCancelEvent) {
					var cancelledTouches = touchCancelEvent.changedTouches;
					var ttracker = this._grTouchTracker;
					var ownerComp = this.watchedComponent;
					var pagePosition = ownerComp.pagePosition();
					for ( var i = 0, t, tId, track, len = cancelledTouches.length; i < len; i++) {
						t = cancelledTouches.item(i);
						tId = t.identifier;
						if (track = ttracker[tId]) {
							track.globalXY = ownerComp.pointTo({
								x : t.pageX - pagePosition.x,
								y : t.pageY - pagePosition.y
							});
							this._grTouchTotal--;
						}
					}
					if (this._grEnabled && (this.state === Possible || this.state === Began || this.state === Changed)) {
						this.doTouchCancel(touchCancelEvent);
					}
					// Reset the detector only when all fingers lifted and in
					// 'ending' state
					if (!this._grTouchTotal
							&& (this.state === Recognized || this.state === Failed || this.state === Canceled)) {
						this.reset();
					}
				},
				/**
				 * This method should be overridden in subclass, to handle
				 * actual gesture detection
				 * 
				 * 
				 * @name sap.viz.mvc.GestureDetector#doTouchBegin
				 * @function
				 * @param {DOMTouchEvent}
				 *            touchStartEvent
				 */
				doTouchBegin : noop,
				/**
				 * Gesture Detector uses this method to receive touches in
				 * moving phase of a touch sequence. This method should be
				 * overridden in subclass.
				 * 
				 * 
				 * @name sap.viz.mvc.GestureDetector#doTouchMove
				 * @function
				 * @param {DOMTouchEvent}
				 *            touchMoveEvent
				 */
				doTouchMove : noop,
				/**
				 * This method should be overridden in subclass, to handle
				 * actual gesture detection
				 * 
				 * 
				 * @name sap.viz.mvc.GestureDetector#doTouchEnd
				 * @function
				 * @param {DOMTouchEvent}
				 *            touchEndEvent
				 */
				doTouchEnd : noop,
				/**
				 * This method should be overridden in subclass, to handle
				 * actual gesture detection
				 * 
				 * 
				 * @name sap.viz.mvc.GestureDetector#doTouchCancel
				 * @function
				 * @param {DOMTouchEvent}
				 *            touchCancelEvent
				 */
				doTouchCancel : noop,
				/**
				 * Reset the state of this gesture detector. Subclass SHOULD NOT
				 * call this method. Override it if necessary.
				 * 
				 * 
				 * @name sap.viz.mvc.GestureDetector#reset
				 * @function
				 */
				reset : function() {
					this.state = Possible;
					this._grTouchTracker = {};
				}
			});

	/**
	 * The mask used to specify gesture detector's state
	 * 
	 * @name sap.viz.mvc.GestureDetector.TransitionState
	 * @class
	 */
	GestureDetector.TransitionState = {
		Possible : Possible,
		Began : Began,
		Changed : Changed,
		Recognized : Recognized,
		Ended : Ended,
		Canceled : Canceled,
		Failed : Failed
	};
	return GestureDetector;
});
define('sap/viz/base/Math',['sap/viz/base/UADetector'],
function Setup(UADetector) {
    var OptMath = {
        PI : Math.PI,
        E : Math.E,
        LN10 : Math.LN10,
        LN2 : Math.LN2,
        LOG2E : Math.LOG2E,
        LOG10E : Math.LOG10E,
        SQRT1_2 : Math.SQRT1_2,
        SQRT2 : Math.SQRT2,

        abs : (function() {
            if(UADetector.isSafari() || (UADetector.isIE() && parseFloat(UADetector.version()) < 9)) {
                return function(n) {
                    return n < 0 ? -n : n;
                };
            } else {
                return Math.abs;
            }
        })(),

        acos : (function() {
            return Math.acos;
        })(),

        asin : (function() {
            return Math.asin;
        })(),

        atan : (function() {
            return Math.atan;
        })(),

        atan2 : (function() {
            return Math.atan2;
        })(),

        /**
         * Get the ceil of a number.
         *
         * @name sap.viz.base.Math#ceil
         * @function
         * @param {n}
         *            n must not be NaN
         * @returns {Number} the ceil of number
         */
        ceil : (function() {
            // if (UADetector.isFirefox()) {
            // return function(n) {
            // var i = n | 0;
            // return n <= 0 ? i : (i == n ? i : i + 1);
            // };
            // }
            // else if (UADetector.isChrome()) {
            // return function(n) {
            // return n <= 0 ? n | 0 : Math.ceil(n);
            // };
            // }
            // else {
            return Math.ceil;
            // }
        })(),

        cos : (function() {
            return Math.cos;
        })(),

        exp : (function() {
            return Math.exp;
        })(),

        /**
         * Get the floor of a number.
         *
         * @name sap.viz.base.Math#floor
         * @function
         * @param {n}
         *            n must not be NaN
         * @returns {Number} the floor of number
         */
        floor : (function() {
            // if(UADetector.isFirefox()) {
            // return function(n) {
            // var a = n | 0;
            // return n < 0 ? (a == n ? a : a - 1) : a;
            // };
            // } else
            return Math.floor;
        })(),

        log : (function() {
            return Math.log;
        })(),

        /**
         * Get the maximum number in an array.
         *
         * @name sap.viz.base.Math#max
         * @function
         * @param {array}
         *            array must be an array of Number
         * @returns {Number} the maximum number in array
         */
        max : (function() {
            // if(UADetector.isIE() && parseFloat(UADetector.version()) < 9) {
                return Math.max;
            // } else
                // return function() {
                    // var max = arguments[0];
                    // var length = arguments.length;
                    // for(var i = 1; i < length; i++) {
                        // max = arguments[i] > max ? arguments[i] : max;
                    // }
                    // return max;
                // };
        })(),

        /**
         * Get the minimum number in an array.
         *
         * @name sap.viz.base.Math#min
         * @function
         * @param {array}
         *            array must be an array of Number
         * @returns {Number} the minimum number in array
         */
        min : (function() {
            // if(UADetector.isIE() && parseFloat(UADetector.version()) < 9) {
                return Math.min;
			// }
			// else return function(){
		        // var min = arguments[0];
		        // var length = arguments.length;
				// for (var i=1; i<length; i++){
					// min = arguments[i] > min ? min : arguments[i];
				// }
				// return min;
            // };
        })(),

        pow : (function() {
            return Math.pow;
        })(),

        random : (function() {
            return Math.random;
        })(),

        /**
         * Get the round of a number.
         *
         * @name sap.viz.base.Math#round
         * @function
         * @param {n}
         *            n must not be NaN
         * @returns {Number} the round of number
         */
        round : (function() {
            return Math.round;
            //			if(UADetector.isFirefox() || (UADetector.isIE() && parseFloat(UADetector.version()) < 9)){
            //				return function(n) {
            //					return (n >= 0) ? (n + 0.5) | 0 : (n - 0.4999999999999999) | 0;
            //				};
            //			}
            //			else if(UADetector.isChrome()){
            //				return function(n) {
            //					return Math.floor(n + 0.5);
            //				};
            //			}
            //			else return Math.round;
        })(),

        sin : (function() {
            return Math.sin;
        })(),

        sqrt : (function() {
            return Math.sqrt;
        })(),

        tan : (function() {
            return Math.tan;
        })()
    };
    return OptMath;
});
define('sap/viz/base/utils/SVGTransformParser',['sap/viz/base/Logger','sap/viz/base/utils/FunctionUtils'],
function Setup(LOG, FuncUtils) {

	var transformMatrixMultiply = function(m1, m2) {
		var result = [];
		for ( var i = 0; i < 3; i++) {
			result[i] = [];
			for ( var j = 0; j < 3; j++) {
				var sum = 0;
				for ( var k = 0; k < 3; k++) {
					sum += m1[i][k] * m2[k][j];
				}
				result[i][j] = sum;
			}
		}
		return result;
	};

	var buildRotateMatrix = function(args) {
		var cosA = Math.cos(args.rad);
		var sinA = Math.sin(args.rad);
		return [ [ cosA, -sinA, -args.cx * cosA + args.cy * sinA + args.cx ],
				[ sinA, cosA, -args.cx * sinA - args.cy * cosA + args.cy ], [ 0, 0, 1 ] ];
	};

	var _dbg_withtrace = false;
	var _dbg_string = '';

	function __dbg_print(text) {
		_dbg_string += text + '\n';
	}

	function __lex(info) {
		var state = 0;
		var match = -1;
		var match_pos = 0;
		var start = 0;
		var pos = info.offset + 1;

		do {
			pos--;
			state = 0;
			match = -2;
			start = pos;

			if (info.src.length <= start)
				return 33;

			do {

				switch (state) {
				case 0:
					if ((info.src.charCodeAt(pos) >= 9 && info.src.charCodeAt(pos) <= 10)
							|| info.src.charCodeAt(pos) == 13 || info.src.charCodeAt(pos) == 32)
						state = 1;
					else if (info.src.charCodeAt(pos) == 40)
						state = 2;
					else if (info.src.charCodeAt(pos) == 41)
						state = 3;
					else if (info.src.charCodeAt(pos) == 43 || info.src.charCodeAt(pos) == 45)
						state = 4;
					else if (info.src.charCodeAt(pos) == 44)
						state = 5;
					else if (info.src.charCodeAt(pos) == 46)
						state = 6;
					else if ((info.src.charCodeAt(pos) >= 48 && info.src.charCodeAt(pos) <= 57))
						state = 7;
					else if (info.src.charCodeAt(pos) == 69 || info.src.charCodeAt(pos) == 101)
						state = 8;
					else if (info.src.charCodeAt(pos) == 109)
						state = 15;
					else if (info.src.charCodeAt(pos) == 114)
						state = 16;
					else if (info.src.charCodeAt(pos) == 115)
						state = 17;
					else if (info.src.charCodeAt(pos) == 116)
						state = 18;
					else
						state = -1;
					break;

				case 1:
					state = -1;
					match = 1;
					match_pos = pos;
					break;

				case 2:
					state = -1;
					match = 7;
					match_pos = pos;
					break;

				case 3:
					state = -1;
					match = 8;
					match_pos = pos;
					break;

				case 4:
					state = -1;
					match = 3;
					match_pos = pos;
					break;

				case 5:
					state = -1;
					match = 6;
					match_pos = pos;
					break;

				case 6:
					state = -1;
					match = 5;
					match_pos = pos;
					break;

				case 7:
					if ((info.src.charCodeAt(pos) >= 48 && info.src.charCodeAt(pos) <= 57))
						state = 7;
					else
						state = -1;
					match = 2;
					match_pos = pos;
					break;

				case 8:
					state = -1;
					match = 4;
					match_pos = pos;
					break;

				case 9:
					state = -1;
					match = 12;
					match_pos = pos;
					break;

				case 10:
					state = -1;
					match = 9;
					match_pos = pos;
					break;

				case 11:
					state = -1;
					match = 10;
					match_pos = pos;
					break;

				case 12:
					state = -1;
					match = 14;
					match_pos = pos;
					break;

				case 13:
					state = -1;
					match = 11;
					match_pos = pos;
					break;

				case 14:
					state = -1;
					match = 13;
					match_pos = pos;
					break;

				case 15:
					if (info.src.charCodeAt(pos) == 97)
						state = 19;
					else
						state = -1;
					break;

				case 16:
					if (info.src.charCodeAt(pos) == 111)
						state = 37;
					else
						state = -1;
					break;

				case 17:
					if (info.src.charCodeAt(pos) == 99)
						state = 20;
					else if (info.src.charCodeAt(pos) == 107)
						state = 21;
					else
						state = -1;
					break;

				case 18:
					if (info.src.charCodeAt(pos) == 114)
						state = 38;
					else
						state = -1;
					break;

				case 19:
					if (info.src.charCodeAt(pos) == 116)
						state = 22;
					else
						state = -1;
					break;

				case 20:
					if (info.src.charCodeAt(pos) == 97)
						state = 23;
					else
						state = -1;
					break;

				case 21:
					if (info.src.charCodeAt(pos) == 101)
						state = 24;
					else
						state = -1;
					break;

				case 22:
					if (info.src.charCodeAt(pos) == 114)
						state = 26;
					else
						state = -1;
					break;

				case 23:
					if (info.src.charCodeAt(pos) == 108)
						state = 28;
					else
						state = -1;
					break;

				case 24:
					if (info.src.charCodeAt(pos) == 119)
						state = 29;
					else
						state = -1;
					break;

				case 25:
					if (info.src.charCodeAt(pos) == 110)
						state = 30;
					else
						state = -1;
					break;

				case 26:
					if (info.src.charCodeAt(pos) == 105)
						state = 31;
					else
						state = -1;
					break;

				case 27:
					if (info.src.charCodeAt(pos) == 116)
						state = 32;
					else
						state = -1;
					break;

				case 28:
					if (info.src.charCodeAt(pos) == 101)
						state = 9;
					else
						state = -1;
					break;

				case 29:
					if (info.src.charCodeAt(pos) == 88)
						state = 10;
					else if (info.src.charCodeAt(pos) == 89)
						state = 11;
					else
						state = -1;
					break;

				case 30:
					if (info.src.charCodeAt(pos) == 115)
						state = 33;
					else
						state = -1;
					break;

				case 31:
					if (info.src.charCodeAt(pos) == 120)
						state = 12;
					else
						state = -1;
					break;

				case 32:
					if (info.src.charCodeAt(pos) == 101)
						state = 13;
					else
						state = -1;
					break;

				case 33:
					if (info.src.charCodeAt(pos) == 108)
						state = 34;
					else
						state = -1;
					break;

				case 34:
					if (info.src.charCodeAt(pos) == 97)
						state = 35;
					else
						state = -1;
					break;

				case 35:
					if (info.src.charCodeAt(pos) == 116)
						state = 36;
					else
						state = -1;
					break;

				case 36:
					if (info.src.charCodeAt(pos) == 101)
						state = 14;
					else
						state = -1;
					break;

				case 37:
					if (info.src.charCodeAt(pos) == 116)
						state = 39;
					else
						state = -1;
					break;

				case 38:
					if (info.src.charCodeAt(pos) == 97)
						state = 25;
					else
						state = -1;
					break;

				case 39:
					if (info.src.charCodeAt(pos) == 97)
						state = 27;
					else
						state = -1;
					break;

				}

				pos++;

			} while (state > -1);

		} while (1 > -1 && match == 1);

		if (match > -1) {
			info.att = info.src.substr(start, match_pos - start);
			info.offset = match_pos;

		} else {
			info.att = new String();
			match = -1;
		}

		return match;
	}

	/* Pop-Table */
	var pop_tab = new Array(new Array(0/* transform_list' */, 1), new Array(16/* transform_list */, 1), new Array(
			16/* transform_list */, 0), new Array(15/* transforms */, 1), new Array(15/* transforms */, 3),
			new Array(17/* transform */, 1), new Array(17/* transform */, 1), new Array(17/* transform */, 1),
			new Array(17/* transform */, 1), new Array(17/* transform */, 1), new Array(17/* transform */, 1),
			new Array(19/* matrix */, 14), new Array(26/* translate_sequence */, 1), new Array(
					26/* translate_sequence */, 3), new Array(20/* translate */, 4), new Array(
					27/* scale_sequence */, 1), new Array(27/* scale_sequence */, 3), new Array(21/* scale */, 4),
			new Array(28/* rotate_sequence */, 1), new Array(28/* rotate_sequence */, 5), new Array(22/* rotate */,
					4), new Array(23/* skewX */, 4), new Array(24/* skewY */, 4), new Array(25/* number */, 1),
			new Array(25/* number */, 1), new Array(25/* number */, 2), new Array(25/* number */, 2), new Array(
					18/* opt-comma-wsp */, 1), new Array(18/* opt-comma-wsp */, 0), new Array(
					29/* integer-constant */, 1), new Array(30/* floating-point-constant */, 1), new Array(
					30/* floating-point-constant */, 2), new Array(30/* floating-point-constant */, 2), new Array(
					31/* fractional-constant */, 2), new Array(31/* fractional-constant */, 2), new Array(
					31/* fractional-constant */, 3), new Array(32/* exponent */, 2), new Array(32/* exponent */, 3));

	/* Action-Table */
	var act_tab = new Array(
	/* State 0 */new Array(14/* "MATRIX_INDICATOR" */, 10, 13/* "TRANSLATE_INDICATOR" */, 11,
			12/* "SCALE_INDICATOR" */, 12, 11/* "ROTATE_INDICATOR" */, 13, 9/* "SKEW_X_INDICATOR" */, 14,
			10/* "SKEW_Y_INDICATOR" */, 15, 33/* "$" */, -2),
	/* State 1 */new Array(33/* "$" */, 0),
	/* State 2 */new Array(33/* "$" */, -1),
	/* State 3 */new Array(6/* "COMMA" */, 17, 33/* "$" */, -3, 14/* "MATRIX_INDICATOR" */, -28,
			13/* "TRANSLATE_INDICATOR" */, -28, 12/* "SCALE_INDICATOR" */, -28, 11/* "ROTATE_INDICATOR" */, -28,
			9/* "SKEW_X_INDICATOR" */, -28, 10/* "SKEW_Y_INDICATOR" */, -28),
	/* State 4 */new Array(33/* "$" */, -5, 6/* "COMMA" */, -5, 14/* "MATRIX_INDICATOR" */, -5,
			13/* "TRANSLATE_INDICATOR" */, -5, 12/* "SCALE_INDICATOR" */, -5, 11/* "ROTATE_INDICATOR" */, -5,
			9/* "SKEW_X_INDICATOR" */, -5, 10/* "SKEW_Y_INDICATOR" */, -5),
	/* State 5 */new Array(33/* "$" */, -6, 6/* "COMMA" */, -6, 14/* "MATRIX_INDICATOR" */, -6,
			13/* "TRANSLATE_INDICATOR" */, -6, 12/* "SCALE_INDICATOR" */, -6, 11/* "ROTATE_INDICATOR" */, -6,
			9/* "SKEW_X_INDICATOR" */, -6, 10/* "SKEW_Y_INDICATOR" */, -6),
	/* State 6 */new Array(33/* "$" */, -7, 6/* "COMMA" */, -7, 14/* "MATRIX_INDICATOR" */, -7,
			13/* "TRANSLATE_INDICATOR" */, -7, 12/* "SCALE_INDICATOR" */, -7, 11/* "ROTATE_INDICATOR" */, -7,
			9/* "SKEW_X_INDICATOR" */, -7, 10/* "SKEW_Y_INDICATOR" */, -7),
	/* State 7 */new Array(33/* "$" */, -8, 6/* "COMMA" */, -8, 14/* "MATRIX_INDICATOR" */, -8,
			13/* "TRANSLATE_INDICATOR" */, -8, 12/* "SCALE_INDICATOR" */, -8, 11/* "ROTATE_INDICATOR" */, -8,
			9/* "SKEW_X_INDICATOR" */, -8, 10/* "SKEW_Y_INDICATOR" */, -8),
	/* State 8 */new Array(33/* "$" */, -9, 6/* "COMMA" */, -9, 14/* "MATRIX_INDICATOR" */, -9,
			13/* "TRANSLATE_INDICATOR" */, -9, 12/* "SCALE_INDICATOR" */, -9, 11/* "ROTATE_INDICATOR" */, -9,
			9/* "SKEW_X_INDICATOR" */, -9, 10/* "SKEW_Y_INDICATOR" */, -9),
	/* State 9 */new Array(33/* "$" */, -10, 6/* "COMMA" */, -10, 14/* "MATRIX_INDICATOR" */, -10,
			13/* "TRANSLATE_INDICATOR" */, -10, 12/* "SCALE_INDICATOR" */, -10, 11/* "ROTATE_INDICATOR" */, -10,
			9/* "SKEW_X_INDICATOR" */, -10, 10/* "SKEW_Y_INDICATOR" */, -10),
	/* State 10 */new Array(7/* "LEFT_P" */, 18),
	/* State 11 */new Array(7/* "LEFT_P" */, 19),
	/* State 12 */new Array(7/* "LEFT_P" */, 20),
	/* State 13 */new Array(7/* "LEFT_P" */, 21),
	/* State 14 */new Array(7/* "LEFT_P" */, 22),
	/* State 15 */new Array(7/* "LEFT_P" */, 23),
	/* State 16 */new Array(14/* "MATRIX_INDICATOR" */, 10, 13/* "TRANSLATE_INDICATOR" */, 11,
			12/* "SCALE_INDICATOR" */, 12, 11/* "ROTATE_INDICATOR" */, 13, 9/* "SKEW_X_INDICATOR" */, 14,
			10/* "SKEW_Y_INDICATOR" */, 15),
	/* State 17 */new Array(14/* "MATRIX_INDICATOR" */, -27, 13/* "TRANSLATE_INDICATOR" */, -27,
			12/* "SCALE_INDICATOR" */, -27, 11/* "ROTATE_INDICATOR" */, -27, 9/* "SKEW_X_INDICATOR" */, -27,
			10/* "SKEW_Y_INDICATOR" */, -27, 3/* "SIGN" */, -27, 2/* "DIGIT-SEQUENCE" */, -27,
			5/* "DECIMAL_DOT" */, -27),
	/* State 18 */new Array(3/* "SIGN" */, 28, 2/* "DIGIT-SEQUENCE" */, 29, 5/* "DECIMAL_DOT" */, 31),
	/* State 19 */new Array(3/* "SIGN" */, 28, 2/* "DIGIT-SEQUENCE" */, 29, 5/* "DECIMAL_DOT" */, 31),
	/* State 20 */new Array(3/* "SIGN" */, 28, 2/* "DIGIT-SEQUENCE" */, 29, 5/* "DECIMAL_DOT" */, 31),
	/* State 21 */new Array(3/* "SIGN" */, 28, 2/* "DIGIT-SEQUENCE" */, 29, 5/* "DECIMAL_DOT" */, 31),
	/* State 22 */new Array(3/* "SIGN" */, 28, 2/* "DIGIT-SEQUENCE" */, 29, 5/* "DECIMAL_DOT" */, 31),
	/* State 23 */new Array(3/* "SIGN" */, 28, 2/* "DIGIT-SEQUENCE" */, 29, 5/* "DECIMAL_DOT" */, 31),
	/* State 24 */new Array(33/* "$" */, -4),
	/* State 25 */new Array(6/* "COMMA" */, 17, 3/* "SIGN" */, -28, 2/* "DIGIT-SEQUENCE" */, -28,
			5/* "DECIMAL_DOT" */, -28),
	/* State 26 */new Array(6/* "COMMA" */, -23, 3/* "SIGN" */, -23, 2/* "DIGIT-SEQUENCE" */, -23,
			5/* "DECIMAL_DOT" */, -23, 8/* "RIGHT_P" */, -23),
	/* State 27 */new Array(6/* "COMMA" */, -24, 3/* "SIGN" */, -24, 2/* "DIGIT-SEQUENCE" */, -24,
			5/* "DECIMAL_DOT" */, -24, 8/* "RIGHT_P" */, -24),
	/* State 28 */new Array(2/* "DIGIT-SEQUENCE" */, 29, 5/* "DECIMAL_DOT" */, 31),
	/* State 29 */new Array(5/* "DECIMAL_DOT" */, 43, 4/* "EXPONENT_INDICATOR" */, 45, 6/* "COMMA" */, -29,
			3/* "SIGN" */, -29, 2/* "DIGIT-SEQUENCE" */, -29, 8/* "RIGHT_P" */, -29),
	/* State 30 */new Array(4/* "EXPONENT_INDICATOR" */, 45, 6/* "COMMA" */, -30, 3/* "SIGN" */, -30,
			2/* "DIGIT-SEQUENCE" */, -30, 5/* "DECIMAL_DOT" */, -30, 8/* "RIGHT_P" */, -30),
	/* State 31 */new Array(2/* "DIGIT-SEQUENCE" */, 47),
	/* State 32 */new Array(8/* "RIGHT_P" */, 48),
	/* State 33 */new Array(6/* "COMMA" */, 17, 8/* "RIGHT_P" */, -12, 3/* "SIGN" */, -28,
			2/* "DIGIT-SEQUENCE" */, -28, 5/* "DECIMAL_DOT" */, -28),
	/* State 34 */new Array(8/* "RIGHT_P" */, 50),
	/* State 35 */new Array(6/* "COMMA" */, 17, 8/* "RIGHT_P" */, -15, 3/* "SIGN" */, -28,
			2/* "DIGIT-SEQUENCE" */, -28, 5/* "DECIMAL_DOT" */, -28),
	/* State 36 */new Array(8/* "RIGHT_P" */, 52),
	/* State 37 */new Array(6/* "COMMA" */, 17, 8/* "RIGHT_P" */, -18, 3/* "SIGN" */, -28,
			2/* "DIGIT-SEQUENCE" */, -28, 5/* "DECIMAL_DOT" */, -28),
	/* State 38 */new Array(8/* "RIGHT_P" */, 54),
	/* State 39 */new Array(8/* "RIGHT_P" */, 55),
	/* State 40 */new Array(3/* "SIGN" */, 28, 2/* "DIGIT-SEQUENCE" */, 29, 5/* "DECIMAL_DOT" */, 31),
	/* State 41 */new Array(6/* "COMMA" */, -26, 3/* "SIGN" */, -26, 2/* "DIGIT-SEQUENCE" */, -26,
			5/* "DECIMAL_DOT" */, -26, 8/* "RIGHT_P" */, -26),
	/* State 42 */new Array(6/* "COMMA" */, -25, 3/* "SIGN" */, -25, 2/* "DIGIT-SEQUENCE" */, -25,
			5/* "DECIMAL_DOT" */, -25, 8/* "RIGHT_P" */, -25),
	/* State 43 */new Array(2/* "DIGIT-SEQUENCE" */, 57, 6/* "COMMA" */, -34, 3/* "SIGN" */, -34,
			5/* "DECIMAL_DOT" */, -34, 4/* "EXPONENT_INDICATOR" */, -34, 8/* "RIGHT_P" */, -34),
	/* State 44 */new Array(6/* "COMMA" */, -32, 3/* "SIGN" */, -32, 2/* "DIGIT-SEQUENCE" */, -32,
			5/* "DECIMAL_DOT" */, -32, 8/* "RIGHT_P" */, -32),
	/* State 45 */new Array(3/* "SIGN" */, 58, 2/* "DIGIT-SEQUENCE" */, 59),
	/* State 46 */new Array(6/* "COMMA" */, -31, 3/* "SIGN" */, -31, 2/* "DIGIT-SEQUENCE" */, -31,
			5/* "DECIMAL_DOT" */, -31, 8/* "RIGHT_P" */, -31),
	/* State 47 */new Array(6/* "COMMA" */, -33, 3/* "SIGN" */, -33, 2/* "DIGIT-SEQUENCE" */, -33,
			5/* "DECIMAL_DOT" */, -33, 4/* "EXPONENT_INDICATOR" */, -33, 8/* "RIGHT_P" */, -33),
	/* State 48 */new Array(33/* "$" */, -14, 6/* "COMMA" */, -14, 14/* "MATRIX_INDICATOR" */, -14,
			13/* "TRANSLATE_INDICATOR" */, -14, 12/* "SCALE_INDICATOR" */, -14, 11/* "ROTATE_INDICATOR" */, -14,
			9/* "SKEW_X_INDICATOR" */, -14, 10/* "SKEW_Y_INDICATOR" */, -14),
	/* State 49 */new Array(3/* "SIGN" */, 28, 2/* "DIGIT-SEQUENCE" */, 29, 5/* "DECIMAL_DOT" */, 31),
	/* State 50 */new Array(33/* "$" */, -17, 6/* "COMMA" */, -17, 14/* "MATRIX_INDICATOR" */, -17,
			13/* "TRANSLATE_INDICATOR" */, -17, 12/* "SCALE_INDICATOR" */, -17, 11/* "ROTATE_INDICATOR" */, -17,
			9/* "SKEW_X_INDICATOR" */, -17, 10/* "SKEW_Y_INDICATOR" */, -17),
	/* State 51 */new Array(3/* "SIGN" */, 28, 2/* "DIGIT-SEQUENCE" */, 29, 5/* "DECIMAL_DOT" */, 31),
	/* State 52 */new Array(33/* "$" */, -20, 6/* "COMMA" */, -20, 14/* "MATRIX_INDICATOR" */, -20,
			13/* "TRANSLATE_INDICATOR" */, -20, 12/* "SCALE_INDICATOR" */, -20, 11/* "ROTATE_INDICATOR" */, -20,
			9/* "SKEW_X_INDICATOR" */, -20, 10/* "SKEW_Y_INDICATOR" */, -20),
	/* State 53 */new Array(3/* "SIGN" */, 28, 2/* "DIGIT-SEQUENCE" */, 29, 5/* "DECIMAL_DOT" */, 31),
	/* State 54 */new Array(33/* "$" */, -21, 6/* "COMMA" */, -21, 14/* "MATRIX_INDICATOR" */, -21,
			13/* "TRANSLATE_INDICATOR" */, -21, 12/* "SCALE_INDICATOR" */, -21, 11/* "ROTATE_INDICATOR" */, -21,
			9/* "SKEW_X_INDICATOR" */, -21, 10/* "SKEW_Y_INDICATOR" */, -21),
	/* State 55 */new Array(33/* "$" */, -22, 6/* "COMMA" */, -22, 14/* "MATRIX_INDICATOR" */, -22,
			13/* "TRANSLATE_INDICATOR" */, -22, 12/* "SCALE_INDICATOR" */, -22, 11/* "ROTATE_INDICATOR" */, -22,
			9/* "SKEW_X_INDICATOR" */, -22, 10/* "SKEW_Y_INDICATOR" */, -22),
	/* State 56 */new Array(6/* "COMMA" */, 17, 3/* "SIGN" */, -28, 2/* "DIGIT-SEQUENCE" */, -28,
			5/* "DECIMAL_DOT" */, -28),
	/* State 57 */new Array(6/* "COMMA" */, -35, 3/* "SIGN" */, -35, 2/* "DIGIT-SEQUENCE" */, -35,
			5/* "DECIMAL_DOT" */, -35, 4/* "EXPONENT_INDICATOR" */, -35, 8/* "RIGHT_P" */, -35),
	/* State 58 */new Array(2/* "DIGIT-SEQUENCE" */, 64),
	/* State 59 */new Array(6/* "COMMA" */, -36, 3/* "SIGN" */, -36, 2/* "DIGIT-SEQUENCE" */, -36,
			5/* "DECIMAL_DOT" */, -36, 8/* "RIGHT_P" */, -36),
	/* State 60 */new Array(8/* "RIGHT_P" */, -13),
	/* State 61 */new Array(8/* "RIGHT_P" */, -16),
	/* State 62 */new Array(6/* "COMMA" */, 17, 3/* "SIGN" */, -28, 2/* "DIGIT-SEQUENCE" */, -28,
			5/* "DECIMAL_DOT" */, -28),
	/* State 63 */new Array(3/* "SIGN" */, 28, 2/* "DIGIT-SEQUENCE" */, 29, 5/* "DECIMAL_DOT" */, 31),
	/* State 64 */new Array(6/* "COMMA" */, -37, 3/* "SIGN" */, -37, 2/* "DIGIT-SEQUENCE" */, -37,
			5/* "DECIMAL_DOT" */, -37, 8/* "RIGHT_P" */, -37),
	/* State 65 */new Array(3/* "SIGN" */, 28, 2/* "DIGIT-SEQUENCE" */, 29, 5/* "DECIMAL_DOT" */, 31),
	/* State 66 */new Array(6/* "COMMA" */, 17, 3/* "SIGN" */, -28, 2/* "DIGIT-SEQUENCE" */, -28,
			5/* "DECIMAL_DOT" */, -28),
	/* State 67 */new Array(8/* "RIGHT_P" */, -19),
	/* State 68 */new Array(3/* "SIGN" */, 28, 2/* "DIGIT-SEQUENCE" */, 29, 5/* "DECIMAL_DOT" */, 31),
	/* State 69 */new Array(6/* "COMMA" */, 17, 3/* "SIGN" */, -28, 2/* "DIGIT-SEQUENCE" */, -28,
			5/* "DECIMAL_DOT" */, -28),
	/* State 70 */new Array(3/* "SIGN" */, 28, 2/* "DIGIT-SEQUENCE" */, 29, 5/* "DECIMAL_DOT" */, 31),
	/* State 71 */new Array(6/* "COMMA" */, 17, 3/* "SIGN" */, -28, 2/* "DIGIT-SEQUENCE" */, -28,
			5/* "DECIMAL_DOT" */, -28),
	/* State 72 */new Array(3/* "SIGN" */, 28, 2/* "DIGIT-SEQUENCE" */, 29, 5/* "DECIMAL_DOT" */, 31),
	/* State 73 */new Array(8/* "RIGHT_P" */, 74),
	/* State 74 */new Array(33/* "$" */, -11, 6/* "COMMA" */, -11, 14/* "MATRIX_INDICATOR" */, -11,
			13/* "TRANSLATE_INDICATOR" */, -11, 12/* "SCALE_INDICATOR" */, -11, 11/* "ROTATE_INDICATOR" */, -11,
			9/* "SKEW_X_INDICATOR" */, -11, 10/* "SKEW_Y_INDICATOR" */, -11));

	/* Goto-Table */
	var goto_tab = new Array(
	/* State 0 */new Array(16/* transform_list */, 1, 15/* transforms */, 2, 17/* transform */, 3, 19/* matrix */,
			4, 20/* translate */, 5, 21/* scale */, 6, 22/* rotate */, 7, 23/* skewX */, 8, 24/* skewY */, 9),
	/* State 1 */new Array(),
	/* State 2 */new Array(),
	/* State 3 */new Array(18/* opt-comma-wsp */, 16),
	/* State 4 */new Array(),
	/* State 5 */new Array(),
	/* State 6 */new Array(),
	/* State 7 */new Array(),
	/* State 8 */new Array(),
	/* State 9 */new Array(),
	/* State 10 */new Array(),
	/* State 11 */new Array(),
	/* State 12 */new Array(),
	/* State 13 */new Array(),
	/* State 14 */new Array(),
	/* State 15 */new Array(),
	/* State 16 */new Array(15/* transforms */, 24, 17/* transform */, 3, 19/* matrix */, 4, 20/* translate */, 5,
			21/* scale */, 6, 22/* rotate */, 7, 23/* skewX */, 8, 24/* skewY */, 9),
	/* State 17 */new Array(),
	/* State 18 */new Array(25/* number */, 25, 29/* integer-constant */, 26, 30/* floating-point-constant */, 27,
			31/* fractional-constant */, 30),
	/* State 19 */new Array(26/* translate_sequence */, 32, 25/* number */, 33, 29/* integer-constant */, 26,
			30/* floating-point-constant */, 27, 31/* fractional-constant */, 30),
	/* State 20 */new Array(27/* scale_sequence */, 34, 25/* number */, 35, 29/* integer-constant */, 26,
			30/* floating-point-constant */, 27, 31/* fractional-constant */, 30),
	/* State 21 */new Array(28/* rotate_sequence */, 36, 25/* number */, 37, 29/* integer-constant */, 26,
			30/* floating-point-constant */, 27, 31/* fractional-constant */, 30),
	/* State 22 */new Array(25/* number */, 38, 29/* integer-constant */, 26, 30/* floating-point-constant */, 27,
			31/* fractional-constant */, 30),
	/* State 23 */new Array(25/* number */, 39, 29/* integer-constant */, 26, 30/* floating-point-constant */, 27,
			31/* fractional-constant */, 30),
	/* State 24 */new Array(),
	/* State 25 */new Array(18/* opt-comma-wsp */, 40),
	/* State 26 */new Array(),
	/* State 27 */new Array(),
	/* State 28 */new Array(30/* floating-point-constant */, 41, 29/* integer-constant */, 42,
			31/* fractional-constant */, 30),
	/* State 29 */new Array(32/* exponent */, 44),
	/* State 30 */new Array(32/* exponent */, 46),
	/* State 31 */new Array(),
	/* State 32 */new Array(),
	/* State 33 */new Array(18/* opt-comma-wsp */, 49),
	/* State 34 */new Array(),
	/* State 35 */new Array(18/* opt-comma-wsp */, 51),
	/* State 36 */new Array(),
	/* State 37 */new Array(18/* opt-comma-wsp */, 53),
	/* State 38 */new Array(),
	/* State 39 */new Array(),
	/* State 40 */new Array(25/* number */, 56, 29/* integer-constant */, 26, 30/* floating-point-constant */, 27,
			31/* fractional-constant */, 30),
	/* State 41 */new Array(),
	/* State 42 */new Array(),
	/* State 43 */new Array(),
	/* State 44 */new Array(),
	/* State 45 */new Array(),
	/* State 46 */new Array(),
	/* State 47 */new Array(),
	/* State 48 */new Array(),
	/* State 49 */new Array(25/* number */, 60, 29/* integer-constant */, 26, 30/* floating-point-constant */, 27,
			31/* fractional-constant */, 30),
	/* State 50 */new Array(),
	/* State 51 */new Array(25/* number */, 61, 29/* integer-constant */, 26, 30/* floating-point-constant */, 27,
			31/* fractional-constant */, 30),
	/* State 52 */new Array(),
	/* State 53 */new Array(25/* number */, 62, 29/* integer-constant */, 26, 30/* floating-point-constant */, 27,
			31/* fractional-constant */, 30),
	/* State 54 */new Array(),
	/* State 55 */new Array(),
	/* State 56 */new Array(18/* opt-comma-wsp */, 63),
	/* State 57 */new Array(),
	/* State 58 */new Array(),
	/* State 59 */new Array(),
	/* State 60 */new Array(),
	/* State 61 */new Array(),
	/* State 62 */new Array(18/* opt-comma-wsp */, 65),
	/* State 63 */new Array(25/* number */, 66, 29/* integer-constant */, 26, 30/* floating-point-constant */, 27,
			31/* fractional-constant */, 30),
	/* State 64 */new Array(),
	/* State 65 */new Array(25/* number */, 67, 29/* integer-constant */, 26, 30/* floating-point-constant */, 27,
			31/* fractional-constant */, 30),
	/* State 66 */new Array(18/* opt-comma-wsp */, 68),
	/* State 67 */new Array(),
	/* State 68 */new Array(25/* number */, 69, 29/* integer-constant */, 26, 30/* floating-point-constant */, 27,
			31/* fractional-constant */, 30),
	/* State 69 */new Array(18/* opt-comma-wsp */, 70),
	/* State 70 */new Array(25/* number */, 71, 29/* integer-constant */, 26, 30/* floating-point-constant */, 27,
			31/* fractional-constant */, 30),
	/* State 71 */new Array(18/* opt-comma-wsp */, 72),
	/* State 72 */new Array(25/* number */, 73, 29/* integer-constant */, 26, 30/* floating-point-constant */, 27,
			31/* fractional-constant */, 30),
	/* State 73 */new Array(),
	/* State 74 */new Array());

	/* Symbol labels */
	var labels = new Array("transform_list'" /* Non-terminal symbol */, "WHITESPACE" /*
																						 * Terminal
																						 * symbol
																						 */, "DIGIT-SEQUENCE" /* Terminal symbol */, "SIGN" /* Terminal symbol */,
			"EXPONENT_INDICATOR" /* Terminal symbol */, "DECIMAL_DOT" /*
																		 * Terminal
																		 * symbol
																		 */, "COMMA" /* Terminal symbol */, "LEFT_P" /* Terminal symbol */, "RIGHT_P" /*
																							 * Terminal
																							 * symbol
																							 */, "SKEW_X_INDICATOR" /* Terminal symbol */, "SKEW_Y_INDICATOR" /*
																				 * Terminal
																				 * symbol
																				 */, "ROTATE_INDICATOR" /* Terminal symbol */, "SCALE_INDICATOR" /*
																				 * Terminal
																				 * symbol
																				 */, "TRANSLATE_INDICATOR" /* Terminal symbol */, "MATRIX_INDICATOR" /*
																					 * Terminal
																					 * symbol
																					 */, "transforms" /* Non-terminal symbol */, "transform_list" /*
																			 * Non-terminal
																			 * symbol
																			 */, "transform" /* Non-terminal symbol */, "opt-comma-wsp" /*
																		 * Non-terminal
																		 * symbol
																		 */, "matrix" /* Non-terminal symbol */, "translate" /*
																	 * Non-terminal
																	 * symbol
																	 */, "scale" /* Non-terminal symbol */, "rotate" /*
																 * Non-terminal
																 * symbol
																 */, "skewX" /* Non-terminal symbol */, "skewY" /*
															 * Non-terminal
															 * symbol
															 */,
			"number" /* Non-terminal symbol */, "translate_sequence" /*
																		 * Non-terminal
																		 * symbol
																		 */, "scale_sequence" /* Non-terminal symbol */, "rotate_sequence" /*
																				 * Non-terminal
																				 * symbol
																				 */, "integer-constant" /* Non-terminal symbol */, "floating-point-constant" /*
																							 * Non-terminal
																							 * symbol
																							 */, "fractional-constant" /* Non-terminal symbol */, "exponent" /*
																				 * Non-terminal
																				 * symbol
																				 */, "$" /*
						 * Terminal symbol
						 */
	);

	function __parse(src) {
		var err_cnt = 0, err_off = [], err_la = [];
		var act, go, la;
		var rval = undefined;
		var info = {
			offset : 0,
			src : src,
			att : ''
		};
		var sstack = [ 0 ], vstack = [ 0 ];

		la = __lex(info);

		while (true) {
			act = 76;
			for ( var i = 0; i < act_tab[sstack[sstack.length - 1]].length; i += 2) {
				if (act_tab[sstack[sstack.length - 1]][i] == la) {
					act = act_tab[sstack[sstack.length - 1]][i + 1];
					break;
				}
			}

			if (_dbg_withtrace && sstack.length > 0) {
				__dbg_print('\\nState ' + sstack[sstack.length - 1] + '\\n' + '\\tLookahead: ' + labels[la] + ' (\\\"'
						+ info.att + '\\\")\\n' + '\\tAction: ' + act + '\\n' + '\\tSource: \\\"'
						+ info.src.substr(info.offset, 30) + ((info.offset + 30 < info.src.length) ? '...' : '')
						+ '\\\"\\n' + '\\tStack: ' + sstack.join() + '\\n' + '\\tValue stack: ' + vstack.join() + '\\n');
			}

			// Panic-mode: Try recovery when parse-error occurs!
			if (act == 76) {
				if (_dbg_withtrace)
					__dbg_print('Error detected: There is no reduce or shift on the symbol ' + labels[la]);

				err_cnt++;
				err_off.push(info.offset - info.att.length);
				err_la.push(new Array());
				for ( var i = 0; i < act_tab[sstack[sstack.length - 1]].length; i += 2)
					err_la[err_la.length - 1].push(labels[act_tab[sstack[sstack.length - 1]][i]]);

				// Remember the original stack!
				var rsstack = new Array();
				var rvstack = new Array();
				for ( var i = 0; i < sstack.length; i++) {
					rsstack[i] = sstack[i];
					rvstack[i] = vstack[i];
				}

				while (act == 76 && la != 33) {
					if (_dbg_withtrace)
						__dbg_print('\\tError recovery\\n' + 'Current lookahead: ' + labels[la] + ' (' + info.att
								+ ')\\n' + 'Action: ' + act + '\\n\\n');
					if (la == -1)
						info.offset++;

					while (act == 76 && sstack.length > 0) {
						sstack.pop();
						vstack.pop();

						if (sstack.length == 0)
							break;

						act = 76;
						for ( var i = 0; i < act_tab[sstack[sstack.length - 1]].length; i += 2) {
							if (act_tab[sstack[sstack.length - 1]][i] == la) {
								act = act_tab[sstack[sstack.length - 1]][i + 1];
								break;
							}
						}
					}

					if (act != 76)
						break;

					for ( var i = 0; i < rsstack.length; i++) {
						sstack.push(rsstack[i]);
						vstack.push(rvstack[i]);
					}

					la = __lex(info);
				}

				if (act == 76) {
					if (_dbg_withtrace)
						__dbg_print('\\tError recovery failed, terminating parse process...');
					break;
				}

				if (_dbg_withtrace)
					__dbg_print('\\tError recovery succeeded, continuing');
			}

			/*
			 * if( act == 76 ) break;
			 */

			// Shift
			if (act > 0) {
				if (_dbg_withtrace)
					__dbg_print('Shifting symbol: ' + labels[la] + ' (' + info.att + ')');

				sstack.push(act);
				vstack.push(info.att);

				la = __lex(info);

				if (_dbg_withtrace)
					__dbg_print('\\tNew lookahead symbol: ' + labels[la] + ' (' + info.att + ')');
			}
			// Reduce
			else {
				act *= -1;

				if (_dbg_withtrace)
					__dbg_print('Reducing by producution: ' + act);

				rval = void (0);

				if (_dbg_withtrace)
					__dbg_print('\\tPerforming semantic action...');

				switch (act) {
				case 0: {
					rval = vstack[vstack.length - 1];
				}
					break;
				case 1: {
					rval = vstack[vstack.length - 1];
				}
					break;
				case 2: {
					rval = [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ];
				}
					break;
				case 3: {
					rval = vstack[vstack.length - 1];
				}
					break;
				case 4: {
					rval = transformMatrixMultiply(vstack[vstack.length - 3], vstack[vstack.length - 1]);
				}
					break;
				case 5: {
					rval = vstack[vstack.length - 1];
				}
					break;
				case 6: {
					rval = vstack[vstack.length - 1];
				}
					break;
				case 7: {
					rval = vstack[vstack.length - 1];
				}
					break;
				case 8: {
					rval = vstack[vstack.length - 1];
				}
					break;
				case 9: {
					rval = vstack[vstack.length - 1];
				}
					break;
				case 10: {
					rval = vstack[vstack.length - 1];
				}
					break;
				case 11: {
					rval = [ [ vstack[vstack.length - 12], vstack[vstack.length - 8], vstack[vstack.length - 4] ],
							[ vstack[vstack.length - 10], vstack[vstack.length - 6], vstack[vstack.length - 2] ],
							[ 0, 0, 1 ] ];
				}
					break;
				case 12: {
					rval = {
						tx : vstack[vstack.length - 1],
						ty : 0
					};
				}
					break;
				case 13: {
					rval = {
						tx : vstack[vstack.length - 3],
						ty : vstack[vstack.length - 1]
					};
				}
					break;
				case 14: {
					rval = [ [ 1, 0, vstack[vstack.length - 2].tx ], [ 0, 1, vstack[vstack.length - 2].ty ],
							[ 0, 0, 1 ] ];
				}
					break;
				case 15: {
					rval = {
						sx : vstack[vstack.length - 1],
						sy : vstack[vstack.length - 1]
					};
				}
					break;
				case 16: {
					rval = {
						sx : vstack[vstack.length - 3],
						sy : vstack[vstack.length - 1]
					};
				}
					break;
				case 17: {
					rval = [ [ vstack[vstack.length - 2].sx, 0, 0 ], [ 0, vstack[vstack.length - 2].sy, 0 ],
							[ 0, 0, 1 ] ];
				}
					break;
				case 18: {
					rval = {
						rad : vstack[vstack.length - 1] * Math.PI / 180,
						cx : 0,
						cy : 0
					};
				}
					break;
				case 19: {
					rval = {
						rad : vstack[vstack.length - 5] * Math.PI / 180,
						cx : vstack[vstack.length - 3],
						cy : vstack[vstack.length - 1]
					};
				}
					break;
				case 20: {
					rval = buildRotateMatrix(vstack[vstack.length - 2]);
				}
					break;
				case 21: {
					rval = [ [ 1, Math.tan(vstack[vstack.length - 2] * Math.PI / 180), 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ];
				}
					break;
				case 22: {
					rval = [ [ 1, 0, 0 ], [ Math.tan(vstack[vstack.length - 2] * Math.PI / 180), 1, 0 ], [ 0, 0, 1 ] ];
				}
					break;
				case 23: {
					rval = parseInt(vstack[vstack.length - 1]);
				}
					break;
				case 24: {
					rval = parseFloat(vstack[vstack.length - 1]);
				}
					break;
				case 25: {
					rval = parseInt(vstack[vstack.length - 2] + vstack[vstack.length - 1]);
				}
					break;
				case 26: {
					rval = parseFloat(vstack[vstack.length - 2] + vstack[vstack.length - 1]);
				}
					break;
				case 27: {
					rval = vstack[vstack.length - 1];
				}
					break;
				case 28: {
					rval = vstack[vstack.length - 0];
				}
					break;
				case 29: {
					rval = vstack[vstack.length - 1];
				}
					break;
				case 30: {
					rval = vstack[vstack.length - 1];
				}
					break;
				case 31: {
					rval = vstack[vstack.length - 2] + 'e' + vstack[vstack.length - 1];
				}
					break;
				case 32: {
					rval = vstack[vstack.length - 2] + 'e' + vstack[vstack.length - 1];
				}
					break;
				case 33: {
					rval = '0.' + vstack[vstack.length - 1];
				}
					break;
				case 34: {
					rval = vstack[vstack.length - 2] + '.0';
				}
					break;
				case 35: {
					rval = vstack[vstack.length - 3] + '.' + vstack[vstack.length - 1];
				}
					break;
				case 36: {
					rval = vstack[vstack.length - 1];
				}
					break;
				case 37: {
					rval = vstack[vstack.length - 2] + vstack[vstack.length - 1];
				}
					break;
				}

				if (_dbg_withtrace)
					__dbg_print('\\tPopping ' + pop_tab[act][1] + ' off the stack...');

				for ( var i = 0; i < pop_tab[act][1]; i++) {
					sstack.pop();
					vstack.pop();
				}

				go = -1;
				for ( var i = 0; i < goto_tab[sstack[sstack.length - 1]].length; i += 2) {
					if (goto_tab[sstack[sstack.length - 1]][i] == pop_tab[act][0]) {
						go = goto_tab[sstack[sstack.length - 1]][i + 1];
						break;
					}
				}

				if (act == 0)
					break;

				if (_dbg_withtrace)
					__dbg_print('\\tPushing non-terminal ' + labels[pop_tab[act][0]]);

				sstack.push(go);
				vstack.push(rval);
			}

			if (_dbg_withtrace) {
				_dbg_string = new String();
				LOG.trace(_dbg_string, 'SVGTranformParser');
			}
		}

		if (_dbg_withtrace) {
			LOG.debug('\\nParse complete.', 'SVGTranformParser');
		}

		if (err_cnt) {
			var errMsg = '';
			for ( var i = 0; i < err_cnt; i++) {
				errMsg += 'Parse error near >' + src.substr(err_off[i], 30) + '<, expecting \\\"' + err_la[i].join()
						+ '\\\"\\n';
			}
			LOG.error(errMsg);
			return false;
		}
		return rval;
	}

	var TransformParser = {
		parse : __parse
	};

	return TransformParser;

});
define('sap/viz/base/utils/TransformHelper',['sap/viz/base/utils/TypeUtils','sap/viz/base/Math','sap/viz/base/utils/SVGTransformParser'],

function Setup(TypeUtils, Math, TransformParser) {
	var isString = TypeUtils.isString, isArray = TypeUtils.isArray;
	var matrixMultiply = function(left, right) {
		if (left[0].length !== right.length)
			return false;
		var row = left.length, col = right[0].length, d = right.length;
		var i = -1, j, k, rowVec, e;
		var result = [];
		while (++i < row) {
			rowVec = [];
			j = -1;
			while (++j < col) {
				k = -1;
				e = 0;
				while (++k < d) {
					e += left[i][k] * right[k][j];
				}
				rowVec.push(e);
			}
			result.push(rowVec);
		}
		return result;
	};
	/**
	 * Static Transform Utility
	 * 
	 * @name sap.viz.base.utils.TransformHelper
	 * @class
	 */
	var TransformHelper = {

		/**
		 * Multiply two matrixes, the two matrixes should be multiply
		 * compatible, otherwise false will be returned.
		 * 
		 * @param {Array}
		 *            left left matrix of the multiplication
		 * @param {Array}
		 *            right right matrix of the multiplication
		 * @returns {Array|false}
		 */
		multiply : matrixMultiply,

		/**
		 * Get the transform matrix by parsing svg transform string, if the
		 * string is not a valid, false will be returned.
		 * 
		 * @param SvgTransform
		 * @returns {Array|false}
		 */
		parse : function(svgTransform) {
			return TransformParser.parse('' + svgTransform);
		},

		/**
		 * Calculate the inversion of a transform. If the transform is not
		 * valid, false will be returned.
		 * 
		 * @param {Array|SvgTransform}
		 *            m the transform to be inverted, either in matrix array
		 *            form or SvgTransform string form.
		 * @returns {Array|false}
		 */
		invert : function(m) {
			if (isString(m)) {
				m = TransformParser.parse(m);
			}
			var a = m[0][0], b = m[0][1], c = m[0][2], d = m[1][0], e = m[1][1], f = m[1][2];
			var det = a * e - b * d;
			if (det != 0) {
				return [ [ e / det, -b / det, (b * f - c * e) / det ], [ -d / det, a / det, (c * d - a * f) / det ],
						[ 0, 0, 1 ] ];
			} else {
				return false;
			}
		},

		/**
		 * Get an identity transform matrix.
		 * 
		 * @return [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ]
		 */
		identityTransform : function() {
			return [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ];
		},

		/**
		 * Make a rotation transform
		 * 
		 * @param {Number}
		 *            angle Rotation angel in radian
		 * @returns {Array}
		 */
		rotate : function(angle) {
			angle = +angle;
			var cosA = Math.cos(angle), sinA = Math.sin(angle);
			return [ [ cosA, -sinA, 0 ], [ sinA, cosA, 0 ], [ 0, 0, 1 ] ];
		},
		/**
		 * Make a translate transform
		 * 
		 * @param {Number}
		 *            tx translate distance in x direction
		 * @param {Number}
		 *            (ty) translate distance in y direction, if omitted, it
		 *            equals 0.
		 * @returns {Array}
		 */
		translate : function(tx, ty) {
			if (arguments.length < 2) {
				ty = 0;
			}
			return [ [ 1, 0, +tx ], [ 0, 1, +ty ], [ 0, 0, 1 ] ];
		},
		/**
		 * Make a scale transform
		 * 
		 * @param {Number}
		 *            sx scale factor in x direction
		 * @param {Number}
		 *            (sy) scale factor in y direction, if omitted, it equals to
		 *            sx.
		 * @returns {Array}
		 */
		scale : function(sx, sy) {
			if (arguments.length < 2) {
				sy = sx;
			}
			return [ [ +sx, 0, 0 ], [ 0, +sy, 0 ], [ 0, 0, 1 ] ];
		},
		/**
		 * Make a transform skew the coordinate system in x direction
		 * 
		 * @param {Number}
		 *            a skewing X coordinates by angle a
		 * @returns {Array}
		 */
		skewX : function(a) {
			return [ [ 1, Math.tan(+a), 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ];
		},

		/**
		 * Make a transform skew the coordinate system in y direction
		 * 
		 * @param {Number}
		 *            a skewing Y coordinates by angle a
		 * @returns {Array}
		 */
		skewY : function(a) {
			return [ [ 1, 0, 0 ], [ Math.tan(+a), 1, 0 ], [ 0, 0, 1 ] ];
		},
		/**
		 * Whether the two transforms are identical
		 * 
		 * @param {transform}
		 *            atm one transform
		 * @param {transform}
		 *            btm another transform
		 * @return {Boolean}
		 */
		isEqualTransform : function(atm, btm) {
			if (isString(atm))
				atm = TransformParser.parse(atm);
			if (isString(btm))
				btm = TransformParser.parse(btm);
			return atm
					&& btm
					&& (atm[0][0] == btm[0][0] && atm[0][1] == btm[0][1] && atm[0][2] == btm[0][2]
							&& atm[1][0] == btm[1][0] && atm[1][1] == btm[1][1] && atm[1][2] == btm[1][2]
							&& atm[2][0] == btm[2][0] && atm[2][1] == btm[2][1] && atm[2][2] == btm[2][2]);
		},
		/**
		 * Whether the matrix is identity matrix, empty string will be treated
		 * as Identity Transform
		 * 
		 * @param {transform|SvgTransform}
		 *            tm the transform matrix or SVG transform string.
		 * @return {Boolean}
		 */
		isIdentityTransform : function(atm) {
			if (isString(atm)) {
				atm = TransformParser.parse(atm);
			}
			return atm
					&& (atm[0][0] == 1 && atm[0][1] == 0 && atm[0][2] == 0 && atm[1][0] == 0 && atm[1][1] == 1
							&& atm[1][2] == 0 && atm[2][0] == 0 && atm[2][1] == 0 && atm[2][2] == 1);
		},
		/**
		 * Whether the matrix is a valid affine transform matrix
		 * 
		 * @param {transform}
		 *            tm the transform to check
		 * @return {Boolean}
		 */
		isValidTransform : function(tm) {
			if (isString(tm)) {
				tm = TransformParser.parse(tm);
			}
			if (!isArray(tm) || tm.length < 3 || tm[0].length < 3) {
				return false;
			}
			return tm && (tm[0][0] * tm[1][1] != tm[1][0] * tm[0][1]);
		},
		/**
		 * Transform a point in current coordinate system into another
		 * coordinate system by given transform.
		 * 
		 * @param {Number|Point}
		 *            x could be the x coordinate of the point or <b>Point</b>
		 *            object.
		 * 
		 * @param {Number|Transform}
		 *            (y) could be the y coordinate of the point or transform.
		 * 
		 * @param {Transform}
		 *            (t) the transform matrix or string in SVG transform format
		 * 
		 * @return {Point}
		 * 
		 * <b>Point</b> object is defined as:
		 * 
		 * <pre>
		 * {
		 *      x : ##,
		 *      y : ##
		 * }
		 * </pre>
		 */
		transformPoint : function(x, y, t) {
			if (arguments.length === 2) {
				t = y;
				y = +x.y;
				x = +x.x;
			}
			if (isString(t)) {
				t = TransformParser.parse(t);
			}
			return {
				x : t[0][0] * x + t[0][1] * y + t[0][2],
				y : t[1][0] * x + t[1][1] * y + t[1][2]
			};
		},
		/**
		 * Transform a rectangle discribed in current coordinate system into
		 * another coordinate system by given transform.
		 * 
		 * @param {Number|Rect}
		 *            x the x coordinate of the top-left corner of the rectangle
		 *            or <b>Rect</b> object
		 * @param {Number|Transform}
		 *            (y) the y coordinate of the top-left corner of the
		 *            rectangle if the first argument x is designated as the x
		 *            coordinate, otherwise transform matrix or Svg Transform
		 *            string should be specified.
		 * @param {Number}
		 *            (width) the width of the rectangle, should be omitted when
		 *            x is <b>Rect</b> object
		 * 
		 * @param {Number}
		 *            (height) the height of the rectangle, should be omitted
		 *            when x is <b>Rect</b> object
		 * 
		 * @param {Transform}
		 *            (t) the transform applied, could be transform matrix or
		 *            Svg Transform string. Should be used when previous 4
		 *            arguments are used
		 * 
		 * <b>Rect</b> object is defined as:
		 * 
		 * <pre>
		 * {
		 *      x : ##,
		 *      y : ##,
		 *      width : ##,
		 *      height : ##
		 * }
		 * </pre>
		 * 
		 * @return {Object} transformed rectangle
		 * 
		 */
		transformRect : function(x, y, width, height, t) {
			if (arguments.length === 2) {
				t = y;
				height = +x.height;
				width = +x.width;
				y = +x.y;
				x = +x.x;
			}
			if (isString(t)) {
				t = TransformParser.parse(t);
			}

			var xy = {
				minx : Number.POSITIVE_INFINITY,
				maxx : Number.NEGATIVE_INFINITY,
				miny : Number.POSITIVE_INFINITY,
				maxy : Number.NEGATIVE_INFINITY
			};
			var corners = [
					[ t[0][0] * x + t[0][1] * y + t[0][2], t[1][0] * x + t[1][1] * y + t[1][2] ],
					[ t[0][0] * (x + width) + t[0][1] * y + t[0][2], t[1][0] * (x + width) + t[1][1] * y + t[1][2] ],
					[ t[0][0] * (x + width) + t[0][1] * (y + height) + t[0][2],
							t[1][0] * (x + width) + t[1][1] * (y + height) + t[1][2] ],
					[ t[0][0] * x + t[0][1] * (y + height) + t[0][2], t[1][0] * x + t[1][1] * (y + height) + t[1][2] ] ];
			for ( var i = 0, corner; i < 4; i++) {
				corner = corners[i];
				if (xy.minx > corner[0]) {
					xy.minx = corner[0];
				}
				if (xy.miny > corner[1]) {
					xy.miny = corner[1];
				}
				if (xy.maxx < corner[0]) {
					xy.maxx = corner[0];
				}
				if (xy.maxy < corner[1]) {
					xy.maxy = corner[1];
				}
			}
			return {
				x : xy.minx,
				y : xy.miny,
				width : xy.maxx - xy.minx,
				height : xy.maxy - xy.miny
			};
		},
		/**
		 * Decomposite a 2d transform matrix by translate, scale, skew, rotate
		 * primitive transform, if the transform is not valid, false will be
		 * returned.
		 * 
		 * @param {transform}
		 *            transform the transform to decomposite
		 * @returns {Object} decomposed transform components
		 * 
		 * <pre>
		 * {
		 * 	tx : tx, //translate in x
		 * 	ty : ty, //translate in y
		 * 	sx : sx, //scale in x
		 * 	sy : sy, //scale in y
		 * 	skew : skew, //skew in xy
		 * 	rotate : rotate
		 * //rotation in radians
		 * }
		 * </pre>
		 */
		unmatrix : function(transform) {
			if (isString(transform)) {
				transform = TransformParser.parse(transform);
			}
			if (!transform) {
				return false;
			}
			var a = transform[0][0], b = transform[1][0], c = transform[0][1], d = transform[1][1], tx = transform[0][2], ty = transform[1][2];

			var rot0 = [ a, b ], rot1 = [ c, d ];
			var scaleX = Math.sqrt(a * a + b * b);
			if (scaleX) {
				rot0[0] /= scaleX;
				rot0[1] /= scaleX;
			}

			var scaleZ = rot0[0] * rot1[0] + rot0[1] * rot1[1];
			rot1[0] += -scaleZ * rot0[0];
			rot1[1] += -scaleZ * rot0[1];

			var scaleY = Math.sqrt(rot1[0] * rot1[0] + rot1[1] * rot1[1]) || 0;
			if (scaleY) {
				rot1[0] /= scaleY;
				rot1[1] /= scaleY;
			}

			if (rot0[0] * rot1[1] < rot1[0] * rot0[1]) {
				rot0[0] *= -1;
				rot0[1] *= -1;
				kx *= -1;
				kz *= -1;
			}

			return {
				tx : tx,
				ty : ty,
				sx : scaleX,
				sy : scaleY,
				skew : scaleY ? Math.atan2(scaleZ, scaleY) : 0,
				rotate : scaleX ? Math.atan2(rot0[1], rot0[0]) : Math.atan2(-rot1[0], rot1[1])
			};
		}
	};
	return TransformHelper;
});
define('sap/viz/mvc/UIComponent',['sap/viz/base/Observable','sap/viz/base/utils/LinkedHashSet','sap/viz/base/utils/DomUtils',
'sap/viz/base/utils/FunctionUtils','sap/viz/mvc/GestureDetector','sap/viz/base/utils/TransformHelper'],
function Setup(Observable, LinkedHashSet, D, FuncUtils, GestureDetector,
		TmHelper) {
	// var $ = jQuery;
	var noop = FuncUtils.noop;
	// if (!$) {
	// FuncUtils.error('Cannot find jQuery');
	// }

	/**
	 * Mark width & height is not flexible when its parent component's size
	 * changed
	 * 
	 * @name sap.viz.mvc.UIComponent.Autosizing#None
	 * @field
	 * 
	 */
	var None = 0;
	/**
	 * Mark the left margin is flexible
	 * 
	 * @name sap.viz.mvc.UIComponent.Autosizing#FlexibleLeftMargin
	 * @field
	 */
	var FlexibleLeftMargin = 1 << 0;
	/**
	 * Mark the width is flexible
	 * 
	 * @name sap.viz.mvc.UIComponent.Autosizing#FlexibleWidth
	 * @field
	 */
	var FlexibleWidth = 1 << 1;
	/**
	 * Mark the right margin is flexible
	 * 
	 * @name sap.viz.mvc.UIComponent.Autosizing#FlexibleRightMargin
	 * @field
	 */
	var FlexibleRightMargin = 1 << 2;
	/**
	 * Mark the top margin is flexible
	 * 
	 * @name sap.viz.mvc.UIComponent.Autosizing#FlexibleTopMargin
	 * @field
	 */
	var FlexibleTopMargin = 1 << 3;
	/**
	 * Mark the height is flexible
	 * 
	 * @name sap.viz.mvc.UIComponent.Autosizing#FlexibleHeight
	 * @field
	 */
	var FlexibleHeight = 1 << 4;
	/**
	 * Mark the bottom margin is flexible
	 * 
	 * @name sap.viz.mvc.UIComponent.Autosizing#FlexibleBottomMargin
	 * @field
	 */
	var FlexibleBottomMargin = 1 << 5;

	var id = 0;
	var nextId = function() {
		return id++;
	};

	function walk(node, fn) {
		var pStack = [{
					node : node,
					childrenItr : node.children.iterator()
				}];
		var current, node, childrenItr;
		while (pStack.length) {
			current = pStack[pStack.length - 1];
			node = current.node;
			fn(node);
			childrenItr = current.childrenItr;
			if (childrenItr.hasNext()) {
				var child = childrenItr.next();
				pStack.push({
							node : child,
							childrenItr : child.children.iterator()
						});
			} else {
				pStack.pop();
			}
		}
	}

	function layout(oldsize, newsize) {
		if (this._autoresizable) {
			var subCompItr = this.children.iterator();
			var subComp, newFrame;
			while (subCompItr.hasNext()) {
				subComp = subCompItr.next();
				newFrame = resizeSubComp.call(this, subComp, oldsize, newsize);
				subComp.frame(newFrame);
			}
		} else {
			this.doLayout();
		}
	}

	function resizeSubComp(subComp, oldsize, newsize) {
		var origFrame = subComp.frame();
		var x = origFrame.x, y = origFrame.y, width = origFrame.width, height = origFrame.height;
		var ml = x, mr = oldsize.width - x - width, mt = y, mb = oldsize.height
				- y - height;
		var wdiff = newsize.width - oldsize.width, hdiff = newsize.height
				- oldsize.height;
		var arMask = subComp._autoresizingMask;
		var horizontalMask = FlexibleLeftMargin | FlexibleWidth
				| FlexibleRightMargin;
		var verticalMask = FlexibleTopMargin | FlexibleHeight
				| FlexibleBottomMargin;
		switch (arMask & horizontalMask) {
			case None :
				if (ml !== 0) {
					x += wdiff * ml / (ml + mr);
				}
				break;
			case FlexibleLeftMargin :
				x += wdiff;
				break;
			case FlexibleLeftMargin | FlexibleRightMargin :
			case FlexibleRightMargin :
				break;
			case FlexibleWidth :
				width += wdiff;
				break;
			case FlexibleLeftMargin | FlexibleWidth :
				if (width !== 0) {
					x += wdiff * ml / (ml + width);
					width += wdiff * width / (ml + width);
				}
				break;
			case FlexibleRightMargin | FlexibleWidth :
				if (width !== 0) {
					width += wdiff * width / (mr + width);
				}
				break;
			case FlexibleLeftMargin | FlexibleWidth | FlexibleRightMargin :
				if (oldsize.width !== 0) {
					var r = wdiff / oldsize.width;
					x += x * r;
					width += width * r;
				}
				break;
		}
		switch (arMask & verticalMask) {
			case None :
				if (mt !== 0) {
					y += hdiff * mt / (mt + mb);
				}
				break;
			case FlexibleTopMargin :
				y += hdiff;
				break;
			case FlexibleTopMargin | FlexibleBottomMargin :
			case FlexibleBottomMargin :
				break;
			case FlexibleHeight :
				height += hdiff;
				break;
			case FlexibleTopMargin | FlexibleHeight :
				if (height !== 0) {
					y += hdiff * mt / (mt + height);
					height += hdiff * height / (mt + height);
				}
				break;
			case FlexibleBottomMargin | FlexibleHeight :
				if (height != 0) {
					height += hdiff * height / (mb + height);
				}
				break;
			case FlexibleTopMargin | FlexibleHeight | FlexibleBottomMargin :
				if (oldsize.height) {
					var r = hdiff / oldsize.height;
					y += y * r;
					height += height * r;
				}
				break;
		}
		return {
			x : x,
			y : y,
			height : height,
			width : width
		};
	}

	function init(options) {
		var opt, dc = D(this.container);
		if (options.clipToBound === false) {
			dc.css('overflow', 'visible');
		}
		if (options.hidden === true) {
			dc.css('display', 'none');
			this._hidden = true;
		}
		if (options.autoResizingMask < 32) {
			this._autoresizingMask = +options.autoResizingMask;
		}
		if (opt = options.pin) {
			this._pinX = opt.x;
			this._pinY = opt.y;
		}
		if (opt = options.position) {
			this._x = opt.x;
			this._y = opt.y;
			dc.css('left', this._x - this._pinX * this._width);
			dc.css('top', this._y - this._pinY * this._height);
		}

		if (opt = options.size) {
			this._width = opt.w || opt.width;
			this._height = opt.h || opt.height;
			dc.width(this._width);
			dc.height(this._height);
		}
		registerMandatoryHandler.call(this);
	}

	function registerMandatoryHandler() {
		this.on({
					'sizeChanged' : updateContainerSize.bind(this),
					'heightChanged' : updateContainerHeight.bind(this),
					'widthChanged' : updateContainerWidth.bind(this),
					'positionChanged' : updateContainerPos.bind(this),
					'pinChanged' : updateContainerPin.bind(this)
				});
	}

	function updateContainerSize(os, ns) {
		var dc = D(this.container);
		dc.width(ns.width);
		dc.height(ns.height);
		if (this._pinX || this._pinY) {
			dc.css('left', this._x - this._pinX * ns.width);
			dc.css('top', this._y - this._pinY * ns.height);
		}
		this.doContentResize(os, ns);
		layout.call(this, os, ns);
	}
	function updateContainerWidth(ow, nw) {
		var dc = D(this.container);
		dc.width(nw);
		if (this._pinX) {
			dc.css('left', this._x - this._pinX * nw);
		}
		var os = {
			height : this._height,
			width : ow
		}, ns = {
			height : this._height,
			width : nw
		};
		this.doContentResize(os, ns);
		layout.call(this, os, ns);
	}

	function updateContainerHeight(oh, nh) {
		var dc = D(this.container);
		dc.height(nh);
		if (this._pinY) {
			dc.css('top', this._y - this._pinY * nh);
		}
		var os = {
			height : oh,
			width : this._width
		}, ns = {
			height : nh,
			width : this._width
		};
		this.doContentResize(os, ns);
		layout.call(this, os, ns);
	}

	function updateContainerPos(op, np) {
		var dc = D(this.container);
		dc.css('left', np.x - this._pinX * this._width);
		dc.css('top', np.y - this._pinY * this._height);
	}

	function updateContainerPin(oap, nap) {
		var dc = D(this.container);
		dc.css('left', this._x - nap.x * this._width);
		dc.css('top', this._y - nap.y * this._height);
	}

	function handleSubCompHide(comp) {
		var pv = comp.visibility();
		if (pv) {
			comp.doBeforeHide();
			comp.fireEvent('beforeHide');
		}
		comp._parentVisible = false;
		var subCompItr = comp.children.iterator();
		while (subCompItr.hasNext()) {
			handleSubCompHide.call(comp, subCompItr.next());
		}
		if (pv) {
			comp.doAfterHide();
			comp.fireEvent('afterHide');
		}
	}

	function handleSubCompShow(comp) {
		var pv = comp.visibility();
		comp._parentVisible = comp.parent.visibility();// true;
		if (!pv && comp.visibility()) {
			comp.doBeforeShow();
			comp.fireEvent('beforeShow');
		}
		var subCompItr = comp.children.iterator();
		while (subCompItr.hasNext()) {
			handleSubCompShow.call(comp, subCompItr.next());
		}

		if (!pv && comp.visibility()) {
			comp.doAfterShow();
			comp.fireEvent('afterShow');
		}
	}

	/**
	 * This class defines UI component which serves as the super class of every
	 * controls
	 * 
	 * @name sap.viz.mvc.UIComponent
	 * @class
	 * @augments sap.viz.base.utils.Observable
	 */
	var UIComponent = Observable.extend(
			/**
			 * @lends sap.viz.mvc.UIComponent
			 * 
			 */
			{
		events : ['widthChanged', 'heightChanged', 'sizeChanged',
				'positionChanged', 'pinChanged', 'attached', 'detached',
				'beforeShow', 'afterShow', 'beforeHide', 'afterHide',
				'focusin', 'focusout', 'focus', 'blur', 'mousedown', 'mouseup',
				'mouseenter', 'mouseleave', 'mousemove', 'click', 'dblclick',
				'touchstart', 'touchmove', 'touchend', 'touchcancel'],
		/**
		 * @constructor
		 * @param {Object}
		 *            options the options to initialize the UI component
		 * @param {Boolean}
		 *            [options.hidden] whether the UI component is hidden
		 * @param {Integer}
		 *            [options.autoresizingMask] the bitwise combination of the
		 *            autoresizing mask, default is
		 *            {@link  sap.viz.mvc.UIComponent.Autosizing#None}
		 * @param {Object}
		 *            [options.anchor] the anchor point of the UI component,
		 *            default is
		 * 
		 * <pre>
		 * {
		 * 	x : 0.5,
		 * 	y : 0.5
		 * }
		 * </pre>
		 * 
		 * @param {Object}
		 *            [options.position] the position of the UI component,
		 *            default is
		 * 
		 * <pre>
		 * {
		 * 	x : 0,
		 * 	y : 0
		 * }
		 * </pre>
		 * 
		 * @param {Object}
		 *            [options.size] the size of the UI component, default is
		 * 
		 * <pre>
		 * {
		 * 	width : 0,
		 * 	height : 0
		 * }
		 * </pre>
		 */
		constructor : function(options) {
			options = options || {};
			var id = options.id ? options.id + '_' + nextId() : 'UIComp_'
					+ nextId();
			Object.defineProperties(this, {
						'id' : {
							value : id,
							enumerable : true
						},
						'container' : {
							// DOM div container for this ui component
							value : D(document.createElement('div'))
									.attr('id', id).css('position', 'relative')
									.css({
												'overflow' : 'hidden',
												'font-size' : '10px',
												'box-sizing' : 'border-box',
												'-moz-box-sizing' : 'border-box',
												'-ms-box-sizing' : 'border-box',
												'-webkit-box-sizing' : 'border-box'
											}).data('selfComp', this).get(0),
							enumerable : true,
							writable : true
						},

						'root' : {
							value : undefined,
							writable : true,
							enumerable : true
						},
						'parent' : {
							value : undefined,
							writable : true,
							enumerable : true
						},
						'children' : {
							value : new LinkedHashSet(function(item) {
										return item.id;
									}),
							enumerable : true,
							writable : true
						},
						'gestureDetectors' : {
							value : [],
							enumerable : true
						}
					});
			// Flag indicates if the underlying div is attached to DOM
			this._attached = false;

			this._hidden = false;

			this._parentVisible = false;

			this._autoresizable = true;

			this._autoresizingMask = None;

			this._x = 0;

			this._y = 0;

			this._width = 1;

			this._height = 1;

			this._pinX = 0.5;

			this._pinY = 0.5;

			init.call(this, options);
		},

		markAttached : function() {
			this._attached = true;
			if (this.parent)
				this._parentVisible = this.parent.visibility();
			if (this.visibility()) {
				this.doBeforeShow();
				this.fireEvent('beforeShow');
			}
			var subCompItr = this.children.iterator();
			while (subCompItr.hasNext()) {
				subCompItr.next().markAttached();
			}
			if (this.visibility()) {
				this.doAfterShow();
				this.fireEvent('afterShow');
			}
		},

		markDetached : function() {
			var pv = this.visibility();
			this._attached = false;
			if (pv) {
				this.doBeforeHide();
				this.fireEvent('beforeHide');
			}
			var subCompItr = this.children.iterator();
			while (subCompItr.hasNext()) {
				subCompItr.next().markDetached();
			}
			if (pv) {
				this.doAfterHide();
				this.fireEvent('afterHide');
			}
		},

		/**
		 * Mark the component as hidden, if the component is already marked as
		 * hidden, nothing will happen; Whether the component will be hidden and
		 * whether the events <b>beforeHide</b>, <b>afterHide</b> will get
		 * fired and the call-back methods <b>doBeforeHide</b>, <b>doAfterHide</b>
		 * will get triggered depend on two conditions: 1, whether its parent is
		 * current shown. 2, whether the component is attached to DOM currently.
		 * 
		 * @name sap.viz.mvc.UIComponent#markHide
		 * @function
		 * @returns {this}
		 */
		markHide : function() {
			if (this._hidden === false) {
				var pv = this.visibility();
				if (pv) {
					this.doBeforeHide();
					this.fireEvent('beforeHide');
				}
				this._hidden = true;
				D(this.container).css('display', 'none');
				var subCompItr = this.children.iterator();
				while (subCompItr.hasNext()) {
					handleSubCompHide.call(this, subCompItr.next());
				}
				if (pv) {
					this.doAfterHide();
					this.fireEvent('afterHide');
				}
			}
			return this;
		},

		/**
		 * Mark the component as shown, if the component is already marked as
		 * shown, nothing will happen; Whether the component will be shown and
		 * whether the events <b>beforeShow</b>, <b>afterShow</b> and the
		 * call-back methods <b>doBeforeShow</b>, <b>doAfterShow</b> will get
		 * triggered depend on two conditions: 1, all of its ancestors are
		 * marked as shown. 2, the component is currently attached to DOM.
		 * 
		 * @name sap.viz.mvc.UIComponent#markShow
		 * @function
		 * @returns {this}
		 */
		markShow : function() {
			if (this._hidden === true) {
				this._hidden = false;
				if (this.visibility()) {
					this.doBeforeShow();
					this.fireEvent('beforeShow');
				}
				D(this.container).css('display', 'block');
				var subCompItr = this.children.iterator();
				while (subCompItr.hasNext()) {
					handleSubCompShow.call(subCompItr.next());
				}
				if (this.visibility()) {
					this.doAfterShow();
					this.fireEvent('afterShow');
				}
			}
			return this;
		},

		clipToBound : function(clipToBound) {
			var dc = D(this.container);
			if (arguments.length) {
				dc.css('overflow', clipToBound ? 'hidden' : 'visible');
				return this;
			} else {
				return dc.css('overflow') === 'hidden';
			}
		},

		/**
		 * Get the current visibility of the component, the visibility is
		 * affected by the component's hidden/shown status, whether it's
		 * attached to DOM, whether it's ancestor components are shown.
		 * 
		 * 
		 * @name sap.viz.mvc.UIComponent#visibility
		 * @function
		 * @returns {Boolean}
		 */
		visibility : function() {
			return !this._hidden && this._attached && this._parentVisible;
		},

		/**
		 * Get and set whether the component should resize automatically when
		 * its parent's size changed
		 * 
		 * @name sap.viz.mvc.UIComponent#autoResizable
		 * @function
		 * @param {undefined|Boolean}
		 *            autoresize
		 * @returns {this|Boolean}
		 */
		autoResizable : function(autoResize) {
			if (arguments.length) {
				this._autoresizable = autoResize && true;
				return this;
			} else {
				return this._autoresizable && true;
			}
		},

		/**
		 * Get and set the autoresizing mask of the component
		 * 
		 * @name sap.viz.mvc.UIComponent#autoResizingMask
		 * @function
		 * @param {undefined|Integer}
		 *            mask
		 * @returns {this|Integer}
		 */
		autoResizingMask : function(mask) {
			if (arguments.length) {
				if (mask < 32) {
					this._autoresizingMask = +mask;
				}
				return this;
			} else {
				return this._autoresizingMask;
			}
		},

		/**
		 * Get the position of the component, the position is in Page coordinate
		 * system
		 * 
		 * @name sap.viz.mvc.UIComponent#pagePosition
		 * @function
		 * 
		 * <pre>
		 * {
		 *      x : ##,
		 *      y : ##,
		 * }
		 * </pre>
		 * 
		 * @returns {Object}
		 */
		pagePosition : function() {
			var offset = D(this.container).offset();
			return {
				x : offset.left,
				y : offset.top
			};
		},
		/**
		 * Get and set the position of the component, the position is in it's
		 * direct super component's coordinate system
		 * 
		 * @name sap.viz.mvc.UIComponent#position
		 * @function
		 * @param {Point|Number}
		 *            x x coordinate or <b>Point</b> object.
		 * @param {Number}
		 *            [y] y coordinate
		 * 
		 * 
		 * @returns {this|Point }
		 */
		position : function(x, y) {
			if (arguments.length === 0)
				return {
					x : this._x,
					y : this._y
				};

			if (arguments.length === 1) {
				y = x.y;
				x = x.x;
			}
			x = +x;
			y = +y;
			if (this._x !== x || this._y !== y)
				this.fireEvent('positionChanged', {
							x : this._x,
							y : this._y
						}, {
							x : this._x = x,
							y : this._y = y
						});
			return this;
		},
		/**
		 * Get and set the size of the component
		 * 
		 * @name sap.viz.mvc.UIComponent#size
		 * @function
		 * @param {Number|Size}
		 *            width the width of the layer or <b>Size</b> object
		 * @param {Number}
		 *            (height) the height of the layer, omitted when receiving a
		 *            <b>Size</b> object
		 * 
		 * Size Object is defined as:
		 * 
		 * <pre>
		 * {
		 *      width : ##,
		 *      height : ##
		 * }
		 * </pre>
		 * 
		 * @returns {this|Size}
		 */
		size : function(width, height) {
			if (!arguments.length)
				return {
					width : this._width,
					height : this._height
				};

			if (arguments.length === 1) {
				height = width.height;
				width = width.width;
			}
			height = +height;
			width = +width;
			if (width !== this._width || height !== this._height)
				this.fireEvent('sizeChanged', {
							width : this._width,
							height : this._height
						}, {
							width : this._width = width,
							height : this._height = height
						});

			return this;
		},
		/**
		 * Get and set the width of the component
		 * 
		 * @name sap.viz.mvc.UIComponent#width
		 * @function
		 * @param {Number}
		 *            width the new width of the layer
		 * 
		 * 
		 * @returns {this|Number}
		 */
		width : function(width) {
			if (!arguments.length)
				return this._width;

			width = +width;
			if (this._width !== width && width > 0)
				this.fireEvent('sizeChanged', {
							width : this._width,
							height : this._height
						}, {
							width : this._width = width,
							height : this._height
						});

			return this;
		},
		/**
		 * Get and set the height of the component
		 * 
		 * @name sap.viz.mvc.UIComponent#height
		 * @function
		 * @param {Number|Function}
		 *            (height) the new height of the layer or function returns
		 *            height value.
		 * 
		 * 
		 * @returns {this|Number}
		 * 
		 * 
		 * @returns {this|Number}
		 */
		height : function(height) {
			if (!arguments.length)
				return this._height;

			height = +height;
			if (this._height !== height && height > 0)
				this.fireEvent('sizeChanged', {
							width : this._width,
							height : this._height
						}, {
							width : this._width,
							height : this._height = height
						});

			return this;
		},
		/**
		 * Pin is used to specify which point the component's geometric boundary
		 * is used to locate the layer. If no argument specified, current Pin is
		 * returned, the default Pin is (0.5,0.5). If single argument specified,
		 * it must be either <b>Point</b> object or a function returns <b>Point</b>.
		 * If two arguments specified, they must be two numbers corresponding to
		 * x, y of Pin.
		 * 
		 * @name sap.viz.mvc.UIComponent#pin
		 * @function
		 * @param {Number|Point}
		 *            (x)
		 * @param {Number}
		 *            (y)
		 * 
		 * 
		 * @returns {this|Point }
		 */
		pin : function(x, y) {
			if (!arguments.length)
				return {
					x : this._pinX,
					y : this._pinY
				};

			if (arguments.length === 1) {
				y = x.y;
				x = x.x;
			}
			x = +x;
			y = +y;

			if (x !== this._pinX || y !== this._pinY)
				this.fireEvent('pinChanged', {
							x : this._pinX,
							y : this._pinY
						}, {
							x : this._pinX = x,
							y : this._pinY = y
						});

			return this;
		},
		/**
		 * Frame is a convenient way to update position and size of the
		 * component at once, frame defines the component's rectangular boundary
		 * using a rectangle in parent's layer's coordinate system. If no
		 * argument specified, the current frame is returned. If single argument
		 * specified, it must be either <b>Rect</b> object or a function
		 * returns <b>Rect</b> object, otherwise 4 arguments must be supplied.
		 * 
		 * @name sap.viz.mvc.UIComponent#frame
		 * @function
		 * @function
		 * @param {Rect|Number}
		 *            x could be Number, <b>Rect</b> object
		 * @param {Number)
		 *            (y)
		 * @param {Number)
		 *            (width)
		 * @param {Number)
		 *            (height)
		 * 
		 * 
		 * @returns {this|Rect }
		 */
		frame : function(x, y, width, height) {
			if (!arguments.length)
				return {
					x : this._x - this._pinX * this._width,
					y : this._y - this._pinY * this._height,
					width : this._width,
					height : this._height
				};

			if (arguments.length === 1) {
				y = x.y;
				width = x.width;
				height = x.height;
				x = x.x;
			}
			var newPosX = x + width * this._pinX, newPosY = y + height
					* this._pinY;
			if (width !== this._width || height !== this._height) {
				this.fireEvent('sizeChanged', {
							width : this._width,
							height : this._height
						}, {
							width : this._width = width,
							height : this._height = height
						});
			}
			if (newPosX !== this._x || newPosY !== this._y) {
				this.fireEvent('positionChanged', {
							x : this._x,
							y : this._y
						}, {
							x : this._x = newPosX,
							y : this._y = newPosY
						});
			}
			return this;
		},

		/**
		 * Append a component as its last child component, the visibility
		 * related events and call-back methods will get triggered on the
		 * component tree based on the appended component's visibility.
		 * 
		 * @name sap.viz.mvc.UIComponent#append
		 * @function
		 * @param {sap.viz.mvc.UIComponent}
		 *            subComp component to append
		 * @return {this}
		 */
		append : function(subComp) {
			if (subComp) {
				if (subComp.parent !== undefined)
					subComp.detach();
				subComp.parent = this;
				if (this.root) {
					walk(subComp, function(node) {
								node.root = this;
							}.bind(this.root));
				}
				this.children.add(subComp);
				this.container.appendChild(subComp.container);
				if (this._attached) {
					subComp.markAttached();
				}
				return this;
			}
		},

		/**
		 * Append this component to other component as a child
		 * 
		 * @param {sap.viz.mvc.UIComponent}
		 *            superComp component to be appended
		 * @return {this}
		 */
		appendTo : function(superComp) {
			superComp.append(this);
			return this;
		},
		/**
		 * Detach this component from its parent, the detached component is not
		 * destroyed and could be reattached later. the visibility related
		 * events and call-back methods will get triggered based on the detached
		 * component's previous visibility.
		 * 
		 * @name sap.viz.mvc.UIComponent#detach
		 * @function
		 */
		detach : function() {
			if (this.parent) {
				this.parent.children.remove(this);
				D(this.container).detach();
				this.parent = undefined;
				walk(this, function(node) {
							node.root = undefined;
						});
				this.markDetached();
			}
			return this;
		},

		before : function(target) {
			target.insertBefore(this);
			return this;
		},
		/**
		 * Insert this component as a child before the specified component, if
		 * this component has been attached to other component, it will be
		 * detached firstly.
		 * 
		 * @name sap.viz.mvc.UIComponent#insertBefore
		 * @function
		 * @param {sap.viz.mvc.UIComponent}
		 *            target the component to be inserted before
		 */
		insertBefore : function(target) {
			if (target && target.parent && target !== this) {
				if (this.parent) {
					this.detach();
				}
				var superComp = target.parent;
				this.parent = superComp;
				if (superComp.root) {
					walk(this, function(node) {
								node.root = this;
							}.bind(superComp.root));
				}
				superComp.children.insertBefore(this, target);
				this.container.parentNode.insertBefore(target.container,
						this.container);
				if (this._attached) {
					this.markAttached();
				}
			}
			return this;
		},

		after : function(target) {
			target.insertAfter(this);
			return this;
		},

		/**
		 * Insert this component as a child after the specified component, if
		 * this component has been attached to other component, it will be
		 * detached firstly.
		 * 
		 * @name sap.viz.mvc.UIComponent#insertAfterSubComponent
		 * @function
		 * 
		 * @param {sap.viz.mvc.UIComponent}
		 *            target the component to be inserted before
		 */
		insertAfter : function(target) {
			if (target && target.parent && target !== this) {
				if (this.parent) {
					this.detach();
				}
				var superComp = target.parent;
				this.parent = superComp;
				if (superComp.root) {
					walk(this, function(node) {
								node.root = this;
							}.bind(superComp.root));
				}
				superComp.children.insertAfter(this, target);
				this.container.parentNode.insertAfter(target.container,
						this.container);
				if (this._attached) {
					this.markAttached();
				}
			}
			return this;
		},
		/**
		 * Bring this component as the last component of its super component
		 * 
		 * @name sap.viz.mvc.UIComponent#bringToFront
		 * @function
		 * 
		 */
		bringToFront : function() {
			var superComp = this.parent;
			if (superComp) {
				if (superComp.children.last() !== this) {
					superComp.children.moveToLast(this);
					D(this.container).detach();
					// this.container.appendTo(subComp.container);
					subComp.container.appendChild(this.container);
				}
			}
			return this;
		},
		/**
		 * Send this component as the first component of its super component
		 * 
		 * @name sap.viz.mvc.UIComponent#bringToFront
		 * 
		 * @name sap.viz.mvc.UIComponent#sendToBack
		 * @function
		 */
		sendToBack : function() {
			var superComp = this.parent;
			if (superComp) {
				if (superComp.children.first() !== this) {
					superComp.children.moveToFirst(this);
					D(this.container).detach();
					// this.container.prependTo(subComp.container);
					subComp.container.insertBefore(this.container,
							subComp.container.firstChild);
				}
			}
			return this;
		},

		/**
		 * Convert the point from other component's coordinate system to this
		 * component's coordinate system. If the <b>this<b> component is
		 * detached from root, no convertion happens; if the <b>from</b>
		 * component is not specified or is detached, the specified x,y will be
		 * treated as a point in global coordinate system.
		 * 
		 * @name sap.viz.mvc.UIComponent#pointFrom
		 * @function
		 * @param {Number|Point}
		 *            x the x coordinate of the point or Point object
		 * @param {Number|sap.viz.mvc.UIComponent}
		 *            (y) the y coordinate of the point or other UIComponent
		 * @param {sap.viz.mvc.UIComponent}
		 *            (from)
		 * @returns {Point}
		 */
		pointFrom : function(x, y, from) {
			if (arguments.length === 1) {
				y = x.y;
				x = x.x;
				from = false;
			}
			if (arguments.length === 2) {
				if (isNaN(x)) {
					from = y;
					y = x.y;
					x = x.x;
				} else {
					from = false;
				}
			}
			x = +x;
			y = +y;
			from.root || (from = false);
			var root = this.root;
			if (root) {
				from || (from = root);

				// this -> from conversion
				var dx = 0, dy = 0, current = this, frame;
				while (current !== root && current !== from) {
					frame = current.frame();
					dx += frame.x;
					dy += frame.y;
					current = current.parent;
				}
				if (current !== from) {
					// "this" is not a child of "from"
					current = from;
					// from -> this conversion
					while (current !== root && current !== this) {
						frame = current.frame();
						x += frame.x;
						y += frame.y;
						current = current.parent;
					}
					if (current === this) {
						// "this" is an ancestor of "from"
						return {
							x : x,
							y : y
						};
					}
				}
				return {
					x : x - dx,
					y : y - dy
				};
			}
			return {
				x : x,
				y : y
			};
		},
		/**
		 * Convert local point to a point in the coordinate system of the
		 * specified component. If the <b>this<b> component is detached from
		 * root, no convertion happens; if the <b>to</b> component is not
		 * specified or is detached, the specified x,y will be converted to
		 * global coordinate system.
		 * 
		 * @name sap.viz.mvc.UIComponent#pointFrom
		 * @function
		 * @param {Number|Point}
		 *            x the x coordinate of the point or Point object
		 * @param {Number|sap.viz.mvc.UIComponent}
		 *            (y) the y coordinate of the point or other UIComponent
		 * @param {sap.viz.mvc.UIComponent}
		 *            (from)
		 * @returns {Point}
		 */
		pointTo : function(x, y, to) {
			if (arguments.length === 1) {
				y = x.y;
				x = x.x;
				from = false;
			}
			if (arguments.length === 2) {
				if (isNaN(x)) {
					from = y;
					y = x.y;
					x = x.x;
				} else {
					from = false;
				}
			}
			x = +x;
			y = +y;
			var root = this.root;
			if (root) {
				to || (to = root);
				return to.pointFrom(x, y, this);
			}
			return {
				x : x,
				y : y
			};
		},

		fireFocusEvent : function(event) {
			this.fireEvent(event.type, event);
			if (this.parent && event.shouldBubble()) {
				event.currentTarget = this.parent;
				this.parent.fireEvent(event);
			}
		},

		fireMouseEvent : function(event) {
			this.fireEvent(event.type, event);
			if (this.parent && event.shouldBubble()) {
				event.currentTarget = this.parent;
				event.currentLocalXY = {
					x : event.currentLocalXY.x + this._x - this._pinX
							* this._width,
					y : event.currentLocalXY.y + this._y - this._pinY
							* this._height
				};
				this.parent.fireMouseEvent(event);
			}
		},

		fireTouchEvent : function(event) {
			this.fireEvent(event.type, event);
			if (this.parent && event.shouldBubble()) {
				event.currentTarget = this.parent;
				this.parent.fireTouchEvent(event);
			}
		},

		/**
		 * Remove all listeners currently attached to the component
		 * 
		 * @name sap.viz.mvc.UIComponent#purgeListeners
		 * @function
		 */
		purgeListeners : function() {
			this._super();
		},
		/**
		 * Remove all listeners currently listening on the given event
		 * 
		 * @name sap.viz.mvc.UIComponent#un
		 * @function
		 * @param {String}
		 *            eventName
		 */
		un : function(eventName) {
			this._super.apply(this, arguments);
			if (arguments.length === 1) {
				switch (eventName) {
					case 'sizeChanged' :
						this.on('sizeChanged', updateContainerSize.bind(this));
						break;
					case 'heightChanged' :
						this.on('heightChanged', updateContainerHeight
										.bind(this));
						break;
					case 'widthChanged' :
						this
								.on('widthChanged', updateContainerWidth
												.bind(this));
						break;
					case 'positionChanged' :
						this.on('positionChanged', updateContainerPos
										.bind(this));
						break;
					case 'pinChanged' :
						this.on('pinChanged', updateContainerPin.bind(this));
						break;
				}
			}
		},
		/**
		 * Add a gesture detector to this component
		 * 
		 * @name sap.viz.mvc.UIComponent#addGestureDetector
		 * @function
		 * @param {sap.viz.mvc.GestureDetector}
		 *            detector
		 */
		addGestureDetector : function(detector) {
			if (detector instanceof GestureDetector) {
				detector.watchedComponent = this;
				this.gestureDetectors.push(detector);
			}
		},
		/**
		 * remove a previously added gesture detector to this component
		 * 
		 * @name sap.viz.mvc.UIComponent#addGestureDetector
		 * @function
		 * @param {sap.viz.mvc.GestureDetector}
		 *            detector
		 */
		removeGestureDetector : function(detector) {
			for (var i = 0, len = this.gestureDetectors.length; i < len; i++) {
				if (this.gestureDetectors[i] === detector) {
					this.gestureDetectors.splice(i, 1);
					detector.watchedComponent = undefined;
					len--;
				}
			}
		},

		/**
		 * Returns the farthest descendant uicomponent that can respond to the
		 * hit point.
		 * 
		 * @name sap.viz.mvc.UIComponent#hitTest
		 * @param {Number|Point}
		 *            x the x coordinate of the point or the point object
		 * @param {Number}
		 *            (y) the y coordinate of the point
		 * @returns {sap.viz.mvc.UIComponent}
		 */
		hitTest : function(x, y) {
			if (arguments.length = 1) {
				y = x.y;
				x = x.x;
			}
			var pStack = [{
						comp : this,
						subCompsItr : this.children.iterator(true)
					}];
			var comp, subCompsItr;
			while (pStack.length) {
				comp = pStack[pStack.length - 1];
				subCompsItr = comp.subCompsItr;
				comp = comp.comp;
				if (comp.visibility()) {
					if (subCompsItr.hasNext()) {
						var subComp = subCompsItr.next();
						pStack.push({
									comp : subComp,
									subCompsItr : subComp.children
											.iterator(true)
								});
						continue;
					} else {
						var point = comp.pointFrom(x, y, this);
						if (point.x >= 0 && point.y >= 0
								&& point.x < comp.width()
								&& point.y < comp.height()
								&& comp.pointContent(x, y))
							return comp;
					}
					pStack.pop();
				} else {
					pStack.pop();
				}
			}
		},

		/**
		 * Test whether the given local point is currently pointing the visual
		 * content of the UIComponent. Hitting test will furthur use this method
		 * to determine if a point is hitting the component after checking the
		 * boundary enclosing. Default implementation always returns true.
		 * 
		 * @name sap.viz.mvc.UIComponent#pointContent
		 * @function
		 * @param {Number|Point}
		 *            x the x coordinate of the point or Point object
		 * @param {Number}
		 *            (y) the y coordinate of the point
		 * @returns {Boolean}
		 */
		pointContent : function(x, y) {
			return true;
		},

		/**
		 * Implement this method to do adhoc sub-components layout, this method
		 * will be called on super component when its size changed.
		 * 
		 * @name sap.viz.mvc.UIComponent#doLayout
		 * @function
		 */
		doLayout : noop,

		/**
		 * Resize component's visual content, when the component's size changed,
		 * this method will be invoked before layout sub components
		 * 
		 * @name sap.viz.mvc.UIComponent#doContentResize
		 * @function
		 * @param {Object}
		 *            os the old size of the component
		 * @param {Object}
		 *            ns the new size of the component
		 */
		doContentResize : noop,

		/**
		 * This method will get called before the component becoming hidden
		 * 
		 * @name sap.viz.mvc.UIComponent#doBeforeHide
		 * @function
		 */
		doBeforeHide : noop,
		/**
		 * This method will get called after the component is hided
		 * 
		 * @name sap.viz.mvc.UIComponent#doAfterHide
		 * @function
		 */
		doAfterHide : noop,
		/**
		 * This method will get called before the component becoming visible
		 * 
		 * @name sap.viz.mvc.UIComponent#doBeforeShow
		 * @function
		 */
		doBeforeShow : noop,
		/**
		 * This method will get called after the component is visible
		 * 
		 * @name sap.viz.mvc.UIComponent#doAfterShow
		 * @function
		 */
		doAfterShow : noop,

		doDestroy : noop,

		destroy : function() {
			this.doDestroy();
			walk(this, function(node) {
						node.detach();
						node.purgeListeners();
					});
			D(this.container).removeData('selfComp');
			//remove reference
			//this._holder = null;
			if(this.children){
			  this.children = null;
			}
		}
	});
	UIComponent.Autosizing = {
		None : None,
		FlexibleLeftMargin : FlexibleLeftMargin,
		FlexibleWidth : FlexibleWidth,
		FlexibleRightMargin : FlexibleRightMargin,
		FlexibleTopMargin : FlexibleTopMargin,
		FlexibleHeight : FlexibleHeight,
		FlexibleBottomMargin : FlexibleBottomMargin
	};
	return UIComponent;
});
define('sap/viz/base/utils/LinkedHashMap',['sap/viz/base/utils/FunctionUtils'],
function Setup(FuncUtils) {
	function hasMoreInOrder() {
		if (this._count !== 0) {
			if (this._count === this._lhm._length) {
				this._cursor = this._lhm._head;
			} else {
				this._cursor = this._cursor.next;
			}
			this._count--;
			return true;
		} else {
			return false;
		}
	}

	function hasMoreInReverse() {
		if (this._count !== 0) {
			if (this._count === this._lhm._length) {
				this._cursor = this._lhm._last;
			} else {
				this._cursor = this._cursor.prev;
			}
			this._count--;
			return true;
		} else {
			return false;
		}
	}
	/**
	 * Iterator for LinkedHashMap, to get an iterator for a linkedHashMap
	 * instance, use {@link sap.viz.base.utils.LinkedHashMap#getIterator}
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap.Iterator
	 * @constructor
	 */
	var lhmItr = function(lhm, reverseOrder) {
		this._lhm = lhm;
		this._reverse = reverseOrder || false;
		this._count = lhm._length;
		this._cursor = this._reverse ? this._lhm._last : this._lhm._head;
		if (this._reverse) {
			this.hasMore = hasMoreInReverse;
		} else {
			this.hasMore = hasMoreInOrder;
		}
	};

	var lhmItrP = lhmItr.prototype;

	/**
	 * Find if there is more item to iterate, calling this method will move the
	 * cursor forward to next item
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap.Iterator#hasMore
	 * @function
	 * @returns {Boolean}
	 */
	lhmItrP.hasMore = FuncUtils.noop;

	/**
	 * Get the entry at the current cursor, calling this method without calling
	 * hasMore method will return the same entry
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap.Iterator#next
	 * @function
	 * @returns {Object} with key & value property indicating the entry's key
	 *          and value object
	 */
	lhmItrP.next = function() {
		var ret = {
			key : this._cursor.key,
			value : this._cursor.value
		};
		return ret;
	};
	/**
	 * Get the value of entry at the current cursor, calling this method without
	 * calling hasMore method will return the same entry
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap.Iterator#nextValue
	 * @function
	 * @returns {Object}
	 */
	lhmItrP.nextValue = function() {
		return this._cursor.value;
	};
	/**
	 * Get the key of entry at the current cursor, calling this method without
	 * calling hasMore method will return the same entry
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap.Iterator#nextKey
	 * @function
	 * @returns {String}
	 */
	lhmItrP.nextKey = function() {
		return this._cursor.key;
	};
	/**
	 * Reset the iterator to initial state
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap.Iterator#reset
	 * @function
	 */
	lhmItrP.reset = function() {
		this._count = this._lhm._length;
	};

	/**
	 * Remove the current entry from LinkedHashMap
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap.Iterator#remove
	 * @function
	 */
	lhmItrP.remove = function() {
		return this._lhm.remove(this._cursor.key);
	};

	/**
	 * Create an empty LinkedHashMap
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap
	 * @constructor
	 */
	var LinkedHashMap = function() {
		this._map = {};
		this._head = undefined;
		this._last = undefined;
		this._length = 0;
	};
	var lhmp = LinkedHashMap.prototype;

	/**
	 * Add one entry, if the key for the entry is already existing, then the old
	 * value will be replaced.
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#add
	 * @function
	 * @param {String}
	 *            key the key for the entry
	 * @param {Object}
	 *            value the value for the entry
	 * @returns {undefined|Object} undefined if key is new, otherwise will be
	 *          the replaced value
	 */
	lhmp.add = function(key, value) {
		var m = this._map;
		var ret = null;
		var node = {
			prev : null,
			key : key,
			value : value,
			next : null
		};
		if (!this._length) {
			this._head = this._last = node;
		}
		if (!m.hasOwnProperty(key)) {
			m[key] = node;
			this._length++;
			node.prev = this._last;
			this._last.next = node;
			this._last = node;
			this._last.next = this._head;
			this._head.prev = this._last;
		} else {
			ret = m[key].value;
			m[key].value = value;
		}
		return ret;
	};
	/**
	 * Add entries from an existing linked hash map, the duplicated entry will
	 * be replaced silently
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#addAll
	 * @function
	 * @param {sap.viz.base.utils.LinkedHashMap}
	 *            linkedHashMap another linkedHashMap to added
	 */
	lhmp.addAll = function(linkedHashMap) {
		var itr = linkedHashMap.getIterator();
		var entry;
		while (itr.hasMore()) {
			entry = itr.next();
			this.add(entry.key, entry.value);
		}
	};
	/**
	 * Insert the entry before one entry, if the inserted entry exists or the
	 * entry to be inserted before doesn't exist, insertion will fail silently
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#insertBefore
	 * @function
	 * @param {String}
	 *            key the key for the entry
	 * @param {Object}
	 *            value the value for the entry
	 * @param {String}
	 *            beforeKey the key of the entry to be inserted before
	 * @returns {Object} the value inserted
	 */
	lhmp.insertBefore = function(key, value, beforeKey) {
		var m = this._map;
		if (!m.hasOwnProperty(key) && m.hasOwnProperty(beforeKey)) {
			var nnode = {
				prev : null,
				key : key,
				value : value,
				next : null
			};
			var anode = m[beforeKey];
			if (anode !== this._head) {
				nnode.prev = anode.prev;
				anode.prev.next = nnode;
			} else {
				this._head = nnode;
				nnode.prev = this._last;
			}
			nnode.next = anode;
			anode.prev = nnode;
			m[key] = nnode;
			this._length++;
			return value;
		}
	};
	/**
	 * Insert the entry after one entry, if the inserted entry exists or the
	 * entry to be inserted after doesn't exist, insertion will fail silently
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#insertAfter
	 * @function
	 * @param {String}
	 *            key the key for the entry
	 * @param {Object}
	 *            value the value for the entry
	 * @param {String}
	 *            afterKey the key of the entry to be inserted after
	 * @returns {Object} the value inserted
	 */
	lhmp.insertAfter = function(key, value, afterKey) {
		var m = this._map;
		if (!m.hasOwnProperty(key) && m.hasOwnProperty(afterKey)) {
			var nnode = {
				prev : null,
				key : key,
				value : value,
				next : null
			};
			var anode = m[afterKey];
			if (anode !== this._last) {
				nnode.next = anode.next;
				anode.next.prev = nnode;
			} else {
				this._last = nnode;
				this._last.next = this._head;
			}
			anode.next = nnode;
			nnode.prev = anode;
			m[key] = nnode;
			this._length++;
			return value;
		}
	};
	/**
	 * Replace the existing entry with new entry, including key in place
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#replace
	 * @function
	 * @param {String}
	 *            key the key for the entry to be replaced
	 * @param {withKey}
	 *            withKey the key for the entry to be added
	 * @param {Object}
	 *            andValue the value of the entry to be added
	 * @returns {Object} the value to be replaced
	 */
	lhmp.replace = function(key, withKey, andValue) {
		var m = this._map;
		if (!m.hasOwnProperty(withKey) && m.hasOwnProperty(key)) {
			var nnode = {
				prev : null,
				key : withKey,
				value : andValue,
				next : null
			};
			var rnode = m[key];
			nnode.prev = rnode.prev;
			nnode.next = rnode.next;
			rnode.prev.next = nnode;
			rnode.next.prev = nnode;
			if (this._head === rnode)
				this._head = nnode;
			if (this._last === rnode)
				this._last = nnode;
			m[withKey] = nnode;
			delete m[key];
			return rnode.value;
		}
	};
	/**
	 * Get the value for the key
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#get
	 * @function
	 * @param {String}
	 *            key the key for the entry to get
	 * 
	 * @returns {Null|Object} the value for the key or Null if key is
	 *          non-existing
	 */
	lhmp.get = function(key) {
		var m = this._map;
		if (m.hasOwnProperty(key)) {
			return m[key].value;
		}
		return null;
	};
	/**
	 * Get the value of entry next to the entry associated with the given key
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#next
	 * @function
	 * @param {String}
	 *            key the key of the entry
	 * 
	 * @returns {Null|Object} the value for the key or Null if key is
	 *          non-existing
	 */
	lhmp.next = function(key) {
		var m = this._map;
		if (m.hasOwnProperty(key)) {
			return m[key].next;
		}
		return null;
	};
	/**
	 * Get the value of entry previous to the entry associated with the given
	 * key
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#prev
	 * @function
	 * @param {String}
	 *            key the key of the entry
	 * 
	 * @returns {Null|Object} the value for the key or Null if key is
	 *          non-existing
	 */
	lhmp.prev = function(key) {
		var m = this._map;
		if (m.hasOwnProperty(key)) {
			return m[key].prev;
		}
		return null;
	};
	/**
	 * Get the first inserted entry
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#getFirstInsert
	 * @function
	 * 
	 * @returns {Object} the value first inserted
	 */
	lhmp.getFirstInsert = function() {
		return this._head ? this._head.value : null;
	};
	/**
	 * Get the last inserted entry
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#getLastInsert
	 * @function
	 * 
	 * @returns {Object} the value last inserted
	 */
	lhmp.getLastInsert = function() {
		return this._last ? this._last.value : null;
	};
	/**
	 * Move entry associated with key to the last of the link
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#moveToLast
	 * @function
	 * @param {String}
	 *            key the key of the entry to move
	 */
	lhmp.moveToLast = function(key) {
		var m = this._map;
		if (m.hasOwnProperty(key) && this._last.key !== key) {
			var node = m[key];
			node.prev.next = node.next;
			node.next.prev = node.prev;
			node.prev = this._last;
			node.next = this._last.next;
			this._last.next = node;
			this._last = node;
			this._head = node.next;
			this._head.prev = node;

		}
	};
	/**
	 * Move entry associated with key to the first of the link
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#moveToFirst
	 * @function
	 * @param {String}
	 *            key the key of the entry to move
	 */
	lhmp.moveToFirst = function(key) {
		var m = this._map;
		if (m.hasOwnProperty(key) && this._head.key !== key) {
			var node = m[key];
			node.prev.next = node.next;
			node.next.prev = node.prev;
			node.next = this._head;
			node.prev = this._head.prev;
			this._head.prev = node;
			this._head = node;
			this._last = node.prev;
			this._last.next = node;
		}
	};
	/**
	 * Check whether having the key
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#has
	 * @function
	 * @param {String}
	 *            key the key of the entry to check
	 * @returns {Boolean}
	 */
	lhmp.has = function(key) {
		var m = this._map;
		return m.hasOwnProperty(key);
	};
	/**
	 * Remove the entry associated with the key
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#remove
	 * @function
	 * @param {String}
	 *            key the key of the entry to remove
	 * @returns {undefined|Object} the removed item or undefined if key is
	 *          non-existing
	 */
	lhmp.remove = function(key) {
		var m = this._map;
		var ret;
		if (m.hasOwnProperty(key)) {
			var node = m[key];
			ret = node.value;
			if (node === this._head) {
				this._head = node.next;
			}
			if (node === this._last) {
				this._last = node.prev;
			}
			node.prev.next = node.next;
			node.next.prev = node.prev;

			delete m[key];
			this._length--;
			if (this._length === 0) {
				this._head = this._last = undefined;
			}
			return ret;
		}
	};
	/**
	 * Remove all entries added before
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#purgeAll
	 * @function
	 */
	lhmp.purgeAll = function() {
		this._map = {};
		this._head = undefined;
		this._last = undefined;
		this._length = 0;
	};
	/**
	 * Whether the map is empty
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#isEmpty
	 * @function
	 * 
	 * @returns {Boolean}
	 */
	lhmp.isEmpty = function() {
		return this._length == 0;
	};
	/**
	 * Length of the map
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#length
	 * @function
	 * @returns {Integer}
	 */
	lhmp.length = function() {
		return this._length;
	};
	/**
	 * Get the iterator of the map
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#getIterator
	 * @function
	 * @param {Boolean}
	 *            reverseOrder whether iterate in reverse order
	 * @returns {sap.viz.base.utils.LinkedHashMap.Iterator}
	 */
	lhmp.getIterator = function(reverseOrder) {
		return new lhmItr(this, reverseOrder);
	};

	lhmp.keys = function() {
		var itr = this.getIterator(), keys = [];
		while (itr.hasMore())
			keys.push(itr.nextKey());
		return keys;
	};

	lhmp.values = function() {
		var itr = this.getIterator(), values = [];
		while (itr.hasMore())
			values.push(itr.nextValue());
		return values;
	};
	return LinkedHashMap;
});
define('sap/viz/base/utils/DomWatcher',['sap/viz/base/UADetector','sap/viz/base/utils/LinkedHashMap'],
function Setup(UADetector, LinkedHashMap) {
    var watcherId = 0, domNo = 1, observer;
    
    function nextWatcherId() {
        return watcherId++;
    }
    function nextDomNo() {
        return domNo++;
    }
                
    function isEmpty(obj) {
        for ( var prop in obj) {
            if (obj.hasOwnProperty(prop))
                return false;
        }
        return true;
    }
    function css(dom, prop) {
        var val = null;
        if (window.getComputedStyle) {
            val = window.getComputedStyle(dom, null)[prop];
        } else if (dom.currentStyle) {
            val = dom.currentStyle[prop];
        }
        return val;
    }
    function domDataAccessor(key, value) {
        if (!this._data)
            this._data = {};
        if (arguments.length === 2) {
            this._data[key] = value;
        } else
            return this._data[key];
    }
    var domTasks = new LinkedHashMap();
    //var observers = new LinkedHashMap();
    function eventHandler(mutations) {
        var task, dom, domNo, domTaskIt;
        mutations.forEach(
            function(mutation){
                dom = mutation.target;
                domNo = domDataAccessor.call(dom, 'domNo');
                if (!domNo)
                    return;
                domTaskIt = domTasks.get(domNo).getIterator();
                while (domTaskIt.hasMore()) {
                    task = domTaskIt.nextValue();
                    task.checkChange();
              }
            }
        );
    }
    
    var Observer = window.MutationObserver || window.WebKitMutationObserver;

    function addEventHandler(id) {
        var task = taskQueue.get(id);
        var dom = task.domElem;
        var domNo = domDataAccessor.call(dom, 'domNo');
        var observer;
        if (!domNo) {
            domNo = nextDomNo();
            domDataAccessor.call(dom, 'domNo', domNo);
            domTasks.add(domNo, new LinkedHashMap());
        }
        domTasks.get(domNo).add(task.id, task);
        observer = domDataAccessor.call(dom, 'observer');
        if (!observer){
            
            if(!Observer)
                return;
            
            observer = new Observer(eventHandler);
            domDataAccessor.call(dom, 'observer', observer);
        }
        observer.observe(dom, { attributes: true });
    }
    function removeFromEventHandler(task) {
        var dom = task.domElem;
        var domNo = domDataAccessor.call(dom, 'domNo');
        if (!domNo)
            return;

        if (domTasks.get(domNo).has(task.id)){
            domTasks.get(domNo).remove(task.id);
        }

        if (domTasks.get(domNo).isEmpty()) {
            domDataAccessor.call(dom, 'observer').disconnect();
            domDataAccessor.call(dom, 'observer', undefined);
            taskQueue.remove(task.id);
        }
    }
    var scannerInstance = undefined;
    var taskQueue = new LinkedHashMap();
    function scanner() {
        var taskItr = taskQueue.getIterator();
        var task;
        while (taskItr.hasMore()) {
            task = taskItr.nextValue();
            task.checkChange();
        }
    }
    function addIntervalTask(task) {
        if (!scannerInstance)
            scannerInstance = setInterval(scanner, 100);
        if (!taskQueue.has(task.id))
            taskQueue.add(task.id, task);
    }
    function removeIntervalTask(id) {
        if (taskQueue.has(id)) {
            taskQueue.remove(id);
        }
        if (taskQueue.isEmpty()) {
            clearInterval(scannerInstance);
            scannerInstance = undefined;
        }
    }
    function hookChange(task) {
        var dom = task.domElem;
        if (typeof (MutationObserver) == "function" 
                || UADetector.isFirefox && parseInt(UADetector.version())>=14 
                || UADetector.isChrome && parseInt(UADetector.version())>=18) {
            addEventHandler(task.id);
        } else {
            // for browsers not support dom attributes change event, add a
            // iterval task to check properties changes.
            addIntervalTask(task);
        }
    }
    function __watcher(id) {
        var task = taskQueue.get(id);
        if (!task)
            return;
        var dom = task.domElem;
        if (!task.callback)
            return;

        var changed = false;
        var i = 0;
        var changedProps = [];
        for ( var l = task.cssProps.length; i < l; i++) {
            var newVal = css(dom, task.cssProps[i]);
            if (task.lastestVals[i] != newVal) {
                task.lastestVals[i] = newVal;
                changed = true;
                changedProps.push(task.cssProps[i]);
            }
        }
        if (changed)
            // task.callback.call(caller, changedProps);
            task.callback(changedProps);
    }
    // var caller;
    var DomWatcher = {
        /**
         * watch a dom element on specific css properties, if change, excute
         * callback func, callback parameter is an array of changed properties
         * 
         * @param dom
         *            element to watch
         * @param props
         *            properties on element to watch, input as a string,
         *            properties should be seperated by comma ','
         *            valid properties are {position|size|show}
         * @param func
         *            function to execute on properties change, when calling
         *            DomWatcher.watch
         * @return generated watcher id
         */
        watch : function(dom, props, func) {
            // caller = this.watch.caller;
            var id = nextWatcherId();
            var task = {
                id : id,
                domElem : dom,
                cssProps : props.split(","),
                lastestVals : [ props.split(",").length ],
                callback : func,
                checkChange : function() {
                    __watcher(id);
                }
            };

            for ( var i = 0, len = task.cssProps.length; i < len; i++) {
                task.lastestVals[i] = css(dom, task.cssProps[i]);
            }
            if (!taskQueue.has(task.id))
                taskQueue.add(task.id, task);
            hookChange(task);
            return id;
        },
        unwatch : function(id) {
            var task = taskQueue.get(id);
            if (task){
                var dom = task.domElem;
                try {
                    if (typeof (MutationObserver) == "function" 
                || UADetector.isFirefox && parseInt(UADetector.version())>=14 
                || UADetector.isChrome && parseInt(UADetector.version())>=18) {
                        removeFromEventHandler(task);
                    } else
                        removeIntervalTask(task.id);
                }
                // ignore if element was already unbound
                catch (e) {
                }
            }
        }
    };
    return DomWatcher;
});
define('sap/viz/mvc/Event',['sap/viz/base/Class'],
function Setup(Class) {
	var Event = Class.define({
		/**
		 * Event class
		 * 
		 * @name sap.viz.mvc.Event
		 * @constructor
		 */
		constructor : function(type, target, canBubbling) {
			this.type = type;
			this.target = target;
			this.currentTarget = target;
			this.timestamp = Date.now();
			this.load = undefined;
			this._canBubbling = canBubbling !== undefined ? canBubbling : true;
		},

		/**
		 * Whether the event is in the bubbling phase
		 * 
		 * @name sap.viz.mvc.Event#isInBubbling
		 * @function
		 * @returns {Boolean}
		 * 
		 */
		isInBubbling : function() {
			return this.target.id !== this.currentTarget.id;
		},
		/**
		 * Whether the event should be bubbled
		 * 
		 * @name sap.viz.mvc.Event#shouldBubble
		 * @function
		 * @returns {Boolean}
		 * 
		 */
		shouldBubble : function() {
			return this._canBubbling;
		},
		/**
		 * Stop the event propagation in the bubbling phase
		 * 
		 * @name sap.viz.mvc.Event#stopPropagation
		 * @function
		 * 
		 */
		stopPropagation : function() {
			this._canBubbling = false;
		}
	});

	return Event;
});
define('sap/viz/mvc/MouseEvent',['sap/viz/mvc/Event'],
function Setup(Event) {
	/**
	 * This class defines Mouse Event
	 * 
	 * @name sap.viz.mvc.MouseEvent
	 * @class
	 * @augments sap.viz.mvc.Event
	 */
	var MouseEvent = Event.extend(
	/**
	 * @lends sap.viz.mvc.MouseEvent
	 * 
	 */
	{
		constructor : function(type, target, canBubbling, localXY, pageXY) {
			this.relatedTarget = undefined;
			this.targetLocalXY = localXY;
			this.currentLocalXY = localXY;
			this.pageXY = pageXY;
		}
	});
	return MouseEvent;
});
define('sap/viz/mvc/TouchEvent',['sap/viz/base/utils/FunctionUtils','sap/viz/mvc/Event', 'sap/viz/lang/langManager'],
function Setup(FuncUtils, Event, langManager) {
	var $ = jQuery;
	if (!$) {
		FuncUtils.error(langManager.getLogMessage('IDS_ERROR_NOT_FIND_JQUERY'));
	}
	/**
	 * Touch class
	 * 
	 * @name sap.viz.mvc.Touch
	 * @constructor
	 */
	var Touch = function(identifier, target, localXY, pageXY) {
		this.identifier = identifier;
		this.target = target;
		this.localXY = localXY;
		this.pageXY = pageXY;
	};
	/**
	 * Touch List class
	 * 
	 * @name sap.viz.mvc.TouchList
	 * @constructor
	 */
	var TouchList = function(tArray, tMap) {
		this.tA = tArray, this.tM = tMap;
	};

	var tlp = TouchList.prototype;
	/**
	 * Return the length of the list
	 * 
	 * @name sap.viz.mvc.TouchList#length
	 * @function
	 * @returns {Number}
	 * 
	 */
	tlp.length = function() {
		return this.tA.length;
	};
	/**
	 * Get the touch at specified index
	 * 
	 * @name sap.viz.mvc.TouchList#item
	 * @function
	 * @param {Number}
	 *            index
	 * @returns {sap.viz.mvc.Touch}
	 */
	tlp.item = function(index) {
		if (index >= 0 && (index < this.tA.length)) {
			return this.tA[index];
		}
	};
	/**
	 * Get the touch with specified identifier
	 * 
	 * @name sap.viz.mvc.TouchList#identifiedTouch
	 * @function
	 * @param {Number}
	 *            identifier
	 * @returns {sap.viz.mvc.Touch}
	 */
	tlp.identifiedTouch = function(identifier) {
		if (identifier) {
			return this.tM[identifier];
		}
	};
	/**
	 * This class defines Touch Event
	 * 
	 * @name sap.viz.mvc.TouchEvent
	 * @class
	 * @augments sap.viz.mvc.Event
	 */
	var TouchEvent = Event.extend(
	/**
	 * @lends sap.viz.mvc.TouchEvent
	 * 
	 */
	{
		constructor : function(type, target, canBubbling, touches, targetTouches, changedTouches) {
			this.touches = touches;
			this.targetTouches = targetTouches;
			this.changedTouches = changedTouches;
		}
	});
	var _buildTouchListFromTouchList = function(touchlist) {
		var tArray = [], tMap = {};
		for ( var i = 0, targetComp, touch, len = touchlist.length; i < len; i++) {
			targetComp = _findTargetComp(touchlist.item(i));
			if (targetComp) {
				// We only consider the touches originated from RIV component
				touch = _buildTouch(touchlist.item(i), targetComp);
				tArray.push(touch);
				tMap[touch.identifier] = touch;
			}
		}
		return new TouchList(tArray, tMap);
	};

	var _buildTouchListFromTouchArray = function(touchArray) {
		var tArray = [], tMap = {};
		for ( var i = 0, targetComp, touch, len = touchArray.length; i < len; i++) {
			targetComp = _findTargetComp(touchArray[i]);
			if (targetComp) {
				// We only consider the touches originated from RIV component
				touch = _buildTouch(touchArray[i], targetComp);
				tArray.push(touch);
				tMap[touch.identifier] = touch;
			}
		}
		return new TouchList(tArray, tMap);
	};

	var _findTargetComp = function(touch) {
		var cnode = $(touch.target);
		while (cnode.length && !cnode.data('selfComp')) {
			cnode = cnode.parent();
		}
		return cnode.data('selfComp');
	};

	var _buildTouch = function(touch, targetComp) {
		var targetCompPagePosition = targetComp.pagePosition();
		var localXY = {
			x : touch.pageX - targetCompPagePosition.x,
			y : touch.pageY - targetCompPagePosition.y
		};
		// binding to UIComponent instead of Element
		return new Touch(touch.identifier, targetComp, localXY, {
			x : touch.pageX,
			y : touch.pageY
		});
	};
	TouchEvent.buildFrom3TouchArray = function(type, target, touches, changedTouches, targetTouches, canBubbling) {
		var _touches = _buildTouchListFromTouchArray(touches);
		var _targetTouches = _buildTouchListFromTouchArray(targetTouches);
		var _changedTouches = _buildTouchListFromTouchArray(changedTouches);
		return new TouchEvent(type, target, canBubbling, _touches, _targetTouches, _changedTouches);
	};
	TouchEvent.buildFromDomTouchEvent = function(type, target, domTouchEvent, canBubbling) {
		var _touches = _buildTouchListFromTouchList(domTouchEvent.touches);
		var _targetTouches = _buildTouchListFromTouchList(domTouchEvent.targetTouches);
		var _changedTouches = _buildTouchListFromTouchList(domTouchEvent.changedTouches);
		return new TouchEvent(type, target, canBubbling, _touches, _targetTouches, _changedTouches);
	};
	return TouchEvent;
});
define('sap/viz/mvc/VizFrame',['sap/viz/base/utils/FunctionUtils','sap/viz/base/utils/DomUtils','sap/viz/base/UADetector','sap/viz/mvc/UIComponent',
'sap/viz/mvc/GestureDetector','sap/viz/base/utils/DomWatcher','sap/viz/mvc/Event',
'sap/viz/mvc/MouseEvent','sap/viz/mvc/TouchEvent','sap/viz/base/Math', 'sap/viz/lang/langManager'],
function Setup(FuncUtils, D, UADetector, UIComponent, GestureDetector,
        DomWatcher, Event, MouseEvent, TouchEvent, Math, langManager) {
     var ArrayPush = Array.prototype.push;
    var error = FuncUtils.error;
    var isMobile = UADetector.isMobile();
    function isInDOM(el) {
        while (el = el.parentNode)
            if (el === document)
                return true;
        return false;
    }

    function getHittedComponent(event) {
        var domEntity = D(event.target);
        while (!(domEntity.data('selfComp') && domEntity.data('selfComp').root === this.root)) {
            domEntity = domEntity.parent();
        }
        return domEntity.data('selfComp');
    }

    var ts = GestureDetector.TransitionState;

    function regDOMEventHandlers() {
        var handler = handleDomEvent.bind(this);
        D(this.container).bind('click', handler);
        D(this.container).bind('dblclick', handler);
        D(this.container).bind('focusin', handler);
        D(this.container).bind('focusout', handler);
        D(this.container).bind('focus', handler);
        D(this.container).bind('blur', handler);
        D(this.container).bind('mousedown', handler);
        D(this.container).bind('mouseup', handler);
        D(this.container).bind('mouseenter', handler);
        D(this.container).bind('mouseleave', handler);
        D(this.container).bind('mousemove', handler);
        // Below events are supposed to be fired when the
        // element is attached/detached to/from document,
        // it's used to register touch listener correctly in
        // iOS Mobile Safari.
        D(this.container).bind('DOMNodeInsertedIntoDocument',
                registerDOMTouchHandler.bind(this));
        D(this.container).bind('DOMNodeRemovedFromDocument',
                unregisterDOMTouchHandler.bind(this));
    }

    function registerDOMTouchHandler() {
        var handler = handleDomEvent.bind(this);
        D(this.container).bind('touchstart', handler);
        D(this.container).bind('touchmove', handler);
        D(this.container).bind('touchend', handler);
        D(this.container).bind('touchcancel', handler);
    }

    function unregisterDOMTouchHandler() {
        D(this.container).unbind('touchstart');
        D(this.container).unbind('touchmove');
        D(this.container).unbind('touchend');
        D(this.container).unbind('touchcancel');
    }

    function handleDomEvent(event) {
        var hittedComp = getHittedComponent.call(this, event), e;
        switch (event.type) {
        case 'mousemove':
            if (hittedComp) {
                var hittedCompPageXY = hittedComp.pagePosition();
                var localPoint = {
                    x : event.pageX - hittedCompPageXY.x,
                    y : event.pageY - hittedCompPageXY.y
                };
                if (this._msTracking.length) {
                    if (this._msTracking[this._msTracking.length - 1] !== hittedComp) {
                        var enteredComps = [];
                        var entered = hittedComp;
                        while (entered) {
                            enteredComps.push(entered);
                            entered = entered.parent;
                        }
                        var inCompCount = 0, checkFinished = false, minLen = Math
                                .min(this._msTracking.length,
                                        enteredComps.length);
                        while (true) {
                            var left = undefined;
                            if (!checkFinished
                                    && this._msTracking[inCompCount] === enteredComps[enteredComps.length
                                            - 1 - inCompCount]) {
                                inCompCount++;
                                checkFinished = inCompCount === minLen;
                            } else {
                                while (this._msTracking.length > inCompCount) {
                                    left = this._msTracking.pop();
                                    e = new MouseEvent('mouseleave', left,
                                            false, left.pointFrom(localPoint,
                                                    hittedComp), {
                                                x : event.pageX,
                                                y : event.pageY
                                            });
                                    e.relatedTarget = hittedComp;
                                    // load property of the dom event is used as
                                    // the vehicle to transfer information to
                                    // component event
                                    e.load = event.load;
                                    left.fireMouseEvent(e);
                                }
                                while (inCompCount < enteredComps.length) {
                                    var entered = enteredComps.shift();
                                    left = this._msTracking[enteredComps.length - 1];
                                    this._msTracking[enteredComps.length] = entered;
                                    e = new MouseEvent('mouseenter', entered,
                                            false, entered.pointFrom(
                                                    localPoint, hittedComp), {
                                                x : event.pageX,
                                                y : event.pageY
                                            });
                                    e.relatedTarget = left;
                                    e.load = event.load;
                                    entered.fireMouseEvent(e);
                                }
                                break;
                            }
                        }
                    }
                } else {
                    var entered = hittedComp, e;
                    do {
                        this._msTracking.push(entered);
                        e = new MouseEvent('mouseenter', entered, false,
                                localPoint, {
                                    x : event.pageX,
                                    y : event.pageY
                                });
                        e.load = event.load;
                        entered.fireMouseEvent(e);
                        entered = entered.parent;
                    } while (entered)
                    this._msTracking.reverse();
                }
                e = new MouseEvent('mousemove', hittedComp, true, localPoint, {
                    x : event.pageX,
                    y : event.pageY
                });
                e.load = event.load;
                hittedComp.fireMouseEvent(e);
            } else {
                while (this._msTracking.length) {
                    var left = this._msTracking.pop();
                    var framePagePosition = this.pagePosition();
                    e = new MouseEvent('mouseleave', left, false, {
                        x : event.pageX - framePagePosition.x,
                        y : event.pageY - framePagePosition.y
                    }, {
                        x : event.pageX,
                        y : event.pageY
                    });
                    e.load = event.load;
                    left.fireMouseEvent(e);
                }
            }
            break;
        case 'mouseleave':
            while (this._msTracking.length) {
                var left = this._msTracking.pop();
                var leftCompPageXY = left.pagePosition();
                e = new MouseEvent('mouseleave', left, false, {
                    x : event.pageX - leftCompPageXY.x,
                    y : event.pageY - leftCompPageXY.y
                }, {
                    x : event.pageX,
                    y : event.pageY
                });
                e.load = event.load;
                left.fireMouseEvent(e);
            }
            break;
        case 'mouseup':
            if (hittedComp) {
                var hittedCompPageXY = hittedComp.pagePosition();
                e = new MouseEvent('mouseup', hittedComp, true, {
                    x : event.pageX - hittedCompPageXY.x,
                    y : event.pageY - hittedCompPageXY.y
                }, {
                    x : event.pageX,
                    y : event.pageY
                });
                e.load = event.load;
                hittedComp.fireMouseEvent(e);
            }
            break;
        case 'mousedown':
            if (hittedComp) {
                var hittedCompPageXY = hittedComp.pagePosition();
                e = new MouseEvent('mousedown', hittedComp, true, {
                    x : event.pageX - hittedCompPageXY.x,
                    y : event.pageY - hittedCompPageXY.y
                }, {
                    x : event.pageX,
                    y : event.pageY
                });
                e.load = event.load;
                hittedComp.fireMouseEvent(e);
            }
            break;
        case 'dblclick':
            if (hittedComp) {
                if (this._focusedComp) {
                    if (this._focusedComp.id !== hittedComp.id) {
                        e = new Event('blur', this._focusedComp, false);
                        e.load = event.load;
                        this._focusedComp.fireFocusEvent(e);
                        e = new Event('focusout', this._focusedLayer, true);
                        e.load = event.load;
                        this._focusedComp.fireFocusEvent(e);
                        this._focusedComp = hittedComp;
                        e = new Event('focus', this._focusedComp, false);
                        e.load = event.load;
                        this._focusedComp.fireFocusEvent(e);
                        e = new Event('focusin', this._focusedComp, true);
                        e.load = event.load;
                        this._focusedComp.fireFocusEvent(e);
                    }
                } else {
                    this._focusedComp = hittedComp;
                    e = new Event('focus', this._focusedComp, false);
                    e.load = event.load;
                    this._focusedComp.fireFocusEvent(e);
                    e = new Event('focusin', this._focusedComp, true);
                    e.load = event.load;
                    this._focusedComp.fireFocusEvent(e);
                }
                var hittedCompPageXY = hittedComp.pagePosition();
                e = new MouseEvent('dblclick', this._focusedComp, true, {
                    x : event.pageX - hittedCompPageXY.x,
                    y : event.pageY - hittedCompPageXY.y
                }, {
                    x : event.pageX,
                    y : event.pageY
                });
                e.load = event.load;
                this._focusedComp.fireMouseEvent(e);
            } else {
                if (this._focusedComp) {
                    e = new Event('blur', this._focusedLayer, false);
                    e.load = event.load;
                    this._focusedComp.fireFocusEvent(e);
                    e = new Event('focusout', this._focusedLayer, true);
                    e.load = event.load;
                    this._focusedComp.fireFocusEvent(e);
                    this._focusedComp = undefined;
                }
            }
            break;
        case 'click':
            if (hittedComp) {
                if (this._focusedComp) {
                    if (this._focusedComp.id !== hittedComp.id) {
                        e = new Event('blur', this._focusedComp, false);
                        e.load = event.load;
                        this._focusedComp.fireFocusEvent(e);
                        e = new Event('focusout', this._focusedComp, true);
                        e.load = event.load;
                        this._focusedComp.fireFocusEvent(e);
                        this._focusedComp = hittedComp;
                        e = new Event('focus', this._focusedComp, false);
                        e.load = event.load;
                        this._focusedComp.fireFocusEvent(e);
                        e = new Event('focusin', this._focusedComp, true);
                        e.load = event.load;
                        this._focusedComp.fireFocusEvent(e);
                    }
                } else {
                    this._focusedComp = hittedComp;
                    e = new Event('focus', this._focusedComp, false);
                    e.load = event.load;
                    this._focusedComp.fireFocusEvent(e);
                    e = new Event('focusin', this._focusedComp, true);
                    e.load = event.load;
                    this._focusedComp.fireFocusEvent(e);
                }
                var hittedCompPageXY = hittedComp.pagePosition();
                e = new MouseEvent('click', this._focusedComp, true, {
                    x : event.pageX - hittedCompPageXY.x,
                    y : event.pageY - hittedCompPageXY.y
                }, {
                    x : event.pageX,
                    y : event.pageY
                });
                e.load = event.load;
                this._focusedComp.fireMouseEvent(e);
            } else {
                if (this._focusedComp) {
                    e = new Event('blur', this._focusedComp, false);
                    e.load = event.load;
                    this._focusedComp.fireFocusEvent(e);
                    e = new Event('focusout', this._focusedComp, true);
                    e.load = event.load;
                    this._focusedComp.fireFocusEvent(e);
                    this._focusedComp = undefined;
                }
            }
            break;
        case 'touchstart':
            !isMobile || event.preventDefault();
            for ( var i = 0, touch, changedTouches = event.changedTouches, len = changedTouches.length; i < len; i++) {
                touch = changedTouches.item(i);
                // 'false' means the touch hasn't been
                // marked
                // cancelled
                this._touchSeqTracking[touch.identifier] = false;
            }

            // Handle gesture Detection
            handleGestureDetect.call(this, hittedComp, event);
            e = TouchEvent.buildFromDomTouchEvent('touchstart', hittedComp,
                    event);
            e.load = event.load;
            hittedComp.fireTouchEvent(e);
            break;
        case 'touchmove':
            !isMobile || event.preventDefault();
            // Handle gesture Detection and fire touchmove
            // event when no gesture currently detected
            if (!handleGestureDetect.call(this, hittedComp, event)) {
                e = TouchEvent.buildFromDomTouchEvent('touchmove', hittedComp,
                        event);
                e.load = event.load;
                hittedComp.fireTouchEvent(e);
            }
            break;
        case 'touchend':
            !isMobile || event.preventDefault();
            // Handle gesture Detection
            handleGestureDetect.call(this, hittedComp, event);
            var uncancelledTouchesArray = [], cancelledTouchesArray = [], touchesArray = [], targetTouchesArray = [];
            for ( var i = 0, touch, changedTouches = event.changedTouches, len = changedTouches.length; i < len; i++) {
                touch = changedTouches.item(i);
                this._touchSeqTracking[touch.identifier] === true ? cancelledTouchesArray
                        .push(touch)
                        : uncancelledTouchesArray.push(touch);
                delete this._touchSeqTracking[touch.identifier];
            }

            if (uncancelledTouchesArray.length) {
                // Some touches are not cancelled, so we
                // have to split the event into two events,
                // one for cancelled touches, one for
                // uncancelled touches
                for ( var i = 0, touch, targetTouches = event.targetTouches, len = targetTouches.length; i < len; i++) {
                    touch = targetTouches.item(i);
                    targetTouchesArray.push(touch);
                }
                for ( var i = 0, touch, touches = event.touches, len = touches.length; i < len; i++) {
                    touch = touches.item(i);
                    touchesArray.push(touch);
                }
                e = TouchEvent
                        .buildFrom3TouchArray('touchcancel', hittedComp,
                                touchesArray, cancelledTouchesArray,
                                targetTouchesArray);
                e.load = event.load;
                hittedComp.fireTouchEvent(e);
                e = TouchEvent.buildFrom3TouchArray('touchend', hittedComp,
                        touchesArray, uncancelledTouchesArray,
                        targetTouchesArray);
                e.load = event.load;
                hittedComp.fireTouchEvent(e);
            } else {
                // All ended touches are marked as cancelled
                e = TouchEvent.buildFromDomTouchEvent('touchcancel',
                        hittedComp, event);
                e.load = event.load;
                hittedComp.fireTouchEvent(e);
            }
            
            if(event.touches.length>0){
                break;
            } else {
                //We don't break the touchend event if the event.touches.length is smaller than 0, so it will force to trigger touchcancel event. 
                //This is a fix for android device which may missing fire a touchcancel after touchend with multi touches.
		//TODO:Add util to check the OS type.
                var agent = navigator.userAgent;
                var is_Android = /Android/i.test(agent); 
                if(!is_Android){
                    break;
                }
            }
           

        case 'touchcancel':
            !isMobile || event.preventDefault();
            // Handle gesture Detection
            handleGestureDetect.call(this, hittedComp, event);
            for ( var i = 0, touch, changedTouches = event.changedTouches, len = changedTouches.length; i < len; i++) {
                touch = changedTouches.item(i);
                delete this._touchSeqTracking[touch.identifier];
            }
            e = TouchEvent.buildFromDomTouchEvent('touchcancel', hittedComp,
                    event);
            e.load = event.load;
            hittedComp.fireTouchEvent(e);
            break;
        }
    }

    function handleGestureDetect(hittedComponent, origTouchEvent) {
        var grs = [];
        var thisLevel = hittedComponent;
        // find the gesture recognizers responsible for the
        // gesture detection of the component hierarchy
        do {
            ArrayPush.apply(grs, thisLevel.gestureDetectors);
        } while (thisLevel = thisLevel.parent)

        var someGestureDetected = false, gestureDetected, needToCancelTouches = false;
        for ( var i = 0, state, gd, len = grs.length; i < len; i++) {
            gd = grs[i];
            switch (origTouchEvent.type) {
            case 'touchstart':
                gd.touchBegin(origTouchEvent);
                break;
            case 'touchmove':
                gd.touchMove(origTouchEvent);
                break;
            case 'touchend':
                gd.touchEnd(origTouchEvent);
                break;
            case 'touchcancel':
                gd.touchCancel(origTouchEvent);
                break;
            }
            state = gd.state;
            gestureDetected = (state === ts.Began) || (state === ts.Changed)
                    || (state === ts.Recognized);
            someGestureDetected = someGestureDetected || gestureDetected;
            needToCancelTouches = needToCancelTouches
                    || (gestureDetected && gd.cancelTouches());
        }
        if (needToCancelTouches) {
            for ( var i = 0, touch, changedTouches = origTouchEvent.changedTouches, len = changedTouches.length; i < len; i++) {
                touch = changedTouches.item(i);
                // Mark all changed touch as cancelled
                this._touchSeqTracking[touch.identifier] = true;
            }
        }
        return someGestureDetected;
    }

    var VizFrame = UIComponent.extend({
        constructor : function(options) {
            options = options || {};
            if (options.holder) {
                
               

                this._holder = D(options.holder).get(0);

                D(this._holder).bind('DOMNodeInsertedIntoDocument', function() {
                    this.markAttached();
                }.bind(this));
                D(this._holder).bind('DOMNodeRemovedFromDocument', function() {
                    this.markDetached();
                }.bind(this));

                this.pin({
                    x : 0,
                    y : 0
                });
                // structure for event dispatching
                this._msTracking = [];
                this._touchSeqTracking = {};

                this.frame({
                    x : 0,
                    y : 0,
                    width : D(this._holder).width(),
                    height : D(this._holder).height()
                });
                this._watcherIds = [];
                this.autoResizing = true;
                this.autoResize();
                this.clipToBound(false);
                regDOMEventHandlers.call(this);
                // this.container.appendTo(this._holder);
                this._holder.appendChild(this.container);
                this.markDetached();
                this.markHide();

                if (isInDOM(this._holder)) {
                    this.markAttached();
                }
                if (D(this._holder).css('display') === 'none'
                        || D(this._holder).css('visibility') === 'hidden') {
                    this._parentVisible = false;
                    this.markHide();
                } else {
                    this._parentVisible = true;
                    this.markShow();
                }
                this.root = this;
            } else {
                error(langManager.getLogMessage('IDS_ERROR_NEED_PROVIDE_CONTAINER_FOR_FRAME'));
            }
        },
        /**
            Ajust content size accordingly, on each time holder size changed. Set onoff=false to disable.
            In these cases, this feature may be failed:
            <pre>
            1. A div size is pixel value at first, but changed to percentage later.
            2. If the dom tree which the holder lays on changed, need to call autoResize again.
            </pre>
            @name sap.viz.mvc.VizFrame#autoResize
            @param {undefined|Boolean}
        */
        autoResize: function(onoff) {
            
            this._watcherIds.forEach(DomWatcher.unwatch);
            this._watcherIds = [];
            if(onoff === false){
                this.autoResizing = false;
                return;
            }
            this.autoResizing = true;
            this.size(true, D(this._holder).width(), D(this._holder).height());
            var onResize = function(dom, callback) {
                var percentSizeReg = /.*%/, 
                    dDom = D(dom), 
                    owidth = dDom.width(), 
                    oheight = dDom.height(), 
                    currentWatchedNode = dom;
                    
                function checkResized(){
                    if(dDom.width() !== owidth || dDom.height() !== oheight){
                        //return true;
                        callback();
                    }
                    return false;
                }
                this._watcherIds.push(DomWatcher.watch(dom, "width,height", callback));
                while((percentSizeReg.test(currentWatchedNode.style.width) || percentSizeReg.test(currentWatchedNode.style.height))
                            && currentWatchedNode !== undefined && currentWatchedNode.nodeName.toLowerCase() !== "html"){
                    
                    if(D(currentWatchedNode).css("position") !== "absolute"){
                         currentWatchedNode = D(currentWatchedNode).parent().get(0);
                    } else {
                        currentWatchedNode = D(currentWatchedNode).offsetParent();
                    }
                    this._watcherIds.push(DomWatcher.watch(currentWatchedNode, "width,height", checkResized));
                }
                
            }.bind(this);
            
            var resizeDelay;
            onResize(this._holder, function() {
                clearTimeout(resizeDelay);
                resizeDelay = setTimeout( function() {
                    this.size(true, D(this._holder).width(), D(this._holder).height());
                }.bind(this), 100);
            }.bind(this));
            
            return this;
        },
        size : function(){
            //get size, autoResizing
            if(arguments.length === 0){
                size = this._super.apply(this);
                size.auto = this.autoResizing;
                return size;
            }
            //check if callee is autoresize function
            if(arguments.length > 0 && arguments[0] == true){
                return this._super.apply(this, Array.prototype.slice.call(arguments, 1));
            }
            //set size
            if(arguments.length > 0){
                this.autoResize(false);
                return this._super.apply(this, arguments);
            }
        },
        doDestroy : function() {
            this._watcherIds.forEach(DomWatcher.unwatch);
            D(this._holder).unbind('DOMNodeInsertedIntoDocument');
            D(this._holder).unbind('DOMNodeRemovedFromDocument');
            D(this.container).unbind();
        },
        destroy : function() {
            this._super();
            this.doDestroy();
            this._msTracking = [];
            D(this.container).detach();
            this.container = null;
        }
    });
    return VizFrame;
});

define('sap/viz/mvc/UIController',['sap/viz/base/Class','sap/viz/base/utils/FunctionUtils','sap/viz/mvc/UIComponent'],
function Setup(Class, FuncUtils, UIComponent) {
	var noop = FuncUtils.noop;
	var Autosizing = UIComponent.Autosizing;
	var UIController = Class
			.define({
				/**
				 * The base class of Controller in VizKit MVC framework
				 * 
				 * @name sap.viz.mvc.UIController
				 * @constructor
				 */
				constructor : function(vizApp) {
					Object
							.defineProperties(
									this,
									{
										'application' : {
											value : vizApp,
											writable : false,
											enumerable : true,
											configurable : false
										},
										'rootUIComponent' : {
											value : new (this.constructor.prototype.RootComponentClass || UIComponent)(
													{
														size : {
															width : vizApp.vizFrame
																	.width(),
															height : vizApp.vizFrame
																	.height()
														},
														autoResizingMask : Autosizing.FlexibleWidth
																| Autosizing.FlexibleHeight,
														hidden : true,
														listeners : {
															'beforeShow' : this.beforeUIComponentAppear
																	.bind(this),
															'beforeHide' : this.beforeUIComponentDisappear
																	.bind(this),
															'afterShow' : this.afterUIComponentAppear
																	.bind(this),
															'afterHide' : this.afterUIComponentDisappear
																	.bind(this)
														}
													}),
											writable : true,
											enumerable : true
										}
									});
				},

				/**
				 * This method will be called automatically when app finishes
				 * launching.
				 * 
				 * @name sap.viz.mvc.UIController#initialize
				 * @param {Object}
				 *            the option passed in app's constructor
				 * @function
				 */
				initialize : noop,
				/**
				 * Fire the event supported by application which is declared in
				 * {@link sap.viz.mvc.VizApplication#getSupportedEvents}
				 * 
				 * @name sap.viz.mvc.UIController#fireAppEvent
				 * @function
				 */
				fireAppEvent : function(event, arguments) {
					this.application.fireEvent(event, arguments);
				},

				/**
				 * This method will be called when the managed UIComponent will
				 * become visible via set the hidden property
				 * 
				 * @name sap.viz.mvc.UIController#beforeUIComponentAppear
				 * @function
				 */
				beforeUIComponentAppear : noop,

				/**
				 * This method will be called after the managed UIComponent
				 * became visible via set the hidden property
				 * 
				 * @name sap.viz.mvc.UIController#afterUIComponentAppear
				 * @function
				 */
				afterUIComponentAppear : noop,
				/**
				 * This method will be called when the managed UIComponent will
				 * become visible via set the hidden property
				 * 
				 * @name sap.viz.mvc.UIController#beforeUIComponentDisappear
				 * @function
				 */
				beforeUIComponentDisappear : noop,
				/**
				 * This method will be called after the managed UIComponent
				 * became visible via set the hidden property
				 * 
				 * @name sap.viz.mvc.UIController#afterUIComponentDisappear
				 * @function
				 */
				afterUIComponentDisappear : noop,

				/**
				 * This method will be called when user apply a new theme, and
				 * if and only if the controller is the root controller.
				 * 
				 * @name sap.viz.mvc.UIController#doThemeApplied
				 * @function
				 * @param {String}
				 *            old the name of the old theme
				 * @param {String}
				 *            new the name of the new theme
				 */
				doThemeApplied : noop,

				/**
				 * This method will be called when user update the theme setting
				 * and if and only if the controller is the root controller.
				 * 
				 * @name sap.viz.mvc.UIController#doThemeUpdated
				 * @function
				 * @param {String}
				 *            key the key of the updated property
				 * @param {Object}
				 *            oldValue the old value
				 * @param {Object}
				 *            newValue the new value
				 */
				doThemeUpdated : noop,

				/**
				 * Default implementation is to destroy the component hierarchy
				 * it managed from the root. Subclass is encouraged to override
				 * this method to provide it's own implementation.
				 * 
				 * @name sap.viz.mvc.UIController#destroy
				 */
				destroy : function() {
					this.rootUIComponent.destroy();
					this.rootUIComponent = null;
				}
			});

	return UIController;
});
define('sap/viz/mvc/VizApplication',['sap/viz/base/Observable','sap/viz/base/utils/FunctionUtils','sap/viz/mvc/ThemeManager',
'sap/viz/mvc/ImageManager','sap/viz/mvc/VizFrame','sap/viz/mvc/UIComponent','sap/viz/mvc/UIController',
'sap/viz/base/Logger', 'sap/viz/lang/langManager'],
function Setup(Observable, FuncUtils, ThemeManager, ImageManager, VizFrame,
		UIComponent, UIController, LOG, langManager) {
	var noop = FuncUtils.noop, error = FuncUtils.error, unimplemented = FuncUtils.unimplemented, arrayPush = Array.prototype.push;
	var id = 0;
	function nextId() {
		return id++;
	}
	/**
	 * The constructor of visualization.
	 * 
	 * @name sap.viz.mvc.VizApplication
	 * @constructor
	 * @param {Object}
	 *            options The possible options could be:
	 * 
	 * <pre>
	 * {
	 * 		id : 'ID_PREFIX',
	 * 		holder : 'Element', // The holder element
	 * 		launchOptions : 'Other Options', //the additional option that will pass to the
	 *            {@link sap.viz.mvc.VizApplication#appDidFinishLaunching}
	 * }
	 * </pre>
	 * 
	 */
	var VizApplication = Observable.extend({
		/**
		 * If there are images will be used in app, declares them here, app
		 * launching process will make sure them loaded before finishing
		 * launching.
		 * 
		 * @name sap.viz.mvc.VizApplication#images
		 * @property todo
		 */
		images : [],

		/**
		 * Place holder for UIController subclass.
		 * 
		 * @name sap.viz.mvc.VizApplication#RootControllerClass
		 * @property todo
		 */
		RootControllerClass : UIController,

		constructor : function(options) {
			if (!arguments.length) {
				error(langManager.getLogMessage('IDS_ERROR_NEED_SPECIFY_OPTIONS_TO_INITIALIZE'));
			}
			var holder = options.holder, id = options.id;
			if (!holder) {
				error(langManager.getLogMessage('IDS_ERROR_NEED_SPECIFY_HOLDER_FOR_VISUALIZATION'));
			}
			delete options.holder;
			delete options.id;
			var prototype = this.constructor.prototype;

			if (!(prototype.RootControllerClass)) {
				error(langManager.getLogMessage('IDS_ERROR_NOT_INITIALIZE_WITHOUT_UICONTROLLER'));
			}

			this.appWillLaunch.apply(this, [ options ]);

			var theme = ThemeManager.defaultTheme();
			Object.defineProperties(this, {
				'id' : {
					value : id ? id + '_' + nextId() : 'VizApp_' + nextId(),
					writable : false
				},
				'vizFrame' : {
					value : new VizFrame({
						holder : holder
					}),
					writable : false
				},
				'theme' : {
					get : function() {
						return theme;
					},
					set : function(value) {
						theme = value;
						if (ThemeManager.hasThemeInstalled(value)) {
							theme !== value;
							this.controller.doThemeApplied(theme);
						}
						return this;
					}
				}
			});

			ThemeManager.on('defaultThemeChanged', function(oldDefault,
					newDefault) {
				if (this._theme === oldDefault) {
					this._theme = newDefault;
					this.controller.doThemeApplied(newDefault);
				}
			}.bind(this), this.id);
			ThemeManager.on('themeSettingChanged', function(theme, key,
					oldValue, newValue) {
				if (this._theme === theme) {
					this.controller.doThemeUpdated(key, oldValue, newValue);
				}
			}.bind(this), this.id);

			var imagesToLoad = [];
			if (this.hasOwnProperty("images") && this.images) {
				arrayPush.apply(imagesToLoad, this.images);
			}
			arrayPush.apply(imagesToLoad, prototype.images);

			ImageManager.loadImages(imagesToLoad, undefined, function() {
				var rc = new prototype.RootControllerClass(this);
				Object.defineProperty(this, 'controller', {
					value : rc,
					writable : false,
					enumerable : true,
					configurable : false
				});
				this.vizFrame.append(rc.rootUIComponent);
				this.controller.initialize(options);
				this.appDidFinishLaunching.apply(this, [ options ]);
				rc.rootUIComponent.frame(0, 0, this.vizFrame.width(), this.vizFrame.height());
				rc.rootUIComponent.markShow();
			}.bind(this));
		},

		/**
		 * This method will be called before the application starting to
		 * launched. launchOptions(if any) will be passed as argument. Normally
		 * you can declare any images that will be used.
		 * 
		 * @name sap.viz.mvc.VizApplication#appWillLaunch
		 * @function
		 * @param {Object}
		 *            launchOption the launchOption which is passed in
		 *            VizApplication constructor
		 */
		appWillLaunch : noop,

		/**
		 * This method will be called after the application fully launched. Any
		 * visualization application specific initialization should be put here,
		 * e.g. initialize necessary data structure.
		 * 
		 * @name sap.viz.mvc.VizApplication#appDidFinishLaunching
		 * @function
		 * @param {Object}
		 *            launchOption the launchOption which is passed in
		 *            VizApplication constructor
		 */
		appDidFinishLaunching : noop,

		/**
		 * Returns metadata about the current app instance. The metadata
		 * contains 3 kinds of specification:SupportedEvent,
		 * SupportedProperties, SupportedMethods
		 * 
		 * @name sap.viz.mvc.VizApplication#getMetadata
		 * @function
		 */
		getMetadata : unimplemented,

		/**
		 * Subclass should implement this method to return plain object contains
		 * the values of requested properties or all properties if no properties
		 * 
		 * 
		 * @name sap.viz.mvc.VizApplication#getPropertyValues
		 * @param {String}
		 *            prop1
		 * @param {String}
		 *            prop2
		 * @returns {Object} property bag
		 * 
		 */
		getPropertyValues : unimplemented,

		/**
		 * Subclass should implement this method to accept a property bag.
		 * 
		 * 
		 * 
		 * @name sap.viz.mvc.VizApplication#setPropertyValues
		 * @param {Object}
		 *            property bag
		 * 
		 */
		setPropertyValues : unimplemented,

		/**
		 * Destroy the viz application instance, after being destroyed calls to
		 * this instance will not be gauranteed to return correctly
		 * 
		 * @name sap.viz.mvc.VizApplication#destroy
		 */
		destroy : function() {
			ThemeManager.un('defaultThemeChanged', this.id);
			ThemeManager.un('themeSettingChanged', this.id);
			this.controller.destroy();
			this.vizFrame.destroy();
		}
	});

	return VizApplication;
});
define('sap/viz/style/Element',['jquery'],
function Setup($) {
  function StyleDef( value ) {
    this.update(value);
  }

  StyleDef.prototype = {
    toString : function() {
      var str = "", i;

      for (i in this) {
        if ( this.hasOwnProperty(i) ) {
          str += i + ":" + this[i] + ";";
        }
      }

      return str;
    },
    toAttrs : function( selection ) {
      for ( var i in this) {
        if ( this.hasOwnProperty(i) ) {
          selection.attr(i, this[i]);
        }
      }
    },
    update : function( obj ) {
      for ( var i in obj) {
        if ( obj.hasOwnProperty(i) ) {
          this[i] = obj[i];
        }
      }
    }
  };

  var html = document.documentElement, matches = html.matchesSelector || html.mozMatchesSelector ||
      html.webkitMatchesSelector || html.msMatchesSelector;

  function Element( el ) {

    if ( !el ) {
      var tempDoc = document.implementation.createHTMLDocument("");
      el = d3.select(tempDoc.body);
      if(tempDoc.domain !== document.domain){
        tempDoc.domain = document.domain;
      }
    }

    this.el = el;
  }

  Element.prototype = {
    destroy : function() {
      this.el = null;  
    },
    
    child : function( classNames, tagNames, defaultTagName, defaultStyle ) {
      if ( !Array.isArray(tagNames) ) {
        tagNames = [tagNames];
      }

      if ( !Array.isArray(classNames) ) {
        classNames = [classNames];
      }

      var el = this.el, create = false;
      var len = Math.max(tagNames.length, classNames.length);
      for ( var i = 0; i < len; i++) {
        var tagName = tagNames[i];
        var className = classNames[i];

        if ( !tagName && !className ) {
          create = true;
        }

        tagName = tagName || defaultTagName;

        if ( !create ) {
          var selector = tagName;
          if ( className ) {
            selector += "." + className.replace(" ", ".");
          }
          var node = el.node();
          var children = el.selectAll(selector).filter(function() {
            return this.parentNode === node;
          });

          if ( !children.empty() ) {
            el = children;
            continue;
          }

          create = true;
        }

        el = d3.select(el.node()).append(tagName).attr("class", className).datum({
          defaultStyle : new StyleDef(),
          currentStyle : new StyleDef(),
          meta : {}
        });
      }

      var result = new Element(el);
      if ( defaultStyle ) {
        var data = el.datum();
        data.defaultStyle.update(defaultStyle);
        data.currentStyle.update(defaultStyle);
      }

      return result;
    },

    defaultStyle : function() {
      return this.el.datum().defaultStyle;
    },

    currentStyle : function() {
      return this.el.datum().currentStyle;
    },

    queryAll : function( selectorText ) {
      var result = [];
      this.el.selectAll(selectorText).each(function() {
        result.push(new Element(d3.select(this)));
      });
      return result;
    },

    match : function( selectorText ) {
      return matches.call(this.el.node(), selectorText);
    },

    update : function( selector, properties ) {
      var currentStyle = this.currentStyle();
      var currentStyleValue = this.currentStyle();
      var currentStylePriority = this.el.datum().meta;
      $.each(properties, function( name, value ) {
        var currentPropertyPriority = currentStylePriority[name];
        var currentImportant = false, currentSelector;
        if ( currentPropertyPriority ) {
          currentImportant = currentPropertyPriority.important;
          currentSelector = currentPropertyPriority.selector;
        }
        var newImportant = value.important;
        if ( (newImportant && (!currentImportant || selector.nlt(currentSelector))) ||
            (!newImportant && !currentImportant && selector.nlt(currentSelector)) ) {
          currentStyleValue[name] = value.value;
          if ( !currentPropertyPriority ) {
            currentPropertyPriority = {};
            currentStylePriority[name] = currentPropertyPriority;
          }
          currentPropertyPriority.important = newImportant;
          currentPropertyPriority.selector = selector;
        }
      });
      return this;
    },
    
    cleanChildren : function() {
      var node = this.el.node();
      var child;
      while ((child = node.firstChild)) {
        node.removeChild(child);
      }
      return this;
    }
  };

  return Element;
});
define('sap/viz/style/Manager',['jquery','sap/viz/style/Element'],
function Setup( $, Element ) {
  function StyleManager( sheets, moduleManifest, element, defaultTagName ) {
    var subEls = {};

    if ( !element ) {
      element = new Element();
    }

    this.el = element;

    if ( moduleManifest ) {
      var css = moduleManifest.css;
      if ( css ) {
        $.each(css, function( selector, obj ) {
          var className = selector.substring(1).replace(".", " ");
          var el = element.child(className, null, defaultTagName || "g", obj.value);
          className.split(" ").forEach(function( singleSelector ) {
            subEls[singleSelector] = el;
          });

          if ( sheets ) {
            sheets.forEach(function( sheet ) {
              sheet.iterate(function( selector, properties ) {
                if ( el.match(selector.text) ) {
                  el.update(selector, properties);
                }
              });
            });
          }
        });
      }
    }

    this.subEls = subEls;
    this.sheets = sheets;
  }

  StyleManager.prototype = {
    query : function( selector ) {
      var currentNode = this.subEls[selector];
      if ( currentNode ) {
        return currentNode.currentStyle();
      }
    },

    queryDefault : function( selector ) {
      var currentNode = this.subEls[selector];
      if ( currentNode ) {
        return currentNode.defaultStyle();
      }
    },

    cssText : function( selector ) {
      return this.query(selector).toString();
    },

    child : function( moduleManifest, classNames, tagNames, defaultTagName ) {
      return new StyleManager(this.sheets, moduleManifest, this.el.child(classNames, tagNames, defaultTagName || "g"),
          defaultTagName);
    },

    applyCSS : function( sheet ) {
      var root = this.el;
      sheet.rules.forEach(function( rule ) {
        rule.selectors.forEach(function( selector ) {
          root.queryAll(selector.text).forEach(function( match ) {
            match.update(selector, rule.properties);
          });
        });
      });
      return this;
    },

    cleanChildren : function() {
      this.el.cleanChildren();
      return this;
    }
  };
  
  StyleManager.prototype.destroy = function(){
    if(this.el){
      this.el.destroy();
    }
    this.el = null;
  };

  return StyleManager;
});
define('sap/viz/util/fn/createContext',['jquery','sap/viz/style/Manager'],
function Setup( $, StyleManager ) {
  return function( moduleManifest, parentCtx, classNames, tagNames ) {
    var styleManager = parentCtx.styleManager;
    if ( !styleManager ) {
      styleManager = new StyleManager();
    }
    styleManager = styleManager.child(moduleManifest, classNames, tagNames);
    var temp = {
      'styleManager' : styleManager,
      'destroy' : function(){
        for(var iter in this){
          if(this.hasOwnProperty(iter)){
            if(typeof this[iter].destroy === 'function'){
              this[iter].destroy();
              delete this[iter];
            }
          }
        }
      }
    };
    $.each(parentCtx, function(key, value){
        if (key !== 'styleManager' && key !== 'destroy'){
            temp[key] = value;
        }
    });
    return temp;
  };
});
define('sap/viz/modules/manifests/Module',['sap/viz/manifest','sap/viz/base/utils/FunctionUtils','sap/viz/base/utils/Objects','sap/viz/base/utils/TypeUtils',
'sap/viz/util/fn/createContext'],
function Setup(manifest, FunctionUtils, Objects, TypeUtils, createContext) {
  var KEEP_DEFINITION = true;
  function loadModule(modules, moduleConfig, moduleRefName) {
    var moduleId = moduleConfig.id;
    if (moduleId === undefined) {
      FunctionUtils.error("Cannot find module id in sub module config \"{0}\"",
          JSON.stringify(moduleConfig));
    }

    var module = manifest.module.get(moduleConfig.id, true);
    modules.push({
      module : module,
      config : moduleConfig,
      moduleRef : moduleRefName,
      subModules : module.subModules(moduleConfig, moduleRefName)
    });
  }

  function exactDefaultProperties(props, keepDefinition) {
    var defaultProps = {}, n, prop;
    for (n in props) {
      if (props.hasOwnProperty(n)) {
        prop = props[n];
        if (prop) {
          if (keepDefinition === true) {
            defaultProps[n] = Objects.extend(true, {}, prop);
          } else {
            defaultProps[n] = prop.supportedValueType === 'Object' ? exactDefaultProperties(
                prop.supportedValues, !KEEP_DEFINITION)
                : prop.defaultValue;
          }
        }
      }
    }
    return defaultProps;
  }
  /**
   * This is a instantce , which already have been registered into
   * {@link sap.viz.manifest.module}.</br> </br> Now, once an item is loaded
   * from {@link sap.viz.manifest.module}, it will automatically provide some
   * APIs .</br> </br>
   * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead.
   * @example  <caption>Sample Code:</caption>
   * var legend = manifest.module.get(legendID);
   * @see sap.viz.manifest.module#get
   * @class Built-in_Manifest_Objects.moduleManifest
   */
  manifest.registerCategory("module", function(obj) {
    var defaultPropertyValues;
    var allPropertyDefinitions;

    Object.defineProperties(obj, {
      subModules : {
        value : function(moduleConfig, parentRefName) {
          var subModules;
          var subModuleConfigs = Objects.extend(true, {}, moduleConfig.modules, moduleConfig.controllers);
          // TODO: fix those hard code when new layout is cheched in.
          if (!TypeUtils.isEmptyObject(subModuleConfigs)) {
            subModules = [];
            var subModuleConfig;
            for (var key in subModuleConfigs ){
              if (subModuleConfigs.hasOwnProperty(key)){
                subModuleConfig = subModuleConfigs[key];
                if (subModuleConfig) {
                  loadModule(subModules, subModuleConfig, parentRefName + '.' + key);
                }               
              }
            }
          }
          
          return subModules;
        }
      },
      /**
       * return properties of this module with or without definitions,
       * controlled by the parameter. if without definition, only default value
       * is returned for each property.
       * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead.
       * @method Built-in_Manifest_Objects.moduleManifest#props
       * @param {Boolean}
       *          withDefinition whether include definitions in the return
       *          object. by default false
       * @return {Object} properties of this module
       */
      props : {
        value : function(withDefinition) {
          if (withDefinition === KEEP_DEFINITION) {
            if (!allPropertyDefinitions) {
              allPropertyDefinitions = exactDefaultProperties(obj.properties,
                  KEEP_DEFINITION);
            }
            return allPropertyDefinitions;
          } else {
            if (!defaultPropertyValues) {
              defaultPropertyValues = exactDefaultProperties(obj.properties,
                  !KEEP_DEFINITION);
            }
            return Objects.extend(true, {}, defaultPropertyValues);
          }
        }
      },
      /**
       * execute the fn(function) defined in selected module. The default
       * argument of fn is the module self.</br>
       * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead.       
       * @method Built-in_Manifest_Objects.moduleManifest#execute
       * @return {Object} the result of executing fn
       * @example  <caption>Sample Code:</caption>  
       * var moduleManifest = manifest.module.get(id);//get the item from module's manifest by id
       * var result = moduleManifest.execute();//execute the fn defined in the item
       */
      execute : {
        value : function( parentCtx, classNames, tagNames ) {
           var fn = obj.fn;
          //TODO, Jimmy, temporary switch between old and new style, remove it when all modules have been migrated 
          if(fn.prototype.__new_style__){
            var target = new fn(obj, classNames === true ? parentCtx : createContext(this, parentCtx, classNames, tagNames));
            var ret = function(selection){
               return target.render(selection);
            }
            for(var i in target){
              //if(target.hasOwnProperty(i)){
              if(typeof(target[i]) === 'function'){
                var targetFn = target[i];
                ret[i] = function(tFn){
                  return function(){
                    return tFn.apply(target, arguments);  
                  }
                }(targetFn);
              }
            }
            return ret;
          }else{
            return fn(obj, classNames === true ? parentCtx : createContext(this, parentCtx, classNames, tagNames)); 
          }
        }
      }
    });
    return obj;
  });

  manifest.module.loadModule = loadModule;

  return manifest.module;
});
define('sap/viz/modules/Constants',[],
function Setup() {
  var moduleConstants = {
    Type : {
      Chart : 'CHART',
      Container : 'CONTAINER',
      Supplementary : 'SUPPLEMENTARY',
      Behavior : 'BEHAVIOR',
      Controller : 'CONTROLLER',
      
      Scientific : {
        Layout : 'Represents a layout algorithm'
      },
      
      Presentation : {
        Tooltip : 'Represents a tooltip'
      },
      
      ThirdParty : 'THIRDPARTY'
    },
    RenderTo : {
      SVG : 'SVG',
      DIV : 'DIV',
      NONE : 'NONE'
    },
    CSS : {
      CLASS : {
        DATAPOINT : "v-datapoint",
        DATAPOINTDEFAULT: "v-datapoint-default",
        DATAPOINTHOVER : "v-datapoint-hover",
        DATAPOINTSELECTED: "v-datapoint-selected",
        MORPHABLEDATAPOINT : "v-morphable-datapoint",
        MORPHABLELABEL : "v-morphable-label",
        MORPHABLEBACKGROUND : "v-morphable-background",
        MORPHABLELINE : "v-morphable-line",
        MORPHABLEAREABG : "v-morphable-areabg",
        MODULEPREFIX : "v-m-",
      }
    },
    LAYOUT_ADJUST_POLICY : {
      APPROXIMATE : 'APPROXIMATE',
      RELAYOUT : 'RELAYOUT'
    },
    Event : {
      SelectData : {
        name: 'selectData',
        desc : 'Event fires when certain data point(s) is(are) selected, data context of selected item(s) would be passed in accordance with the following format.'
          + '<code>{name: "selectData",'
          + 'data:[{\n//selected element\'s detail\n'
          + 'target:"Dom Element",//an object pointed to corresponding dom element\n'
          + 'data:[{val: "...",//value of this element\n'
          + 'ctx:{type:"Dimension"||"Measure"||"MND",\n'
          + '//for Dimension\n'
          + 'path:{aa:"...",di:"...",dii:"..."},\n'
          + '//for Measure\n'
          + 'path:{mg:"...",mi:"...",dii_a1:"...",dii_a2:"..."},\n'
          + '//for MND\n'
          + 'path:{mg:"...",mi:"..."}\n'
          + '//path: analysis path\n'
          + '//aa: analysis axis index // 0 for analysis axis 1,  1 for analysis 2\n'
          + '//di: dimension index //zero based\n'
          + '//dii: dimension item index //zero based\n'
          + '//mg: measure group index // 0 for measure group 1,1 for measure group 2\n'
          + '//mi: measure index // measure index in measure group zero based\n'
          + '//dii_a1: each dii of di in analysis axis 1 index\n'
          + '//dii_a2: each dii of di in analysis axis 2 index\n'
          + '}},{\n//for bubble, tagcloud and scatter, there will be more than one values in one selected element.\n'
          + 'var:"...",ctx:"..."}]},{\n//if under multi selection, there will be more than one selected elements\n'
          + 'target:"...",data:["..."]}]}'
      },
      DeSelectData : {
        name: 'deselectData',
        desc : 'Event fires when certain data point(s) is(are) deselected, data context of deselected item(s) would be passed in accordance with the following format.'
          + '<code>{name: "deselectData",'
          + 'data:["---the same as selectedData---"]}'
      },
      TooltipShow : {
        name: 'showTooltip',
        desc : 'Event fires when the mouse hover onto the specific part of chart, data context of tooltip would be passed in accordance with the following format.'
          + '<code>{name:"showTooltip",data:{body:[{\n//data of one group\n'
          + 'name:"...",val:[{\n//data of one row\n'
          + 'color:"...",label:"...",shape:"...",value:"..."},"..."]},"..."],footer:[{label:"...",value:"..."},"..."],'
          + 'plotArea:{\n//this object specifies the plot area of the chart\n'
          + 'height:"...",width:"...",x:"...",y:"..."},point:{\n//this object specifies a point which affects the position of tooltip\n'
          + 'x:"...",y:"..."}}}'
      },
      TooltipHide : {
        name: 'hideTooltip',
        desc : 'Event fires when the mouse hover out of the specific part of chart, no data is passed.'
      },
      Initialized : {
        name: 'initialized',
        desc : 'Event fires when the loading ends. To use the event listener when creating charts, you must use an event that is passed by the events option. For more information on events options, see the usrOptions section of the <a href="sap.viz.core.html#createViz" target="_blank">createViz</a> function in the API document.'
      },
      highlightedByLegend : {
        desc : "Event fires when legend item is clicked, which contains its data context."
      }   
    },
    
    mappings : {
      e2p : function ( em ) { return em * 12; }
    },
    COLOR:{
      SAPColorSingleAxis : [ "#748CB2", "#9CC677", "#EACF5E", "#F9AD79",
        "#D16A7C", "#8873A2", "#3A95B3", "#B6D949", "#FDD36C", "#F47958",
        "#A65084", "#0063B1", "#0DA841", "#FCB71D", "#F05620", "#B22D6E",
        "#3C368E", "#8FB2CF", "#95D4AB", "#EAE98F", "#F9BE92", "#EC9A99",
        "#BC98BD", "#1EB7B2", "#73C03C", "#F48323", "#EB271B", "#D9B5CA",
        "#AED1DA", "#DFECB2", "#FCDAB0", "#F5BCB4" ],

      SAPColorDualAxis1 : [ "#8FBADD", "#B8D4E9", "#7AAED6", '#A3C7E3',
        '#3D88C4', '#66A1D0', '#297CBE', '#5295CA', '#005BA3', '#146FB7',
        '#005395', '#0063B1' ],

      SAPColorDualAxis2 : [ "#F6A09B", "#F9C3C0", "#F58E88", '#F8B1AD',
        '#F05B52', '#F37D76', '#EE4A40', '#F16C64', '#D92419', '#ED382D',
        '#C52117', '#EB271B' ]
    },
    DocExample:{
      SnippetUrl:'http://shg-ci-web.dhcp.pgdev.sap.corp/vizdocs_snippet/#',
      TryThisValue:'Try this.'
    }
  };

  return moduleConstants;
});
define('sap/viz/util/ignite',['sap/viz/base/utils/TypeUtils','sap/viz/modules/manifests/Module'],
function Setup( TypeUtils, manifest ) {
  return function( moduleId, parentCtx, classNames, tagNames ) {
    var moduleManifest;
    if ( TypeUtils.isString(moduleId) ) {
      moduleManifest = manifest.get(moduleId);
    } else {
      moduleManifest = moduleId;
      classNames = true;
    }

    return moduleManifest.execute(parentCtx, classNames, tagNames);
  };
});
define('sap/viz/style/Selector',[],
function Setup() {
  function Specificity( selectorText ) {
    this.b = 0;
    this.c = selectorText ? (selectorText.split('.').length - 1) : 0;
    this.d = 0;
  }

  Specificity.prototype = {
    nlt : function( s ) {

      if ( this.b === s.b ) {
        if ( this.c === s.c ) {
          return this.d >= s.d;
        }
        return this.c > s.c;
      }

      return this.b > s.b;
    }
  };

  function Selector( text ) {
    this.text = text;

    var specificity;
    Object.defineProperty(this, "specificity", {
      get : function() {
        if ( !specificity ) {
          specificity = new Specificity(text);
        }
        return specificity;
      }
    });
  }

  Selector.prototype = {
    nlt : function( s ) {
      if ( !s ) {
        return true;
      }
      return this.specificity.nlt(s.specificity);
    }
  };

  return Selector;
});
define('sap/viz/style/Sheet',['sap/viz/style/Selector'],
function Setup( Selector ) {
  function Sheet( source, id ) {
    this.source = source;
    var idSelector = "." + id + " ";

    this.styleElement = document.createElement("style");
    document.head.appendChild(this.styleElement);

    var sheet = this.styleElement.sheet;
    sheet.disabled = true;

    var ruleTexts = source.split("}");
    
    for ( var i = 0, len = ruleTexts.length - 1; i < len; i++) {
      if(ruleTexts[i].indexOf(",") < 0 || ruleTexts[i].indexOf(',') > ruleTexts[i].indexOf('{')){
         sheet.insertRule(idSelector + " " + ruleTexts[i] + "}", i);
      }else{
         var tempTexts = ruleTexts[i].split(",");
         var tempText = "";
         for(var k=0;k<tempTexts.length-1;k++){
            tempText = tempText + idSelector + tempTexts[k] + ",";
         }
         tempText += (idSelector + tempTexts[tempTexts.length-1]);
         
         sheet.insertRule(tempText + "}", i);
      }
    }

    this.rules = [];
    var cssRules = sheet.cssRules;
    for (i = 0, len = cssRules.length; i < len; i++) {
      var cssRule = cssRules[i];
       var selectorTexts = cssRule.selectorText.split(",");
       
      var selectors = selectorTexts.map(function( selector ) {
        if(selector.indexOf(idSelector) >= 0){
            return new Selector(selector.substring(idSelector.length,selector.length));
        }else{
            return new Selector(selector);
        }
      });

      var properties = {};
      var style = cssRule.style;
      for ( var j = 0, styleLen = style.length; j < styleLen; j++) {
        var name = style[j];
        properties[name] = {
          value : style.getPropertyValue(name),
          important : style.getPropertyPriority(name) === "important"
        };
      }

      this.rules.push({
        selectors : selectors,
        properties : properties
      });
    }

    sheet.disabled = false;
  }

  Sheet.prototype = {
    destroy : function() {
      this.styleElement.parentNode.removeChild(this.styleElement);
      return this;
    },

    iterate : function( cb ) {
      this.rules.forEach(function( rule ) {
        rule.selectors.forEach(function( selector ) {
          cb(selector, rule.properties);
        });
      });
      return this;
    }
  };

  return Sheet;
});
define('sap/viz/util/append',[],
function Setup () {
  return function ( markup, attrs ) {
    var node = this.append(markup);
    for ( var key in attrs ) {
      if ( attrs.hasOwnProperty(key) ) { node.attr(key, attrs[key]); }
    }
    return node;
  };
});
define('sap/viz/util/elementutil',[],
function Setup () {
  var ret = {
    'isSVG' : function(selection){
      return ret.isGElement(selection) || ret.isSVGElement(selection);
    },
    'isGElement' : function(selection){
      return selection.node().nodeName.toLowerCase() === 'g';
    },
    'isSVGElement' : function(selection){
      return selection.node().nodeName.toLowerCase() === 'svg';
    },
    'isDIV' : function(selection){
      return selection.node().nodeName.toLowerCase() === 'div';
    }
  };
  return ret;
});
define('sap/viz/util/fn/dombuilder',['sap/viz/modules/Constants','sap/viz/modules/manifests/Module','sap/viz/util/append','sap/viz/base/utils/FunctionUtils',
'sap/viz/util/elementutil'],
function Setup (Constants, ModuleDefs, append, FnUtil, elementutil) {

  /*
   * this function helps you create viz structure on parent based on passed in modules configuration.
   * @returns {Object} {'ModuleReferenceKey' : DOMElement/D3Selection(based on module's renderTo type)}
   */
  var retfn = function ( parent, conf ) {
    //if parent is svg/d3selection, we don't allow any more div children
    var parentSVG = elementutil.isSVG(parent);
    var root = parent;
    var ret = {};
    //if all sub modules is render to SVG/NULL, we need create only one SVG and append a 'g' for each of them
    //if sub modules have both SVG and DIV, we create div for DIV and create 'svg->g' element for each SVG sub modules
    var allSVG = true; 
    var key, module;
    for(key in conf){
      if(conf.hasOwnProperty(key) && conf[key]){
        module = ModuleDefs.get(conf[key].id);
        if(module && module.renderto === Constants.RenderTo.DIV){
          if(parentSVG){
            FnUtil.error('Configuration Error! Does not allow append div under svg element!');  
          }else{
            allSVG = false;
            break;  
          }
        } 
      }
    }

    for(key in conf){
      if(conf.hasOwnProperty(key) && conf[key]){
        module = ModuleDefs.get(conf[key].id);
        if(module){
          if(module.renderto === Constants.RenderTo.DIV){
            ret[key] = append.apply(root, ['div', {'class' : 'v-m-' + key}]);
          }else if (module.renderto === Constants.RenderTo.NONE){
            ret[key] = undefined;
          }else{
            //Jimmy, by default all current modules are rendered to SVG.
            ret[key] = append.apply(root, [parentSVG ? 'g' : 'svg', {'class' : 'v-m-' + key}]);
          }
        } 
      }
    }
    
    return ret;
  };
  
  return retfn;
});
define('sap/viz/util/fn/domposition',['sap/viz/util/elementutil'],
function Setup (elementutil) {
  
  var positionSVG = function(target, info){
    if(target && info){
      if(elementutil.isSVGElement(target)){
        //if it's SVG element, we should use left/top to position it, instead of transform
        target.attr('width', info.width);
        target.attr('height', info.height);
        target.style('position', 'absolute').style( 'box-sizing', 'border-box').style( 'left',info.x + 'px').style('top',info.y + 'px');
      }else{
        target.attr('transform', 'translate(' + info.x +', ' + info.y + ')'); 
      }
    }
  };
  
  var positionDIV = function(target, info){
    if(target && info){
      target.style('position', 'absolute').style('box-sizing', 'border-box').style('overflow','hidden').style('width',info.width + 'px').style('height',info.height + 'px').style('left', info.x + 'px').style('top', info.y + 'px');
    }
  };
  
  /*
   * this function helps you to position dom elements (selections) based on passed in layout info.
   * @returns 
   */
  var retfn = function ( layout, selections ) {
    var iter;
    for(iter in selections){
      if(selections.hasOwnProperty(iter)){
        if(layout[iter]){
          var info = layout[iter];
          if(elementutil.isSVG(selections[iter])){
            positionSVG(selections[iter], info);
          }else if(elementutil.isDIV(selections[iter])){
            positionDIV(selections[iter], info);
          }
        }
      }
    }
  };
  
  return retfn;
});
define('sap/viz/modules/event/Manager',[],
function Setup() {

    return function(){
        var component;

        var eventManager = {
            UIComponent : function(_) {
                if (!arguments.length) {
                    return component;
                }
                component = _;
                return eventManager;
            },

            on : function(type, listener) {
                component.on(type, listener);
                return eventManager;
            },

           addGestureDetector : function(_) {
                if (!arguments.length) {
                    return;
                }
                component.addGestureDetector(_);
                return eventManager;
            },
            
            destroy : function() {
              component = null;
            }
        };

        return eventManager;  
    };
});
define('sap/viz/util/FeedingZoneUtil',['sap/viz/base/utils/Objects', 'sap/viz/manifest'],

function Setup(Objects, manifest){
    

    var lookupModule = function(tree, id) {
        if (tree.hasOwnProperty(id)) {
            return tree[id];
        }
        
        if (typeof tree !== 'object') {
            return;
        }
        
        for (var i in tree) {
            if (tree.hasOwnProperty(i) && tree[i]) {
                var res = lookupModule(tree[i], id);
                if (res) {
                    return res;
                }
            }
        }
        return;
    };
    
    var lookupFeed = function(allFeeds, ids) {
        var res = [];
        for (var i = 0; i < allFeeds.length; i++) {
            for (var j = 0; j < ids.length; j++) {
                if (allFeeds[i].id === ids[j]) {
                    res.push(allFeeds[i]);
                }
            }
            
        }
        return res;
    };

    var buildMultiRes = function(name, feed, selection, byBound) {
        var element = selection.select('.v-m-' + name);
        var rect = element.node().getBBox();
        if (byBound) {
            rect = element.select('.v-bound').node().getBBox();
        }
        var transform = element.node().getTransformToElement(element.node().ownerSVGElement);
        var point1 = [transform.e + rect.x, transform.f + rect.y];
        var point2 = [point1[0] + rect.width, point1[1]];
        var point3 = [point1[0] + rect.width, point1[1] + rect.height];
        var point4 = [point1[0], point1[1] + rect.height];
        var res = {
            name : name,
            feedDef : feed,
            bound : [[point1, point2, point3, point4]]
        };
        return res;
    };
    
    var buildRes = function(name, feed, selection, byBound) {
        var elements = selection.selectAll('.v-m-' + name);
        var bound = [];
        elements.each(function(d, i) {
            var rect = this.getBBox();
            if (byBound) {
                var node = d3.select(this).select('.v-bound').node();
                if (node === null) {
                    return;
                }
                rect = node.getBBox();
            }
            var transform = this.getTransformToElement(this.ownerSVGElement);
            var point1 = [transform.e + rect.x, transform.f + rect.y];
            var point2 = [point1[0] + rect.width, point1[1]];
            var point3 = [point1[0] + rect.width, point1[1] + rect.height];
            var point4 = [point1[0], point1[1] + rect.height];
            bound.push([point1, point2, point3, point4]);
        });
        var res = {
            name : name,
            feedDef : feed,
            bound : bound
        };
        return res;
    };
    
    var buildGeoRes = function(id, name, feed, selection) {
        var bound = [];
        var elements;
        if(id === 'viz/choropleth' || id === 'viz/geobubble'|| id === 'viz/geopie')
        {
         elements = selection.selectAll('.v-m-main');
         elements.each(function(d, i) {
            var node = d3.select(this).select('.v-bound').node();
            if (node === null) {
                return;
            }
            var rect = node.getBBox();            
            var transform = this.getTransformToElement(this.ownerSVGElement);
            var point1 = [transform.e + rect.x, transform.f + rect.y];
            var point2 = [point1[0] + rect.width, point1[1]];
            var point3 = [point1[0] + rect.width, point1[1] + rect.height];
            var point4 = [point1[0], point1[1] + rect.height];
            bound.push([point1, point2, point3, point4]);
            });
        }
        if(id === 'viz/multi_choropleth' || id === 'viz/multi_geobubble')
        {
         var mainelements = selection.selectAll('.v-m-plot');
         for(var i = 0; i< mainelements[0].length; i++)
         {
             elements = selection.selectAll('.v-m-plot'+i);
             elements.each(function(d, i) {
                var node = d3.select(this).select('.v-bound').node();
                if (node === null) {
                return;
                }
                var rect = node.getBBox();            
                var transform = this.getTransformToElement(this.ownerSVGElement);
                var point1 = [transform.e + rect.x, transform.f + rect.y];
                var point2 = [point1[0] + rect.width, point1[1]];
                var point3 = [point1[0] + rect.width, point1[1] + rect.height];
                var point4 = [point1[0], point1[1] + rect.height];
                bound.push([point1, point2, point3, point4]);
               });
         }
        }
        var res = {
            name : name,
            feedDef : feed,
            bound : bound
        };
        return res;
    };
    
    var parseXYLegend = function(id, selection) {
        var chartManifest = manifest.viz.get(id);
        var allFeeds = chartManifest.allFeeds();
        var legend = lookupModule(chartManifest, 'legends');
        if (legend) {
            // waterfall chart uses xy feed, but without legend
            return [buildRes('legend', lookupFeed(allFeeds, ['regionColor']), selection, true)];
        }
        return;
    };
    
    var parseXYChart = function(id, selection, moduleManifest) {
        var chartManifest = manifest.viz.get(id);
        var allFeeds = chartManifest.allFeeds();
        var res = [];
        
        var plotDef = buildRes('plot', allFeeds.filter(function(d){if(d.id === 'multiplier'){ return false;} return true;}), selection);
        res.push(plotDef);
        
        var isTwoD = id.indexOf('3d') < 0;

        var xAxis = lookupModule(moduleManifest ? moduleManifest : chartManifest, 'xAxis');
        var xAxisDef;
        if (xAxis.configure.properties.type === 'value') {
            // value axis
            xAxisDef = buildRes('xAxis', lookupFeed(allFeeds, ['primaryValues']), selection, isTwoD);
        } else {
            // category axis
            xAxisDef = buildRes('xAxis', lookupFeed(allFeeds, ['axisLabels']), selection, isTwoD);
        }
        res.push(xAxisDef);
        
        var x2Axis = lookupModule(moduleManifest ? moduleManifest : chartManifest, 'xAxis2');
        if (x2Axis) {
            // only value axis can be applied
            var x2AxisDef = buildRes('xAxis2', lookupFeed(allFeeds, ['secondaryValues']), selection, isTwoD);
            res.push(x2AxisDef);
        }
        
        var yAxis = lookupModule(moduleManifest ? moduleManifest : chartManifest, 'yAxis');
        var yAxisDef;
        if (yAxis.configure.properties.type === 'value') {
            yAxisDef = buildRes('yAxis', lookupFeed(allFeeds, ['primaryValues']), selection, isTwoD);
        } else {
            yAxisDef = buildRes('yAxis', lookupFeed(allFeeds, ['axisLabels']), selection, isTwoD);
        }
        res.push(yAxisDef);
        
        var y2Axis = lookupModule(moduleManifest ? moduleManifest : chartManifest, 'yAxis2');
        if (y2Axis) {
            var y2AxisDef = buildRes('yAxis2', lookupFeed(allFeeds, ['secondaryValues']), selection, isTwoD);
            res.push(y2AxisDef);
        }
        
        // zAxis exists for 3D bar/column, which is always category axis
        var zAxis = lookupModule(moduleManifest ? moduleManifest : chartManifest, 'zAxis');
        if (zAxis) {
            var zAxisDef = buildRes('zAxis', lookupFeed(allFeeds, ['regionColor']), selection, isTwoD);
            res.push(zAxisDef);
        }
        
        return res;
    };
    
    var parseScatterLegend = function(id, selection) {
        var chartManifest = manifest.viz.get(id);
        var allFeeds = chartManifest.allFeeds();
        var res = [buildRes('legend', lookupFeed(allFeeds, ['regionColor', 'regionShape']), selection, true)];
        if (lookupModule(chartManifest, 'sizeLegend')) {
            res.push(buildRes('sizeLegend', lookupFeed(allFeeds, ['bubbleWidth']), selection, true));
        }
        return res;
    };
    
    var parseScatterChart = function(id, selection) {
        var chartManifest = manifest.viz.get(id);
        var allFeeds = chartManifest.allFeeds();
        
        var plotDef = buildRes('plot',  allFeeds.filter(function(d){if(d.id === 'multiplier'){ return false;} return true;}), selection);
        
        var xAxisDef = buildRes('xAxis', lookupFeed(allFeeds, ['primaryValues']), selection, true);
        
        var yAxisDef = buildRes('yAxis', lookupFeed(allFeeds, ['secondaryValues']), selection, true);
        
        var res = [plotDef, xAxisDef, yAxisDef];
        return res;
    };
    
    var parserScatterMatrixChart = function(id, selection) {
        var chartManifest = manifest.viz.get(id);
        var allFeeds = chartManifest.allFeeds();
        
        var plotDef = buildRes('plot', allFeeds, selection, true);
        
        var xAxisDef = buildRes('xAxis', lookupFeed(allFeeds, ['primaryValues']), selection, true);
        
        var yAxisDef = buildRes('yAxis', lookupFeed(allFeeds, ['primaryValues']), selection, true);
        
        var res = [plotDef, xAxisDef, yAxisDef];
        return res;
    };
    
    var parsePieLegend = function(id, selection) {
        var chartManifest = manifest.viz.get(id);
        var allFeeds = chartManifest.allFeeds();
        return [buildRes('legend', lookupFeed(allFeeds, ['pieSectorColor']), selection, true)];
    };
    
    var parsePieChart = function(id, selection) {
        var chartManifest = manifest.viz.get(id);
        var allFeeds = chartManifest.allFeeds();
        
        var plotDef = buildRes('plot',  allFeeds.filter(function(d){if(d.id === 'multiplier'){ return false;} return true;}), selection);

        var res = [plotDef];
        return res;
    };
    
    
    var parseMapLegend = function(id, selection) {
        var chartManifest = manifest.viz.get(id);
        var allFeeds = chartManifest.allFeeds();
        return [buildRes('legend', lookupFeed(allFeeds, ['rectangleColor']), selection, true)];
    }; 
    
    var parseMapChart = function(id, selection, moduleManifest) {
        var chartManifest = manifest.viz.get(id);
        var allFeeds = chartManifest.allFeeds();
        
        var plotDef = buildRes('plot', allFeeds, selection);
        
        var res = [plotDef];
        
        var xAxis = lookupModule(moduleManifest ? moduleManifest : chartManifest, 'xAxis');
        if (xAxis) {
            var xAxisDef = buildRes('xAxis', lookupFeed(allFeeds, ['mainLabelAxis']), selection, true);
            res.push(xAxisDef);
        }
        
        var yAxis = lookupModule(moduleManifest ? moduleManifest : chartManifest, 'yAxis');
        if (yAxis) {
            var yAxisDef = buildRes('yAxis', lookupFeed(allFeeds, ['secondaryLabelAxis']), selection, true);
            res.push(yAxisDef);
        }
	
        return res;
    };
    
    var parseGeoLegend = function(id, selection) {
        var chartManifest = manifest.viz.get(id);
        var allFeeds = chartManifest.allFeeds();
        var res;
        if (id === 'viz/choropleth' || id === 'viz/multi_choropleth')
        {
           res = [buildRes('legend', lookupFeed(allFeeds, ['featureValues']), selection, true)];
        }
        if (id === 'viz/geobubble' || id === 'viz/multi_geobubble')
        {
            if (lookupModule(chartManifest, 'sizeLegend')) {
                res = [buildRes('sizeLegend', lookupFeed(allFeeds, ['featureValues']), selection, true)];
            }
        }
        if (id === 'viz/geopie')
        {
            res = [buildRes('legend', lookupFeed(allFeeds, ['featureAnalysis']), selection, true)];
            if (lookupModule(chartManifest, 'sizeLegend')) {
                res.push(buildRes('sizeLegend', lookupFeed(allFeeds, ['featureValues']), selection, true));
            }
        }
        return res;
    }; 
    
    var parseGeoChart = function(id, selection, moduleManifest) {
        var chartManifest = manifest.viz.get(id);
        var allFeeds = chartManifest.allFeeds();
        var plotDef = buildGeoRes(id, 'plot', allFeeds.filter(function(d){if(d.id === 'multiplier'){ return false;} return true;}), selection);
        var res = [plotDef];        
        return res;
    };
    
    var parseTagCloudLegend = function(id, selection) {
        var chartManifest = manifest.viz.get(id);
        var allFeeds = chartManifest.allFeeds();
        return [buildRes('legend', lookupFeed(allFeeds, ['tagFamily']), selection, true)];
    };
    
    var parseTagCloudChart = function(id, selection) {
      var chartManifest = manifest.viz.get(id);
      var allFeeds = chartManifest.allFeeds();
      
      var plotDef = buildRes('plot', allFeeds, selection);
      
      return [plotDef];
    };
  
    var parseNetworkChart = function(id, selection) {
      var chartManifest = manifest.viz.get(id);
      var allFeeds = chartManifest.allFeeds();
      
      var plotDef = buildRes('plot', allFeeds, selection, true);
      
      return [plotDef];
    };
    
    var parseTreeChart = parseTagCloudChart;
    
    var parseNetworkLegend = function (){};
    
    var parseTreeLegend = function (){};

    var parseRadarChart = function(id, selection) {
        var chartManifest = manifest.viz.get(id);
        var allFeeds = chartManifest.allFeeds();
        
        var plotDef = buildRes('plot', allFeeds.filter(function(d){if(d.id === 'multiplier'){ return false;} return true;}), selection);
        
        var elements = selection.selectAll('.v-valueaxis');
        var bound = [];
        elements.each(function(d, i) {
            var rect;
            if (d3.select(this).select('.v-bound').empty()) {
                rect = d3.select(this).node().getBBox();
            } else {
                rect = d3.select(this).select('.v-bound').node().getBBox();
            }
            var transform = this.getTransformToElement(this.ownerSVGElement);
            var point1 = [transform.e + rect.x, transform.f + rect.y];
            var point2 = [point1[0] + rect.width, point1[1]];
            var point3 = [point1[0] + rect.width, point1[1] + rect.height];
            var point4 = [point1[0], point1[1] + rect.height];
            bound.push([point1, point2, point3, point4]);
        });
        var valueaxisDef = {
            name : 'valueaxis',
            feedDef : lookupFeed(allFeeds, ['radarAxesValues']),
            bound : bound
        };
        
        return [plotDef, valueaxisDef];
    };
    
    var parseMultiChart = function(plotParser, legendParser) {
        return function(id, selection) {
            var chartManifest = manifest.viz.get(id);
            var allFeeds = chartManifest.allFeeds();
            
            var plotSelection = selection.select('.v-m-plot');
            var def = plotParser.call(this, id, plotSelection, chartManifest.modules.root.modules.main.modules.plot.modules);
            
            var legendDef = legendParser.call(this, id, selection);
            def = def.concat(legendDef);
            
            var plotsDef = buildMultiRes('plot', allFeeds, selection, true);
            plotsDef.name = 'mainPlot';
            def = def.concat(plotsDef);
            
            var multiplierDef = buildMultiRes('xAxis2', lookupFeed(allFeeds, ['multiplier']), selection, true);
            multiplierDef.name = 'multiplier';
            
            var yAxisDef = buildMultiRes('yAxis', lookupFeed(allFeeds, ['multiplier']), selection, true);
            multiplierDef.bound = multiplierDef.bound.concat(yAxisDef.bound);
            
            def.push(multiplierDef);
            return def;
        };
    };
    
    var parseSingleChart = function(plotParser, legendParser) {
        return function(id, selection) {
            var scatterMatrixSelection;
            if (id === 'viz/scatter_matrix') {
                scatterMatrixSelection = selection.select('.v-m-plot');
            }
            var def = plotParser.call(this, id, scatterMatrixSelection ? scatterMatrixSelection : selection);
            var legendDef = legendParser.call(this, id, selection);
            if (legendDef) {
                def = def.concat(legendDef);
            }
            return def;
        };
    };
    
    var distribute = function(id) {
        var chartManifest = manifest.viz.get(id);
        if (chartManifest.feedingZone) {
            return chartManifest.feedingZone;
        }
        var module, plotParser, legendParser;
        if (id === 'viz/scatter_matrix') {
            module = chartManifest.modules.root.modules.main.id;
        } else if (id.indexOf('multi') >= 0) {
            module = chartManifest.modules.root.modules.main.modules.plot.modules.plot.id;
        } else {
            module = chartManifest.modules.root.modules.main.modules.plot.id;
        }
        
        switch(manifest.module.get(module).feeds.id) {
            case 'xy' : 
                plotParser = parseXYChart;
                legendParser = parseXYLegend;
                break;
            case 'scatter' : 
                plotParser = parseScatterChart;
                legendParser = parseScatterLegend;
                break;
            case 'pie' : 
                plotParser = parsePieChart;
                legendParser = parsePieLegend;
                break;
            case 'heatMap' :
            case 'treeMap' : 
                plotParser = parseMapChart;
                legendParser = parseMapLegend;
                break;
            case 'tagCloud' : 
                plotParser = parseTagCloudChart;
                legendParser = parseTagCloudLegend;
                break;
            case 'network':
              plotParser = parseNetworkChart;
              legendParser = parseNetworkLegend;
              break;
            case 'tree':
              plotParser = parseTreeChart;
              legendParser = parseTreeLegend;
              break;
            case 'radar' : 
                plotParser = parseRadarChart;
                legendParser = parseScatterLegend;
                break;
            case 'scattermatrix' :
                plotParser = parserScatterMatrixChart;
                legendParser = parseScatterLegend;
                break;
            case 'geo':
                plotParser = parseGeoChart;
                legendParser = parseGeoLegend;
                break;
            default :
        }
        
        if (id.indexOf('multi') >= 0) {
            return parseMultiChart(plotParser, legendParser);
        } else {
            return parseSingleChart(plotParser, legendParser);
        }
    }; 

  
    var FeedingZoneUtil = {
        
        parse : function(id, selection) {
            var parser = distribute(id);
            return parser.call(this, id, selection);
        }

    };
  
    return FeedingZoneUtil;
});

define('sap/viz/util/TextUtils',['sap/viz/base/utils/TypeUtils','sap/viz/base/UADetector'],
function Setup( TypeUtils, UADetector ) {
  var ns = "http://www.w3.org/2000/svg";
  var node;
  var canvasNode;
  var fasterFun;
  var sensitiveStyle = ["font", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style",
      "font-variant", "font-weight", "letter-spacing", "word-spacing", "alignment-baseline", "baseline-shift",
      "dominant-baseline"];
  var textSizeCache = [];
  var textSizeCacheForSuper = [];
  var myTextSizeCache = [];
  
  function getNode() {
    if ( !node ) {
      var svg = document.body.appendChild(document.createElementNS(ns, "svg"));
      svg.style.cssText = "position:absolute;left:-1000px;top:-1000px;z-index:-9000;width:1px;height:1px";
      node = svg.appendChild(document.createElementNS(ns, "text"));
    }

    return node;
  }

  function applyText( text, style ) {
    var node = getNode();

    if ( !style ) {
      node.removeAttribute("style");
    } else {
      if ( !TypeUtils.isString(style) ) {
        var computedStyle = UADetector.isIE() ? style.ownerSVGElement.getComputedStyle(style) : window
            .getComputedStyle(style);

        var cssText = "";
        sensitiveStyle.forEach(function( i ) {
          var s = computedStyle.getPropertyValue(i);
          if ( s !== null ) {
            cssText += i + ":" + s + ";";
          }
        });
        style = cssText;
      }
      node.style.cssText = style;
    }
    if ( text === undefined || text === null ) {
      text = "";
    }

    node.textContent = text;
    return node;
  }

  function ellipsis( text, textNode, expectedLength, cssStyle, textApplied ) {
    var index = "..." + cssStyle;
    if ( expectedLength > 0 ) {
      if (myTextSizeCache[index]) {
        if(text.length > 3) {
          if(expectedLength < myTextSizeCache[index]/3*4) {
            if ( textNode ) {
              textNode.textContent = "";
            }
            return "";
          }
        } else {
          if(expectedLength < myTextSizeCache[index]/3*text.length) {
            if ( textNode ) {
              textNode.textContent = "";
            }
            return "";
          }
        }
      }
      var node,initTextLength;
      index = text + cssStyle;
      node = textApplied ? getNode() : applyText(text, cssStyle || textNode);
      initTextLength = node.getComputedTextLength();
      
      if (initTextLength  <= expectedLength ) {
        if ( textNode ) {
          textNode.textContent = text;
        }
        return text;
      }
      
      index = "..." + cssStyle;
      if (!myTextSizeCache[index]) {
        node.textContent = "...";
        myTextSizeCache[index] = node.getComputedTextLength();
      }

      expectedLength -= myTextSizeCache[index];
      node.textContent = text;
      if ( expectedLength > 0 ) {
        var charNumber = text.length;
        var i = Math.ceil(expectedLength/initTextLength*charNumber);
        var subStr = text.substring(0, i);
        index = subStr + cssStyle;
        var textLength = node.getSubStringLength(0, i);
        var reText;
        if(textLength <= expectedLength) {
          while(++i <= charNumber) {
            subStr = text.substring(0, i);
            index = subStr + cssStyle;
            textLength = node.getSubStringLength(0, i);
            if(textLength > expectedLength) {
              reText = text.substring(0, i-1) + "...";
              if ( textNode ) {
                textNode.textContent = reText;
                textNode.appendChild(document.createElementNS(textNode.namespaceURI, "title")).textContent = text;
              }
              return reText;
            }
          }
        } else {
          while(--i > 0) {
            subStr = text.substring(0, i);
            index = subStr + cssStyle;
            textLength = node.getSubStringLength(0, i);
            
            if(textLength <= expectedLength) {
              reText = subStr + "...";
              if ( textNode ) {
                textNode.textContent = reText;
                textNode.appendChild(document.createElementNS(textNode.namespaceURI, "title")).textContent = text;
              }
              return reText;
            }
          }
        }
      } 
    }
    if ( textNode ) {
      textNode.textContent = "";
    }
    return "";
  }

  return {
    /**
     * Measure the dimension of the text in given style
     * 
     * @param {String}
     *          text the text to be measured
     * @param style
     *          the style definition text or a DOM node. If it is a node, its style will be used to measure text.
     * @returns {Object}
     */
    measure : function( text, style ) {
      if ( text === '' ) {
        return {
          width : 0,
          height : 0,
          x : 0,
          y : 0
        };
      }
      var box = applyText(text, style).getBBox();
      return {
        width : box.width,
        height : box.height,
        x : box.x,
        y : box.y
      };
    },

    /**
     * Measure text in a canvas
     * 
     * @param {String}
     *          the text to be measured
     * @param {String}
     *          fontSize
     * @param {String}
     *          fontWeight
     * @param {String}
     *          fontFamily
     * @returns {Object}
     */
    measureInCanvas : function( text,  tFontSize, tFontWeight, tFontFamily ) {
        if(!tFontFamily || !tFontSize || !tFontWeight)
        {
            //the function cannot get right value 
            return;
        }

        var strWidth = 0;
        if (!canvasNode)
        {        
            canvasNode = document.createElement("canvas");
            canvasNode.style.cssText = "position:absolute;left:-1000px;top:-1000px;z-index:-9000;width:0px;height:0px;visibility:hidden";
            document.body.appendChild(canvasNode);
        }

        if (canvasNode.getContext)
        {
            var ctx = canvasNode.getContext("2d");
            var fontString = tFontWeight + " " + tFontSize + " " + tFontFamily;
            ctx.font = fontString;
            strWidth = ctx.measureText(text).width;
        }

        var fontSizeFloat = parseFloat(tFontSize) * 1.2;
    
        return {
            width : strWidth,
            height : fontSizeFloat
        };    
    },

    /**
     * Fast measure the dimension of the text in given fontSize, fontWeight and fontFamily
     * 
     * @param {String}
     *          text the text to be measured
     * @param {String}
     *          fontSize
     * @param {String}
     *          fontWeight
     * @param {String}
     *          fontFamily
     * @returns {Object}
     */
    fastMeasure : function( text, tFontSize, tFontWeight, tFontFamily ) {
      var index = text + tFontSize + tFontWeight + tFontFamily;
      var cachedSize = textSizeCache[index];
      if ( !cachedSize ) {
        textSizeCache[index] = this.measure(text, "font-size:" + tFontSize + "; font-weight:" + tFontWeight +
            "; font-family:" + tFontFamily);

        cachedSize = textSizeCache[index];
      }
      return cachedSize;
    },
    
    //find the fastest measure function for the browser.
    //measureInCanvas may be faster in Chrome, but not in Firefox.
    bestMeasureFun : function(tFontSize, tFontWeight, tFontFamily)
    {
        if(!fasterFun)
        {
            var i; 
            var testTimes = 100;
            var testText = "Test";
            //test measureInCanvas
            var startC = new Date().getTime();
            for(i = 0; i < testTimes; i++)
            {
                this.measureInCanvas(testText, tFontSize, tFontWeight, tFontFamily);
            }
            var endC = new Date().getTime();
            var timeC = endC - startC;

            //test measure
            var startM = new Date().getTime();
            for(i = 0; i < testTimes; i++)
            {           
                this.measure(testText, "font-size:" + tFontSize + "; font-weight:" + tFontWeight +
                             "; font-family:" + tFontFamily);
            }
            var endM = new Date().getTime();
            var timeM = endM - startM;

            if(timeC < timeM)
            {
                fasterFun = "C";
            }
            else
            {
                fasterFun = "M";
            }
        }

        return fasterFun;
    },
    /**
     * Super fast measure the dimension of the text in given fontSize, fontWeight and fontFamily
     * 
     * @param {String}
     *          text the text to be measured
     * @param {String}
     *          fontSize
     * @param {String}
     *          fontWeight
     * @param {String}
     *          fontFamily
     * @returns {Object}
     */
    superFastMeasure : function( text, tFontSize, tFontWeight, tFontFamily ) {
      var index = text + tFontSize + tFontWeight + tFontFamily;
      var cachedSize = textSizeCacheForSuper[index];
      if ( !cachedSize ) {
        if(this.bestMeasureFun(tFontSize, tFontWeight, tFontFamily) === "C")
        {
            textSizeCacheForSuper[index] = this.measureInCanvas(text, tFontSize, tFontWeight, tFontFamily);
        }
        else
        {
            textSizeCacheForSuper[index] = this.measure(text, "font-size:" + tFontSize + "; font-weight:" + tFontWeight +
            "; font-family:" + tFontFamily);
        }
        cachedSize = textSizeCacheForSuper[index];
      }
      return cachedSize;
    },

    /**
     * Ellipsis long text.
     * 
     * @param {String}
     *          text the text to be processed
     * @param {Node}
     *          textNode the svg:text which will be display text
     * @param {Number}
     *          maxLength the max text length
     */
    ellipsis : function( text, textNode, maxLength, cssStyle ) {
      return ellipsis(text, textNode, maxLength, cssStyle, false);
    },

    /**
     * Ellipsis long text in a circle area.
     * 
     * @param {String}
     *          text the text to be processed
     * @param {Node}
     *          textNode the svg:text which will be display text
     * @param {Number}
     *          r the radius of circle
     * @param {Number}
     *          h the offset from center of circle
     * @param {Object}
     *          cssStyle the style object
     */
    ellipsisInCircle : function( text, textNode, r, h, cssStyle ) {
      var node = applyText(text, textNode);

      var maxLength = Math.sqrt(Math.pow(r, 2) - Math.pow(h + node.getBBox().height / 2, 2)) * 2;
      ellipsis(text, textNode, maxLength, cssStyle, true);
    },

    verticalCentralOffset : function( text, textNode ) {
      var tmpNode = applyText(text, textNode);
      var box = tmpNode.getBBox();
      var actualHeight = -box.y;
      var fontSize = parseInt(tmpNode.ownerSVGElement.getComputedStyle(tmpNode)["fontSize"], 0);
      return (actualHeight - (box.height - fontSize)) / 2;
    },
    
    destroy : function(){
      if(node){
        //svg
        var svg = node.parentNode;
        if(svg){
          svg.parentNode.removeChild(svg);  
        }
      }
      node = null;
      textSizeCacheForSuper = [];
      textSizeCache = [];
      if(canvasNode){
        canvasNode.parentNode.removeChild(canvasNode);
      }
      canvasNode = null;
    }
  };
});
define('sap/viz/chart/mvc/ChartComponent',['jquery','sap/viz/base/utils/TypeUtils','sap/viz/base/utils/ObjectUtils','sap/viz/base/utils/Objects',
'sap/viz/base/utils/FunctionUtils','sap/viz/mvc/UIComponent','sap/viz/manifest','sap/viz/modules/manifests/Module',
'sap/viz/modules/Constants','sap/viz/util/ignite',
'sap/viz/lang/langManager','sap/viz/config','sap/viz/style/Manager','sap/viz/style/Sheet','sap/viz/util/fn/dombuilder',
'sap/viz/util/fn/domposition','sap/viz/base/utils/log/LogUtil','sap/viz/modules/event/Manager', 'sap/viz/util/FeedingZoneUtil', 'sap/viz/util/TextUtils','sap/viz/config'],
function($, TypeUtils, ObjectUtils, Objects, Functions,
  UIComponent, manifest, Modules, registry, ignite, 
  langManager, canvgConf, StyleManager, StyleSheet, 
  dombuilder, domposition, LOG , EventManager, FeedingZoneUtil, TextUtils,config){
  var DOT = '.';
  var CANVGSTATUS = 'canvg';
  var SOURCEMODULE ='sourceModule';
  var TARGETMODULE= 'targetModule';
  var INITIALIZED_EVENT_NAME = 'initialized.rootComponent'; 
  
  function buildPropertiesTree ( obj ) {
    var returnObj = {};
    for ( var i in obj ) {
      if ( obj.hasOwnProperty(i) ) {
        if ( obj[i].supportedValueType === "Object" ) {
          returnObj[i] = buildPropertiesTree(obj[i].supportedValues);
        } else {
          returnObj[i] = obj[i].defaultValue;
        }
      }
    }
    return returnObj;
  }
  
  function mergeProperties ( defaultVal, all ) {
    var defaults = defaultVal, ret = {};    
    
    // FIXME This function is inadequate for handling container
    // property merge. This code snippet is just as a rescue to
    // pass the unit testing and should not be treated as correct.
    // Please correct it later.
    if ( all.general && defaults.layout ) {
      defaults.general = {};
      defaults.general.layout = Objects.extend(true, {}, defaults.layout);
      delete defaults.layout;
    }
    
    ret = Objects.extend(true, {}, defaults);
    
    for ( var key in defaults ) {
      if ( defaults.hasOwnProperty(key) ) {
        if ( typeof all === 'object' && all.hasOwnProperty(key) ) {
          if ( defaults[key] !== null &&
               typeof defaults[key] === 'object' && 
               !( defaults[key] instanceof Array ) ) {
            ret[key] = mergeProperties(defaults[key], all[key]);
          } else {
            if ( (typeof all[key] !== 'undefined' && all[key] instanceof Array && 
                  defaults[key] instanceof Array) || 
                 (typeof all[key] !== 'undefined' && typeof all[key] !== 'object') ) {
              ret[key] = all[key];
            }
          }
        }
      }
    }
    
    // FIXME hard-coding
    if ( ret.general ) {
      ret.layout = $.extend(true, {}, ret.general.layout);
      delete ret.general;
    }
    return ret;
  }

  function extractProperties ( modules, chartId ) {
    var defaultProperties = manifest.viz.get(chartId).allProperties();
    var mergedProperties = {};
    var tempKey;
    var tempProp = {};
    var i, j;
    for ( i in modules ) {
      if ( modules.hasOwnProperty(i) ) {
        if ( modules[i].properties && !TypeUtils.isEmptyObject(modules[i].properties()) ) {
          if ( i.indexOf('[') > -1 ) {
            if ( parseInt(i[i.indexOf('[') + 1],10) > 0 ) {
              continue;
            } else {
              tempKey = i.substring(0,i.indexOf('[')) + i.substring(i.indexOf(']') + 1);
            }
          } else {
            tempKey = i;
          }
          for ( j in defaultProperties ) {
            if ( defaultProperties.hasOwnProperty(j) ) {
              if ( defaultProperties[j].moduleRefPath === tempKey ) {
                tempProp = buildPropertiesTree(defaultProperties[j]);
                mergedProperties[j] = mergeProperties(tempProp, modules[i].properties());
              }
            }
          }
        }
      }
    }
    return mergedProperties;
  }
    
  /* Represents the root component. */
  var ChartComponent = UIComponent.extend({

    initialize : function ( options ) {
      this._config = options.config;
      this._data = options.data;
      this._modules = {};//store all modules from all levels
      this._rootModules = {};//store modules in the root level
      this._selections = {};
      this._properties = options.options;
      this._dispatch = d3.dispatch('dataTruncation', 'initialized');
      this._attachedByFramework = false;
      this._initializedEventDispatched = false;
      
      this._i18nListener = {
        fn : this._localeChanged,
        scope : this
      };

      langManager.addListener(this._i18nListener);
      
      if ((config.get("isCrossTable"))&&this._data.emptyDataset()) { return; } //TODO support empty data set in module level 
      
      this._canvas = d3.select(document.createElement('canvas'))
        .style('width', 0).style('height', 0);
      
      $(this.container).prepend(this._canvas.node());
      
      var m_canvg_config = canvgConf.get(this._config.id) || {} ;
      this._max_svg =  canvgConf.enableCanvg() && m_canvg_config.max_svg ? 
        m_canvg_config.max_svg : Number.POSITIVE_INFINITY ;
      this._max_canvas = canvgConf.enableCanvg() && m_canvg_config.max_canvas ?
        m_canvg_config.max_canvas : Number.POSITIVE_INFINITY ;
      
      this._root = d3.select(this.container);      // D3 selection
      this._component_status = 'svg';
      
      var id = ObjectUtils.guid("sap-viz");
      var chartClass = this.container.id + "-" + id;
      this._id = chartClass;
      
      var chartId = options.config.id.split('/');
      for ( var i = 0; i < chartId.length; i++ ) {chartClass= chartClass + ' v-'+chartId[i];}
      this._root.attr("class", chartClass).style('-webkit-user-select', 'none').style('-moz-user-select', 'none').style('-ms-user-select', 'none');
      
      this._properties = this._mergeProperties({}, this._properties);
      
      this._styleSheets = [];
      this._styleManager = new StyleManager(this._styleSheets);
      this._eventManager = EventManager().UIComponent(this);

      var helpers = {
        styleManager : this._styleManager.child(undefined, undefined, "div"),
        eventManager : this._eventManager
      };
      
      var that = this;
      
      LOG.profiling("Engine:dom_builder_for_root_level");
      // start the initialization process, currently there is only root in _selections.
      this._selections = dombuilder(this._root, this._config.modules);
      LOG.profiling("Engine:dom_builder_for_root_level");
      
      //fix the bug: BITVIZ-1111 [reg][PI][all chart][JavaFx] when resize chart to small, chart is cut 
//      this._selections.root.style('position', 'absolute');
      //[Christy | 2013/5/2] BITVIZ-1276 [regression] Chart draw in wrong position when set 'text-align: center' in div
      this._selections.root.style('left', 0).style('top', 0).style('direction','ltr');

      if ((config.get("isCrossTable"))&& this._data.dataPointCount() > this._max_svg ) {
          this._component_status = CANVGSTATUS;
          this._selections.root.attr('visibility', 'hidden').style('left', 0).style('top', 0);
       }
      
      
      this._rootModules = (function (scope) {
        var modules = {};
        
        //FIXME remove hard code here. and the performance is OK for now as for most of the chart we only have one module in root level
        // initialize top level modules
        var modulesArray = [];
        for (var i in scope._config.modules) {
          if (scope._config.modules.hasOwnProperty(i)) {
            //The following is hard code, it is just for letting data transform module be the first in initialized chain of modules.
            if(i === 'dataTransform'){
              modulesArray.splice(0, 0, {'key' : i, 'module' : scope._config.modules[i] });
            }else{
              modulesArray.push({'key' : i, 'module' : scope._config.modules[i] });  
            }
          }
        }
        
        //root component wants to listen on 'initialized' event for each module (if they have) in root level
        scope._toBeInitializedModulesCount = 0;
        
        function internalListener(){
          scope._intializedListener.apply(scope);
        }
        
        $.each(modulesArray, function ( index, itr ) {
          var key = itr.key;
          var value = itr.module;
          LOG.profiling("Engine:create_module");
          var target = ignite(value.id, helpers, "v-m-"+key, scope._selections[key] ? scope._selections[key].node().nodeName : undefined);
          modules[key] = target;
          LOG.profiling("Engine:create_module");
          
          LOG.profiling("Engine:prepare_data");
          var data = value.data ? scope._data.createDataAdapterForModule(value.data) : scope._data;
          LOG.profiling("Engine:prepare_data");
          
          LOG.profiling("Engine:set_data");
          if(target.data){
            target.data(data);
          }
          LOG.profiling("Engine:set_data");
          
          //root component wants to listen on 'initialized' event for each module (if they have) in root level
          if(target.dispatch && target.dispatch()['initialized']){
            scope._toBeInitializedModulesCount++;
            target.dispatch().on(INITIALIZED_EVENT_NAME, internalListener);
          }
          
          modules[key].alias = key;
          
          // TODO add support for non-containers
          var props = {};
          if ( value.modules ) { // container indicator
            
            LOG.profiling("Engine:initialize_children_set_properties");
            if ( value.configure ) {
              props[value.configure.propertyCategory] = value.configure.properties;
            }
            
            if ( modules[key].container ) {
              modules[key].container(scope._root.node()); 
            }
            
            if ( modules[key].parent ) {
              modules[key].parent(scope._selections[key]);
            }
            
            modules[key].config(value)
              .properties(Objects.extend( true, {}, props, scope._properties ))
              .chartType(options.config.id)
              .recharge({ func : scope._wire, scope : scope });
            LOG.profiling("Engine:initialize_children_set_properties");
            
          } else {
            LOG.profiling("Engine:set_properties");
            var propertyCategory;
            if ( value.configure ) {
              propertyCategory = value.configure.propertyCategory;
              props[propertyCategory] = value.configure.properties;
            }
            modules[key].properties(Objects.extend( 
              true, 
              {}, 
              props, 
              scope._properties[propertyCategory] ));
            LOG.profiling("Engine:set_properties");
          }
        });

        return modules;
      })(this);
      
      LOG.profiling("Engine:flattern_modules");
      // flatten and extract sub module names
      var allModules = {};
      for ( var key in this._rootModules ) {
        if ( this._rootModules.hasOwnProperty(key)) {
          allModules = Objects.extend(true, {}, allModules, this._flatten(key, this._rootModules[key]));
        }
      }
      this._modules = allModules;
      LOG.profiling("Engine:flattern_modules");
      
      this._domposition(this.size());
    
     
      LOG.profiling("CSS:parse_css");
      this.css(options.css);
      LOG.profiling("CSS:parse_css");
      
      this._dispatch.on('initialized.exportToCanvas', function () {
        that._exportToCanvas.apply(that);
      });
      
      this._attachEvents(options);
    },
    
    doAfterShow : function(){
      this.render();
    },

    _intializedListener : function(){
      var targetCount = this._toBeInitializedModulesCount;
      targetCount--;
      if(targetCount === 0 /*&& this._attachedByFramework && !this._initializedEventDispatched*/){
        //Jimmy,3/25/2013, JS will run initialized callback immediately, however, we haven't
        //finished all work when code executing here. we will redispatch initialized event only
        //when framework is ready
        
        //Jimmy, see comments above, currently it's a workaround to use setTimeout
        var that = this;
        setTimeout(function(){
          that._dispatch.initialized();
        }, 0);        
        //this._initializedEventDispatched = true;
      }
    },
    
    _getRootLevelModules : function ( keys, modules ) {
      var allModules = {};
      for (var i = 0; i < keys.length; i++) {
        if (this._modules.hasOwnProperty(keys[i])) {
          allModules = Objects.extend(true, {}, allModules, this._flatten(keys[i], this._modules[keys[i]]));
        }
      }
      return allModules;
    },
    
    // flatten keys of the modules tree
    _flatten : function ( rootKey, rootNode, joiner ) {
      var token = joiner || '.', 
          ret = {},
          hierarchy = [ { key : rootKey, value : rootNode } ];
      
      // depth-first and exhaustively walk the tree
      (function walk ( parentKey, node ) {
        if (node.hasOwnProperty('modules')) {
          var children = node.modules(), 
              layer, 
              currentKey = parentKey;
          
          for ( var k in children ) {
            if ( children.hasOwnProperty(k) ) {
              layer = {
                key : parentKey + token + k,
                value : children[k]
              }; 
              hierarchy.push(layer);
              
              if ( children[k].modules ) {
                walk(currentKey + token + k, children[k]);
              }
            }
          }
        }
      })(rootKey, rootNode);
      
      for ( var i = 0; i < hierarchy.length; i++ ) {
        ret[hierarchy[i].key] = hierarchy[i].value;
      }
      
      return ret;
    },
    
    _attachEvents : function ( options ) {
      var events = options.events;
      
      for ( var obj in events ) {
        if ( events.hasOwnProperty(obj) ) {
          this.attachEvent(obj, events[obj].fn, events[obj].scope);
        }
      }
    },
    
    //event register strategy
    //0. first check the event on chart component,if find, only listen on controller
    //1. when modules A, B, C in the same level has this event type dispatch, register this event type on all modules.
    //2. If the module A contain other modules B, C and A, B, C all has this event type dispatch, only register event on this module.
    //3. Also there are event on chart controller, and the event name in chart controller should be unique.
    attachEvent : function ( evtType, callback, scope ) {
      var modules = this.modules(), hittedModules = {};
      var dispatch = this._dispatch;
      
      //we support optional namespace in evtType
      var i = evtType.indexOf(".");
      var typeToCheck = i > 0 ? evtType.substring(0, i) : evtType;
      
      //first check the event on chart controller
      //if find, only listen on component
      if ( dispatch[typeToCheck] ) {
        dispatch.on(evtType, function () {
          callback.apply(scope, arguments);
        });
        return;
      }
      
      for ( var m in modules ) {
        if ( modules.hasOwnProperty(m) ) {
          var slist = m.split('.'),  index = slist.length - 1;
          if ( modules[m].dispatch && modules[m].dispatch()[typeToCheck] ) {
            
            for ( var t = 0; t <= index; t++ ) {
              if ( hittedModules[t] && hittedModules[t][slist.slice(0, t).toString()] ) {
                break;
              }
            }
            //if t is larger than index, it means do not exist the parent modules has this event type dispatch.
            if ( t > index ) {
              if ( !hittedModules[slist.length] ) {
                hittedModules[slist.length] = {};
              }
              hittedModules[slist.length][slist.toString()] = modules[m];
              modules[m].dispatch().on(evtType, function(){
                callback.apply(scope, arguments);
              });
            }
          }
        }
      }
    },
    
    _getRootLevelKeys : function () {
      if ( this._rootKeys ) { return this._rootKeys; }
      this._rootKeys = [];
      for ( var key in this._modules ) {
        if ( this._modules.hasOwnProperty(key) && key.indexOf(DOT) < 0 ) {
          this._rootKeys.push(key);
        }
      }
      return this._rootKeys;
    },
    
    _getRootKey : function () {
      if ( this._rootKey ) { return this._rootKey; }
      var type;
      for ( var key in this._modules ) {
        if ( this._modules.hasOwnProperty(key)){
          type = Modules.get(this._config.modules[key].id).type;
          if(type !== registry.Type.Controller && type !== registry.Type.Behavior && key.indexOf('.') < 0) {
            return ( this._rootKey = key );
          }
        }  
      }
    },
    
    _getRootContainer : function () {
      if ( this._rootContainer ) { return this._rootContainer; } 
      for ( var key in this._config.modules ) {
        if ( this._config.modules.hasOwnProperty(key) && 
             Modules.get(this._config.modules[key].id).type === registry.Type.Container ) {
          return ( this._rootContainer = this._modules[key] );
        }
      }
    },
    
    _domposition : function (newSize) {
      //Jimmy/1/28/2013 layout root container, in the core level, we only allow one drawing element (does it have to be a container?)
      //so we give all size to it, we will resize when the actual size being changed from framework
      var rootKey = this._getRootKey();
      var allSizeLayout = {};
      //do we need an extra layout module for this to accept padding/margin properties?
      allSizeLayout[rootKey] = {
        'x' : 0,
        'y' : 0,
        'width' : newSize.width,
        'height' : newSize.height
      };
      domposition(allSizeLayout, this._selections);
    },

    _doLayout : function ( newSize ) {
      this._domposition(newSize);
      this._getRootContainer().size(newSize);
    },
    
    _updateProperties : function () {
      this._properties = this._mergeProperties(this._properties);
      
      var conf = this._config.modules;
      for ( var key in conf ) {
        if ( conf.hasOwnProperty(key) ) {
          if ( Modules.get(conf[key].id).type === registry.Type.Container ) {
            this._modules[key].properties(this._properties);
            continue;
          }
          if ( conf[key].configure && conf[key].configure.propertyCategory ) {
            this._modules[key].properties(
              this._properties[conf[key].configure.propertyCategory]);
          }
        }
      }
    },
    
    _mergeProperties : function ( xs, xs1 ) {
      var ret = {};
      ret = Objects.extend(true, {}, xs, xs1);
      return this._mergeCanvgProperties(ret) || ret;
    },
    
    _mergeCanvgProperties : function (xs) {
      if ( canvgConf.enableCanvg() && (config.get("isCrossTable"))&&  this._data.dataPointCount() >= this._max_svg ) {
        var ret = {};
        // FIXME 
        // Currently, property category is missing from GEO charts 
        // by invoking this._config.getChartPropCate(). So plotArea is used to
        // mark CanVG properties instead. 
        ret['plotArea'] = {
          animation: { dataLoading: false, dataUpdating: false }
        };
        return Objects.extend( true, {}, xs, ret );
      }
    },
    
    render : function () {
      if ( (config.get("isCrossTable")) &&this._data.emptyDataset() ) { return; } // TODO support empty data set in module level
      
      LOG.profiling("Render:layout");
      this._doLayout(this.size());
      LOG.profiling("Render:layout");
      
      LOG.profiling("Render:drawing");
      this._paint();
      LOG.profiling("Render:drawing");
    },
    
    _localeChanged : function () {
      // update the data of modules to let the module have change to make up locale string again.
      this._getRootContainer().data(this._data);
      this._updateProperties();
      this.render();
    },

    properties : function (xs) {
      if ( !arguments.length ) { 
        return extractProperties(this._modules, this._config.id);
      }
      this._properties = this._mergeProperties(this._properties, xs);

      var conf = this._config.modules;
      for ( var key in conf ) {
        if ( conf.hasOwnProperty(key) ) {
          if ( Modules.get(conf[key].id).type === registry.Type.Container ) {
            this._modules[key].properties(this._properties);
          } else {
            if ( !conf[key].configure ) { continue; }
            this._modules[key].properties(
              this._properties[conf[key].configure.propertyCategory]);
          }
        }
      }
      //Alex Su: we may also need to update sub module path when numberOfDimsInColumn is changed
//      this._modules = this._flatten(this._getRootKey(), this._getRootContainer());
      this._modules = this._getRootLevelModules(this._getRootLevelKeys(), this._modules);
    },
       
    css : function( cssText ) {
      if ( cssText === undefined ) {
        var str = "";
        this._styleSheets.forEach(function( sheet ) {
          str += sheet.source;
        });

        return str;
      }

      if ( cssText ) {
        var sheet = new StyleSheet(cssText, this._id);
        this._styleManager.applyCSS(sheet);
        this._styleSheets.push(sheet);
      }
    },

    getSelectedObjects : function(withDataCtx, withInfo) {
      var key;
      var modules = this._modules;
      for(key in modules)
      {
          if(modules.hasOwnProperty(key))
          {
              if(modules[key].getSelectedObjects)
              {
                  break;
              }
          }
      }

      var mainPlot = modules[key];
      return mainPlot.getSelectedObjects(this._data, withDataCtx, withInfo);
    },
    
    setSelectedObjects : function(items, clearFlag) {
      var key;
      var modules = this._modules;
      for(key in modules)
      {
          if(modules.hasOwnProperty(key))
          {
              if(modules[key].setSelectedObjects)
              {
                  break;
              }
          }
      }

      var mainPlot = modules[key];
      return mainPlot.setSelectedObjects(this._data, items, clearFlag);
    },
    
    getAllFeedingZone : function() {
        return FeedingZoneUtil.parse(this._config.id, this._selections['root']);
    },
    
    data : function (_) {
      if ( !arguments.length ) { return this._data; }
      
      this._data = _;
     
      // Hard cord: data transform module needs to refresh data
      if (this._modules.hasOwnProperty('datatransform')) {
        this._modules['datatransform'].data(this._data);
      }
      
      //currenty, we should update properties when reset dataset. As when change the component mode from svg to canvg, we should disable all animation
      this._updateProperties();
      
     
    //switch canvg mode to svg mode when change the size of dataset
      var isCanvgMode = (config.get("isCrossTable"))&&(this._data.dataPointCount() >= this._max_svg ) && canvgConf.enableCanvg();

      if( ! ( this._component_status === 'svg' && !isCanvgMode ) ){
        this._canvas.node().getContext('2d').clearRect(0, 0, this._canvas.node().width, this._canvas.node().height);
        this._canvas.style('width', 0), this._canvas.style('height', 0);
        this._canvas.attr('width', 0), this._canvas.attr('height', 0);

        if ( isCanvgMode ) {
          this._component_status = 'canvg';
          this._selections[this._getRootKey()].attr('visibility', 'hidden').style('left', 0).style('top', 0);
        } else {
          this._component_status = 'svg';
          this._selections[this._getRootKey()].attr('visibility', 'visible');
        }
      }
      
      // refresh data
      this._getRootContainer().data(this._data);
      this._getRootContainer().refresh();
      
      // after we reset data, we need update submodules as they may
      // have changed during data update
      // TODO a potential optimization here: if we split data update and schema data updata
      // we can skip module update when only data has been updated
      //this._modules = this._flatten(this._getRootKey(), this._getRootContainer());
      this._modules = this._getRootLevelModules(this._getRootLevelKeys(), this._modules);
    },
    
    modules : function () { return this._modules; },
    
    // Callback invoked by platform upon the occurrence of a resizing event.
    doContentResize : function ( oldSize, newSize ) {
      this._super('doContentResize', oldSize, newSize);
      this.render();
    },
    
    _expandDependencyDefs : function ( item ) {
      var defs = [];
      var sourceModule = item[SOURCEMODULE];
      var targetModule = item[TARGETMODULE];
      var expandedSourceModules = this._expandModulePath(sourceModule);
      var expandedTargetModules = this._expandModulePath(targetModule);
      if ( expandedSourceModules.length > 1 && expandedTargetModules.length > 1 ) {
        if ( expandedSourceModules.length !== expandedTargetModules.length ) {
          Functions.error('Error on resolving dependency:' + sourceModule + ',' + targetModule);
        } else {
          for ( var i = 0, len = expandedSourceModules.length; i < len; i++ ) {
            defs.push({
              'sourceModule' : expandedSourceModules[i],
              'targetModule' : expandedTargetModules[i],
              'source' : item['source'],
              'target' : item['target'],
              'type' : item['type'],
              'listener' : item['listener']
            });
          }
        }
      } else {
        //we are sure that one of the loop will execute only once, and we don't care which one
        for ( var n = 0, nlen = expandedSourceModules.length; n < nlen; n++ ) {
          for ( var j = 0, jlen = expandedTargetModules.length; j < jlen; j++ ) {
            defs.push({
              'sourceModule' : expandedSourceModules[n],
              'targetModule' : expandedTargetModules[j],
              'source' : item['source'],
              'target' : item['target'],
              'type' : item['type'],
              'listener' : item['listener']
            });
          }
        }
      }
      
      //FIXME jimmy/8/8/2012 if both sourceModule and targetModule have
      //been expanded, and they have different number of items, what should
      //we do? do cartesian product? currently we simply throw exception
      return defs;
    },
    
    //nodeN.nodeN-1.nodeN-2...node1, for each nodeN,
    //if we have several entities for it, we should expand it
    _expandModulePath : function ( path ) {
      var pathArray = path.split('.');
      var currentPrefix = [];
      var currentExpand = [];
      for ( var i = 0, len = pathArray.length; i < len; i++ ) {
        var j = 0, jlen = currentPrefix.length;
        do {
          var pathI = jlen > 0 ? [currentPrefix[j], pathArray[i]].join('.') : pathArray[i];
          if ( TypeUtils.isArray(this._modules[pathI]) ) {
            //we have to expand this, and we may have undefined items in the array
            for ( var k = 0, klen = this._modules[pathI].length; k < klen; k++ ) {
              if ( this._modules[pathI][k] ) {
                var newPrefix = jlen > 0 ? [currentPrefix[j], pathArray[i] + '[' + k + ']'].join('.') : pathArray[i] + '[' + k + ']';
                currentExpand.push(newPrefix);
              }
            }
          } else {
            // put it in directly
            currentExpand.push(pathI);
          }
          j++;
        } while ( j < jlen );
        
        var refTemp = currentPrefix;
        currentPrefix = [].concat(currentExpand);
        currentExpand.length = 0;
        refTemp.length = 0;
      }
      return currentPrefix;  
    },

    _expandModules : function () {
      var modules = this._modules;
      var result = [];
      for ( var p in modules ) {
        if ( modules.hasOwnProperty(p) ) { 
          var m = modules[p];
          if ( TypeUtils.isArray(m) ) {
            for ( var i = 0; i < m.length; i++ ) {
              result[p + '[' + i + ']'] = m[i];
            }
          } else {
            result[p] = m; 
          }
        }
      }
        
      return result;
    },
    
    _unwireEvents : function() {
      var dependencies = this._config.dependencies, item, i;
      var events = dependencies ? (dependencies.events || []) : [];
      var expandedDefs, expandedDef;
      var modules = this._expandModules();
      
      // Resolve events.
      for ( i = 0; i < events.length; i++ ) {
        item = events[i];
        expandedDefs = this._expandDependencyDefs(item);
        for(var n = 0, nlen = expandedDefs.length; n < nlen; n++) {
          expandedDef = expandedDefs[n];
          if ( modules[ expandedDef[TARGETMODULE] ] && modules[ expandedDef[SOURCEMODULE] ] ) {
            if ( typeof modules[ expandedDef[TARGETMODULE] ][ expandedDef['listener'] ] === 'function' &&
                 typeof modules[ expandedDef[SOURCEMODULE] ] === 'function' ) {
                   if(typeof modules[ expandedDef[SOURCEMODULE] ].dispatch === 'function'){
                      modules[ expandedDef[SOURCEMODULE] ].dispatch().on(expandedDef['type'] + '.' + expandedDef[TARGETMODULE] + '.' + n, null);
                   }
            }
          }
        }
      }
    },
    
    // Configures various kinds of module dependencies.
    _wire : function () {
      var dependencies = this._config.dependencies, item, i;
      var attrs = dependencies ? (dependencies.attributes || [] ) : [],
          events = dependencies ? (dependencies.events || []) : [];
      
      var expandedDefs, expandedDef;
      
      // Resolve attributes.
      /*
     * [jimmy/8/8/2012]each node in the path may have several entities
     * like main.plot, we may create several main.plots
     * (here the xycontainer), by using 'main.plot.xAxis'
     * here we actually means for xAxis in each main.plot
     * 
     * in the future, we may need support more complicated dependency resolving
     * like 'the 3rd xycontainer's xAxis', can be described
     * as main.plot[2].xAxis
     */
      var modules = this._expandModules();
      
      for ( i = 0; i < attrs.length; i++ ) {
        item = attrs[i];
        if( item === null ){
          continue;
        }
        expandedDefs = this._expandDependencyDefs(item);
        for(var j = 0, jlen = expandedDefs.length; j < jlen; j++) {
          expandedDef = expandedDefs[j];
          if ( modules[ expandedDef[SOURCEMODULE] ] && modules[ expandedDef[TARGETMODULE] ] ) {
            if ( typeof modules[ expandedDef[SOURCEMODULE] ][ expandedDef['source'] ] === 'function' &&
                 typeof modules[ expandedDef[TARGETMODULE] ][ expandedDef['target'] ] === 'function' ) {
              modules[ expandedDef[TARGETMODULE] ][ expandedDef['target'] ]( 
                modules[ expandedDef[SOURCEMODULE]][ expandedDef['source']]() );
            } else {
              Functions.error('dependency configuration error');
            }
          } else {
            Functions.error('dependency configuration error');
          }
        }
      }
      
      // Resolve events.
      for ( i = 0; i < events.length; i++ ) {
        item = events[i];
        expandedDefs = this._expandDependencyDefs(item);
        for(var n = 0, nlen = expandedDefs.length; n < nlen; n++) {
          expandedDef = expandedDefs[n];
          if ( modules[ expandedDef[TARGETMODULE] ] && modules[ expandedDef[SOURCEMODULE] ] ) {
            if ( typeof modules[ expandedDef[TARGETMODULE] ][ expandedDef['listener'] ] === 'function' &&
                 typeof modules[ expandedDef[SOURCEMODULE] ] === 'function' ) {
                   if(typeof modules[ expandedDef[SOURCEMODULE] ].dispatch === 'function'){
                      modules[ expandedDef[SOURCEMODULE] ].dispatch().on(expandedDef['type'] + '.' + expandedDef[TARGETMODULE] + '.' + n, 
                        modules[ expandedDef[TARGETMODULE] ][ expandedDef['listener'] ]);
                   } else {
                     Functions.error('dependency configuration error:' + expandedDef[SOURCEMODULE] + ' does not support event!');
                   }
            } else {
              Functions.error('dependency configuration error');
            }
          } else {
            Functions.error('dependency configuration error: source or target does not exist!');
          }
        }
      }
    },
    
    // starting point of invoking the chain of painting logic
    _paint : function () {
      this._selections[this._getRootKey()].call(this._getRootContainer());
      //FIXME Jimmy, 3/25/2013 currently we don't call modules in the root level, such as datatransform
      //we may need do it in the future.
    },
    
    // Merge Ian Li's fix to make canvg waiting for chart modules' initialized event
    _exportToCanvas: function(){
      if ( canvgConf.enableCanvg() && this._component_status === CANVGSTATUS ) {
          d3.select(this.container).selectAll('title').remove();
          if ( canvg ) {
              var node = this._selections[this._getRootKey()].node().cloneNode(true);
              node.setAttribute('visibility', 'visible');
              
              canvg(this._canvas.node(), $('<div></div>').append(node).html(), { ignoreMouse: true, ignoreAnimation: true });
              
              if ((config.get("isCrossTable"))&& this._data.dataPointCount() > this._max_canvas ) {
                this._dispatch.dataTruncation();
              }
          }
        }
    },
    
    /**
     * Loops over events configuration of each module
     * and return the events TypeUtils.
     * 
     * @function
     * @returns {Array} Array of supported event TypeUtils
     */
    getSupportedEvents : function () {
      var events = [];
      var modules = this._config.modules;
      
      function getEventDefs( modules ) {
        for ( var m in modules ) {
          if ( modules.hasOwnProperty(m) ) {
            if(!modules[m]) {
                continue;
            }
              
            var module = manifest.module.get(modules[m].id);
            if ( module && module.events ) {
              events.push({
                sourceId : modules[m].id,
                source : {},
                evtTypes : module.events
              });
            }
            // Continue searching for composite module like a container
            if ( modules[m].modules ) {
                getEventDefs(modules[m].modules);
            } 
          }
        }
      }
      getEventDefs(modules);
      return events;
    },
    
    doDestroy : function(){
      //self destroy
      this._root = null;
      this._canvas = null;
      this._selections = null;
      //unwire events
      this._unwireEvents();
      this._eventManager.destroy();
      //this event listener holds a reference to this
      //we have to remove the listener
      this._dispatch.on('initialized.exportToCanvas', null);
      //unregister events listener on root modules
      var rootModules = this._rootModules;
      var key;
      for(key in rootModules){
        if(rootModules.hasOwnProperty(key)){
           var target = rootModules[key];
           if(target.dispatch && target.dispatch()['initialized']){
             target.dispatch().on(INITIALIZED_EVENT_NAME, null);
           }
        }
      }
      
      //global single instance destroy
      TextUtils.destroy();
      
      var modules = this._modules;
      for(key in modules){
        if(modules.hasOwnProperty(key)){
          var destroyFn = modules[key].destroy;
          if(destroyFn){
            destroyFn();
          }          
        }
      }
      
      langManager.removeListener(this._i18nListener);
      this._i18nListener = null;
      this.detach();
      this._styleSheets.forEach(function(sheet){
        sheet.destroy();
      });
    }
  });
  return ChartComponent;
});

define('sap/viz/chart/mvc/ChartController',['sap/viz/base/utils/FunctionUtils','sap/viz/mvc/UIController',
'sap/viz/manifest', 'sap/viz/chart/mvc/ChartComponent'], 
function(Functions, UIController, manifest, ChartComponent){
  /* Represents the chart controller. */
  var ChartController = UIController.extend({
    RootComponentClass : ChartComponent,
    
    _parseOptions : function ( options ) {
      if ( !manifest.viz.get(options.vizType) ) {
        Functions.error('Invalid vizType');  
      } 
      this._dataset = options.dataset ? options.dataset : {};
      this._options = options.option;
      this._vizType = options.vizType;
      this._dataFeeding = options.feeding;
      this._css = options.css;
      this._events = options.events;
    },
    
    initUIComponent : function ( options ) {
        this._parseOptions(options);
        var config = manifest.viz.get(this._vizType);
        this.rootUIComponent.initialize({
          data : this._dataset,
          dataFeeding : this._dataFeeding,
          config : config,
          options : this._options,
          clipToBound : true,
          css : this._css,
          events : this._events
        });
      },

    getSelectedObjects : function (withDataCtx, withInfo) {
        return this.rootUIComponent.getSelectedObjects (withDataCtx, withInfo);
    },

    setSelectedObjects : function (items, clearFlag) {
        return this.rootUIComponent.setSelectedObjects (items, clearFlag);
    },
    
    getAllFeedingZone : function() {
        return this.rootUIComponent.getAllFeedingZone();
    },
        
    getSupportedEvents : function () {
        return this.rootUIComponent.getSupportedEvents();
    },
    
    setDataset : function ( dataset ) {
        this.rootUIComponent.data(dataset);
    },
    
    doThemeChanged : function(){
        this.rootUIComponent.themeChanged();
    },
    
    updateProperties : function (props) {
        this.rootUIComponent.properties(props);
    },
    
    getProperties : function() {
        return this.rootUIComponent.properties();
    },
    
    css : function () {
        return this.rootUIComponent.css.apply(this.rootUIComponent, arguments);
    },
    
    render : function(){
        this.rootUIComponent.render();
    }
    
  });
  return ChartController;
});

define('sap/viz/feeds/Manifest',['sap/viz/manifest','sap/viz/base/utils/ObjectUtils','sap/viz/lang/langManager'],
function Setup(manifest, ObjectUtils, langManager) {
  /**
   * This is a instantce , which already have been registered into {@link sap.viz.manifest.feeds}.</br>
   * </br>
   * Now, once an item is loaded from {@link sap.viz.manifest.feeds}, it will automatically provide some APIs .</br>
   * </br>
   * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead.
   * @see sap.viz.manifest.feeds#get
   * @class Built-in_Manifest_Objects.feedsManifest
   * @example <caption>Sample Code:</caption>
   * var pieFeed = manifest.feeds.get(pieId);
   */
  return manifest.registerCategory("feeds", function(obj) {

    var feeds = {};
    obj.feeds.forEach(function(o) {
      feeds[o.id] = o;
      var na = o.name;
      delete o.name;
      Object.defineProperty(o, 'name', {
        get : function() {
          var res = langManager.get(na);
          if (res) {
            return res;
          }
          return na;
        },
        enumerable : true
      });
    });
    /**
     * This is a instantce , which already have been registered into {@link sap.viz.manifest.feeds}.</br>
     * </br>
     * Now, once an item is loaded from {@link sap.viz.manifest.feeds}, it will automatically provide some APIs .</br>
     * </br>
     * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead.
     * @see sap.viz.manifest.feeds#get
     * @class Built-in_Manifest_Objects.feedsManifest
     * @example <caption>Sample Code:</caption>
     * var pieFeed = manifest.feeds.get(pieId);
     * @ignore
     */
    Object.defineProperty(obj, "feedsMap", {
      value : feeds,
      writable : false,
      enumerable : false,
      configurable : false
    });

    return obj;
  });
});
define('sap/viz/data/feed/Constants',[],
function Setup() {
  var feed = {
    Type : {
      Dimension : "Dimension",
      Measure : "Measure"
    },
    Constraints : {
      INF : Number.POSITIVE_INFINITY
    }
  };
  return feed;
});
define('sap/viz/manifests/Viz',['sap/viz/manifest','sap/viz/feeds/Manifest','sap/viz/base/utils/ObjectUtils','sap/viz/base/utils/TypeUtils',
'sap/viz/base/utils/Objects','sap/viz/data/feed/Constants','sap/viz/modules/manifests/Module',
'sap/viz/lang/langManager'],
function Setup(manifest, feedsManifest, ObjectUtils, TypeUtils, Objects, constants, module,
    langManager) {
  function getModuleByType(modules, type) {
    for ( var i = 0; i < modules.length; ++i) {
      if (modules[i].module.type === type) {
        return modules[i];
      }
      if (modules[i].subModules) {
        var r = getModuleByType(modules[i].subModules, type);
        if (r) {
            return r;    
        }
          
      }
    }
    return null;
  }
  function overrideProperties (target, overProps){
    if(!overProps){
      return;
    }
    var tempPropName, tempPropObj;
    for(tempPropName in target){
      if(target.hasOwnProperty(tempPropName) && overProps.hasOwnProperty(tempPropName)){
        tempPropObj = target[tempPropName];
        if(tempPropObj.supportedValueType === 'Object'){
          overrideProperties(tempPropObj.supportedValues, overProps[tempPropName]);
        }else{
          tempPropObj.defaultValue = overProps[tempPropName];
        }
      }
    }
  }
  function filterProperties (target, filterInfo){
    var tempPropName, tempPropObj;
    for(tempPropName in target){
      if(target.hasOwnProperty(tempPropName)){
        if (target[tempPropName] === null){
          delete target[tempPropName];
          continue;
        }
        tempPropObj = target[tempPropName];
        /*[Jimmy/11/15/2012]what if we override supportedValueType in the propertyOverride?
         currently we don't know how to deal with it.
         * */
        if(filterInfo){
          Objects.extend(true, tempPropObj, filterInfo[tempPropName]);
        }
        if(tempPropObj.isExported === false){
          delete target[tempPropName];
        }else{
          if(tempPropObj.supportedValueType === 'Object'){
            filterProperties(tempPropObj.supportedValues, filterInfo ? filterInfo[tempPropName] : null);
            //if its type is object and with no children, we just delete it
            if(TypeUtils.isEmptyObject(tempPropObj.supportedValues)){
              delete target[tempPropName];
            } 
          } 
        }
      }
    }
  }
  function loadProperties(allProperties, modules) {
    if(modules){
      //3 properties we need take care of
      //propertyCategory, properties and propertiesOverride
      var mProps/*original module properties*/, 
          mcProps/*properties defined in chart manifest, aka module reference*/,
          moProps/*properties definition override in chart manifest, aka propertiesOverride*/,
          propCate/*property category*/,
          mRef/*module reference name in chart config*/;
      modules.forEach(function(o){//@Alex Su: configure module if module has one.
        if (o.config.configure){
          mRef = o.moduleRef;
          mProps = o.module.properties;
          mcProps = o.config.configure.properties;
          propCate = o.config.configure.propertyCategory;
          moProps = o.config.configure.propertiesOverride;
          allProperties[propCate] = Objects.extend(true, null, mProps);
          //we add a new meta data info here to indicate the reference path in chart configure of each property category        
          Object.defineProperties(allProperties[propCate], { 
            'moduleRefPath':{            
              get : (function(_refName) {
                return function() {
                  return _refName;
                };
              }(mRef)),
              enumerable : false
            }  
          });
          //filter out isExported=false, it can come from moProps or mProps
          filterProperties(allProperties[propCate], moProps);
          //override default values which come from mcProps
          overrideProperties(allProperties[propCate], mcProps);
        }
        loadProperties(allProperties, o.subModules);
      });
    }
  }

  function loadFeeds(allFeeds, modules, aaIndexOffset, mndProOffset) {
    if (modules) {
      modules.forEach(function(o) {
        var feeds = o.module.feeds;
        var newAAIndexOffset = aaIndexOffset;
        var newMNDProOffset = mndProOffset;
        if (feeds) {
          var moduleFeeds;
          var feedsId = feeds.id;
          if (feedsId !== undefined) {
            var feedsConfigure = feeds.configure;
            moduleFeeds = feedsManifest.get(feedsId).feedsMap;
            if (feedsConfigure) { 
              moduleFeeds = ObjectUtils.extend(true, null, moduleFeeds,
                  feedsConfigure);
              }
          } else {
            moduleFeeds = {};
            feeds.forEach(function(feed) {
              moduleFeeds[feed.id] = feed;
            });
          }
     
          var i;
          for (i in moduleFeeds) {
            if(moduleFeeds.hasOwnProperty(i)){
              var feed = moduleFeeds[i];
              if (feed) {
                feed = ObjectUtils.extend(true, null, feed);
                allFeeds[i] = feed;
                if (feed.type === constants.Type.Dimension) {
                  var aaIndex = feed.aaIndex;
                  aaIndex += aaIndexOffset;
                  if (newAAIndexOffset < aaIndex) {
                      newAAIndexOffset = aaIndex;
                  }
                   
                  feed.aaIndex = aaIndex;
  
                  var mndPro = feed.acceptMND;
                  if (mndPro >= 0) {
                    if (mndProOffset > 0) {
                      mndPro += mndProOffset;  
                    }
                      
  
                    if (newMNDProOffset < mndPro) {
                      newMNDProOffset = mndPro;
                      }
  
                    feed.acceptMND = mndPro;
                  }
                }
              }
            }
          }
          if (newMNDProOffset >= 0) {
              newMNDProOffset += 1;
          }
            

        }
        loadFeeds(allFeeds, o.subModules, newAAIndexOffset, newMNDProOffset);
      });
    }
  }
  /**
     * This is a instantce , which already have been registered into {@link sap.viz.manifest.viz}.</br>
     * </br>
     * Now, once an item is loaded from {@link sap.viz.manifest.viz}, it will automatically provide some APIs .</br>
     * </br>
     * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead. You can use sap.viz.api.manifest.Viz instead.
     * @example <caption>Sample Code:</caption>
     * var allFeedOfBar = manifest.viz.get(barType).allFeeds();
     * @see sap.viz.manifest.viz#get
     * @class Built-in_Manifest_Objects.vizManifest
     */
  return manifest
      .registerCategory(
          "viz",
          function(obj) {
            var modules =[];
            var configModules = obj.modules;
            for ( var moduleRefName in configModules) {
              if(configModules.hasOwnProperty(moduleRefName)){
                var moduleRef = configModules[moduleRefName];
                if (moduleRef !== null) {
                  manifest.module.loadModule(modules, moduleRef, moduleRefName);
                }
              }
            }
            var chartPropCategory = "";
            var moduleType = getModuleByType(modules, 'CHART');
            if (moduleType && moduleType.config.configure){
              chartPropCategory = moduleType.config.configure.propertyCategory;
            }
            var feedsConfigure = obj.feeds;
            var allFeeds, allRequiredFeeds, vizname = obj.name;
            var allProperties;
            delete obj.name;
            Object
                .defineProperties(
                    obj,
                    {
                      /**
                         * get the feeds definition of an item in {@link sap.viz.manifest.viz}
                         * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead.
                         * @method Built-in_Manifest_Objects.vizManifest#allFeeds
                         * @return {[Object] allFeeds} all feeds definition of an item
                         * @example <caption>Sample Code:</caption>
                         * var allFeedOfBar = sap.viz.manifest.viz.get('viz/bar').allFeeds();
                         */
                      allFeeds : {
                        value : function() {
                          if (!allFeeds) {
                            allFeeds = {};
                            loadFeeds(allFeeds, modules, 0, -1);
                            ObjectUtils.extend(true, allFeeds, feedsConfigure);
                            allFeeds = d3.values(allFeeds).filter(function(o) {
                              return o;
                            });
                          }

                          //Data Handler needs to know full feed definition including useless feed for data dispatching
                          var includeUselessFeed = !arguments.length || arguments[0] === false ? false : true;
                          if (includeUselessFeed === false){
                              if (!allRequiredFeeds){
                                  allRequiredFeeds = d3.values(allFeeds).filter(function(o) {
                                  if (o.min === 0 && o.max === 0){
                                      return false;
                                  }else {
                                      return true;
                                  }
                                  
                                  });
                              }
                              return allRequiredFeeds;
                          }else{
                              return allFeeds;
                          }
       
                        },
                        enumerable : true
                      },
                      /**
                         * get all properties definition of an item in {@link sap.viz.manifest.viz}
                         * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead.
                         * @method Built-in_Manifest_Objects.vizManifest#allProperties
                         * @return {[Object] allProperties} all properties definition of an item
                         * @example <caption>Sample Code:</caption>
                         * var allPropertiesOfBarChart = sap.viz.manifest.viz.get('viz/bar').allProperties();
                         */
                      allProperties : {
                        /*we will go through all modules and merge their property definitions with properties override in chart manifest,
                         and return. note all the properties with isExport=false will be filtered out*/
                        value : function() {
                          if(!allProperties) {
                            allProperties = {};
                            loadProperties(allProperties, modules);
                          }
                          return allProperties;
                        },
                        enumerable : true  
                      },
                      getChartPropCate : {
                        value : function() {
                          return chartPropCategory;
                        },
                        enumerable : true
                      },
                      /**
                       * get the name of the visualization
                       * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead.
                       * @property {String}  Built-in_Manifest_Objects.vizManifest#name
                       * @example <caption>Sample Code:</caption>
                       * var name = sap.viz.manifest.viz.get('viz/bar').name
                       */
                      name : {
                        get : function() {
                          var res = langManager.get(vizname);
                          if (res) {
                              return res;
                          }
                           
                          return vizname;
                        },
                        enumerable : true
                      }
                    });
            return obj;
          });
});
define('sap/viz/base/utils/oo',[], function() {
  var oo = {};

  oo.extend = function(subClz, superClz) {
    var subClzPrototype = subClz.prototype;

    // add the superclass prototype to the subclass definition
    subClz.superclass = superClz.prototype;

    // copy prototype
    var F = function() {};
    F.prototype = superClz.prototype;

    subClz.prototype = new F();
    for (var prop in subClzPrototype) {
      if (subClzPrototype.hasOwnProperty(prop)) {
        subClz.prototype[prop] = subClzPrototype[prop];
      }
    }
    subClz.prototype.constructor = subClz;
    if (superClz.prototype.constructor === Object.prototype.constructor) {
      superClz.prototype.constructor = superClz;
    }
    return subClz;
  };

  return oo;
});

define('sap/viz/modules/Base',[], function(){
  var base = function(){
  };
  
  //a temp flag used to distinguish new and old module style in manifest
  base.prototype.__new_style__ = true;
  
  return base;
  
});

define('sap/viz/modules/dispatch',[],
function Setup() {
  return d3.dispatch;
});
define('sap/viz/modules/util/BoundUtil',[],
function Setup() 
{
  var classname = 'v-bound';
  var BoundUtil = {
      drawBound : function(selection, width, height, css){
          var rect ;
          if(selection.select('.' + classname).node() == null){
              rect = selection.insert('rect', ':first-child').attr('class', classname).attr('width', width).attr('height', height).attr('visibility', 'hidden');
          }else{
              rect = selection.select('.' + classname).attr('width', width).attr('height', height);
          }
          
          if (css) {
            for( var i in css){
                rect.attr(i, css[i]);
            }
          }
      }

  };
  
  return BoundUtil;
});
define('sap/viz/modules/background',['sap/viz/modules/Constants','sap/viz/base/utils/ObjectUtils','sap/viz/modules/dispatch','sap/viz/base/utils/Objects','sap/viz/modules/util/BoundUtil'],
function Setup(ModuleConstants, ObjectUtils, dispatch, Objects, BoundUtil) {
  return function(manifest, ctx) {
 
     var CSSCLASS_BORDER = 'v-background-border',
         CSSCLASS_BORDER_2 = 'viz-plot-background-border',
         CSSCLASS_BODY = 'v-background-body',
         CSSCLASS_BODY_2 = 'viz-plot-background',
         CSSCLASS_MORPHABLEBACKGROUND = ModuleConstants.CSS.CLASS.MORPHABLEBACKGROUND;

    var randomSuffix = ObjectUtils.guid();
    var width = 0, 
      height = 0;
    var effectManager = ctx.effectManager,
      properties,
      d3root;
    var eDispatch = new dispatch('initialized');
    
    function background(selection) {
      d3root = selection;
      //BoundUtil.drawBound(selection, width, height); //background module should not need to use bound rect
      
      if (properties.visible) {
        getCSSStyle();

        var d3rect = d3root.select('#' + 'background-rect-' + randomSuffix);
        if (d3rect.empty()) {
          d3rect = d3root.append('svg:rect').attr('class', CSSCLASS_BODY + ' ' + CSSCLASS_BODY_2 + ' ' + CSSCLASS_MORPHABLEBACKGROUND).attr('id', 'background-rect-' + randomSuffix);
        }
        var fillID = effectManager.register({
          graphType : 'background',
          fillColor : properties.style.body.fill,
          drawingEffect : properties.drawingEffect,
          direction : properties.direction
        });
        d3rect.attr('x', 0).attr('y', 0).attr('width', width).attr('height', height).attr('style', "fill:" + fillID);
        
        var borderData = [];
        if (properties.border.left.visible) {
          borderData.push({
            x1: 0, y1: 0, x2: 0, y2: height
          });
        }
        if (properties.border.right.visible) {
          borderData.push({
            x1: width, y1: 0, x2: width, y2: height
          });
        }
        if (properties.border.top.visible) {
          borderData.push({
            x1: 0, y1: 0, x2: width, y2: 0
          });
        }
        if (properties.border.bottom.visible) {
          borderData.push({
            x1: 0, y1: height, x2: width, y2: height
          });
        }
        
        var d3border = selection.selectAll("." + CSSCLASS_BORDER).data(borderData);
        d3border.enter().append('svg:line').attr('class', CSSCLASS_BORDER + ' ' + CSSCLASS_BORDER_2);
        d3border.exit().remove();
        d3border.attr('x1', function(d){return d.x1;}).attr('y1', function(d){return d.y1;})
          .attr('x2', function(d){return d.x2;}).attr('y2', function(d){return d.y2;});
        // now we use attribute in dom element to let customer css file work.
        d3border.each(function(d){
            d3.select(this).attr('shape-rendering' , 'crispEdges');
            for (var key in properties.style.border) {
              if (properties.style.border.hasOwnProperty(key)) {
                d3.select(this).attr(key, properties.style.border[key]);
              }
            }
        });
      } else {
        var temp = d3root.node();
        while(temp.hasChildNodes()) {
            temp.removeChild(temp.firstChild);
        }
      }
      
      //currently, we do not have animation. If it has, should fire initialized event after animation complete.
      eDispatch.initialized();
      
      return background;
    }
    
    background.properties = function(_){
      if (!arguments.length){
        return properties;
       }
      Objects.extend(true, properties, _);
      return background;
    };
    background.size = function(_size) {
      if (arguments.length === 0) {
        return {
            "width" : width,
            "height": height
        };
      }
      width = _size.width;
      height = _size.height;
      return background;
    };
    background.width = function(_width) {
      if (arguments.length === 0) {
        return width;
      }
      width = _width;
      return background;
    };
    background.height = function(_height) {
      if (arguments.length === 0) {
        return height;
      }
      height = _height;
      return background;
    };
    background.data = function(_) {
      if(!arguments.length) {
        return {};
      }
      return background;
    };
    background.parent = function() {
      return null;
    };

    background.dispatch = function(_){
      if(!arguments.length) {
        return eDispatch;
      }
      eDispatch = _;
      return background;
    };
    
    background.destroy = function() {
      d3root = null;
      //destroy ctx
      if(ctx){
        ctx.destroy();
        ctx = null;
      }
    };
    
    function getCSSStyle() {
      if (!properties.style) {
        properties.style = {};
      }
      properties.style.body = ctx.styleManager.query(CSSCLASS_BODY);
      if (!properties.style.border) {
        properties.style.border = ctx.styleManager.queryDefault(CSSCLASS_BORDER);
      }
    }

    properties = manifest.props(null);
    return background;

  };
});
define('sap/viz/modules/util/BackgroundUtil',['sap/viz/modules/manifests/Module','sap/viz/util/ignite','sap/viz/modules/background'],
function Setup(ModuleManifest, ignite) 
{
  var CLASSNAME = 'v-backgroundutil';
  var BackgroundUtil = {
      drawBackground : function(selection, backgroundModule, props ){
        var d3background = d3.selectAll(selection.node().childNodes).filter('.' + CLASSNAME);
        if (d3background.empty() ) {
            d3background = selection.insert('svg:g', ":first-child").attr('class', CLASSNAME);
        }
        if (!backgroundModule) {
            backgroundModule = ignite('sap.viz.modules.background', props.parentCtx, CLASSNAME);
        }

        backgroundModule.width(props.width).height(props.height).properties(props.properties);
        d3background.call(backgroundModule);

        return backgroundModule;
      }
  };
  
  return BackgroundUtil;
});
define('sap/viz/util/functional',[],
function Setup () {
  
  var _ = {
    // Represents a tail recursion combinator. 
    tailrec : function ( cond, then, before ) {
      return function () {
        var args = arguments;
        
        // for saving an intermediate storage of linear structure
        /*jshint noempty:false*/
        for (; !cond.apply(this, args); args = before.apply(this, args)){}
        
        // a resulting action taken after recursion completes
        return then.apply(this, args);
      };
    }
  };
  
  return _;
  
});
define('sap/viz/modules/layout/dock',['jquery', 'sap/viz/modules/Constants','sap/viz/util/functional','sap/viz/util/Objects','sap/viz/base/utils/log/LogUtil'],
function Setup ( $, registry, lambda, Objects,LOG ) {

  function dock_sort (a, b) { return a - b; }
  function dock_edge (x) { return x.position; }
  function dock_value (x) { return x.value; }
  function dock_filter (x) { return; }
  function dock_size (x) { return x.size(); }

  var _ = function () {
    var sort = dock_sort,
        edge = dock_edge,
        value = dock_value,
        filter = dock_filter,
        size = dock_size,
        width = 0,
        height = 0,
        charger = { func : null, scope : null },
        em = registry.mappings.e2p(1),
        padding = [2 * em, 2 * em, 2 * em, 2 * em],
        tolerance = 1,
        cache = [],
        // counters for position requests
        tops = 0, bottoms = 0, lefts = 0, rights = 0,
        // anchoring sentinels
        x1 = 0, x2 = 0, y1 = 0, y2 = 0;
    var hgap,vgap;

    function dock () {
      // orientation test
      function isHorizontal (x) { return edge(x) === 'top' || edge(x) === 'bottom'; }
      function isVertical (x) { return edge(x) === 'left' || edge(x) === 'right'; }

      // minimum size accessing utility
      function minSize (x) {
        var pref = size(x);
        if ( pref === null ) {return null;}
        return filter(x) ? filter(x).call(this, { 
          edge : edge(x),
          result : { width : pref.minWidth, height : pref.minHeight },
          size : { width : width, height : height }
        }) : maxSize(x);
      }
      
      // maximum size accessing utility
      function maxSize (x) {
        var pref = size(x);
        if ( pref === null ) {return null;}
        return filter(x) ? filter(x).call(this, {
          edge : edge(x), 
          result : { width : pref.maxWidth, height : pref.maxHeight },
          size : { width : width, height : height }
        }) : minSize(x);
      }
      
      // re-wiring component links
      function rewire () { if ( charger.func ) {charger.func.call(charger.scope);} }

      // perfectly fits or not
      function perfect (x) {
        var module = x.module, pref = maxSize(x);
        if ( isVertical(x) ) {return Math.abs(pref.width - module.width()) < tolerance;}    
        if ( isHorizontal(x) ) {return Math.abs(pref.height - module.height()) < tolerance;}
        return true;
      }
      
      function enough (xs) {
        var result = true;
        xs.forEach(function (d) { result = perfect(d); });
        return result;
      }
      
      // reconciles space conflicts in orders of precedences
      function reconcile ( src, targets ) {
        // calculate viable improvement
        function improve (x) { // half-interval method
          var module = x.module, pref = maxSize(x);
          return isHorizontal(x) ?
            (pref.height - module.height()) / 2:
            (pref.width - module.width()) / 2;
        }
        
        var priority = targets.indexOf(src),
            result = {};
        result = targets.map(function ( d, i ) {
          if ( i <= priority ) {return d;}
          
          var vol = improve(src), 
              module = d.module, srcModule = src.module;
          
          if ( isVertical(src) ) {
            if ( vol > 0 ) {
              srcModule.width(srcModule.width() + vol);
              module.width(module.width() - vol);
            } else {
              srcModule.width(srcModule.width() - vol);
              module.width(module.width() + vol);
            }
          } else {
            if ( vol > 0 ) {
              srcModule.height(srcModule.height() + vol);
              module.height(module.height() - vol);
            } else {
              srcModule.height(srcModule.height() - vol);
              module.height(module.height() + vol);
            }
          }
          
          return d;
        });
        
        rewire();
        return result;
      }
      
      function layoutOnce (fullSize, elems) {
        var fullW = fullSize[0], fullH = fullSize[1];
        // FIXME thanks to the state-oriented programming style,
        // the dock function will be called with state. So this
        // refreshing has to be performed in order to react to 
        // resizing.
        x1 = 0, x2 = 0, y1 = 0, y2 = 0;
        tops = 0, bottoms = 0, lefts = 0, rights = 0;
        
        x1 = padding[3], x2 = fullW - padding[1];
        y1 = padding[0], y2 = fullH - padding[2];
        fullW -= ( padding[1] + padding[3] );
        fullH -= ( padding[0] + padding[2] );
        var area = [fullW, fullH];
        elems.forEach(function (d) {
          LOG.profiling("Render:drawing-layout-calculation-formatValue-" + d.module.alias);
          var module = d.module,
              osize = size(d), 
              max = maxSize(d),
              min = minSize(d),
              pref = {
                width : max !== null && min !== null ? 
                        d3.max([ max.width, min.width ]) : undefined,
                height : max !== null && min !== null ? 
                         d3.max([ max.height, min.height ]) : undefined
              };
          
          d.acceptable = true;
          
          if ( pref.width === 0 || pref.height === 0 ||
              ( edge(d) !== 'center' && (osize.minWidth > pref.width || osize.minHeight > pref.height || area[0] < osize.minWidth || area[1] < osize.minHeight) )) {
            // FIXME refactor
			if ( d.module.alias === 'legends' && d.module.modules()['sizeLegend'] && Objects.size(d.module.modules()) === 1 ) {
              d.acceptable = true;
            } else {
              d.acceptable = false;
              module.width(0).height(0);
              LOG.profiling("Render:drawing-layout-calculation-formatValue-" + d.module.alias);
              return;
			}
          }
          
          // grant initial available space
          switch ( edge(d) ) {
            case 'top' :
              module.width(area[0]).height(pref.height);
              if(tops){
                area[1] -= (pref.height + hgap * (tops - 1));
              }else{
                area[1] -= (pref.height + hgap);
              }
              tops++;
              break;
            case 'bottom' :
              module.width(area[0]).height(pref.height);
              if (bottoms){ 
                area[1] -= (pref.height + hgap * (bottoms - 1));
              }else{
                area[1] -= (pref.height + hgap);
              }
              bottoms++;
              break;
            case 'left' :
              module.width(pref.width).height(area[1]);
              if (lefts){ 
                area[0] -= (pref.width + vgap * (lefts - 1));
              }else{
                area[0] -= (pref.width + vgap);
              }
              lefts++;
              break;
            case 'right' :
              module.width(pref.width).height(area[1]);
              if (rights){ 
                area[0] -= (pref.width + vgap * (rights - 1));
              }else{
                area[0] -= (pref.width + vgap);
              }
              rights++;
              break;
            case 'center' :
              module.size({width:area[0],height:area[1]});
              area[0] = 0, area[1] = 0;
              break;
            }
            LOG.profiling("Render:drawing-layout-calculation-formatValue-" + d.module.alias);
          });
      }
      
      function anchor (xs) {
        var map = xs.map(function ( d, i ) {
          var coord = { x : 0, y : 0 },
              module = d.module;
          
          if ( !d.acceptable ) {
            d.anchor = coord;
            return d;
          }
          
          switch ( edge(d) ) {
          case 'top' :
            coord.x = x1, coord.y = y1;
            y1 += (module.height() + hgap);
            break;
          case 'bottom' :
            coord.x = x1, coord.y = y2 - module.height();
            y2 -= (module.height() + hgap);
            break;
          case 'left' :
            coord.x = x1, coord.y = y1;
            x1 += (module.width() + vgap);
            break;
          case 'right' :
            coord.x = x2 - module.width(), coord.y = y1;
            x2 -= (module.width() + vgap);
            break;
          case 'center' :
            coord.x = x1, coord.y = y1;
            x1 = x2, y1 = y2;
            break;
          }
          
          d.anchor = coord;
          return d;
        }), result = {};
        
        for ( var key in map ) {
          if ( map.hasOwnProperty(key) ) {
            var moduleIter = map[key].module;
            result[moduleIter.alias] = map[key].anchor;
            //we add more info here although it doesn't fit the function name
            //consider a new function name 
            result[moduleIter.alias].width = moduleIter.width();
            result[moduleIter.alias].height = moduleIter.height();
          }
        }
        
        return result;
      }

      // start of processing
      var elems = [],
          adjustPolicy = arguments[1],
          result = {};
      
      // accepts array argument only
      if ( !$.isArray(arguments[0]) ) {return result;}
      
      // defensive copy and sort by custom needs
      elems = arguments[0].slice().sort(sort);
      
      cache = [];
      
      // first layout
      
      layoutOnce([width, height], elems);
      
      // re-wiring component links after initial calculation
      rewire();
      
      if ( adjustPolicy === registry.LAYOUT_ADJUST_POLICY.APPROXIMATE ) {
        /*
        // tail recursion of reconciliation against incomplete layout data
        return lambda.tailrec(
          perfect,  // * CONDITION * base condition
          anchor,   // * THEN *      action taken when recursion stops
          reconcile // * BEFORE *    action taken before next loop/recursion
        ).apply(this, elems);
        */
        return anchor.call(this, (function recur (xs) {
          var first = xs[0];
          if ( !first.acceptable || perfect(first) ) {
            cache.push( xs.shift() );
            if ( xs.length ) {recur(xs);}
          } else {
            recur( reconcile(first, xs) );
          }
          return cache;
        })(elems)); 
      } else if ( adjustPolicy === registry.LAYOUT_ADJUST_POLICY.RELAYOUT ){
        //layout again
        
        layoutOnce([width, height], elems);
       
        rewire();
        return anchor.call(this, elems);
      } else {
        // No further precise size approaching will be taken,
        // which trades possible layout preciseness for time.
        return anchor(elems);
      }
    }
    
    dock.filter = function (x) {
      if ( !arguments.length ) {return filter;}
      filter = x;
      return dock;
    };
    
    dock.sort = function (x) {
      if ( !arguments.length ) {return sort;}
      sort = x;
      return dock;
    };
    
    dock.size = function (x) {
      if ( !arguments.length ) {return size;}
      size = x;
      return dock;
    };
    
    dock.edge = function (x) {
      if ( !arguments.length ) {return edge;}
      edge = x;
      return dock;
    };
    
    dock.value = function (x) {
      if ( !arguments.length ) {return value;}
      value = x;
      return dock;
    };
    
    dock.rewire = function (xs) {
      if ( !arguments.length ) {return charger;}
      charger = xs;
      return dock;
    };
    
    dock.vgap = function () {
      if ( !arguments.length ) {return vgap;}
      vgap = $.isFunction(arguments[1]) ? 
             arguments[1](arguments[0]) : arguments[0];
      return dock;
    };
    
    dock.hgap = function () {
      if ( !arguments.length ) {return hgap;}
      hgap = $.isFunction(arguments[1]) ? 
             arguments[1](arguments[0]) : arguments[0];
      return dock;
    };
    
    dock.padding = function () {
      if ( !arguments.length ) {return padding;}
      var val = arguments[0], filter = arguments[1];
      
      if ( $.isArray(val) ) {
        val.forEach(function (d, i) {
          padding[i] = $.isFunction(filter) ? filter(d) : +d;
        });
      } else {
        padding.forEach(function (d, i) { padding[i] = val; });
      }
      
      return dock;
    };
    
    dock.width = function (x) {
      if ( !arguments.length ) {return width;}
      width = x;
      return dock;
    };
    
    dock.height = function (x) {
      if ( !arguments.length ) {return height;}
      height = x;
      return dock;
    };
    
    dock.tolerance = function (x) {
      if ( !arguments.length ) {return tolerance;}
      tolerance = x;
      return dock;
    };
    
    dock.properties = function () { return dock; };
    dock.data = function () { return dock; };
    
    dock.destroy = function() {
      //charger.scope holds the div contaier in UIComponent
      charger.func = null;
      charger.scope = null;      
      charger = null;
    };
    
    return dock;
  };
  
  return _;

});
define('sap/viz/util/fn/modulebuilder',['sap/viz/util/ignite', 'sap/viz/modules/manifests/Module', 'sap/viz/modules/Constants', 'sap/viz/base/utils/Objects'], 
function Setup(ignite, category, Constants, Objects) {
  var WORDING = {
    'CLASS_PREFIX': Constants.CSS.CLASS.MODULEPREFIX
  };
  var retfn = function(paras, selections, context) {
    var dataset = paras.dataset, attrs = paras.props, conf = paras.conf, children = {};
    var modules = conf.modules;
    for(var key in modules) {
      if(modules.hasOwnProperty(key)){
        var value = modules[key];
        if (value === null) {
          continue;
        }
        var target = ignite(value.id, context, WORDING.CLASS_PREFIX + key);
        var data = value.data ? dataset.createDataAdapterForModule(value.data) : dataset;
        var props = {};
        var type = category.get(value.id).type;
  
        if (target.data) {
          target.data(data);
        }
        target.alias = key;
  
        // containers
        if (type === Constants.Type.Container) {
          if (value.configure) {
            props[value.configure.propertyCategory] = value.configure.properties;
          }
          target.parent(selections[key]).config(value).properties(Objects.extend(true, {}, props, attrs));
        } else {// non-containers
          target.properties(Objects.extend(true, {}, value.configure ? value.configure.properties : {}, value.configure ? attrs[value.configure.propertyCategory] : {}));
          if (target.parent) {
            target.parent(selections[key]);
          }
        }
        children[key] = target;
      }
    }
    return children;
  };
  return retfn;
}); 
define('sap/viz/modules/BaseContainer',['sap/viz/base/utils/oo','sap/viz/modules/Base','jquery','sap/viz/modules/Constants','sap/viz/modules/manifests/Module','sap/viz/util/ignite',
'sap/viz/util/append','sap/viz/modules/dispatch','sap/viz/base/utils/Objects','sap/viz/modules/util/BackgroundUtil','sap/viz/modules/layout/dock','sap/viz/util/fn/dombuilder','sap/viz/util/fn/domposition','sap/viz/util/fn/modulebuilder',
'sap/viz/base/utils/FunctionUtils','sap/viz/base/utils/log/LogUtil'],
function Setup ( oo, Base, $, Constants, category, ignite, append, evts, 
  Objects, BackgroundUtil, dock, dombuilder, domposition, modulebuilder, FnUtil, LOG ) {
    
    var rewireControllers = function () {
      var config = this._bc_config;
      var modules = this._modules;
      $.each(config.modules, function ( key, value ) {
        if ( value === null ) { return; }
        if ( category.get(value.id).type === Constants.Type.Controller ) {
          modules[key]().module(modules[value.configure.clientID]);
        }
      });
    };
    
    var init = function( args ) {
      this._selections = this.dombuilder(this._parentNode, this._bc_config.modules);
      this._modules = this.modulebuilder(args, this._selections, this._bc_context);
      bindInitializedEvent.call(this);
      bindControllerClient.call(this);
    };
    
    var bindInitializedEvent = function() {
      var that = this;
      for(var key in this._modules){
        if(this._modules.hasOwnProperty(key)){
          var target = this._modules[key];
          if (target.dispatch && target.dispatch()['initialized']) {
            target.dispatch().on('initialized.BaseContainer', function() {
              return function() {
                initialized.call(that);
              };
            }());
            that._bc_count++;
          }   
        }
      }
    };
    
    var unBindInitializedEvent = function() {
      var that = this;
      for(var key in this._modules){
        if(this._modules.hasOwnProperty(key)){
          var target = this._modules[key];
          if (target.dispatch && target.dispatch()['initialized']) {
            target.dispatch().on('initialized.BaseContainer', null);
          }
        }
      }
    };
    
    var initialized = function () {
      if ( ++this._bc_inits === this._bc_count ) {
        this._bc_inits = 0;
        this._bc_dispatch.initialized();
        this._bc_dispatch.ready();
      }
    };
    
    var bindControllerClient = function() {
      var config = this._bc_config;
      var modules = this._modules;
      $.each(config.modules, function(key, value) {
        if (value === null) {
          return;
        }
        if (category.get(value.id).type === Constants.Type.Controller && modules[key].module) {
          if(!value.configure || !value.configure.clientID){
            FnUtil.error('A clientID is required for a controller module:' + value.id);
          }
          modules[key].module(modules[value.configure.clientID]);
        }
      });
    };
    
    var getDefaultLayout = function () {
      //why don't add it to modules directly? because sometimes we will
      //iterate all modules and want to get meta data for each module, then
      //we will fail for this default layout as we don't have metadata for it in the config.
      if ( !this._bc_defaultLayout ) {
        this._bc_defaultLayout = this.getDefaultLayout(this._bc_context);
      }
      return this._bc_defaultLayout;
    };

    var initIfReady = function() {
      //don't check && !$.isEmptyObject(this._bc_properties) as we may have empty properties
      //so we are always using empty properties to initialize, then update properties for each sub module in 'properties' API
      if($.isEmptyObject(this._modules) && !$.isEmptyObject(this._bc_config) && !$.isEmptyObject(this._data)) {
         init.call(this, { 'dataset' : this._data, 'conf' : this._bc_config, 'props' : this._bc_properties });
      }
    };
    
    var WORDING = {
      'CLASS_PREFIX': Constants.CSS.CLASS.MODULEPREFIX,
      'DEFAULT_LAYOUT_KEY': 'sap_viz_modules_layout_dock_key'
    };
    
    var BaseContainer = function ( manifest, context ) {
      BaseContainer.superclass.constructor.apply(this, arguments);
      
      this._bc_manifest = manifest;
      this._bc_context = context;
      this._bc_width = 0; 
      this._bc_height = 0;
      //for containers, we have two kinds of properties, one is for its own which
      //should not passed down to sub modules; the other is specified by users, need
      //pass down to sub modules
      this._bc_ownProperties = manifest.props(null);
      this._bc_properties = {};
      this._bc_config = {};
      this._bc_dispatch = evts('initialized', 'ready');
      this._bc_count = 0;
      this._bc_inits = 0;
      this._bc_backgroundModule = null;
      this._bc_charger = { func : null, scope : null };
      this._bc_chartType = '';
      // checklist items in order upon update against this module
      this._bc_update_checklist = [ rewireControllers ];
      this._bc_defaultLayout = null;//hold default layout instance
      
      ///////////Protected//////////////
      this._modules = {};
      this._selections = {};//hold parent selection for each render-able sub module
      this._layout = {};//hold layout info for each render-able sub module
      this._data = {};//hold the data for this container
      this._parentNode = null;
    };
    
    oo.extend(BaseContainer, Base);
    
    BaseContainer.prototype.render = function(selection){
      this._bc_inits = 0;
      this._parentNode = selection;
      var subSelections = this._selections;
      var modules = this._modules;
      var config = this._bc_config;
      
      LOG.profiling('Render:drawing-layout');
      this._layout = this.layout(config, this._bc_width, this._bc_height, modules, subSelections);
      // special treatment against inefficient workflow
      // TODO refine work flow definition
      var type = this._bc_chartType.substr(this._bc_chartType.indexOf('/') + 1);
      if ( type === 'bubble' || type === 'multi_bubble' || type === 'geobubble' || 
           type === 'geopie' || type === 'multi_geobubble' ) {
        this._layout = this.layout(config, this._bc_width, this._bc_height, modules, subSelections);
      }
      LOG.profiling('Render:drawing-layout');
      
      LOG.profiling("Render:drawing-paint");
      LOG.profiling("Render:drawing-paint-background");
      //Jimmy/6/6/2013, currently we have two places to draw background, they are both using
      //background module, but here the module usage is hardcoded (while in xycontainer is configurable)
      //here the background module is not exposed to external and only used in internal high contrast template  
      this.drawBackground();
      LOG.profiling("Render:drawing-paint-background");
      
      LOG.profiling("Render:drawing-paint-chart");
      // execute module drawing logics
      for ( var key in subSelections ) {//only render-able modules will have corresponding selection
        if ( subSelections.hasOwnProperty(key) && subSelections[key] && modules.hasOwnProperty(key) && modules[key] ) {
           LOG.profiling("Render:drawing-paint-chart-" + key);
           subSelections[key].call(modules[key]);
           LOG.profiling("Render:drawing-paint-chart-" + key);
         }
      }
      LOG.profiling("Render:drawing-paint-chart");
      LOG.profiling("Render:drawing-paint");
    };
    
    // x stands for scalar values and xs stands for collection/compound values
    BaseContainer.prototype.width = function (x) {
      if ( !arguments.length ) { return this._bc_width; }
      this._bc_width = x;
      return this;
    };
    
    BaseContainer.prototype.height = function (x) {
      if ( !arguments.length ) { return this._bc_height; }
      this._bc_height = x;
      return this;
    };
    
    BaseContainer.prototype.size = function (xs) {
      if ( !arguments.length ) { return { 'width' : this._bc_width, 'height' : this._bc_height }; }
      this._bc_width = xs.width;
      this._bc_height = xs.height;
      return this;
    };
    
    BaseContainer.prototype.config = function (xs) {
      if ( !arguments.length ) { return this._bc_config; }
      this._bc_config = xs;
      initIfReady.call(this);
      return this;
    };
    
    BaseContainer.prototype.data = function (xs) {
      if ( !arguments.length ) { return this._data; }
      this._data = xs;
      
      initIfReady.call(this);
      var modules = this._modules;
      var config = this._bc_config;
      var data = this._data;
      
      for ( var key in modules ) {
        if ( modules.hasOwnProperty(key) ) {
          if ( config.modules[key].data ) {
            modules[key].data(
              data.createDataAdapterForModule(config.modules[key].data));
          } else {
            if ( modules[key].data ) {
              modules[key].data(data);
            }
          }
        }
      }
      
      return this;
    };
    
    BaseContainer.prototype.properties = function (xs) {
      if ( !arguments.length ) { return this._bc_properties; }
           
      var modules = this._modules;
      var config = this._bc_config;
      
      Objects.extend(true, this._bc_properties, xs);
      //merge to own properties
      this._bc_ownProperties = this.getMergedProperties(xs);
      //update to _bc_properties
      var propertyCategory = config.configure ? config.configure.propertyCategory : null;
      Objects.extend(true, this._bc_properties[propertyCategory], this._bc_ownProperties);
      
 
      
      for ( var key in modules ) {
        if ( modules.hasOwnProperty(key) ) {
          if ( category.get(config.modules[key].id).type === Constants.Type.Container ) {//container indicator
            modules[key].properties(this._bc_properties);
          } else if (config.modules[key].configure) {
            //if it's not container, see if it has configured properties
            modules[key].properties(this._bc_properties[config.modules[key].configure.propertyCategory]);
          }
        }
      }
      
      return this;
    };
    
    BaseContainer.prototype.relayout = function ( evt ) {
      //Jimmy/6/4/2013 I found legend in bubble chart may trigger relayout of BaseContainer by event dependency
      /*
      {
              targetModule : 'root',
              listener : 'relayout',
              sourceModule : 'root.legends',
              type : 'relayout'
            }*/
      this.layout(this._bc_config, this._bc_width, this._bc_height, this._modules, this._selections);
    };
    
    BaseContainer.prototype.chartType = function (x) {
      if ( !arguments.length ) {
        return this._bc_chartType;
      }
      this._bc_chartType = x;
      return this;
    };
    
    // Means of wiring up module dependencies
    BaseContainer.prototype.recharge = function (x) {
      if ( !arguments.length ) { return this._bc_charger; }
      this._bc_charger = x;
      return this;
    };
    
    BaseContainer.prototype.dispatch = function (x) {
      if ( !arguments.length ) { return this._bc_dispatch; }
      this._bc_dispatch = x;
      return this;
    };
    
    BaseContainer.prototype.refresh = function () {
      //Jimmy/6/4/2013 I found refresh happens when data is updated from outside in ChartComponent
      var update_checklist = this._bc_update_checklist;
      for ( var i = 0; i < update_checklist.length; i++ ) {
        update_checklist[i].call(this);
      }
      return this;
    };
    
    BaseContainer.prototype.parent = function (x) {
      if ( !arguments.length ) { return this._parentNode; }
      this._parentNode = x;
      return this;
    };
    
    BaseContainer.prototype.modules = function (xs) {
      if ( !arguments.length ) {
        initIfReady.call(this);
        return this._modules;
      }
      this._modules = xs;
      return this;
    };
    
    BaseContainer.prototype.destroy = function() {
      unBindInitializedEvent.call(this);
      //release all properties which hold dom instances
      this._selections = null;
      this._bc_backgroundModule = null;
      this._parentNode = null;
      this._bc_charger = null;
      this._bc_dispatch = null;
      //call sub modules destroy
      //default layout
      if(this._bc_defaultLayout && this._bc_defaultLayout.destroy){
        this._bc_defaultLayout.destroy();
      }
      this._data = null;
      this._modules = null;
      //we don't need iterate sub modules here, we will iterate all modules in chart component
    };
    
    //////////////Protected Methods///////////////////////
    /*
     * build dom nodes for each children and save it to local var 
     * by default only SVG nodes supported
     * @Protected
     */
    BaseContainer.prototype.dombuilder = function( parentNode, subModulesConfig ) {
      return dombuilder(parentNode, subModulesConfig);
    };
    
    /*
     * initialize sub modules and save it to local var
     * @Protected  
     */
    BaseContainer.prototype.modulebuilder = function( args, selections, context ) {
      return modulebuilder(args, selections, context);
    };
    
    /*
     * get default layout for container. by default, it's sap.viz.modules.layout.dock
     * @Protected 
     */
    BaseContainer.prototype.getDefaultLayout = function( context ) {
      //if no layout has been specified for container, we will use dock layout by default
      //and for this default layout module, we will give a DEFAULT_LAYOUT_KEY to it.
      //actually we are hard coding package here
      var defaultKey = WORDING['DEFAULT_LAYOUT_KEY'];
      return ignite('sap.viz.modules.layout.dock', context, WORDING.CLASS_PREFIX + defaultKey);
    };
    
    /*
     * draw background. by default, we are using sap.viz.modules.background to draw background
     * @Protected
     */
    BaseContainer.prototype.drawBackground = function( parent ) {
      var props = {
        'width' : this._bc_width,
        'height' : this._bc_height,
        'properties' : {
          'border' : {
            'left' : {
              'visible' : false
            },
            'right' : {
              'visible' : false
            },
            'top' : {
              'visible' : false
            },
            'bottom' : {
              'visible' : false
            }
          }
        },
        'parentCtx' : this._bc_context
      };
      this._bc_backgroundModule = BackgroundUtil.drawBackground(this._parentNode, this._bc_backgroundModule, props);
    };
    
    /*
     * properties for a module can come from 3 possible places, here we will return merged properties order by priority
     * user defined > module reference > module default
     * here the passedInProperties already contain properties from user defined and module reference
     * it will be called each time properties API is called
     * @Protected 
     */
    BaseContainer.prototype.getMergedProperties = function(passedInProperties){
      
      var currentProperties = this._bc_ownProperties;//it's module default at the first time
      var config = this._bc_config;
      
      var propertyCategory = config.configure ? config.configure.propertyCategory : null; 
      var passedIn = propertyCategory ? passedInProperties[propertyCategory] : null;
      
      var merged = Objects.extend(true, currentProperties, passedIn);
      
      return merged;  
    };
    
    /*
     * layout is responsible for:
     * set width/height for each sub module
     * set position for each sub module's selection
     * return a map with module reference key as key and (position (x, y) and size (width, height)) as value
     * {
     *   x:xx
     *   y:xx
     *   width:xx
     *   height:xx
     * } 
     * @Protected
     */
    BaseContainer.prototype.layout = function( ownConfig, width, height, subModules, subSelections) {
      
      var charger = this._bc_charger;
      var algorithm = subModules.layout || getDefaultLayout.call(this);
      var props = this._bc_ownProperties.layout; 
      
      // evaluates layout function
      function calc (xs, adjustPolicy) {
        return (algorithm.width(width).height(height))(xs, adjustPolicy);
      }
      
      // formulates layout data
      function create (xs, chargerFn) {
        LOG.profiling("Render:drawing-layout-calculation-formatModule");
        var padding = [ 24, 24, 24, 24 ], 
            vgap = 0,
            hgap = 0,
            elements = [];
        
        vgap = props.vgap;
        hgap = props.hgap;
        
        if ( typeof props.padding !=='undefined' && props.padding !== null && props.padding >= 0 ) {
          for ( var i = 0; i < padding.length; i++ ) {
            padding[i] = props.padding;
        }
        }
        if ( typeof props['paddingLeft'] !=='undefined' && props['paddingLeft'] !== null) { padding[3] = props['paddingLeft'] < width/2 ? props['paddingLeft'] : 24;}
        if ( typeof props['paddingRight']!=='undefined' && props['paddingRight'] !== null) { padding[1] = props['paddingRight'] < width/2 ? props['paddingRight'] : 24;}
        if ( typeof props['paddingTop'] !=='undefined' && props['paddingTop'] !== null) { padding[0] = props['paddingTop'] < height/2 ? props['paddingTop'] : 24;}
        if ( typeof props['paddingBottom'] !=='undefined' && props['paddingBottom'] !== null) { padding[2] = props['paddingBottom'] < height/2 ? props['paddingBottom'] : 24;}
        
        algorithm
          .padding(padding,function(d){
           var min=Math.min(width,height);
           if(min<=108){
             return d <= 2 ? d : 2;
           }else{
             return d;
           }
           })
          .vgap(vgap || 0, function (d) { return d; })
          .hgap(hgap || 0, function (d) { return d; })
          .width(width)
          .height(height)
          .rewire(chargerFn)
          .sort(function (a, b) { return a.priority - b.priority; })
          .size(function (d) {
            return d.module.getPreferredSize ? d.module.getPreferredSize() : null; 
          })
          .value(function (d) { return d.priority; })
          .edge(function (d) { return d.position; })
          .filter(function (d) { return d.filter; })
          .tolerance(1);
        
        $.each(xs, function ( key, value ) {
          if ( category.get(ownConfig.modules[key].id).type !== Constants.Type.Container &&
               category.get(ownConfig.modules[key].id).type !== Constants.Type.Supplementary &&
               category.get(ownConfig.modules[key].id).type !== Constants.Type.Chart ) {
            return;
          }
          
          //if value is a container, the properties contains all property categories. 
          //we need get it from its own propertyCategory
          //otherwise, we get it from 'layout' properties directly
          var req = value.properties().layout || 
                    value.properties()[ownConfig.modules[key].configure.propertyCategory].layout,
              pos = req.position;
          
          if ( key === 'legends' ) {
            subModules.legends
              .maxWidth(1/3 * width - padding[0] - padding[2])
              .maxHeight(1/3 * height - padding[1] - padding[3]);
          }
          
          elements.push({
            module : value,
            position : pos,
            filter : function (d) {
              var ret = {},
                  result = d.result,
                  size = d.size;
              if ( d.edge === 'top' || d.edge === 'bottom' ) {
                 ret.height = ( result.height > 1/3 * (size.height - padding[0] - padding[2]) ) ? 
                    1/3 * (size.height - padding[0] - padding[2]) : result.height;
                 ret.width = result.width;
              }
              if ( d.edge === 'left' || d.edge === 'right' ) {
                  ret.width = ( result.width > 1/3 * (size.width - padding[1] - padding[3]) ) ? 
                    1/3 * (size.width - padding[1] - padding[3]) : result.width;
                ret.height = result.height;
              }
              return ret;
            },
            priority : req.priority
          }); 
        });
        LOG.profiling("Render:drawing-layout-calculation-formatModule");
        return elements;
      }
      
      LOG.profiling("Render:drawing-layout-calculation");
      var ret = calc(create(subModules, charger), 'RELAYOUT');
     // console.log(padding);
      LOG.profiling("Render:drawing-layout-calculation");
      
      LOG.profiling('Render:drawing-layout-positionsub');
      domposition(ret, subSelections);
      LOG.profiling('Render:drawing-layout-positionsub');
      
      return ret;
      
    };
    
    return BaseContainer;
});
define('sap/viz/util/EffectManager',[],
function Setup(){

  /**
   * 
   * @param svgdef d3 svg defs to store all gradient effect
   * @return TODO: add desc
   */
  function EffectManager(svgdef, enableGhostEffect){
    this._defs  = svgdef;
    this._enableGhostEffect = enableGhostEffect;
  }

  function rgba (r_, g_, b_, a_) {
    var temp = {
        r: r_,
        g: g_,
        b: b_,
        a: a_,
        toHex : function() {
            return d3.rgb(temp.r, temp.g, temp.b).toString();
        },
        toString : function() {
          if (temp.a<1) {
            return "rgba(" + temp.r + "," + temp.g + "," + temp.b + "," + temp.a + ")";
          } else {
            return temp.toHex();
          }
        }
    };
    return temp;
  }

  function color2rgba(color) {
    var nc = d3.rgb(0,0,0), na=1;
    if (color !== undefined && typeof(color) === 'object') {
      if (color.rgb) {
        nc = color.rgb();
      } else {
        nc = color;
      }
    } else if (typeof(color) === 'string') {
        color = color.toLowerCase();
        var temp, i, j;
        if (color.indexOf('rgba') >= 0) {
            temp = color.substring(color.indexOf('(')+1);
            
            i = temp.lastIndexOf(',');
            j = temp.indexOf(')');
            if (i>=0 && j>=0) {
                var rgbStr = 'rgb(' + temp.substring(0,i) + ')';
                na = parseFloat(temp.substring(i+1,j));
                nc = d3.rgb(rgbStr);
            }
        } else if (color.indexOf('hsla') >= 0) {
            temp = color.substring(color.indexOf('(')+1);

            i = temp.lastIndexOf(',');
            j = temp.indexOf(')');
            if (i>=0 && j>=0) {
                var hslStr = 'hsl(' + temp.substring(0,i) + ')';
                na = parseFloat(temp.substring(i+1,j));
                nc = d3.hsl(hslStr).rgb();
            }
        } else if (color.indexOf('hsl') >= 0) {
            nc = d3.hsl(color).rgb();
        } else if (color.indexOf('#') >= 0){
           var r,g,b;
           if (color.length === 4) {
                r = color.charAt(1);
                r += r;
                g = color.charAt(2);
                g += g;
                b = color.charAt(3);
                b += b;
            } else if (color.length === 7) {
                r = color.substring(1, 3);
                g = color.substring(3, 5);
                b = color.substring(5, 7);
            }
            r = parseInt(r, 16);
            g = parseInt(g, 16);
            b = parseInt(b, 16);
            nc = d3.rgb(r,g,b);
        } else{
            nc = d3.rgb(color);
        }
    }
    return rgba(nc.r, nc.g, nc.b, na);
  }
  
  function rgba2gray (c) {
    var r = c.r, g = c.g, b = c.b, gc;

    if ((r === g) && (g === b)) {
      gc = Math.round(r + (255 - r)*0.6);
    } else {
      gc = Math.round((r*299 + g*587 + b*114 + 500) / 1000);
    }
    return rgba(gc, gc, gc, c.a);
  }

  function increaseBrightness(c, percent) {
    var r = c.r, g = c.g, b = c.b, nr,ng,nb;
    if (percent >= 0) {
      nr = Math.round(r + (255 - r) * percent / 100);
      ng = Math.round(g + (255 - g) * percent / 100);
      nb = Math.round(b + (255 - b) * percent / 100);
    } else {
      nr = Math.round(r * (100 + percent) / 100);
      ng = Math.round(g * (100 + percent) / 100);
      nb = Math.round(b * (100 + percent) / 100);
    }
    return rgba(nr,ng,nb,c.a);
  }
  
  function drawGlossySector(d3defs, id, c, radius) {
    var c0 = c.toHex();
    var c2 = increaseBrightness(c, 50).toHex();
    var c3 = increaseBrightness(c, -30).toHex();

    var d3rg = d3defs.append('radialGradient');
    var rg = d3rg[0][0];
    rg.setAttribute('id', id);
    rg.setAttribute('cx', 0);
    rg.setAttribute('cy', 0);
    rg.setAttribute('r', radius);
    rg.setAttribute('fx', 0);
    rg.setAttribute('fy', 0);
    rg.setAttribute('gradientUnits',"userSpaceOnUse");
    d3rg.append("stop").attr('stop-opacity', c.a).attr("offset", 0).attr("stop-color", c2);
    d3rg.append("stop").attr('stop-opacity', c.a).attr("offset", 0.9).attr("stop-color", c0);
    d3rg.append("stop").attr('stop-opacity', c.a).attr("offset", 1).attr("stop-color", c3);
  }
  
  function drawGlossy3dSector(d3defs, id, c) {
    var c0 = c.toHex();
    var c1 = increaseBrightness(c, 10).toHex();
    var c2 = increaseBrightness(c, 60).toHex();

    var d3rg = d3defs.append('radialGradient');
    var rg = d3rg[0][0];
    rg.setAttribute('id', id);
    rg.setAttribute('cx', '50%');
    rg.setAttribute('cy', '50%');
    rg.setAttribute('r', '50%');
    rg.setAttribute('fx', '25%');
    rg.setAttribute('fy', '25%');
    rg.setAttribute('gradientUnits',"userSpaceOnUse");
    d3rg.append("stop").attr('stop-opacity', c.a).attr("offset", 0).attr("stop-color", c2);
    d3rg.append("stop").attr('stop-opacity', c.a).attr("offset", 0.8).attr("stop-color", c1);
    //d3rg.append("stop").attr('stop-opacity', c.a).attr("offset", 0.9).attr("stop-color", c0);
    d3rg.append("stop").attr('stop-opacity', c.a).attr("offset", 1).attr("stop-color", c0);
  }   
  function drawGlossyCircle(d3defs, id, c) {
    var c0 = c.toHex();
    var c1 = increaseBrightness(c, 10).toHex();
    var c2 = increaseBrightness(c, 80).toHex();

    var d3rg = d3defs.append('radialGradient');
    var rg = d3rg[0][0];
    rg.setAttribute('id', id);
    rg.setAttribute('cx', '50%');
    rg.setAttribute('cy', '50%');
    rg.setAttribute('r', '50%');
    rg.setAttribute('fx', '50%');
    rg.setAttribute('fy', '20%');
    d3rg.append("stop").attr('stop-opacity', c.a).attr("offset", 0).attr("stop-color", c2);
    d3rg.append("stop").attr('stop-opacity', c.a).attr("offset", 0.7).attr("stop-color", c1);
    d3rg.append("stop").attr('stop-opacity', c.a).attr("offset", 0.9).attr("stop-color", c0);
    d3rg.append("stop").attr('stop-opacity', c.a).attr("offset", 1).attr("stop-color", c0);
  }

  function drawGlossyRectangle(d3defs, id, c, direction) {
    var c1 = increaseBrightness(c, 30).toHex();
    var c2 = increaseBrightness(c, 50).toHex();
    var c3 = increaseBrightness(c, -10).toHex();
    var c4 = increaseBrightness(c, 10).toHex();
    var gradient = d3defs.append("svg:linearGradient").attr("id", id).attr("x1", "0%").attr("y1", "0%");
    if(direction === 'horizontal') {
      gradient.attr("y2", "0%").attr("x2", "100%");
    } else {
      gradient.attr("y2", "100%").attr("x2", "0%");
    }
    
    gradient.append("stop").attr('stop-opacity', c.a).attr("offset", 0).attr("stop-color", c1);
    gradient.append("stop").attr('stop-opacity', c.a).attr("offset", 0.2).attr("stop-color", c2);
    gradient.append("stop").attr('stop-opacity', c.a).attr("offset", 0.8).attr("stop-color", c3);
    gradient.append("stop").attr('stop-opacity', c.a).attr("offset", 1).attr("stop-color", c4);
 }
  
  function drawGlossyCubeTopSurface(d3defs, id, c, direction) {
    var c1 = increaseBrightness(c, 50).toHex();
    var c2 = increaseBrightness(c, -10).toHex();
    
    var gradient = d3defs.append("svg:linearGradient").attr("id", id);

    switch(direction){
    case "LeftRight": 
      gradient.attr("x1", "0%").attr("y1", "0%").attr("y2", "0%").attr("x2", "100%");
      break;
    case "BottomUp": 
      gradient.attr("x1", "0%").attr("y1", "100%").attr("y2", "0%").attr("x2", "0%");
      break;
    case "RightLeft": 
      gradient.attr("x1", "100%").attr("y1", "0%").attr("y2", "0%").attr("x2", "0%");
      break;
    case "TopDown": 
      gradient.attr("x1", "0%").attr("y1", "0%").attr("y2", "100%").attr("x2", "0%");
      break;
    default :
      gradient.attr("x1", "0%").attr("y1", "0%").attr("y2", "0%").attr("x2", "100%");      
    }
    gradient.append("stop").attr('stop-opacity', c.a).attr("offset", 0).attr("stop-color", c2);
    gradient.append("stop").attr('stop-opacity', c.a).attr("offset", 1).attr("stop-color", c1);
 }
  
  function drawGlossyCubeSideSurface(d3defs, id, c, direction) {
    var c1 = increaseBrightness(c, 50).toHex();
    var c2 = increaseBrightness(c, -10).toHex();

    var gradient = d3defs.append("svg:linearGradient").attr("id", id).attr("x1", "0%").attr("y1", "100%").attr("y2", "0%").attr("x2", "100%");
    
    gradient.append("stop").attr('stop-opacity', c.a).attr("offset", 0).attr("stop-color", c2);
    gradient.append("stop").attr('stop-opacity', c.a).attr("offset", 1).attr("stop-color", c1);
 }
  function drawGlossySectorSideSurface(d3defs, id, c, direction) {
    var c1 = increaseBrightness(c, 50).toHex();
    var c2 = increaseBrightness(c, -30).toHex();

    var gradient = d3defs.append("svg:linearGradient").attr("id", id).attr("x1", "0%").attr("y1", "100%").attr("y2", "0%").attr("x2", "100%");
    
    gradient.append("stop").attr('stop-opacity', c.a).attr("offset", 0).attr("stop-color", c2);
    gradient.append("stop").attr('stop-opacity', c.a).attr("offset", 1).attr("stop-color", c1);
 }

  function drawGlossyBackground(d3defs, id, c, direction) {
     var gradient = d3defs.append("svg:linearGradient").attr("id", id);
     if(direction === 'horizontal') {
       gradient.attr("x1", "100%").attr("y1", "0%").attr("x2", "0%").attr("y2", "0%");
     } else {
       gradient.attr("x1", "0%").attr("y1", "0%").attr("x2", "0%").attr("y2", "100%");
     }
     
     gradient.append("stop").attr('stop-opacity', c.a).attr("offset", 0).attr("stop-color", '#ffffff');
     gradient.append("stop").attr('stop-opacity', c.a).attr("offset", 1).attr("stop-color", c.toHex());
  }

  
  function getFillElementId(parameters, color)
  {
    var id;

    if(parameters.drawingEffect === "glossy")
    {
      var colorStr = color.toHex().slice(1) + color.a.toString().replace('.','');
      switch(parameters.graphType)
      {
      case 'sector':
        id = parameters.drawingEffect + parameters.graphType + colorStr + Math.round(parameters.radius);
        break;
      case '3dSector':
        id = parameters.drawingEffect + parameters.graphType + colorStr;
        break;
      case 'cubeTop':
        id = parameters.drawingEffect + parameters.graphType + colorStr + parameters.direction;
        break;
      case 'cubeSide':
        id = parameters.drawingEffect + parameters.graphType + colorStr;
        break;
      case 'sectorSide':
        id = parameters.drawingEffect + parameters.graphType + colorStr;
        break;
      case 'circle':
        id = parameters.drawingEffect + parameters.graphType + colorStr;
        break;
      case 'triangle-up' ://TODO: remove duplicate
      case 'triangle-down' ://TODO: remove duplicate
      case 'triangleUp' :
      case 'triangleDown' :
        id = parameters.drawingEffect + 'triangle' + colorStr + 'vertical';
        break;
      case 'triangle-left' ://TODO: remove duplicate
      case 'triangle-right' ://TODO: remove duplicate
      case 'triangleLeft' :
      case 'triangleRight' :
        id =  parameters.drawingEffect + 'triangle' + colorStr + 'horizontal';
        break;
      case 'rectangle' :
      case 'diamond' :
      case 'cross' :
      case 'star' :
      case 'intersection' :
      case 'background' :
        id =  parameters.drawingEffect + 'rectangle' + colorStr + parameters.direction;
        break;
      default :
        id =  parameters.drawingEffect + 'rectangle' + colorStr + parameters.direction;
        break;
      case 'line' :
        id = null;
        break;
      }
    }

    return id;

  }
  /**
   * 
   * @param parameters
   * {
   *   graphType: 'circle','square','diamond'.....
   *   drawingEffect,
   *   fillColor,
   *   direction,  "horizontal" means left to right. "vertical" means top to bottom
   * }
   * @return id to use in "fill"
   */

  EffectManager.prototype.register = function(parameters)
  {
    var originalColor = parameters.fillColor;
    if (typeof(originalColor) === 'string') {
        if ((originalColor.toLowerCase() === 'transparent') ||
            (originalColor.toLowerCase() === 'none')) {
            return originalColor;
        }
    }

    var color = color2rgba(originalColor);
    if (this._enableGhostEffect) {
      color = rgba2gray(color);
    }

    var id = getFillElementId(parameters, color);
    if(!id) { return color.toString(); }

    var element = this._defs.select("#" + id);
    if(element.empty())
    {
      if(parameters.drawingEffect === "glossy") {
        switch (parameters.graphType)
        {
        case 'background' : 
          drawGlossyBackground(this._defs, id, color, parameters.direction);
          break;
         case 'sector' :
          drawGlossySector(this._defs, id, color, parameters.radius);
          break;
         case '3dSector':
           drawGlossy3dSector(this._defs, id, color);
           break;
         case 'cubeTop':
           drawGlossyCubeTopSurface(this._defs, id, color, parameters.direction);
           break;
         case 'cubeSide':
           drawGlossyCubeSideSurface(this._defs, id, color);
           break;
         case 'sectorSide':
           drawGlossySectorSideSurface(this._defs, id, color);
           break;
         case 'circle' :
          drawGlossyCircle(this._defs, id, color, parameters.direction);
          break;
         case 'triangle-up' :
         case 'triangle-down' :
          drawGlossyRectangle(this._defs, id, color, 'vertical');
          break;
         case 'triangle-left' :
         case 'triangle-right' :
          drawGlossyRectangle(this._defs, id, color, 'horizontal');
          break;
         case 'rectangle' :
         case 'diamond' :
         case 'cross' :
         case 'star' :
         case 'intersection' :
           drawGlossyRectangle(this._defs, id, color, parameters.direction);
           break;
         default :
          drawGlossyRectangle(this._defs, id, color, parameters.direction);
          break;
         }
       } else {
            return color.toString();
       }
     }
     return "url(#" + id + ")";
   };
   
  EffectManager.prototype.container = function(container){
    if(!arguments.length){
      return this._defs;
    }
    this._defs = container;
  };

  EffectManager.prototype.ghostEffect = function(_){
    if(!arguments.length) {
      return this._enableGhostEffect;
    }
    this._enableGhostEffect = _;
  };
  
  EffectManager.prototype.destroy = function(){
    this._defs = null;
  };
  return EffectManager;
});
define('sap/viz/modules/rootContainer',['sap/viz/base/utils/oo','sap/viz/modules/BaseContainer','sap/viz/base/utils/log/LogUtil','sap/viz/util/EffectManager','sap/viz/config'],
function Setup ( oo, BaseContainer, LOG, EffectManager,config) {
    
    var RootContainer = function ( manifest, context ) {
      RootContainer.superclass.constructor.apply(this, arguments);
      
      this._rc_effectManager = new EffectManager();
      context.effectManager = this._rc_effectManager;
      this._rc_container = null;
    };
    
    oo.extend(RootContainer, BaseContainer);
    
    RootContainer.prototype.container = function (x) {
      if ( !arguments.length ) { return this._rc_container; }
      this._rc_container = x;
      return this;
    };
    
    RootContainer.prototype.data = function(xs) {
      var ret = RootContainer.superclass.data.apply(this, arguments);
      if ( !arguments.length ) { return ret; }
      
      if((!config.get('isFlatTable')) && this._rc_effectManager){
        this._rc_effectManager.ghostEffect(this._data.fakeData());  
      }
      return this;
    };
    
    RootContainer.prototype.parent = function(xs) {
      var ret = RootContainer.superclass.parent.apply(this, arguments);
      if ( !arguments.length ) { return ret; }
      
      if(this._rc_effectManager){
        this._rc_effectManager.container(this._parentNode.append("svg:defs"));  
      }
      return this;
    };
    
    RootContainer.prototype.modulebuilder = function(args, selections, context){
      var ret = RootContainer.superclass.modulebuilder.apply(this, arguments);
      
      //Tooltip module needs special care, hard code names here
      for(var key in ret){
        if(ret.hasOwnProperty(key) && key === 'tooltip'){
          ret[key] = ret[key](this._rc_container);
        }
      }
      return ret;
    };
    
    RootContainer.prototype.render = function(selection){
      RootContainer.superclass.render.apply(this, arguments);
      var modules = this._modules;
      var selections = this._selections;
      
      //Special case for tooltip, we need refactor tooltip
      //Get transform for main module, tooltip needs the boundary
     var layoutInfo = this._layout;
      if ( modules['tooltip'] ) {
        modules['tooltip'].plotArea({
          'x' : layoutInfo['main'].x,
          'y' : layoutInfo['main'].y,
          'width' : modules['main'].width(),
          'height' : modules['main'].height()
        }).zone({ 'width' : this.width(), 'height' : this.height() });
      }
    };
    
    RootContainer.prototype.destroy = function() {
      RootContainer.superclass.destroy.apply(this, arguments);
      //set null to all properties which holds html elements
      this._rc_container = null;
      if(this._rc_effectManager && this._rc_effectManager.destroy){
        this._rc_effectManager.destroy();
      }
    };
    
    return RootContainer;
});
define('sap/viz/modules/manifests/BaseContainer',['sap/viz/modules/manifests/Module','sap/viz/modules/Constants'],
function Setup ( Manifest, Constants) {
  
  var module = {
    id : "sap.viz.modules.basecontainer",
    type : Constants.Type.Container,
    'abstract' : true, //seems abstract is keyword in YUI compressor
    name : "BaseContainer",
    renderto : Constants.RenderTo.SVG,
    description : "Represents the abstract base container.",
    properties : {
      layout : {
        name : 'layout',
        description : 'Layout properties',
        supportedValueType : 'Object',
        supportedValues : {
          adjustPolicy : {
            name : 'adjustPolicy',
            supportedValueType : 'String',
            defaultValue : undefined,
            description : 'Indicates the layout adjust policy.',
            isExported : false
          },
          padding : {
            name : 'padding',
            supportedValueType : 'PositiveInt',
            defaultValue : 24,
            description : 'Universal padding value settings. The single value will be applied to all laterals of the chart area. Explicit settings for each edge are supported.',
            'example': "<a href='"+Constants.DocExample.SnippetUrl+"4609' target='_blank'>"+Constants.DocExample.TryThisValue+"</a>"
          },
          'paddingTop' : {
            name : 'paddingTop',
            supportedValueType : 'PositiveInt',
            defaultValue : undefined,
            description : 'Padding value for the top side',
           'example': "<a href='"+Constants.DocExample.SnippetUrl+"4609' target='_blank'>"+Constants.DocExample.TryThisValue+"</a>"
          },
          'paddingLeft' : {
            name : 'paddingLeft',
            supportedValueType : 'PositiveInt',
            defaultValue : undefined,
            description : 'Padding value for the left side',
            'example': "<a href='"+Constants.DocExample.SnippetUrl+"4609' target='_blank'>"+Constants.DocExample.TryThisValue+"</a>"
          },
          'paddingRight' : {
            name : 'paddingRight',
            supportedValueType : 'PositiveInt',
            defaultValue : undefined,
            description : 'Padding value for the right side',
            'example': "<a href='"+Constants.DocExample.SnippetUrl+"4609' target='_blank'>"+Constants.DocExample.TryThisValue+"</a>"
          },
          'paddingBottom' : {
            name : 'paddingBottom',
            supportedValueType : 'PositiveInt',
            defaultValue : undefined,
            description : 'Padding value for the bottom side',
            'example': "<a href='"+Constants.DocExample.SnippetUrl+"4609' target='_blank'>"+Constants.DocExample.TryThisValue+"</a>"
          },
          vgap : {
            name : 'vgap',
            supportedValueType : 'PositiveInt',
            defaultValue : 8,
            description : 'Vertical gap value between UI components',
            isExported : false
          },
          hgap : {
            name : 'hgap',
            supportedValueType : 'PositiveInt',
            defaultValue : 8,
            description : 'Horizontal gap value between UI components',
            isExported : false
          }
        }
      }
    },
    events : {
      selectData : Constants.Event.SelectData.desc,
      deselectData : Constants.Event.DeSelectData.desc,
      showTooltip : Constants.Event.TooltipShow.desc,
      hideTooltip : Constants.Event.TooltipHide.desc
    },
    configure : null
  };
  
  Manifest.register(module);
  
});
define('sap/viz/modules/manifests/RootContainer',['sap/viz/modules/manifests/Module','sap/viz/modules/Constants','sap/viz/modules/rootContainer', 'sap/viz/modules/manifests/BaseContainer'],
function Setup ( Manifest, Constants, fn ) {
  
  var module = {
    id : "sap.viz.modules.rootContainer",
    base : "sap.viz.modules.basecontainer",
    type : Constants.Type.Container,
    name : "rootContainer",
    description : "Represents the root container.",
    fn : fn
  };
  
  Manifest.register(module);
  
});
define('sap/viz/modules/title',['sap/viz/base/utils/oo','sap/viz/modules/Base','sap/viz/util/TextUtils','sap/viz/lang/langManager','sap/viz/base/utils/Objects','sap/viz/modules/util/BoundUtil', 'sap/viz/base/UADetector'],
function Setup ( oo, Base, TextUtils, langManager, Objects, boundings, UADetector ) {

	var Title = function ( manifest, ctx ) {
		this._ttl_width = 0;
		this._ttl_height = 0; 
		this._ttl_titleStyle = null;
		this._ttl_options = manifest.props(null);
		this._ttl_size = { width : 500, height : 100 }, 
		this._ttl_titleText = '';
		this._ttl_ctx = ctx;
	};

	oo.extend(Title,Base);

	Title.prototype.render = function ( selection ) {
      if ( this._ttl_options.visible ) {
        boundings.drawBound(selection, this._ttl_width, this._ttl_height);
        this._ttlfn_updateTitleStyle();
        
        var wrapper = selection.selectAll('text.v-title').data([this._ttl_titleText]);
        wrapper.exit().remove();
        wrapper
          .enter()
          .append('text')
          .attr('class', 'v-title viz-title-label');
          
        this._ttl_ctx.styleManager
          .queryDefault('v-title')
          .toAttrs(wrapper);
        var that = this;
          
        wrapper.attr('text-anchor', function () {
          if ( that._ttl_options.alignment === 'right' ) {
            return 'end';
          }
          else if ( that._ttl_options.alignment === 'left' ){
           return 'start';
          }
          else {
            return 'middle'; 
          }
        })
        .attr('x', function () {
          if ( that._ttl_options.alignment === 'right' ){
            return that._ttl_width;
          }
          else if (that._ttl_options.alignment === 'left'){
            return 0;
          }
          else {
            return that._ttl_width / 2; //"center" anyway
          }
        })
        .attr('y', this._ttl_height /2 )
        .attr('dominant-baseline', 'central');
        if(UADetector.isIE()){
          wrapper.attr('y', this._ttl_height ).attr('dominant-baseline', 'auto');
        }
        
        TextUtils.ellipsis(this._ttl_titleText, wrapper.node(), this._ttl_width, this._ttl_titleStyle);
      }
      else
      {
        selection.selectAll('text.v-title').remove();
      }
    };

    Title.prototype.width = function ( value ) {
      if ( !arguments.length ) {
        return this._ttl_width;
      }
      this._ttl_width = value;
      return this;
    };

    Title.prototype.height = function ( value ) {
      if ( !arguments.length ) {
        return this._ttl_height;
      }
      this._ttl_height = value;
      return this;
    };
    
    Title.prototype.size = function ( value ) {
      if ( !arguments.length ) {
        return this._ttl_size;
      }
      this._ttl_size = value;
      return this;
    };
    
    Title.prototype.destroy = function() {
      //destroy ctx
      if(this._ttl_ctx){
        this._ttl_ctx.destroy();
        this._ttl_ctx = null;
      }
    };

    Title.prototype.properties = function ( properties ) {
      if ( !arguments.length ) {
        return this._ttl_options;
      }
      Objects.extend(true, this._ttl_options, properties);

      if ( this._ttl_options.text === '' || this._ttl_options.text === null) {
        this._ttl_titleText = langManager.get('IDS_DEFAULTCHARTTITLE');
      } else {
        this._ttl_titleText = this._ttl_options.text;
      }

      return this;
    };
    
    Title.prototype.getPreferredSize = function () {
      if ( this._ttl_options.visible ) {
        this._ttlfn_updateTitleStyle();
        var titleSize = TextUtils.measure(this._ttl_titleText, this._ttl_titleStyle);
        var minSize = TextUtils.measure('M...', this._ttl_titleStyle);
        return {
          hideOversize : true,
          maxSizeConstant : 1 / 3,
          'width' : titleSize.width,
          'height' : titleSize.height,
          minWidth : minSize.width,
          minHeight : minSize.height,
          maxWidth : titleSize.width,
          maxHeight : titleSize.height
        };
      }
      
      return { maxWidth : 0, maxHeight : 0, minWidth : 0, minHeight : 0, 'width' : 0, 'height' : 0 };      
    };
    
    Title.prototype._ttlfn_updateTitleStyle = function () {
      this._ttl_titleStyle = this._ttl_ctx.styleManager.query('v-title').toString();
    };

	return Title;
});
define('sap/viz/modules/manifests/Title',['sap/viz/modules/manifests/Module','sap/viz/modules/Constants','sap/viz/modules/title'],
function Setup(Manifest, Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.title',
    'type' : Constants.Type.Supplementary,
    'name' : 'title',
    'description': "Settings for the chart's main title.",
    'properties' : {
      'visible' : {
        'name' : 'visible',
        'supportedValueType' : 'Boolean',
        'defaultValue' : false,
        'description' : 'Set visibility of chart title.'
      },
      'text' : {
        'name' : 'text',
        'supportedValueType' : 'String',
        'defaultValue' : null,
        'description' : 'Set chart title text.'
      },
      'alignment' : {
        'name' : 'alignment',
        'supportedValueType' : 'String',
        'supportedValues' : [ 'left', 'center', 'right' ],
        'defaultValue' : 'center',
        'description' : 'Set chart title alignment.'
      },
      'layout' : {
        'name' : 'layout',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'position' : {
            'name' : 'position',
            'supportedValueType' : 'String',
            'defaultValue' : 'right',
            'description' : 'Set the position of the title.',
          },
          'priority' : {
            'name' : 'priority',
            'supportedValueType' : 'Int',
            'defaultValue' : 0,
            'description' : 'Set the priority of the position for the title.',
            'isExported' : false
          },           
        },
        'description' : 'Settings for layout of title.',
        'isExported' : false
       },
    },
    'css' : {
      '.viz-title-label.v-title' : {
        'description' : 'Define style for the title label.',
        'value' : {
          'font-family' : "'Open Sans', Arial, Helvetica, sans-serif",
          'font-size' : '16px',
          'font-weight' : 'bold',
          'fill' : '#333333'
        }
      }
    },
    'configure' : null,
    fn : fn
  };

  Manifest.register(module);
});
define('sap/viz/modules/layout/stack',[],
function Setup () {
  
  function stack_sortDefault (a, b) { return a.order - b.order; }
  function stack_sizeDefault (x) { return x.size(); }
  function stack_orderDefault (x) { return x.order; }
  
  var _ = function () {
    var sort = stack_sortDefault,
        size = stack_sizeDefault,
        order = stack_orderDefault,
        gravity = -1, // top or bottom alignment
        position = 'right',
        spacing = 0,
        width = 0,
        height = 0;
    
    function stack () {
      var data = arguments[0].slice().sort(stack_sortDefault),
        align = arguments[1],
        result = {},
        isEnough = false,
        preSizeInfo = _setSizeInfoByOrientation(data);
      
      var start = 0, _finalSize, 
        _availableSize = preSizeInfo.availableSize,
        _referenceSize = preSizeInfo.referenceSize,
        _referenceMinSizes = preSizeInfo.referenceMinSizes,
        _maxSizes = preSizeInfo.maxSizes,
        _minSizes = preSizeInfo.minSizes,
        _totalSize = {width : 0, height: 0},
        _maxSize, _minSize;
      
      if (d3.sum(_maxSizes) <= _availableSize) {
        isEnough = true;
      }
      
      data.forEach(function(d, i) {
        var anchor = { x : 0, y : 0 }; 
        
        _maxSize = _maxSizes[i];
        _minSize = _minSizes[i];
        
        if( i > 0 ){
          start = start + spacing;
        }
        
        if(position === 'top' || position === 'bottom'){
          anchor.x = start;
        }else{
          anchor.y = start;
        }
          
        if (isEnough && _referenceMinSizes[i] < _referenceSize) {
          start = start + _maxSize;
          _finalSize = _maxSize;
        } else {
          // No enough
          if (_availableSize < _minSize || _referenceMinSizes[i] > _referenceSize) {
            d.module.width(0).height(0);
            return anchor;
          } else if (_availableSize > _maxSize) {
            start = start + _maxSize;
            _finalSize = _maxSize;
            _availableSize = _availableSize - _maxSize;
          } else {
            start = start + _availableSize;
            _finalSize  = _availableSize;
            _availableSize = 0;
          }
        }
        
        //Set module size
        if(position === 'top' || position === 'bottom'){
          d.module.height(height).width(_finalSize);
          _totalSize.width = _finalSize + _totalSize.width;
          _totalSize.height = height;
        }else{
          d.module.width(width).height(_finalSize);
          _totalSize.height = _finalSize + _totalSize.height;
          _totalSize.width = width;
        }

//        if (align === 'right' && (w = maxWidth(d)) < width) {
//          anchor.x = width - w;
//        }

        /* if ( align === 'center' ) {  TODO add support  }*/

        result[d.module.alias] = anchor;
      });

      //Alignment
//      if(position === 'top' || position === 'bottom'){
//        var gap = width - _totalSize.width;
//        if(gap > 0){
//          data.forEach(function(d, i) {
//            if(result[d.module.alias]){
//              result[d.module.alias].x = result[d.module.alias].x + gap/2;
//            }
//          });
//        }
//      }
      
      return result;
    }
    
    stack.sort = function (x) {
      if ( !arguments.length ) { return sort; }
      sort = x;
      return stack;
    };
    
    stack.size = function (x) {
      if ( !arguments.length ) { return size; }
      size = x;
      return stack;
    };
    
    stack.gravity = function (x) {
      if ( !arguments.length ) { return gravity; }
      gravity = x;
      return stack;
    };
    
    stack.order = function (x) {
      if ( !arguments.length ) { return order; }
      order = x;
      return stack;
    };
    
    stack.width = function (x) {
      if ( !arguments.length ) { return width; }
      width = x;
      return stack;
    };
    
    stack.height = function (x) {
      if ( !arguments.length ) { return height; }
      height = x;
      return stack;
    };
    
    stack.position = function(_){
      if(!arguments.length) {
        return position;
      }
      position = _;
      return stack;
    };
    
    stack.spacing = function(_){
      if(!arguments.length) {
        return spacing;
      }
      spacing = _;
      return stack;
    };
    
    stack.data = function () { return stack; };
    stack.properties = function () { return stack; };
    
    var _setSizeInfoByOrientation = function(data){
      var availableSize, refSize, maxSizes = [], minSizes = [], preSize, refMinSizes = [];
      if(position === 'top' || position === 'bottom'){
        //Horizontal layout
        availableSize = width;
        refSize = height;
        
        data.forEach(function(d) {
          preSize = size(d);
          maxSizes.push(preSize.maxWidth);
          minSizes.push(preSize.minWidth);
          refMinSizes.push(preSize.minHeight);
        });
      }else{
        //Vertical layout
        availableSize = height;
        
        data.forEach(function(d) {
          preSize = size(d);
          maxSizes.push(preSize.maxHeight);
          minSizes.push(preSize.minHeight);
          refMinSizes.push(preSize.minWidth);
        });
      }
      return {
        'availableSize' : availableSize,
        'referenceSize' : refSize,
        'maxSizes' : maxSizes,
        'minSizes' : minSizes,
        'referenceMinSizes' : refMinSizes
      };
    };
    
    return stack;
  };
  
  return _;
  
});
define('sap/viz/modules/legend',['jquery','sap/viz/modules/Constants','sap/viz/modules/manifests/Module','sap/viz/util/ignite','sap/viz/util/append',
'sap/viz/base/utils/Objects','sap/viz/modules/dispatch','sap/viz/modules/layout/stack'],
function Setup ( $, registry, category, ignite, append, objects, evts, stack ) {
  
  var _ = function ( manifest, context ) {
    var width = 0,
        height = 0,
        maxWidth = 0,
        maxHeight = 0,
        properties = {},
        innerProperties = manifest.props(null),//set an inner properties list to maintain contain's private properties.
        data = {},
        config = {},
        parentNode = null,
        children = {},
        selections = {},
        dispatch = evts('relayout', 'initialized'),
        charger = {},
        initComplete = false;
    
    var PROPERTYCATEGORY = 'legendGroup', SPACING = 0;

    // TODO redundant logic to be abstracted out
    function init ( data, attrs, conf ) {
      var children = {};
      
      $.each(conf.modules, function ( key, value ) {
        if ( value === null ) { return; }
        var dataset = value.data ? data.createDataAdapterForModule(value.data) : data,
            type = category.get(value.id).type;
        
        children[key] = ignite(value.id, context, 'v-m-' + key);
        children[key].alias = key;
        
        if ( key !== 'layout' ) {
          selections[key] = append.apply(parentNode, [ 'g', { 'class' : 'v-m-' + key } ]);
        }
        
        if ( type !== registry.Type.Container ) {
          children[key].data(dataset)
            .properties(_setLegendPositionPro(attrs[PROPERTYCATEGORY], objects.extend(
              true, 
              {}, 
              value.configure ? value.configure.properties : {}, 
              value.configure ? attrs[value.configure.propertyCategory] : {})));
          
          if ( children[key].parent ) { children[key].parent(selections[key]); }
        }
      });
      
      initComplete = true; 
      return children;
    }
    
    function layout () {
      var algorithm = children.layout, 
          components = [],
          props = properties.legendGroup ? 
                  properties.legendGroup.layout : manifest.props().layout,
          alignment = 'left', // alignment for legend stack always at left
          result = {};
      
      algorithm
        .width(width)
        .height(height)
        .gravity(-1)
        .spacing(SPACING)
        .position(props.position)
        .size(function (d) { return d.module.getPreferredSize(); })
        .sort(function (a, b) { return a.order - b.order; });
      
      $.each(config.modules, function ( key, value ) {
        if ( value === null ) { return; }
        if ( !value.configure || !value.configure.properties || !value.configure.properties.layout ) { 
          return;
        }
        
        if ( value.configure.properties.layout ) {
          components.push({
            module : children[key],
            order : value.configure.properties.layout.order
          });
        }
      });
      
      result = algorithm(components, alignment);

      $.each(result, function ( key, value ) {
        selections[key].attr('transform', 
          'translate(' + value.x + ',' + value.y + ')');
      });
    }
    
    function chart ( selection ) {
      selection.each(function (d) {
        layout();
        $.each(children, function ( key, value ) {
          if ( key !== 'layout' ) { selections[key].call(value); }
        });
      });
      
      dispatch.initialized();
    }
    
    chart.width = function (x) {
      if ( !arguments.length ) { return width; }
      width = x;
     // FIXME remove it
     for ( var key in children ) {
       if ( children.hasOwnProperty(key) ) {
         children[key].width(x);
       }
     }
      return chart;
    };
    
    chart.height = function (x) {
      if ( !arguments.length ) { return height; }
      height = x;
      // FIXME remove it
      for ( var key in children ) {
        if ( children.hasOwnProperty(key) ) {
          children[key].height(x);
        }
      }
      return chart;
    };
    
    chart.size = function (xs) {
      if ( !arguments.length ) { return { width : width, height : height }; }
      width = xs.width;
      height = xs.height;
      return chart;
    };
    
    chart.properties = function (xs) {
      if ( !arguments.length ) { return innerProperties; }
      properties = $.extend(true, {}, properties, xs);
      if (properties[PROPERTYCATEGORY]){
        objects.extend(true, innerProperties, properties[PROPERTYCATEGORY]);
      }
      $.each(children, function ( key, value ) {
        if ( config.modules[key].configure ) {
          value.properties(_setLegendPositionPro(properties[PROPERTYCATEGORY], properties[config.modules[key].configure.propertyCategory]));
        }
      });
      
      if ( !$.isEmptyObject(config) && !$.isEmptyObject(data) && !initComplete ) {
        children = init(data, properties, config);
      }
      
      return chart;
    };
    
    chart.config = function (xs) {
      if ( !arguments.length ) { return config; }
      config = xs;
      
      if ( !$.isEmptyObject(properties) && !$.isEmptyObject(data) && !initComplete ) {
        children = init(data, properties, config);
      }
      
      return chart;
    };
    
    chart.dispatch = function (x) {
      if ( !arguments.length ) { return dispatch; }
      dispatch = x;
      return chart;
    };
    
    chart.data = function (xs) {
      if ( !arguments.length ) { return data; }
      data = xs;
      
      $.each(children, function ( key, value ) {
        if ( config.modules[key].data ) {
          value.data(data.createDataAdapterForModule(config.modules[key].data));
        } else {
          value.data(data);
        }
      });
      
      if ( !$.isEmptyObject(config) && !$.isEmptyObject(properties) && !initComplete ) {
        children = init(data, properties, config);
      }
      
      return chart;
    };
    
    chart.parent = function (x) {
      if ( !arguments.length ) { return parentNode; }
      parentNode = x;
      return chart;
    };
    
    // Means of wiring up module dependencies
    chart.recharge = function (x) {
      if ( !arguments.length ) { return charger; }
      charger = x;
      return chart;
    };
    
    chart.modules = function (xs) {
      if ( !arguments.length ) { return children; }
      children = xs;
      return chart;
    };
    
    chart.maxHeight = function (x) {
      if ( !arguments.length ) { return maxHeight; }
      maxHeight = x;
      return chart;
    };
    
    chart.maxWidth = function (x) {
      if ( !arguments.length ) { return maxWidth; }
      maxWidth = x;
      return chart;
    };
    
    chart.getPreferredSize = function () {
      var minWidths = [], maxWidths = [], minHeights = [], maxHeights = [];
      
      $.each(children, function ( key, value ) {
        if ( key === 'layout' ) { return; }
        var size = value.getPreferredSize();
        minWidths.push(size.minWidth);
        minHeights.push(size.minHeight);
        maxWidths.push(size.maxWidth);
        maxHeights.push(size.maxHeight);
      });
      
      var minimums = {
        width : d3.min(minWidths),
        height : d3.min(minHeights)
      },
      maximums = {
        width : d3.max(maxWidths),
        height : d3.max(maxHeights)
      };
      
      var props = properties.legendGroup ? properties.legendGroup.layout : manifest.props().layout, 
          position, i = 0;
      position = props.position;
      
      if(position === 'top' || position === 'bottom'){
        for ( i = 0; i < minHeights.length; i++ ) {
          if ( minHeights[i] > maxHeight ) {
            maximums.height = d3.min(maxHeights);
          }
        }
      }else{
        for ( i = 0; i < minWidths.length; i++ ) {
          if ( minWidths[i] > maxWidth ) {
            maximums.width = d3.min(maxWidths);
          }
        }
      }
    
      return {
        minWidth : minimums.width,
        maxWidth : maximums.width,
        minHeight : minimums.height,
        maxHeight : maximums.height
      };
    };
    
    chart.destroy = function(){
      selections = null;
      parentNode = null;
      data = null;
      dispatch.on('relayout', null);
      dispatch.on('initialized', null);
      //destroy ctx
      if(context){
        context.destroy();
        context = null;
      } 
    };
    
    var _setLegendPositionPro = function(groupPros, legendPros){
      if(groupPros && groupPros.layout && groupPros.layout.position){
        if(legendPros === undefined){
          legendPros = {};
        }
        legendPros.position = groupPros.layout.position;
      }
      return legendPros;
    };
    return chart;
  };
  
  return _;
  
});
define('sap/viz/modules/manifests/Legend',['sap/viz/modules/manifests/Module','sap/viz/modules/Constants','sap/viz/modules/legend'],
function Setup(Manifest, Constants, fn) {
  var module = {
    id : 'sap.viz.modules.legend',
    type : Constants.Type.Container,
    name : 'legend',
    description: 'The legend is a box containing a symbol and name for each series item or point item in the chart.',
    properties : {
		'layout' : {
        'name' : 'layout',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'position' : {
            'name' : 'position',
            'supportedValueType' : 'String',
            'supportedValues' : [ 'top', 'bottom', 'right', 'left' ],
            'defaultValue' : 'right',
            'description' : 'Set the position of the legend area.',
            'example': "<a href='"+Constants.DocExample.SnippetUrl+"4945' target='_blank'>"+Constants.DocExample.TryThisValue+"</a>"
          },
          'priority' : {
            'name' : 'priority',
            'supportedValueType' : 'Int',
            'defaultValue' : 1,
            'description' : 'Set the priority of the position for the legend area.',
			'isExported' : false
          },           
        },
        'description' : 'Settings for layout of legend area.'
      },
    },
    css : {
      
    },
    configure : null,
    fn : fn
  };

  Manifest.register(module);
});
define('sap/viz/modules/datalabel',['sap/viz/util/TextUtils','sap/viz/base/utils/TypeUtils','sap/viz/format/FormatManager','sap/viz/manifest',
'sap/viz/base/utils/Objects','sap/viz/modules/dispatch'],
function Setup(TextUtils, TypeUtils, formatManager, Manifest,Objects, Dispatch){
    var dataLabel = function(manifest, ctx){
      var fontSize = '12px', fontColor = '#333333', fontFamily = '"Open Sans" Arial, Helvetica, sans-serif', fontWeight = 'normal';
      var properties = manifest.props(null);
      var dataLabel,                      // labels of each datashapesgroup
          dataLabels,                     // all labels, it must be two-dimension array
          originalLabels;                 // used for smartLayout, it must be one-dimension array
      var gPlot, parentNodeBBox;
      var labelStyle;
      var _SVGRoot;
      var _dispatch = new Dispatch("initialized");
      
      /*
       * Properties that needed for different charts.
       * Data label is designed as a general module, but different charts do have different requirements. Most of these properties are used for this reason.
       */
      var labelOrientation = 'horizontal',  // label can be horizontal or vertical
          orientation,                      // chart orientation, it is used during smart layout. if it is vertical, the move is from middle to top or bottom; if it is horizontal, the move is from middle to left or right.
          paintingMode,                     // the kind of coordinate system
          visible,                          // show or hide data label
          position,                         // data label can be inside or outside
          automaticInOutside,               // if the data label is longer than its owner element, move label out of it.
          formatString, isPercentMode, isStackMode, showZero, outsideVisible, outsidePosition, positionPreference,
          isGeoChart,    
          isMekko,
          isTreeMapChart,
          type;                             // label type, for now, two types, 1, value 2 label and value
      var isDonut = false;
      var heatMapLabelFontColor = '#ffffff', isHeatMap = false, isOneCategoryHeatmap = false, padding = 2, isTreeMap = false, treeMapLabelFontColor = '#ffffff';

      function label (){}
      
      label.removeLabel = function(){
        if(TypeUtils.isExist( gPlot.parent())){
          gPlot.parent().selectAll('g.v-m-datalabel').remove();
        }
      };
      
      /**
       * [08-Jan-2012 Nick]
       */
      label.showLabel = function(){
        if (gPlot === null) {
            return;
        }
        if(visible && gPlot.parent()){
          getCSSSetting();
          gPlot.parent().selectAll('g.v-m-datalabel').remove();
          if (!isGeoChart) {
            parentNodeBBox = gPlot.parent().select('.v-bound')[0][0].getBoundingClientRect();//gPlot.parent().node().getBoundingClientRect();
          } else {
            parentNodeBBox = gPlot.parent().node().getBoundingClientRect();
          }
          prepareLabel(parentNodeBBox);
          if(dataLabel.length === 0){
            _dispatch.initialized();
            return;
          }

          labelStyle = 'fill:' + fontColor + '; font-family: ' + fontFamily + '; font-weight: ' + fontWeight +'; font-size: '+ fontSize +"; text-anchor:start";
          var datashapesgroups = gPlot.parent().selectAll('.v-datashapesgroup');
              datashapesgroups.each(function(d,i){
                var labelGroup = d3.select(this).selectAll('g.v-m-datalabel').data([dataLabels[i]]);
                    labelGroup = labelGroup.enter().append('g').attr('class','v-m-datalabel').append('g').attr('class','v-datalabel');
                    ctx.styleManager.query('v-datalabel').toAttrs(labelGroup);
                    if (isHeatMap) {
                      labelGroup.attr('fill',heatMapLabelFontColor);
                    } else if (isTreeMap) {
                      labelGroup.attr('fill',treeMapLabelFontColor);
                    }
                  
                    labelGroup.each(function(labels, index){
                      var dLabel = d3.select(this).selectAll('text').data(labels);
                      var text = dLabel.enter().append('g')
                                   .attr('transform',function(label){
                                       return label.transformString;
                                   });
                      text.each(function(d, i){
                        //we can also find main shape through data
                        var currd = gPlot.parent().selectAll('.v-datapoint').data()[i];
                        //register decoration to main shape
                        if(TypeUtils.isExist(currd.decoras)){
                          currd.decoras.push(this);
                        }
                      });
                      text = text.append('text');
                      text.text(function(d) {
                        return d.value;
                      });
                      text.attr('visibility', 'hidden');
                      
                      text.attr('x', function(d){
                            return d.x;
                          })
                          .attr('y', function (d) {
                            return d.y;
                          });
                   
                      if(labelOrientation === 'vertical'){
                        text.attr('transform',function(d){
                          return 'rotate(270 '+d.centerX + ',' + d.centerY + ')';
                        });
                      }
                      
                    });
              });
              smartLayout();
        }
        _dispatch.initialized();
      };
      
      function smartLayout() {
        var gElements = gPlot.parent().selectAll('.v-datalabel text')[0];//gPlot.parent().selectAll('rect.viz-event-sub-layer')[0][0].getBoundingClientRect();
        var labels = [], label, plotArea = {};
        var i;
        for (i = 0; i < gElements.length; i++) {
          label = {};
          var elementBBox = gElements[i].getBoundingClientRect();
          label.top = elementBBox.top; 
          label.left = elementBBox.left; 
          label.right = elementBBox.right; 
          label.bottom = elementBBox.bottom; 
          label.visible = true;
          label.needMove = false;
          label.x = 0;
          label.y = 0;
          labels.push(label);
        }
        
        plotArea.top = parentNodeBBox.top;
        plotArea.left = parentNodeBBox.left;
        plotArea.right = parentNodeBBox.right;
        plotArea.bottom = parentNodeBBox.bottom;
        
        automaticLayout(originalLabels, labels, plotArea);
        removeUnqualifiedLabels(labels, plotArea);
        
        for (i = 0; i < labels.length; i++) {
          if (labels[i].visible) {
            if (labels[i].needMove) {
              gElements[i].setAttribute('x', labels[i].x);
              gElements[i].setAttribute('y', labels[i].y);
            }
            gElements[i].setAttribute('visibility', 'visible');
          } else {
            gElements[i].parentNode.parentNode.removeChild(gElements[i].parentNode);
          }
        }
      }
      
      function getCSSSetting() {
        var dataLabelStyle = ctx.styleManager.query('v-datalabel');
        if(dataLabelStyle){
          if(dataLabelStyle['fill']){
            fontColor = dataLabelStyle['fill'];
          }
          if(dataLabelStyle['font-family']){
            fontFamily = dataLabelStyle['font-family'];
          }
          if(dataLabelStyle['font-size']){
            fontSize = dataLabelStyle['font-size'];
          }
          if(dataLabelStyle['font-weight']){
            fontWeight = dataLabelStyle['font-weight'];
          }
//          labelStyle = 'fill:' + fontColor + '; font-family: ' + fontFamily + '; font-size: '+ fontSize +";";
        }
      }
      
      function formatDataLabel(value,dataPoint){
        if(TypeUtils.isExist(formatString)){
          var formatedValue, iFormatString, indexOfiFS, indexOfctx;
          //for bubble ,val is an array , datalebel will display y .so just format the y value.
          if(TypeUtils.isArray(dataPoint.__data__.val)){
            indexOfctx = isGeoChart ?  0 : 1;
            if (dataPoint.__data__.ctx.length === 1){
              indexOfctx = 0;
            }
            iFormatString = formatString[0];
            indexOfiFS = dataPoint.__data__.ctx[indexOfctx].path.mi >= iFormatString.length ? iFormatString.length -1 : dataPoint.__data__.ctx[indexOfctx].path.mi;

            formatedValue = formatManager.format(value, iFormatString[indexOfiFS]);
          }else{
             //it is possible that ctx is an array, but val is not an array.
            if(TypeUtils.isArray(dataPoint.__data__.ctx))
            {
                iFormatString = formatString[dataPoint.__data__.ctx[0].path.mg];
            }
            else
            {
                iFormatString = formatString[dataPoint.__data__.ctx.path.mg];
            }
            //if this array is null of undefined, we will use default value
            if(TypeUtils.isExist(iFormatString)){
              if(TypeUtils.isArray(dataPoint.__data__.ctx))
              {
                  indexOfiFS = dataPoint.__data__.ctx[0].path.mi >= iFormatString.length ? iFormatString.length -1 : dataPoint.__data__.ctx[0].path.mi;
              }
              else
              {
                  indexOfiFS = dataPoint.__data__.ctx.path.mi >= iFormatString.length ? iFormatString.length -1 : dataPoint.__data__.ctx.path.mi;
              }
              formatedValue = formatManager.format(value, iFormatString[indexOfiFS]);
            }else{
              formatedValue = value;
            }
          }
          return formatedValue;
        }
        return value;
      }

      
      
      var automaticLayout = function(srcLabels, desLabels, plotArea) {
        
        var _isStackMode = isStackMode, _isPercentMode = isPercentMode, _automaticInOutside = automaticInOutside, _showZero = showZero, _isGeoChart = isGeoChart, _orientation = orientation, _position = position;
        if (srcLabels !== null && desLabels !== null) {
          for (var i = 0; i < srcLabels.length; i++) {
            if (i < desLabels.length) {
              if (TypeUtils.isExist(srcLabels[i].metaInfo)) {
                if (srcLabels[i].metaInfo.chart === 'combination' && srcLabels[i].metaInfo.element === 'line') {
                  _automaticInOutside = false;
                }
              }
              if (!_isStackMode && !_isPercentMode && _automaticInOutside) {
                
                if (_orientation === 'horizontal') {
                  if (_showZero && srcLabels[i].originalValue === 0 && !_isGeoChart) {
                    var bbox1 = srcLabels[i].datapointRect;
                    desLabels[i].needMove = true;
                    desLabels[i].x = srcLabels[i].outsideX;
                    desLabels[i].y = srcLabels[i].outsideY;
                    desLabels[i].left = bbox1.right;
                    desLabels[i].right = bbox1.right + srcLabels[i].width;
                    if (isCrossBorder(desLabels[i], plotArea)) {
                      desLabels[i].visible = false;
                    }
                  } else if (_position === 'inside') {
                    if (srcLabels[i].width > srcLabels[i].ownerWidth || isCrossBorder(desLabels[i], plotArea)) {
                      desLabels[i].needMove = true;
                      desLabels[i].x = srcLabels[i].outsideX;
                      desLabels[i].y = srcLabels[i].outsideY;
                      var boundingBox1 = srcLabels[i].datapointRect; 
                      if (srcLabels[i].originalValue > 0) {
                        desLabels[i].left = boundingBox1.left + srcLabels[i].ownerWidth;
                        desLabels[i].right = boundingBox1.right + srcLabels[i].width;
                      } else {
                        desLabels[i].left =  boundingBox1.left - srcLabels[i].width;
                        desLabels[i].right = boundingBox1.right - srcLabels[i].ownerWidth;
                      }
                    }
                    
                    if (isCrossBorder(desLabels[i], plotArea)) {
                      desLabels[i].visible = false;
                    }
                  } else if (_position === 'outside') {
                    if (isCrossBorder(desLabels[i], plotArea)) {
                      if (srcLabels[i].width <= srcLabels[i].ownerWidth) {
                        desLabels[i].needMove = true;
                        desLabels[i].x = srcLabels[i].insideX;
                        desLabels[i].y = srcLabels[i].insideY;
                        var boundingBox2 = srcLabels[i].datapointRect;
                        if (srcLabels[i].originalValue > 0) {
                          desLabels[i].left = boundingBox2.left + (srcLabels[i].ownerWidth - srcLabels[i].width) / 2;
                          desLabels[i].right = boundingBox2.right - (srcLabels[i].ownerWidth - srcLabels[i].width) / 2;                      
                        } else {
                          desLabels[i].left = boundingBox2.left + (srcLabels[i].ownerWidth - srcLabels[i].width) / 2;
                          desLabels[i].right = boundingBox2.right - (srcLabels[i].ownerWidth - srcLabels[i].width) / 2;
                        }
                        
                        if (isCrossBorder(desLabels[i], plotArea)) {
                          desLabels[i].visible = false;
                        }
                      } else {
                        desLabels[i].visible = false;
                      }
                    }
                  }
                } else if (_orientation === 'vertical') {
                  if (_showZero && srcLabels[i].originalValue === 0 && !_isGeoChart) {
                    desLabels[i].needMove = true;
                    desLabels[i].x = srcLabels[i].outsideX;
                    desLabels[i].y = srcLabels[i].outsideY;  
                    var bbox2 = srcLabels[i].datapointRect;
                    desLabels[i].top = bbox2.top - srcLabels[i].height;
                    desLabels[i].bottom = bbox2.top;
                    if (isCrossBorder(desLabels[i], plotArea)) {
                      desLabels[i].visible = false;
                    }
                  } else if (_position === 'inside') {
                    if (srcLabels[i].height > srcLabels[i].ownerHeight || isCrossBorder(desLabels[i], plotArea)) {
                      desLabels[i].needMove = true;
                      desLabels[i].x = srcLabels[i].outsideX;
                      desLabels[i].y = srcLabels[i].outsideY;
                      var boundingBox3 = srcLabels[i].datapointRect;
                      if (srcLabels[i].originalValue >= 0) {
                        desLabels[i].top =  boundingBox3.top - srcLabels[i].height;
                        desLabels[i].bottom =  boundingBox3.bottom - srcLabels[i].ownerHeight;   
                      } else {
                        desLabels[i].top = boundingBox3.top + srcLabels[i].ownerHeight;
                        desLabels[i].bottom = boundingBox3.bottom + srcLabels[i].height;               
                      }
                    }
                    
                    if (isCrossBorder(desLabels[i], plotArea)) {
                      desLabels[i].visible = false;
                    }
                  } else if (_position === 'outside') {
                    if (isCrossBorder(desLabels[i], plotArea)) {
                      if (srcLabels[i].height <= srcLabels[i].ownerHeight) {
                        desLabels[i].needMove = true;
                        desLabels[i].x = srcLabels[i].insideX;
                        desLabels[i].y = srcLabels[i].insideY;   
                        var boundingBox4 = srcLabels[i].datapointRect;
                        if (srcLabels[i].originalValue > 0) {
                          desLabels[i].top = boundingBox4.top + (srcLabels[i].ownerHeight - srcLabels[i].height) / 2;
                          desLabels[i].bottom =  boundingBox4.bottom - (srcLabels[i].ownerHeight - srcLabels[i].height) / 2;                      
                        } else {
                          desLabels[i].top = boundingBox4.top + (srcLabels[i].ownerHeight - srcLabels[i].height) / 2;
                          desLabels[i].bottom =  boundingBox4.bottom - (srcLabels[i].ownerHeight - srcLabels[i].height) / 2;                     
                        }               
                        if (isCrossBorder(desLabels[i], plotArea)) {
                          desLabels[i].visible = false;
                        }
                      } else {
                        desLabels[i].visible = false;
                      }
                    }
                  }
                } 
                
              } else if (!_isStackMode && !_isPercentMode && !_automaticInOutside) {
                
                if (_orientation === 'horizontal') {
                  if (_showZero && srcLabels[i].originalValue === 0 && !_isGeoChart && srcLabels[i].width === 0) {
                    var bbox3 = srcLabels[i].datapointRect;
                    desLabels[i].left = bbox3.right;
                    desLabels[i].right = bbox3.right + srcLabels[i].width;
                  } else if (!outsideVisible && srcLabels[i].width > srcLabels[i].ownerWidth) {
                    desLabels[i].visible = false;
                  }
                  
                } else if (_orientation === 'vertical') {
                  if (_showZero && srcLabels[i].originalValue === 0 && !_isGeoChart && srcLabels[i].height === 0) {
                    var bbox4 = srcLabels[i].datapointRect;
                    desLabels[i].top = bbox4.top + srcLabels[i].height;
                    desLabels[i].bottom = bbox4.top;
                  } else if (!outsideVisible) {
                    if (isHeatMap || isTreeMap) {
                      if (isOneCategoryHeatmap || isTreeMap) {
                        if (srcLabels[i].height > srcLabels[i].ownerHeight/2) {
                          desLabels[i].visible = false;
                        }
                      } else {
                        if (srcLabels[i].height > srcLabels[i].ownerHeight) {
                          desLabels[i].visible = false;
                        }
                      }
                      
                      if (srcLabels[i].width > srcLabels[i].ownerWidth) {
                        desLabels[i].visible = false;
                      }
                    } else if (srcLabels[i].height > srcLabels[i].ownerHeight) {
                      desLabels[i].visible = false;
                    }
                  }
                }
                
                if (_showZero && srcLabels[i].originalValue === 0 && _position === 'inside' && !_isGeoChart) {
                  desLabels[i].needMove = true;
                  desLabels[i].x = srcLabels[i].outsideX;
                  desLabels[i].y = srcLabels[i].outsideY;
                } else if (!_showZero && srcLabels[i].originalValue === 0) {
                  desLabels[i].visible = false;
                }
 
                if (isCrossBorder(desLabels[i], plotArea)) {
                  desLabels[i].visible = false;
                }
                
              } else if (_isStackMode) {
                if (_orientation === 'horizontal') {
                  if (isCrossBorder(desLabels[i], plotArea) || (srcLabels[i].width > srcLabels[i].ownerWidth)) {
                    desLabels[i].visible = false;
                  }
                } else if (_orientation === 'vertical') {
                  if (isCrossBorder(desLabels[i], plotArea) || (srcLabels[i].height > srcLabels[i].ownerHeight)) {
                    desLabels[i].visible = false;
                  }
                }
                if (!_isPercentMode && srcLabels[i].originalValue === 0) {
                  desLabels[i].visible = false;
                }
              } else if (_isPercentMode) {
                if (isCrossBorder(desLabels[i], plotArea)) {
                  desLabels[i].visible = false;
                }
              }
            }
          }
          resetFlags();
        }
      };

      var resetFlags = function() {
        isHeatMap = false;
        isOneCategoryHeatmap = false;
        isTreeMap = false;
      };
      
      var parseOptions = function(props){
        orientation = TypeUtils.isExist(props.orientation) ? props.orientation : orientation;
        paintingMode = TypeUtils.isExist(props.paintingMode) ? props.paintingMode : paintingMode;
        visible = TypeUtils.isExist(props.visible) ? props.visible : visible;
        position = TypeUtils.isExist(props.position) ? props.position : position;
        automaticInOutside = TypeUtils.isExist(props.automaticInOutside) ? props.automaticInOutside : automaticInOutside;
        formatString = TypeUtils.isExist(props.formatString) ? props.formatString : formatString;
        isPercentMode = TypeUtils.isExist(props.isPercentMode) ? props.isPercentMode : isPercentMode;
        isStackMode = TypeUtils.isExist(props.isStackMode) ? props.isStackMode : isStackMode;
        isDonut = TypeUtils.isExist(props.isDonut) ? props.isDonut : isDonut;
        showZero = TypeUtils.isExist(props.showZero) ? props.showZero : showZero;
        outsideVisible = TypeUtils.isExist(props.outsideVisible) ? props.outsideVisible : outsideVisible;
        outsidePosition = TypeUtils.isExist(props.outsidePosition) ? props.outsidePosition : outsidePosition;
        isGeoChart = TypeUtils.isExist(props.isGeoChart) ? props.isGeoChart : isGeoChart;
        isMekko = TypeUtils.isExist(props.isMekko) ? props.isMekko : false;
        isTreeMapChart = TypeUtils.isExist(props.isTreeMap) ? props.isTreeMap : false;
        positionPreference = TypeUtils.isExist(props.positionPreference) ? props.positionPreference : positionPreference;
        type = TypeUtils.isExist(props.type) ? props.type : type;
      };
      
      //get customlabel text from from the rawObj, if the type is url, return the original text
      var getCustomlabelText = function(rawObj){
        var ret;
        if(rawObj.info){
          var clobj = rawObj.info.customlabel;
          if(clobj){
            if(clobj.type === 'url'){
              ret = rawObj.val;
            }else if(clobj.type === 'string'){
              ret = clobj.val;
            }
          }else{
            ret = rawObj.val;
          }
        }else{
          ret = rawObj.val;
        }
        return ret;
      };
      var cutDataPointElement = function(elem, boundElemClientRect) {
        var tempbbox = elem.getBBox(),
            tempClientRect = elem.getBoundingClientRect(),
            bbox = {
              x : tempbbox.x,
              y : tempbbox.y,
              width : tempbbox.width,
              height : tempbbox.height
            },
            clientRect = {
              left : tempClientRect.left,
              right : tempClientRect.right,
              top : tempClientRect.top,
              bottom : tempClientRect.bottom,
              width : tempClientRect.width,
              height : tempClientRect.height
            };
        if (clientRect.bottom > boundElemClientRect.top &&
            clientRect.top < boundElemClientRect.bottom &&
            clientRect.left < boundElemClientRect.right && 
            clientRect.right > boundElemClientRect.left) {
          if (clientRect.bottom > boundElemClientRect.bottom) {
            bbox.height -= clientRect.bottom - boundElemClientRect.bottom;
            clientRect.height -= clientRect.bottom - boundElemClientRect.bottom;
            clientRect.bottom = boundElemClientRect.bottom;
          }
          if (clientRect.top < boundElemClientRect.top) {
            bbox.height -= boundElemClientRect.top - clientRect.top;
            bbox.y = boundElemClientRect.top - clientRect.top;
            clientRect.height -= boundElemClientRect.top - clientRect.top;
            clientRect.top = boundElemClientRect.top;
          }
          if (clientRect.left < boundElemClientRect.left) {
            bbox.width -= boundElemClientRect.left - clientRect.left;
            bbox.x = boundElemClientRect.left - clientRect.left;
            clientRect.width -= boundElemClientRect.left - clientRect.left;
            clientRect.left = boundElemClientRect.left;
          }
          if (clientRect.right > boundElemClientRect.right) {
            bbox.width -= clientRect.right - boundElemClientRect.right;
            clientRect.width -= clientRect.right - boundElemClientRect.right;
            clientRect.right = boundElemClientRect.right;
          }
        } 
        return {
          bbox: bbox,
          clientRect: clientRect
        };
      };
      
      var prepareLabel = function(boundElemClientRect){
        _SVGRoot = gPlot.parent()[0][0].ownerSVGElement;
        dataLabel = [], dataLabels = [], originalLabels = [];
        if( _SVGRoot !== null && _SVGRoot.getBBox().width === 0){
          return;
        }
        var i = 0, j = 0, label, plotOffset, tempElement;
        var datashapeOffset, labelSize, percentageValue;
        
        var boundarySelection = gPlot.parent().selectAll('.v-datashapesgroup');
        if(boundarySelection[0].length === 0){
          boundarySelection = gPlot.parent();
        }
        var gElements = boundarySelection.selectAll('.v-datapoint');
        
        if(paintingMode === 'polarCoordinate'){
          for( i = 0 ; i < boundarySelection[0].length; i++){
            var polarBoundaryBox = boundarySelection[0][i].getBBox();
            if (polarBoundaryBox.width === 0 || polarBoundaryBox.height === 0) {
              break;
            }
            plotOffset = boundarySelection[0][i].getTransformToElement(_SVGRoot);
            dataLabel = [];
            for( j = 0 ; j < gElements[i].length; j++){
              label = {};
              tempElement = gElements[i][j];
              datashapeOffset = tempElement.getTransformToElement(_SVGRoot);
              /**
               *  [07-Jan-2012 Nick] 
               *  FIX FOR IE, in some cases, datashapesOffset is null here.
               *  So if it is null, the logic should jump out of here.
               */
              if(!TypeUtils.isExist(datashapeOffset)){
                  break;
              }
              label.dataShape = tempElement;
              var dimensions = '';
              percentageValue = (tempElement.__data__.endAngle - tempElement.__data__.startAngle) / ( 2 * Math.PI);
              label.originalValue = percentageValue;
              percentageValue = formatDataLabel(percentageValue, tempElement);
              /*
               * [18-Dec-2012 Nick] Combine measures and dimensions into one label. (for pie only)
               */
              if(type === 'label and value'){
                var dimensionObjects = tempElement.__data__.dimValueObjects;
                for(var k=0; k < dimensionObjects.length; k++){
                  var subText = getCustomlabelText(dimensionObjects[k]);
                  dimensions += (subText === null? 'No value' : subText);
                  if (dimensionObjects[k].dataTransformInfo && dimensionObjects[k].dataTransformInfo.autoBinning) {
                    break;
                  }
                  if(k !== (dimensionObjects.length - 1)){
                    dimensions += '/';
                  }
                }  
              }
              label.value = dimensions + ' (' + percentageValue + ')';
              
              label.transformString = ('translate(' + (datashapeOffset.e - plotOffset.e) + ',' + (datashapeOffset.f - plotOffset.f) + ')' );

              labelSize = TextUtils.fastMeasure(label.value, fontSize, fontWeight, fontFamily);
              var r = tempElement.__data__.r;           
              var mAngle = (tempElement.__data__.endAngle + tempElement.__data__.startAngle)/ 2;        
              var sinLabelAngle = Math.sin(mAngle);
              var cosLabelAngle = Math.cos(mAngle);
            
              var labelCenterX, labelCenterY;
            
              if(isDonut){
                labelCenterX = 0.65 * r * sinLabelAngle;
                labelCenterY = 0.65 * r * cosLabelAngle;
              }else{
                labelCenterX = 0.5 * r * sinLabelAngle;
                labelCenterY = 0.5 * r * cosLabelAngle;
              }
            
              label.x = 0 + labelCenterX * datashapeOffset.a - labelSize.width/2;
              label.y = 0 - labelCenterY * datashapeOffset.d + labelSize.height/2;
              label.centerX = labelCenterX;
              label.centerY = labelCenterY;
              label.datapointRect = tempElement.getBoundingClientRect();
            
              dataLabel.push(label);
              originalLabels.push(label);
            }
            dataLabels.push(dataLabel);
          }
        }else if(paintingMode === 'rectCoordinate'){
          for( i = 0; i < boundarySelection[0].length; i++){
            var rectBoundaryBox = boundarySelection[0][i].getBBox();
            if (rectBoundaryBox.width === 0 || rectBoundaryBox.height === 0) {
              break;
            }
            plotOffset = boundarySelection[0][i].getTransformToElement(_SVGRoot);
            dataLabel = [];
            for( j = 0 ; j < gElements[i].length; j++){
              label = {};
              tempElement = gElements[i][j];
              datashapeOffset = tempElement.getTransformToElement(_SVGRoot);
              
              /**
               *  [07-Jan-2012 Nick] 
               *  FIX FOR IE, in some cases, datashapesOffset is null here,
               *  so if it is null, the logic should jump out of here.
               */
              if(!TypeUtils.isExist(datashapeOffset)){
                  break;
              }
              label.dataShape = tempElement;
              var temp = cutDataPointElement(tempElement, boundElemClientRect);
              var bbox = temp.bbox;
              var clientRect = temp.clientRect;
              /*
               * [18-Dec-2012 Nick] 
               * For different charts, the requirements of showing label are different.
               * 1. Geo bubble/chorolopeth chart, it has an array of values in __data__.val, but the array only has one object
               * 2. Bubble and scatter has more than one object in __data__.val, but only y member is displayed.
               * 3. for the other charts, show val directly.
               * 4. If __data__.val is an array and it is BarLike, it is mekko.
               */
              var originalValue;
              if(TypeUtils.isArray(tempElement.__data__.val)){
                if(isGeoChart){
                  originalValue = tempElement.__data__.val[0];
                }else{
                  if(isMekko)
                  {
                      if(isPercentMode)
                      {
                          originalValue = tempElement.__data__.value;
                      }
                      else
                      {
                          originalValue = tempElement.__data__.val[0];
                      }
                  }
                  else if(isTreeMapChart)
                  {
                      originalValue = tempElement.__data__.val[0];
                  }
                  else
                  {
                      originalValue = tempElement.__data__.y;
                  }
                }
              }else{
                if(isPercentMode && type === 'value'){
                  originalValue = tempElement.__data__.value;
                }else{
                  originalValue = tempElement.__data__.val;
                }
              }
              if(type !== 'value' && tempElement.__data__.isNegative){
                originalValue = '-' + originalValue;
              }
              var heatMapLabelWidth = 0, heatMapLabelHeight = 0;
              if (tempElement.__data__.isOnlyOneCategory !== undefined) {
                isHeatMap = true;
                if (tempElement.__data__.isOnlyOneCategory) {
                  isOneCategoryHeatmap = true;
                  var heatMapLabel = gPlot.parent().selectAll('text.v-heatmapdatalabel')[0][0];
                  if (heatMapLabel) {
                    var heatmapLabelBBox = heatMapLabel.getBBox();
                    heatMapLabelWidth = heatmapLabelBBox.width;
                    heatMapLabelHeight = heatmapLabelBBox.height;
                  }
                }
              }
              
              var treeMapLabelWidth = 0, treeMapLabelHeight = 0;
              if (tempElement.__data__.isTreeMap !== undefined) {
                isTreeMap = true;
                var treeMapLabel = gPlot.parent().selectAll('text.v-treemapdatalabel')[0][0];
                if (treeMapLabel) {
                  var treeMapLabelBBox = treeMapLabel.getBBox();
                  treeMapLabelWidth = treeMapLabelBBox.width;
                  treeMapLabelHeight = treeMapLabelBBox.height;
                }
              }
        
              label.originalValue = originalValue;
              label.value =  formatDataLabel(originalValue, tempElement);
              if(type === 'label and value'){
                label.value = tempElement.__data__.label + ' (' + (label.value === null? 'No value' : label.value) + ')';
              }
              var x = bbox.x * datashapeOffset.a, y = bbox.y * datashapeOffset.d, width = bbox.width* datashapeOffset.a, height = bbox.height* datashapeOffset.d;    
              /**
               *  [18-Dec-2012 Nick] 
               *  plotOffset means the offset between g.datashapesgroup and svg root element
               *  datashapeOffset means the offset between element.datapoint and svg root element
               *  so the difference between them means the offset between element.datapoint and g.datashapesgroup
               */
              label.transformString = ('translate(' + (datashapeOffset.e - plotOffset.e) + ',' + (datashapeOffset.f - plotOffset.f) + ')' );
              var insideCenterX = 0, insideCenterY = 0, outsideUpCenterX = 0, outsideUpCenterY = 0, outsideDownCenterX = 0, outsideDownCenterY = 0, outsideLeftCenterX = 0, outsideRightCenterX = 0, outsideLeftCenterY = 0, outsideRightCenterY = 0;
              if (isHeatMap || isTreeMap) {
                var labelValue = label.value;
                if (TypeUtils.isNumber(labelValue)){
                  labelValue = labelValue.toString();
                }
                var dataLabeFontColor = null;
                if (isHeatMap) {
                  dataLabeFontColor = heatMapLabelFontColor;
                } else if (isTreeMap) {
                  dataLabeFontColor = treeMapLabelFontColor;
                }
                label.value = TextUtils.ellipsis(labelValue, null, width - 3,  "fill:" + dataLabeFontColor + ";font-family:" + fontFamily + ";font-size:" + fontSize);
              }
              labelSize = TextUtils.fastMeasure(label.value, fontSize, fontWeight, fontFamily);
 
              if(orientation === 'horizontal'){
                label.centerX = x + width/2;
                label.centerY = y + height/2;
                /**
                 * [07-Jan-2012 Nick]
                 * if the label value is negative, set outsidePosition to left, so make sure it is listed on the left sideof data shape element
                 */
                if (positionPreference && position === 'outside') {
                  if (outsidePosition === 'right'){
                    label.centerX = label.centerX  + width/2 + labelSize.width/2;
                  }
                } else {
                  if(position === 'outside'){
                    if( outsidePosition === 'left' || (!TypeUtils.isExist(tempElement.__data__.isNegative) && originalValue < 0)){
                      label.centerX = label.centerX - (width/2 + labelSize.width/2);
                    }else if (outsidePosition === 'right'){
                      label.centerX = label.centerX  + width/2 + labelSize.width/2;
                    }
                  }
                }
                insideCenterX = x + width/2;
                insideCenterY = y + height/2;

                if (!isStackMode) {
                  if (!(!TypeUtils.isExist(tempElement.__data__.isNegative) && originalValue < 0)) {
                    outsideRightCenterX = label.centerX  + width/2 + labelSize.width/2;
                    outsideRightCenterY = y + height/2;
                  } else {
                    outsideLeftCenterX = label.centerX - (width/2 + labelSize.width/2);
                    outsideLeftCenterY = y + height/2;
                  }
                }

              }else{
                label.centerX = x + width/2;
                label.centerY = y + height/2;
                /**
                 * [07-Jan-2012 Nick]
                 * if the label value is negative, set outsidePosition to down, so make sure it is listed below the data shape element
                 */
                if(tempElement.__data__.isNegative){
                  outsidePosition = 'down';
                }   
                if (isHeatMap && isOneCategoryHeatmap) {
                  label.centerY += labelSize.height/2;
                } else if (isTreeMap) {
                  label.centerY += (treeMapLabelHeight/2 + labelSize.height/2);
                }
                
                if (positionPreference && position === 'outside') {
                  if (outsidePosition === 'up'){
                    label.centerY = label.centerY - height/2 - labelSize.height/2;
                  }
                } else {
                  if(position === 'outside'){
                    if( outsidePosition === 'down' || (!TypeUtils.isExist(tempElement.__data__.isNegative) && originalValue < 0)){
                      label.centerY = label.centerY + height/2 + labelSize.height/2;
                    }else if (outsidePosition === 'up'){
                      label.centerY = label.centerY - height/2 - labelSize.height/2;
                    } 
                  }
                }
    
                insideCenterY = y + height/2;
                insideCenterX = x + width/2;
                
                if (!isStackMode) {
                  if (!(!TypeUtils.isExist(tempElement.__data__.isNegative) && originalValue < 0)) {
                    outsideUpCenterY = label.centerY - height/2 - labelSize.height/2;
                    outsideUpCenterX = x + width/2;
                  } else {
                    outsideDownCenterY = label.centerY + height/2 + labelSize.height/2;
                    outsideDownCenterX = x + width/2;
                  }
                }
              }
              if (isGeoChart && gPlot.projection && tempElement.__data__.feature.properties.centroid) {
                var projection = gPlot.projection();
                var centroPoint = projection(tempElement.__data__.feature.properties.centroid);
                label.centerX = centroPoint[0] - (datashapeOffset.e - plotOffset.e) ;
                label.centerY = centroPoint[1] - (datashapeOffset.f - plotOffset.f);
              } 
              label.x = label.centerX - labelSize.width/2;
              label.y = label.centerY - labelSize.y/2;
              label.width = labelSize.width;
              label.height = labelSize.height;
              label.ownerWidth = width;
              label.ownerHeight = height;
              label.datapointRect = clientRect;
              label.insideX = insideCenterX - labelSize.width/2;
              label.insideY = insideCenterY - labelSize.y/2;
              if (tempElement.__data__.hasOwnProperty('metaInfo')) {
                label.metaInfo = tempElement.__data__.metaInfo;
              }
              if (!isStackMode) {
                if (orientation === 'horizontal') {
                  if (!(!TypeUtils.isExist(tempElement.__data__.isNegative) && originalValue < 0)) {
                    label.outsideX = outsideRightCenterX - labelSize.width/2;
                    label.outsideY = outsideRightCenterY - labelSize.y/2;
                  } else {
                    label.outsideX = outsideLeftCenterX - labelSize.width/2;
                    label.outsideY = outsideLeftCenterY - labelSize.y/2;
                  }
                } else if (orientation === 'vertical') {
                  if (!(!TypeUtils.isExist(tempElement.__data__.isNegative) && originalValue < 0)) {
                    label.outsideX = outsideUpCenterX - labelSize.width/2;
                    label.outsideY = outsideUpCenterY - labelSize.y/2;
                  } else {
                    label.outsideX = outsideDownCenterX - labelSize.width/2;
                    label.outsideY = outsideDownCenterY - labelSize.y/2;
                  }
                }
              }
              dataLabel.push(label);
              originalLabels.push(label);
            }
            dataLabels.push(dataLabel);
          }
        }
      };
      
      var isOverlappedWith = function(srcLabel, desLabel) {
  
        var left1 = srcLabel.left, top1 = srcLabel.top, right1 = srcLabel.right, bottom1 = srcLabel.bottom;
        var left2 = desLabel.left, top2 = desLabel.top, right2 = desLabel.right, bottom2 = desLabel.bottom;
        
        if (!((left1 >= right2) || (top1 >= bottom2) || (right1 <= left2) || (bottom1 <= top2))) {
          return true;
        }
        return false;        
      };
      
      var removeUnqualifiedLabels = function(labels, plotArea) {

        if (labels === null || plotArea === null) {
          return;
         }
            
         for (var i = 0; i < labels.length; i++) {
           
           var srcLabel = labels[i];
           if (!srcLabel.visible) {
             continue;
           }
           for (var j = i + 1; j < labels.length; j++) {
             var desLabel = labels[j];
             if (!desLabel.visible) {
               continue;
             }
             if (isOverlappedWith(srcLabel, desLabel)) {
               desLabel.visible = false;
             }
           }
         }
         
      };
      
      var isCrossBorder = function(label, plotArea) {
        
        if (label.top < plotArea.top || label.left < plotArea.left || label.right > plotArea.right || label.bottom > plotArea.bottom) {
          return true;
        }
        
        return false;
      };
      /**
     * get/set your event dispatch if you support event
     */
     label.dispatch = function(_){
       if(!arguments.length){
         return _dispatch;
       }
       _dispatch = _;
       return label;
     };
     
      label.plot = function(_){
        if(!arguments.length){
          return gPlot;
        }
        gPlot = _;
      };

      label.parent = function(){};
      
      label.properties = function(_){
        if(!arguments.length){
          return properties;
        }        
        Objects.extend(true,properties, _);
        parseOptions(properties);
      };
      
      label.destroy = function() {
        gPlot = null;
        _SVGRoot = null;
        parentNodeBBox = null;
        if(dataLabel){
          for(var i = 0; i < dataLabel.length; i++){
            dataLabel[i].dataShape = null;
            if(originalLabels[i]){
              originalLabels[i].dataShape = null;
            }
          }
        }
        dataLabel = null;
        dataLabels = null;
        originalLabels = null;
         //destroy ctx
        if(ctx){
          ctx.destroy();
          ctx = null;
        }       
      };
      
      return label;
    };
    return dataLabel; 
});
define('sap/viz/modules/manifests/DataLabel',['sap/viz/modules/manifests/Module','sap/viz/modules/Constants','sap/viz/modules/datalabel'],
function Setup(Manifest,Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.datalabel',
    'name' : 'datalabel',
    'type' : Constants.Type.Supplementary,
    'properties' : {  
      'visible': {
        'name' : 'visible',
        'supportedValueType' : 'Boolean',
        'defaultValue' : false,
        'description' : 'Set whether data label is visible.',
     },
     'isDonut': {
       'name' : 'isDonut',
       'supportedValueType' : 'Boolean',
       'defaultValue' : false,
       'description' : 'Set for donut chart only.',
       'isExported': false
    },
    'type' : {
      'name' : 'type',
      'supportedValueType' : 'String',
      'defaultValue' : 'value',
      'description' : 'Set the type of label',
      'isExported': false
    },
    'automaticInOutside': {
      'name' : 'automaticInOutside',
      'supportedValueType' : 'Boolean',
      'defaultValue' : true,
      'description' : 'if it is true, the data label will be automatically placed outside when data label postion property is inside and vice versa.',
      'isExported': false    
    },
    'showZero': {
      'name' : 'showZero',
      'supportedValueType' : 'Boolean',
      'defaultValue' : true,
      'description' : 'if it is true, the value zero will be shown in data label.',
      'isExported': false    
    },
    'isGeoChart': {
      'name' : 'isGeoChart',
      'supportedValueType' : 'Boolean',
      'defaultValue' : false,
      'description' : 'if it is true, it is a geo chart.',
      'isExported': false    
    },
    'isStackMode': {
      'name' : 'isStackMode',
      'supportedValueType' : 'Boolean',
      'defaultValue' : false,
      'description' : 'Set for stack chart only.',
      'isExported': false    
    },
    'isPercentMode': {
      'name' : 'isPercentMode',
      'supportedValueType' : 'Boolean',
      'defaultValue' : false,
      'description' : 'Set for percent chart only.',
      'isExported': false    
    },
    'positionPreference': {
      'name' : 'positionPreference',
      'supportedValueType' : 'Boolean',
      'defaultValue' : false,
      'description' : 'If it is true, the data label position is defined by property outsidePosition no matter whether data label value is negative.',
      'isExported': false    
    },
    'outsideVisible': {
      'name' : 'outsideVisible',
      'supportedValueType' : 'Boolean',
      'defaultValue' : true,
      'description' : 'when data label is oustide, it can control whether it is visible or not.',
      'isExported': false    
    },
    'outsidePosition': {
      'name' : 'outsidePosition',
      'supportedValueType' : 'String',
      'supportedValues': ['up','down', 'left', 'right'],
      'defaultValue' : 'up',
      'description' : 'when data label is oustide, its position is above the element.',
      'isExported': false    
    },
        'paintingMode': {
           'name' : 'paintingMode',
           'supportedValueType' : 'String',
           'supportedValues': ['rectCoordinate','polarCoordinate'],
           'defaultValue' : 'rectCoordinate',
           'description' : 'Set painting mode of data labels.',
           'isExported' : false
        },
        'position': {
           'name' : 'position',
           'supportedValueType' : 'String',
           'supportedValues' : ['inside','outside'],
           'defaultValue' : 'inside',
           'description' : 'Set position of data labels.'
        },
        'orientation': {
           'name' : 'orientation',
           'supportedValueType' : 'String',
           'supportedValues' : ['horizontal', 'vertical'],
           'defaultValue' : 'vertical',
           'description' : 'Set orientation of data labels.',
           'isExported' : false
        },
        'formatString': {
        	'name' : 'formatString',
        	'supportedValueType': 'Two-Dimensions-Array',
          'defaultValue' : null,
        	'description' : 'Set format string of datalabel.As we may have dual axis with serveral measures,the first array is applied to primary axis and the second one is applied to the second axis.'
        		+'If the length of format string list is less than the length of data series, the last format string in the list will be applied to exceeded data series.Any character in "MDYHSAmdyhsa#?%0@" is reserved as a token for format code. A simple sample is like this [["0.00%"],["0.00%"]].' 
        	}
      },
      'css' : {
        '.v-datalabel' : {
          'description' : 'Define style for the data label',
          'value' : {
            'fill' : '#333333',
            'font-family' : "'Open Sans', Arial, Helvetica, sans-serif",
            'font-size' : '12px',
            'font-weight' : 'normal'
          }
        }
      },
      configure: null,
    fn : fn
  };

  Manifest.register(module);
});
define('sap/viz/modules/manifests/layout/Base',['sap/viz/modules/manifests/Module','sap/viz/modules/Constants'],
function Setup ( Manifest, Constants) {
  var module = {
    'abstract' : true,
    'id' : "sap.viz.modules.layout.base",
    'type' : Constants.Type.Scientific.Layout,
    'renderto' : Constants.RenderTo.NONE,
    'name' : "Abstract Layout",
    'description' : "Abstract layout algorithm",
    'properties' : {},
    'configure' : null,
    'fn' : null
  };
  Manifest.register(module);
});

define('sap/viz/modules/manifests/layout/Dock',['sap/viz/modules/manifests/Module','sap/viz/modules/layout/dock', 'sap/viz/modules/manifests/layout/Base'],
function Setup ( Manifest, fn ) {
  var module = {
    'id' : "sap.viz.modules.layout.dock",
    'name' : "dock",
    'base' : "sap.viz.modules.layout.base",
    'description' : "The dock layout algorithm",
    'properties' : {},
    'configure' : null,
    'fn' : fn
  };
  Manifest.register(module);
});
define('sap/viz/util/DrawUtil',[],

function Setup() {

  var DrawUtil = {

  };

  /**
   *  props = {
   *    type: 
   *    rx:
   *    ry:
   *  }
   *  @return path "d" for D3 
   */
  DrawUtil.createMarkerData = function (props){
    // TODO Maybe we can use hashmap to cache here
    //if(symbolMap[props]) return symbolMap[props];
    var result;
    var temp = props.borderWidth / 2;
    switch(props.type)
    {
    case "circle" :
      result = "M" + (-props.rx - temp)  + ",0 A" + (props.rx + temp) + "," + (props.ry + temp) + " 0 1,0 " + (props.rx + temp) + ",0 A";
      result += (props.rx + temp) + "," + (props.ry + temp) + " 0 1,0 " + (-props.rx -temp) + ",0z";
      break;
    case "cross" :
      result = "M" + (-props.rx - temp) + "," + (-props.ry/3 - temp) + "H" + (-props.rx/3  - temp) + "V" + (-props.ry - temp)+ "H" + (props.rx/3 +temp);
      result += "V" + (-props.ry/3 - temp) + "H" + (props.rx + temp) + "V" + (props.ry/3 + temp) + "H" + (props.rx/3 + temp);
      result += "V" + (props.ry +temp) + "H" + (-props.rx/3 - temp) + "V" + (props.ry/3 + temp) + "H" + (-props.rx -temp) + "Z";
      break;
    case "diamond" :
      result = "M0," + (-props.ry -temp)  + "L" + (props.rx + temp) + ",0" + " 0," + (props.ry + temp) + " " + (-props.rx -temp) + ",0" + "Z";
      break;
    case "square" :
      result = "M" + (-props.rx - temp) + "," + (-props.ry - temp) + "L" + (props.rx + temp) + ",";
      result += (-props.ry - temp) + "L" + (props.rx + temp) + "," + (props.ry + temp) + "L" + (-props.rx - temp) + "," + (props.ry + temp) + "Z";
      break;
    case "triangle-down" ://TODO: remove duplicate
    case "triangleDown" :
      result = "M0," + (props.ry + temp) + "L" + (props.rx + temp) + "," + -(props.ry + temp) + " " + -(props.rx + temp) + "," + -(props.ry + temp) + "Z";
      break;
    case "triangle-up" ://TODO: remove duplicate
    case "triangleUp" : 
      result =  "M0," + -(props.ry + temp) + "L" + (props.rx + temp) + "," + (props.ry + temp) + " " + -(props.rx + temp) + "," + (props.ry + temp) + "Z";
      break;
    case "triangle-left" ://TODO: remove duplicate
    case "triangleLeft" :
      result = "M" + -(props.rx + temp) + ",0L" + (props.rx + temp) + "," + (props.ry + temp) + " " + (props.rx + temp) + "," + -(props.ry + temp) + "Z";
      break;
    case "triangle-right" ://TODO: remove duplicate
    case "triangleRight" :
      result = "M" + (props.rx + temp) + ",0L" + -(props.rx + temp) + "," + (props.ry + temp) + " " + -(props.rx + temp) + "," + -(props.ry + temp) + "Z";
      break;
    case "intersection" :
      result = "M" + (props.rx + temp) + "," + (props.ry + temp) + "L" +  (props.rx/3 + temp) + ",0L" + (props.rx + temp) + "," + -(props.ry +temp) + "L";
      result += (props.rx / 2 - temp) + "," + -(props.ry + temp) + "L0," + (-props.ry/3 - temp) + "L" + (-props.rx / 2 + temp) + "," + -(props.ry + temp) + "L";
      result += -(props.rx + temp) + "," + -(props.ry +temp) + "L" + -(props.rx/3 + temp) + ",0L" + -(props.rx + temp) + "," + (props.ry + temp) + "L";
      result += (-props.rx/2 + temp) + "," + (props.ry + temp) + "L0," + (props.ry/3 + temp) + "L" + (props.rx/2 - temp) + "," + (props.ry + temp) + "Z";
      break;
    case 'squareWithRadius' : 
      var r = props.rx;
      var radius = r - 3;
      result = "M0," +  -r + "L" + -radius + ","+ -r + "Q" + -r +"," + -r + " " + -r + "," + -radius + "L" + -r +"," + radius + "Q" + -r + "," + r + " " + -radius + "," + r;
      result += "L" + radius + "," + r +"Q" + r + "," + r + " " + r + "," +radius + "L" + r +"," + -radius + "Q" + r + "," + -r + " "+ radius + "," + -r +"Z";
      break;
    }
    //symbolMap[props] = result;
    return result;

  };

  function getAnimationInitData(props)
  {
    var result;
    switch(props.type)
    {
    case "circle" :
      result = "M0,0A0,0 0 1,0 0,0A0,0 0 1,0 0,0z"; 
      break;
    case "cross" :
      result = "M0,0H0V0H0V0H0V0H0V0H0V0H0Z";
      break;
    case "diamond" :
      result = "M0,0L0,0 0,0 0,0Z";
      break;

    case "triangle-down" ://TODO: remove duplicate
    case "triangle-up" ://TODO: remove duplicate
    case "triangle-left" ://TODO: remove duplicate
    case "triangle-right" :  //TODO: remove duplicate
    case "triangleDown" :
    case "triangleUp" :
    case "triangleLeft" :
    case "triangleRight" :        
      result = "M0,0L0,0 0,0Z";
      break;
    case "intersection" :
      result = "M0,0L0,0L0,0L0,0L0,0L0,0L0,0L0,0L0,0L0,0L0,0L0,0Z";
      break;
    case 'squareWithRadius' : 
      result = "M0,0L0,0Q0,0 0,0L0,0Q0,0 0,0L0,0Q0,0 0,0L0,0Q0,0 0,0Z";
      break;  
    case "square" :
      result = "M0,0L0,0L0,0L0,0Z";
      break;
    default:
      result = "M0,0L0,0L0,0L0,0Z";
      break;
    }
    return result;
  }
  
  DrawUtil.createElements = function(d3Enter, props)
  {
    return d3Enter.append("path").attr("class", props.className);
  };
  
  DrawUtil.createElement = function(d3Parent, props, effectManager)
  {
    var d3Element = d3Parent.append("path").attr("class", props.className);
    props.node = d3Element;
    DrawUtil.drawGraph(props, effectManager);
    return d3Element;
  };

  /**
   * props = {
   *   node: current d3 svg element,
   *  graphType : marker type
   *  drawingEffect: drawingEffect
   *  direction : direction
   *   rx : size
   *  ry: size
   *  fillColor: color
   *  borderWidth:
   *  borderColor,
   *  visibility: "visible" or "hidden"
   *  animateTime: total time for animation in ms 
   *  strokeOpacity: opacity for border line
   *  endFunc: callback function, when animation complete, it will be called
   * }
   *  effectManager: current effectManager
   */
  DrawUtil.drawGraph =  function (props, effectManager)
  {
    var para = {
        type: props.graphType,
        rx:Math.round(props.rx),
        ry:Math.round(props.ry),
        borderWidth: props.borderWidth ? Math.round(props.borderWidth) : 0
    };
    var data = DrawUtil.createMarkerData(para);

    var tempOpacity;
    if (props.visibility === 'hidden') {
        tempOpacity = 0;
    } else {
        tempOpacity = 1;
    }
    var fillId = effectManager.register(props);

    if(props.animateTime && props.animateTime > 0) {
      props.node.each(function(){
            this.setAttribute("fill", fillId);
            this.setAttribute("stroke-width", props.borderWidth);
            this.setAttribute("stroke", props.borderColor);
            this.setAttribute("opacity", tempOpacity);
            this.setAttribute("stroke-opacity", props.strokeOpacity);
            this.setAttribute("d", getAnimationInitData(para));
      });
      props.node.transition().duration(props.animateTime).attr("d", data).each('end', props.endFunc);
    } else {
      props.node.each(function(){
            this.setAttribute("fill", fillId);
            this.setAttribute("stroke-width", props.borderWidth);
            this.setAttribute("stroke", props.borderColor);
            this.setAttribute("opacity", tempOpacity);
            this.setAttribute("stroke-opacity", props.strokeOpacity);
            this.setAttribute("d", data);
      });
    }
    return  props.node;
  };
  
  return DrawUtil;
});
define('sap/viz/modules/legend/colorLegendArea',['sap/viz/base/utils/oo', 'sap/viz/modules/Base', 'sap/viz/util/TextUtils', 'sap/viz/base/utils/Objects', 'sap/viz/modules/dispatch','sap/viz/util/DrawUtil','sap/viz/base/utils/ObjectUtils',
'sap/viz/base/UADetector'],
function Setup(oo, Base, TextRuler, Objects, dispatch, DrawUtil, ObjectUtils, UADetector) {
  
  var ColorLegendArea = function(styleManager){
    this._colorLA_width = 400;
    this._colorLA_height = 200;
    this._colorLA_valueLabelFont = {
      'fontfamily' : "'Open Sans', Arial, Helvetica, sans-serif",
      'fontsize' : '12px',
      'fontweight' : 'normal',
      'color' : '#333333'
    };
    this._colorLA_options = {
      isHierarchy : undefined,
      position : 'right',
      legendType : 'ColorLegend'
    };
    this._colorLA_colorLabelSize = 1;
    this._colorLA_shapes = [];
    this._colorLA_colors = [];
    this._colorLA_colorFeedLength = 0;
    this._colorLA_shapeFeedLength = 0;
    this._colorLA_wrap = undefined;
    this._colorLA_textHeight = 20;
    this._colorLA_textWidth = 80;
    this._colorAL_maxTextCount = 12; //For measure max text width. if the frist twelve text width is less than maxTextWidth(80), use its width. Otherwise, use maxTextWidth.
    this._colorLA_selectedItem = [];
    this._colorLA_isStyleChanged = true;
    this._colorLA_selectionMode = 'multiple';
    this._colorLA_markerMargin = {
        right : 0.5,
        bottom : 0.5,
        left : 1,
        top : 0
    };
    this._colorLA_pagingBtnInfo = {
        height : 1.6,
        markerHeight : 0.5,
        padding: 0.5,
        hasNext : true,
        hasPre : false
    };
    this._colorLA_relayout  = true;
    
    this._colorLA_imageInfo = {
        imageMode: false,
        imagePalette: [],
        radio: 1
    };
    
    
    this._colorLA_startRow = 0;
    this._colorLA_lastStartRow = 0;
    this._colorLA_endRow = Infinity;
    
    //Each row's position [{x: 10, y: 10}, {...}...]
    this._colorLA_rowPosArr = [];
    this._colorLA_chartData = {};
    this._colorLA_hieChartData = []; //For hierarchical data
    this._colorLA_isItemsOverflow = undefined;
    this._colorLA_endItemNum = undefined;
    this._colorLA_startItemNum = 0;
    this._colorLA_firstOverFlowPos = undefined;
    
    this._colorLA_effectManager = null;
    this._colorLA_styleManager = styleManager;
    
    this._colorLA_style = {};
    this._colorLA_style.hovershadow = styleManager.queryDefault('v-hovershadow');
  };
    
  oo.extend(ColorLegendArea, Base);
  
  ColorLegendArea.prototype.render = function(selection){
    this._colorLAfn_getThemeStyleDef();

    // relayout for new smart layout
    var labelsData;
    if (this._colorLA_relayout) {
      this._colorLA_wrap = undefined;
      this._colorLA_isItemsOverflow = false;
        this._colorLAfn_calculateRowPosition({width: this._colorLA_width, height: this._colorLA_height});
      labelsData = this._colorLAfn_getLabelData();
    } else {
      labelsData = this._colorLAfn_getLabelData();
      this._colorLA_isItemsOverflow = false;
        if(labelsData.length > 0 && labelsData.length < this._colorLA_chartData.length){
        this._colorLA_isItemsOverflow = true;
      }
      if (this._colorLA_isItemsOverflow === true) {
          this._colorLAfn_calculateRowPosition({width: this._colorLA_width, height: this._colorLA_height});
        labelsData = this._colorLAfn_getLabelData();
      }
    }

    // initial wrap
    var wrap;
    if (this._colorLA_wrap === undefined) {
      wrap = selection;
      this._colorLA_wrap = wrap;
    } else {
      wrap = this._colorLA_wrap;
    }

    // indicated item while hovering or clicking
    var indicatedItems = wrap.selectAll('rect.v-indicatedRect');
    if (indicatedItems.empty()) {
      indicatedItems = wrap.append('rect').attr('class', 'v-indicatedRect v-hovershadow').attr('visibility', 'hidden');
    }
    var rectMargin = this._colorLA_markerMargin.bottom * this._colorLA_textHeight;
      indicatedItems.attr('width', this._colorLA_width+10).attr('height', this._colorLA_textHeight + rectMargin).attr('x', -5).attr('y', -rectMargin/2);

    // Set default value style
    var defaultValueLabelStyle = this._colorLA_styleManager.queryDefault('v-label');
        wrap.attr('font-family', defaultValueLabelStyle['font-family']).attr('font-size', defaultValueLabelStyle['font-size']).attr('font-weight', defaultValueLabelStyle['font-weight']).attr('fill', defaultValueLabelStyle['fill']);

    // Create each row
        var gEnterRow = wrap.selectAll('g.v-row').data(labelsData);
    gEnterRow.exit().remove();

    var rectEnterRow = gEnterRow.enter().append('g');

    gEnterRow.attr('class', function(d, i) {
      return 'v-row ID_' + i;
    });

    // Render legend itmes
    if ((this._colorLA_options.legendType !== 'BubbleColorLegend') && this._colorLA_options.isHierarchy && (!(this._colorLA_options.position === 'top' || this._colorLA_options.position === 'bottom'))) {
          //Legend with hierarchy, not bubble color legend and not in top/bottom
      this._colorLAfn_renderHierarchicalLegend.call(this, labelsData, gEnterRow);
    } else {
      // No hierarchy
      this._colorLAfn_renderNormalLegend.call(this, labelsData, gEnterRow);
    }

    // Add 'rect' element to handle click event.
    rectEnterRow.append('rect').attr('class', 'v-eventRect');
    gEnterRow.each(function(d, i) {
      wrap.selectAll('rect.v-eventRect').attr('class', function() {
        return 'v-eventRect ID_' + i;
      });
    });
        var eventItems = wrap.selectAll('rect.v-eventRect').data(labelsData, function(d, i){
        return d.val;
      });
    eventItems = wrap.selectAll('rect.v-eventRect');
    eventItems.attr('height', this._colorLA_textHeight).attr('fill', 'rgba(255, 255, 255, 0)');
    if (this._colorLA_options.position === 'top' || this._colorLA_options.position === 'bottom') {
      // markerSize = Color_Marker_Size + Right_Margin + Left_Margin
      var markerSize = (this._colorLA_colorLabelSize + this._colorLA_markerMargin.right) * this._colorLA_textHeight + this._colorLA_markerMargin.left * this._colorLA_textHeight / 2;
          eventItems.attr('width', function(d){
          return (d.size === undefined) ? (this._colorLA_textWidth + markerSize) : (d.size.width + markerSize);
        });
    } else {
      eventItems.attr('width', this._colorLA_width);
    }

    // Handle items are overflow
    wrap.selectAll('text.v-itemsEllipsis').attr('visibility', 'hidden');
    if (this._colorLA_isItemsOverflow && (labelsData.length > 0 || this._colorLA_hieChartData.length > 0)) {
      if (!this._colorLA_options.isHierarchy && this._colorLA_options.isScrollable && (this._colorLA_options.position === 'left' || this._colorLA_options.position === 'right')) {
        // if isScrollable is set true, display pre/next button.
        this._colorLAfn_renderScrollable.call(this, labelsData);
      } else {
        this._colorLAfn_renderEllipsis.call(this);
      }
    } else {
      // Clean pagination buttons
      var btnsWrapper = wrap.selectAll('g.v-pagination-buttons');
      if (!btnsWrapper.empty()) {
        btnsWrapper.remove();
      }
    }
    if (UADetector.isMobile()) {
      wrap.on('touchstart', function() {
        this._colorLAfn_itemClicked.call(this, arguments);
      }.bind(this)).on('touchend.color', function() {
        this._colorLAfn_blurHandler.call(this, arguments);
      }.bind(this));
    } else {
      wrap.on('mouseover', function() {
        this._colorLAfn_hoverHandler.call(this, arguments);
      }.bind(this)).on('mouseout', function() {
        this._colorLAfn_blurHandler.call(this, arguments);
      }.bind(this)).on('mousedown', function() {
        this._colorLAfn_itemClicked.call(this, arguments);
      }.bind(this)).on('mouseup', function() {
        this._colorLAfn_hoverHandler.call(this, arguments);
      }.bind(this));
    }
    this._colorLA_relayout = false;
  };
    
    ColorLegendArea.prototype.width = function(_) {
      if(!arguments.length){
        return this._colorLA_width;
      }
      this._colorLA_width = _;
      this._colorLA_relayout = true;
      this._colorLA_isItemsOverflow = false;
      return this;
    };

    ColorLegendArea.prototype.height = function(_) {
      if(!arguments.length){
        return this._colorLA_height;
      }
      this._colorLA_height = _;
      this._colorLA_relayout = true;
      this._colorLA_isItemsOverflow = false;
      return this;
    };
    
    ColorLegendArea.prototype.color = function(_) {
      if(!arguments.length){
        return this._colorLA_colors;
      }
      this._colorLA_colors = _;  
      return this;
    };

    ColorLegendArea.prototype.shapes = function(_) {
      if(!arguments.length){
        return this._colorLA_shapes;
      }
      this._colorLA_shapes = _;
      return this;
    };
    
    ColorLegendArea.prototype.colorFeedLength = function(_){
      this._colorLA_colorFeedLength = _;
      return this;
    };
    
    ColorLegendArea.prototype.shapeFeedLength = function(_){
      this._colorLA_shapeFeedLength = _;
      return this;
    };
    
    ColorLegendArea.prototype.data = function(_){
      if(!arguments.length){
        return this._colorLA_chartData;
      }
      this._colorLA_chartData = _;
      return this;
    };

    ColorLegendArea.prototype.imageInfo = function(_) {
      if(!arguments.length){
        return this._colorLA_imageInfo;
      }
      this._colorLA_imageInfo = _;
      this._colorLA_relayout = true;
      return this;
    };
    
    ColorLegendArea.prototype.properties = function(properties) {
      if(!arguments.length){
        return this._colorLA_options;
      }
      //TODO use extends...
      this._colorLA_options = properties;
      return this;
    };
    
    ColorLegendArea.prototype.hasData = function(){
     if( this._colorLA_chartData && this._colorLA_chartData.length > 0){
       return true;
     }else {
       return false;
       }
    };
    
    ColorLegendArea.prototype.getPreferredSize = function() {
      this._colorLAfn_getThemeStyleDef();
      //TODO reset itemsCount which is used in overflow legend items
      this._colorLA_startItemNum = 0;
      return this._colorLAfn_calculateRowPosition({width: this._colorLA_width, height: this._colorLA_height});
    };
    
    ColorLegendArea.prototype.doLayout = function(size){
      return size;
    };
    
    ColorLegendArea.prototype.setSelectionMode = function(_){
      this._colorLA_selectionMode = _;
    };
    
    ColorLegendArea.prototype.effectManager = function(_) {
      if(!arguments.length){
        return this._colorLA_effectManager;
      }
      this._colorLA_effectManager = _;

      return ColorLegendArea.prototype;
    };
    ColorLegendArea.prototype.destroy = function(){
      //remove listener
      if(this._colorLA_wrap){
        this._colorLA_wrap.on('touchstart', null);
        this._colorLA_wrap.on('touchend.color', null);
        this._colorLA_wrap.on('mouseover', null);
        this._colorLA_wrap.on('mouseup', null);
        this._colorLA_wrap.on('mousedown', null);
        this._colorLA_wrap.on('mouseout', null);
        this._colorLA_wrap = null;  
      }
      this._colorLA_styleManager = null;
      this._colorLA_selectedItem = null;
      this._colorLA_effectManager = null;
    };

    ColorLegendArea.prototype._colorLAfn_renderEllipsis = function(){
      var that = this;
      //Clean pagination buttons
      var btnWrapper = this._colorLA_wrap.selectAll('g.v-pagination-buttons');
      if(!btnWrapper.empty()){
        btnWrapper.remove();
      }
      //Much items ellipsis
      var itemsEllipsis = this._colorLA_wrap.selectAll('text.v-itemsEllipsis');
      if(itemsEllipsis.empty()){
        itemsEllipsis = this._colorLA_wrap.append('text').attr('class', 'v-itemsEllipsis').text('...'); //.attr('text-anchor', 'middle');
      }
      var dx = (this._colorLA_colorLabelSize + this._colorLA_markerMargin.right) * this._colorLA_textHeight; //this._colorLA_width/2
      itemsEllipsis.attr('visibility', function(){
        var visible = 'hidden';
        if(that._colorLA_isItemsOverflow){
          visible = 'visible';
        }
        return visible;
      }).attr('dx', dx).attr('dy', function(){
        return (that._colorLA_firstOverFlowPos === undefined) ? that._colorLA_height : that._colorLA_firstOverFlowPos;
      });
    };
    
    ColorLegendArea.prototype._colorLAfn_renderScrollable = function(labelsData){
      var _generatePagingBtnPath = function(x, y, height, type){
        var w = (7*height) / 8;
        var h = height / 2;
        var path = "";
        if(type === 'triangleUp'){
          path = 'M ' + x + " " + (y - h) + " L " + (x + w) + " " + (y + h) + " L " + (x - w) + " "+ (y + h);
        }else{
          path = 'M ' + (x - w) + " " + (y - h) + " L " + (x + w) + " " + (y - h) + " L " + x + " " + (y + h);
        }
        return path;
      };
      
      //Add pre/next button
      var pagingBtnHeight = this._colorLA_pagingBtnInfo.height * this._colorLA_textHeight; 
      var pagingMarkerHeight = this._colorLA_pagingBtnInfo.markerHeight * this._colorLA_textHeight;
      var preWrapper, nextWrapper, nextPosY, btnWrapper;
      btnWrapper = this._colorLA_wrap.selectAll('g.v-pagination-buttons');
      var that = this;
      if(btnWrapper.empty()){
        btnWrapper = this._colorLA_wrap.append('g').attr('class', 'v-pagination-buttons');
        
        //Pre Button Group
        preWrapper = btnWrapper.append('g').attr('class', 'v-preWrapper');
        preWrapper.append('rect').attr('class', 'v-preBtn').attr('width', this._colorLA_width + 10).attr('height', pagingBtnHeight).attr('x', -5).attr('y', 0).attr('fill','rgba(0,0,0,0)');
        
        preWrapper.append('text').attr('class', 'v-preText').attr('text-anchor', 'end');
        preWrapper.append('path').attr('class', 'v-prePath');
        
        //Next Button Group
        nextWrapper = btnWrapper.append('g').attr('class', 'v-nextWrapper');
        nextWrapper.append('rect').attr('class', 'v-nextBtn').attr('width', this._colorLA_width + 10).attr('height', pagingBtnHeight).attr('x', -5).attr('fill','rgba(0,0,0,0)');
        
        nextWrapper.append('text').attr('class', 'v-nextText').attr('text-anchor', 'end');
        nextWrapper.append('path').attr('class', 'v-nextPath');
      }
      
      //Update pre/next status
      btnWrapper.selectAll('g.v-preWrapper').attr('visibility', function(){
        return (that._colorLA_pagingBtnInfo.hasPre === true) ? 'visible' : 'hidden';
      });
      nextPosY = labelsData[labelsData.length - 1].pos.y + this._colorLA_textHeight + this._colorLA_pagingBtnInfo.padding * this._colorLA_textHeight;
      btnWrapper.selectAll('g.v-nextWrapper').attr('transform', 'translate( '+ 0 + ', '+ nextPosY +')').attr('visibility', function(){
        return (that._colorLA_pagingBtnInfo.hasNext === true) ? 'visible' : 'hidden';
      });
      btnWrapper.selectAll('text.v-preText').attr('x', this._colorLA_width/2 - this._colorLA_textHeight).attr('y', (pagingBtnHeight + this._colorLA_textHeight)/2 - 2).text(function(){
        return "(" + that._colorLA_startItemNum+") ";
      });
      btnWrapper.selectAll('text.v-nextText').attr('x', this._colorLA_width/2 - this._colorLA_textHeight).attr('y', (pagingBtnHeight + this._colorLA_textHeight)/2 - 2).text(function(){
        return "(" + (that._colorLA_chartData.length - that._colorLA_endItemNum) + ") ";
      });
      btnWrapper.selectAll('path.v-prePath').attr('d', function(){
        return _generatePagingBtnPath(that._colorLA_width / 2, pagingBtnHeight  / 2, pagingMarkerHeight, 'triangleUp');
      }).attr('fill', this._colorLA_valueLabelFont['fill']);
      btnWrapper.selectAll('path.v-nextPath').attr('d', function(){
        return _generatePagingBtnPath(that._colorLA_width / 2, pagingBtnHeight  / 2, pagingMarkerHeight, 'triangleDown');
      }).attr('fill', this._colorLA_valueLabelFont['fill']);
    };
    
    ColorLegendArea.prototype._colorLAfn_renderNormalLegend = function(labelsData, gEnterRow){
      //Create each row
      this._colorLA_wrap.selectAll('g.v-group').remove();
      var rowWrap;
      for(var i = 0, len = labelsData.length; i < len; i++) {
        rowWrap = this._colorLA_wrap.selectAll("g.v-row.ID_" + i);
        if(this._colorLA_options.position === 'top' || this._colorLA_options.position === 'bottom') {
          this._colorLAfn_createRowWithColorLabel.call(this, rowWrap, i + this._colorLA_startItemNum, true, labelsData[i].val, this._colorLA_textWidth);
        }else{
          this._colorLAfn_createRowWithColorLabel.call(this, rowWrap, i + this._colorLA_startItemNum, true, labelsData[i].val);
        }
        
      }

      //Each row position
      gEnterRow.attr('transform', function(d, i) {
        if(d.pos){
          return 'translate(' + d.pos.x + ',' + d.pos.y + ')';
        }
      });
    };
    
    ColorLegendArea.prototype._colorLAfn_renderHierarchicalLegend = function(labelsData, gEnterRow){
      var hieLabelsData = this._colorLA_hieChartData, that = this;
      
      this._colorLA_wrap.selectAll('g.v-group').remove();
      var groupWrap = this._colorLA_wrap.selectAll('g.v-group').data(hieLabelsData);
      groupWrap.exit().remove();
      var groupWrapEnter = groupWrap.enter().append('g').attr('class', 'v-group');
      
      var groupText = groupWrapEnter.selectAll('text').data(function(d){
        return d.subgroup;
      }, function(d){
        return d;
      });
      groupText.enter().append('text');
      var labelFont = "font-size:" + this._colorLA_valueLabelFont.fontsize + "; font-weight:" + this._colorLA_valueLabelFont.fontweight + "; font-family:" + this._colorLA_valueLabelFont.fontfamily;
      groupText.each(function(d, i) {
        TextRuler.ellipsis(d, this, that._colorLA_width - i * 10, labelFont);
      });
      
      groupWrap.selectAll('text').attr('dy', function(d, i){
        return (i + 1) * that._colorLA_textHeight + ((i > 0) ? i * that._colorLA_markerMargin.bottom * that._colorLA_textHeight : 0);
      }).attr('dx', function(d, i){
        return i * 10;
      });
      
      var rowWrap, maxItemTextWidth;
      for(var i = 0, len = labelsData.length; i < len; i++) {
        rowWrap = this._colorLA_wrap.selectAll("g.v-row.ID_" + i);
        if(this._colorLA_options.position === 'top' || this._colorLA_options.position === 'bottom') {
          this._colorLAfn_createRowWithColorLabel.call(this, rowWrap, i + this._colorLA_startItemNum, true, labelsData[i].orignialVal[labelsData[i].orignialVal.length-1], this._colorLA_textWidth);
        }else{
          maxItemTextWidth = this._colorLA_width - labelsData[i].pos.x - (this._colorLA_colorLabelSize + this._colorLA_markerMargin.right) * this._colorLA_textHeight;
          this._colorLAfn_createRowWithColorLabel.call(this, rowWrap, i + this._colorLA_startItemNum, true, labelsData[i].orignialVal[labelsData[i].orignialVal.length-1], maxItemTextWidth);
        }
      }
      groupWrap.attr('transform', function(d, i){
        if(d.pos){
          return 'translate(' + d.pos.x + ',' + d.pos.y + ')';
        }
      });
      //Each row position
      gEnterRow.attr('transform', function(d, i) {
        if(d.pos){
          return 'translate(' + d.pos.x + ',' + d.pos.y + ')';
        }
      });
    };
    
   ColorLegendArea.prototype._colorLAfn_getLabelData = function(){
      var labelsData = [], start = this._colorLA_startItemNum, len = this._colorLA_endItemNum;
      if(this._colorLA_chartData.length > 0){
        //Split items
        labelsData = this._colorLA_chartData.slice(start, len);
        this._colorLA_startRow = 0;
        this._colorLA_endRow = len;
      }
      return labelsData;
    };
    
    ColorLegendArea.prototype._colorLAfn_getThemeStyleDef = function(){
      var valueLabelStyle = this._colorLA_styleManager.query('v-label');
      if(valueLabelStyle){
        if(valueLabelStyle['fill']){
          this._colorLA_valueLabelFont.color = valueLabelStyle['fill'];
        }
        if(valueLabelStyle['font-family']){
          this._colorLA_valueLabelFont.fontfamily = valueLabelStyle['font-family'];
        }
        if(valueLabelStyle['font-size']){
          if(this._colorLA_valueLabelFont.fontsize !== valueLabelStyle['font-size']){
            this._colorLA_isStyleChanged = true;
          }
          this._colorLA_valueLabelFont.fontsize = valueLabelStyle['font-size'];
        }
        if(valueLabelStyle['font-weight']){
          if(this._colorLA_valueLabelFont.fontweight !== valueLabelStyle['font-weight']){
            this._colorLA_isStyleChanged = true;
          }
          this._colorLA_valueLabelFont.fontweight = valueLabelStyle['font-weight'];
        }
      }
    };
    
    ColorLegendArea.prototype._colorLAfn_hoverHandler = function(){
      var target = getCurrentEvent().target;
      var item = d3.select(target);
      var clickedItemClass = item.attr('class');
      if(this._colorLAfn_isPagingEvent(target)){
        if(clickedItemClass.search('v-pre') === -1){
          this._colorLA_wrap.selectAll('.v-nextBtn').attr('class', 'v-nextBtn v-hovershadow').attr('fill', this._colorLA_style.hovershadow.fill);
        }else{
          this._colorLA_wrap.selectAll('.v-preBtn').attr('class', 'v-preBtn v-hovershadow').attr('fill', this._colorLA_style.hovershadow.fill);
        }
      }else{
        if(!this._colorLAfn_validateEvent(target)){
          return;
        }
      
        var indicatedItem = this._colorLA_wrap.selectAll('.v-indicatedRect');
        var indicatedItemPos = this._colorLAfn_getIndicatedItemPosition(item);
        indicatedItem.attr('class', 'v-indicatedRect v-hovershadow').attr('fill', this._colorLA_style.hovershadow.fill)
          .attr('y', indicatedItemPos.y).attr('visibility', 'visible');
        if(this._colorLA_options.position === 'top' || this._colorLA_options.position === 'bottom') {
          indicatedItem.attr('x', indicatedItemPos.x).attr('width', indicatedItemPos.width);
        }
      }
    };
    
    ColorLegendArea.prototype._colorLAfn_blurHandler = function(){
      var target = getCurrentEvent().target;
      var item = d3.select(target);
      var clickedItemClass = item.attr('class');
      if(this._colorLAfn_isPagingEvent(target)){
        if(clickedItemClass.search('v-pre') === -1){
          this._colorLA_wrap.selectAll('.v-nextBtn').attr('class', 'v-nextBtn').attr('fill', 'rgba(0, 0, 0 ,0)');
        }else{
          this._colorLA_wrap.selectAll('.v-preBtn').attr('class', 'v-preBtn').attr('fill', 'rgba(0, 0, 0 ,0)');
        }
      }else{
        if(!this._colorLAfn_validateEvent(target)){
          return;
        }
      
        var indicatedItem = this._colorLA_wrap.selectAll('.v-indicatedRect');
        indicatedItem.attr('visibility', 'hidden');
      }
    };
    
    ColorLegendArea.prototype._colorLAfn_itemClicked = function(){
      var target = getCurrentEvent().target;
      
      var item = d3.select(target);
      var clickedItemClass = item.attr('class');

      if(!clickedItemClass){
        return;
      }
      
      if(clickedItemClass.search('v-pre') === -1 && clickedItemClass.search('v-next') === -1){
        var isValid = this._colorLAfn_validateEvent(target);
        if(isValid === false){
          return;
        }
        
        var indicatedItem = this._colorLA_wrap.selectAll('.v-indicatedRect');
        var indicatedItemPos = this._colorLAfn_getIndicatedItemPosition(item);
        indicatedItem.attr('class', 'v-indicatedRect v-hovershadow-mousedown').attr('visibility', 'visible').attr('fill', '#808080').attr('y', indicatedItemPos.y);
        if(this._colorLA_options.position === 'top' || this._colorLA_options.position === 'bottom') {
          indicatedItem.attr('x', indicatedItemPos.x).attr('width', indicatedItemPos.width);
        }
      }else{
        //click on preBtn or nextBtn
        var paging = false;
        if(clickedItemClass.search('v-pre') === -1){
          //Next page
          //Current page's last item always be shown as the first item of next page.
          if(this._colorLA_pagingBtnInfo.hasNext){
            this._colorLA_lastStartRow = this._colorLA_startItemNum;
            this._colorLA_startItemNum = this._colorLA_endItemNum;
            paging = true;
          }
          this._colorLA_wrap.selectAll('.v-nextBtn').attr('class', 'v-nextBtn v-hovershadow-mousedown').attr('fill', '#808080');
        }else{
          //Pre page
          if(this._colorLA_pagingBtnInfo.hasPre){
            var eachRowHeight = this._colorLA_textHeight + this._colorLA_textHeight * this._colorLA_markerMargin.bottom;
            var itemsCount = Math.floor((this._colorLA_height-this._colorLA_pagingBtnInfo.height*this._colorLA_textHeight*2) / eachRowHeight);
            if(itemsCount === 0) {
              itemsCount = 1;
            }
            this._colorLA_startItemNum = this._colorLA_startItemNum - itemsCount;
//              this._colorLA_startItemNum = lastStartRow;
            paging = true;
          }
          this._colorLA_wrap.selectAll('.v-preBtn').attr('class', 'v-preBtn v-hovershadow-mousedown').attr('fill', '#808080');
        }
        
        if(paging){
          this._colorLA_startItemNum  = (this._colorLA_startItemNum < 0) ? 0 : this._colorLA_startItemNum;
          this._colorLAfn_calculateRowPosition({width: this._colorLA_width, height: this._colorLA_height});
          this.render(d3.select(this));
        }
      }
    };
    
    ColorLegendArea.prototype.clickHandler = function(){
      var target = getCurrentEvent().target;
      var isValid = this._colorLAfn_validateEvent(target);
      if(isValid === false){
        return;
      }
   
      var isSelected = false;
      
      if(_contains(this._colorLA_selectedItem, target)){
        //has been selected.
        isSelected = true;
      }else{
        //New selected item
        this._colorLA_selectedItem.push(target);
      }
      return isSelected;
    };
    
    ColorLegendArea.prototype.deselectByCtx = function(deselectedData){
      if(!deselectedData){
        //deslected All items. Remove all selected legend items.
        this._colorLA_selectedItem = [];
//        d3.selectAll('.indicatedRect').attr('fill', 'rgba(0,0,0,0)');
      }else{
        var itemData, isSame = true;
        for(var i = 0, len = this._colorLA_selectedItem.length; i < len; i++){
          isSame = true;
          itemData = this._colorLA_selectedItem[i].__data__.ctx.path;
          if(!itemData){
            itemData = this._colorLA_selectedItem[i].__data__.ctx.ranges;
            if(itemData !== deselectedData.ctx.ranges){
              isSame = false;
            }
          }else{
            for(var k in itemData){
              if(deselectedData.ctx.path[k] !== undefined){
                if(deselectedData.ctx.path[k].length > 0){
                  if(deselectedData.ctx.path[k] !== itemData[k]){
                    isSame = false;
                  }
                }else{
                  if(deselectedData.ctx.path[k] !== itemData[k]){
                    isSame = false;
                  }
                }
              }
            }
          }
          
          if(isSame === true){
            //remove the deselected item.
            this._colorLA_selectedItem.splice(i, 1);
            break;
          }
        }
      }
    };
    
    ColorLegendArea.prototype._colorLAfn_validateEvent = function(target){
      var isValid = true;
      if(this._colorLA_selectionMode === 'single' || this._colorLA_selectionMode === 'none'){
        isValid = false;
      }
      
      var item = d3.select(target);
      var clickedItemClass = item.attr('class');
      if(!clickedItemClass || clickedItemClass.search('eventRect') === -1){
        isValid = false;
      }
      
      return isValid;
    };
    
    ColorLegendArea.prototype._colorLAfn_isPagingEvent = function(target){
      var isValid = false;
      
      var item = d3.select(target);
      var clickedItemClass = item.attr('class');
      if(clickedItemClass && (clickedItemClass.search('v-pre') !== -1 || clickedItemClass.search('v-next') !== -1)){
        isValid = true;
      }
      return isValid;
    };
    
    ColorLegendArea.prototype._colorLAfn_getIndicatedItemPosition = function(item){
      var data = item.datum(); 
      var markerSize = (this._colorLA_colorLabelSize + this._colorLA_markerMargin.right) * this._colorLA_textHeight + this._colorLA_markerMargin.left * this._colorLA_textHeight / 2;
      return {
        x : data.pos.x - 4,
        y : data.pos.y - this._colorLA_markerMargin.bottom * this._colorLA_textHeight / 2,
        width : this._colorLA_textWidth + markerSize
      };
    };
    
    /*
     * Calculate legend row position and return legend max size. 
     * return max and min size.
     */
    ColorLegendArea.prototype._colorLAfn_calculateRowPosition = function(wholeSize) {
      var maxHeight = 0, maxWidth = 0, minWidth = 0, minHeight = 0,
        maxRowTextSize = {'width':0, 'height':0}, 
        labelsData = this._colorLA_chartData,
        maxRowWidth = 0;
      
      if(labelsData && labelsData.length > 0){
        var labelFont = "font-size:" + this._colorLA_valueLabelFont.fontsize + "; font-weight:" + this._colorLA_valueLabelFont.fontweight + "; font-family:" + this._colorLA_valueLabelFont.fontfamily;
        this._colorLA_textHeight = parseInt(this._colorLA_valueLabelFont.fontsize, 10); //1em
        
        //markerSize = Color_Marker_Size + Right_Margin
        var markerSize = (this._colorLA_colorLabelSize + this._colorLA_markerMargin.right) * this._colorLA_textHeight;
        var rowLabelSize = [], xPos = 0, yPos = 0; //each row text width
        var eachRowHeight = this._colorLA_textHeight + this._colorLA_textHeight * this._colorLA_markerMargin.bottom;
        
        this._colorLA_rowPosArr = [];
        
        var i, j, len, jLen = 0, _colorLA_contentHeight = 200;
        //Measure labels size
        //If colors feed don't have MND, can't show legend in hierarchy.
        if((this._colorLA_options.legendType !== 'BubbleColorLegend') && this._colorLA_options.isHierarchy && (!(this._colorLA_options.position === 'top' || this._colorLA_options.position === 'bottom'))){
          
          var dimLen = 0, lastDimIndex, lastSameDimVal, 
            hieLabelItem = {
              subgroup: [],
              item: [],
              pos: { x: xPos, y: yPos}
            },
            hieLabelsData = this._colorLA_hieChartData = [];
          this._colorLA_endItemNum = labelsData.length;
          if(wholeSize.height !== 0) {
            _colorLA_contentHeight = wholeSize.height;
          }
          
          for(i = 0, len = labelsData.length; i < len; i++) {
            dimLen = labelsData[i].orignialVal.length;
            lastDimIndex = labelsData[i].val.search(labelsData[i].orignialVal[dimLen - 1]);
            if(lastSameDimVal === undefined){
              lastSameDimVal = labelsData[i].val.substring(0, lastDimIndex);
              for(j = 0; j < dimLen; j++){
                if(j === dimLen - 1){
                  hieLabelItem.item.push({
                    val: labelsData[i].orignialVal[j],
                    ctx: labelsData[i].ctx
                  });
                }else{
                  hieLabelItem.subgroup.push(labelsData[i].orignialVal[j]);
                }
                yPos = yPos + eachRowHeight;
              }
            }else{
              if(labelsData[i].val.search(lastSameDimVal) === -1){
                hieLabelsData.push(Objects.extend(true, {}, hieLabelItem));
  
                //New group
                lastSameDimVal = labelsData[i].val.substring(0, lastDimIndex);
                hieLabelItem.subgroup = [];
                hieLabelItem.item = [];
                hieLabelItem.pos = {
                  x: xPos,
                  y: yPos
                };
                for(j = 0; j < dimLen; j++){
                  yPos = yPos + eachRowHeight;
                  if(yPos > _colorLA_contentHeight){
                    break;
                  }
                  if(j === dimLen - 1){
                    hieLabelItem.item.push({
                      val: labelsData[i].orignialVal[j],
                      ctx: labelsData[i].ctx
                    });
                  }else{
                    hieLabelItem.subgroup.push(labelsData[i].orignialVal[j]);
                  }
                }
              }else{
                yPos = yPos + eachRowHeight;
                hieLabelItem.item.push({
                  val: labelsData[i].orignialVal[dimLen - 1],
                  ctx: labelsData[i].ctx
                });
              }
            }
            if(yPos > _colorLA_contentHeight){
              this._colorLA_isItemsOverflow = true;
              this._colorLA_endItemNum = i;
              yPos = yPos - eachRowHeight;
              this._colorLA_firstOverFlowPos = yPos + this._colorLA_textHeight;
              
              if(hieLabelItem.subgroup.length > 0){
                hieLabelsData.push(Objects.extend(true, {}, hieLabelItem));
              }
              hieLabelItem = undefined;
              break;
            }
            labelsData[i].pos = {x: (xPos + 10 * (dimLen-1)), y: (yPos - eachRowHeight)};
          }
          if(len > 0 && hieLabelItem !== undefined){
            hieLabelsData.push(Objects.extend(true, {}, hieLabelItem));
          }
          
          //Calculate max width
          var rowWidth = 0, isOverMaxTextCount = false; //Used for measure text
          maxRowWidth = 0;
         
          for(i = 0, len = hieLabelsData.length; i < len; i++){
            for(j = 0, jLen = hieLabelsData[i].subgroup.length; j < jLen; j++){
              rowWidth = xPos + j * 10 + TextRuler.measure(hieLabelsData[i].subgroup[j], labelFont).width;
              if(rowWidth > maxRowWidth){
                maxRowWidth = rowWidth;
              }
            }
            for(j = 0; j < hieLabelsData[i].item.length; j++){
              rowWidth = xPos + 10 * (jLen - 1) + markerSize + this._colorLA_markerMargin.left * this._colorLA_textHeight + TextRuler.measure(hieLabelsData[i].item[j].val, labelFont).width;
              if(rowWidth > maxRowWidth){
                maxRowWidth = rowWidth;
              }
            }
          }

          maxWidth = maxRowWidth;
          minWidth = xPos + 10 * (jLen - 1) + markerSize + this._colorLA_markerMargin.left * this._colorLA_textHeight + TextRuler.measure('M...', labelFont).width;
          maxHeight = yPos;
          minHeight = 2 * this._colorLA_textHeight;
        }else{
          //No isHierarchy. Calculate each row's position
          if(this._colorLA_options.position === 'top' || this._colorLA_options.position === 'bottom'){
            //Horizontal Layout
            
            var _colorLA_contentSize = {width : 200, height: 200};
            if(wholeSize.width !== 0) {
              _colorLA_contentSize.width = wholeSize.width;
            }
            if(wholeSize.height !== 0) {
              _colorLA_contentSize.height = wholeSize.height;
            }
            
            var maxTextItemWidth = 0;
            //Measure max text size
            for(i = 0, len = labelsData.length; i < len; i++){
              if(i >= this._colorAL_maxTextCount){
                break;
              }
              labelsData[i].size = TextRuler.measure(labelsData[i].val, labelFont);
              if(labelsData[i].size.width > maxTextItemWidth){
                maxTextItemWidth = labelsData[i].size.width; 
              }
            }
            if(maxTextItemWidth > this._colorLA_textWidth){
              maxTextItemWidth = this._colorLA_textWidth;
            }
            
            var eachItemWidth = markerSize + maxTextItemWidth + this._colorLA_markerMargin.left * this._colorLA_textHeight,
              eachRowCount = Math.floor(_colorLA_contentSize.width / eachItemWidth),
              colIndex = 0;
            
            maxWidth = (eachRowCount > labelsData.length) ? (labelsData.length * eachItemWidth) : (eachRowCount * eachItemWidth);
            var maxRowCount = Math.ceil(labelsData.length/eachRowCount);
            maxHeight = maxRowCount * this._colorLA_textHeight + (maxRowCount - 1) * this._colorLA_textHeight * this._colorLA_markerMargin.bottom;
            
            if(labelsData.length > eachRowCount) {
              minHeight = this._colorLA_textHeight * 2 + this._colorLA_textHeight * this._colorLA_markerMargin.bottom;
            }else{
              minHeight = this._colorLA_textHeight;
            }
            
            this._colorLA_endItemNum = labelsData.length;
            for(i = 0, len = labelsData.length; i < len; i++){
              if(colIndex === eachRowCount){
                this._colorLA_firstOverFlowPos = xPos;
                xPos = 0;
                colIndex = 0;
                yPos = yPos + this._colorLA_textHeight + this._colorLA_textHeight * this._colorLA_markerMargin.bottom;
                
                if((len - i > eachRowCount) && (yPos + this._colorLA_textHeight + this._colorLA_textHeight * this._colorLA_markerMargin.bottom > _colorLA_contentSize.height)){
                  this._colorLA_endItemNum = i;
                  this._colorLA_firstOverFlowPos = yPos + this._colorLA_textHeight;
                  this._colorLA_isItemsOverflow = true;
                  break;
                }
              }
              labelsData[i].pos = {x: xPos, y: yPos};
              
              colIndex++;
              xPos = xPos + eachItemWidth;
            }
            
            minWidth = eachItemWidth;
          }else{
            //Vertical Layout
            _colorLA_contentHeight = 200;
            if(wholeSize.height !== 0) {
              _colorLA_contentHeight = wholeSize.height;
            }
            var pagingBtnHeight = (this._colorLA_pagingBtnInfo.height + this._colorLA_pagingBtnInfo.padding) * this._colorLA_textHeight;
            this._colorLA_endItemNum = labelsData.length;
            if(this._colorLA_isItemsOverflow === true ){
              if(this._colorLA_pagingBtnInfo.hasPre === true){
                //Add PRE button's height
                yPos = yPos + pagingBtnHeight;
              }
            }
            for(i = this._colorLA_startItemNum, len = labelsData.length; i < len; i++){
              // Initialize the maxRowTextSize
              if(maxRowTextSize.width === 0 && maxRowTextSize.height === 0){
                 maxRowTextSize= TextRuler.measure(labelsData[i].val, labelFont);
              }

              //Set Y-Position
              if(i > this._colorLA_startItemNum){
                yPos = yPos + eachRowHeight;
              }
              if((yPos + this._colorLA_textHeight > _colorLA_contentHeight) && (i < len)){
                this._colorLA_endItemNum = i; //This index's label can't be shown.
                this._colorLA_isItemsOverflow = true;
                
                this._colorLA_pagingBtnInfo.hasNext = true;
                this._colorLA_pagingBtnInfo.hasPre = true;
                
                if(yPos + pagingBtnHeight > _colorLA_contentHeight){
                  this._colorLA_endItemNum = this._colorLA_endItemNum - 1;
                }
                this._colorLA_firstOverFlowPos = yPos;
                
                break;
              }
              //Measure label text size.
              if((labelsData[i].size === undefined) || (this._colorLA_isStyleChanged !== false)){
                labelsData[i].size = TextRuler.measure(labelsData[i].val, labelFont);
              }
              labelsData[i].pos = {x: xPos, y: yPos};
              
              //Set max text length
              if(labelsData[i].size.width > maxRowTextSize.width){
                maxRowTextSize = labelsData[i].size;
              }
            }
            
            //Update hasNext and hasPre status
            if(yPos + eachRowHeight <= _colorLA_contentHeight || this._colorLA_endItemNum === len){
              this._colorLA_pagingBtnInfo.hasNext = false;
              this._colorLA_pagingBtnInfo.hasPre = true;
            }
            if(this._colorLA_startItemNum === 0){
              this._colorLA_pagingBtnInfo.hasPre = false;
            }
            

            maxRowWidth = markerSize + maxRowTextSize.width;
            maxWidth = xPos + maxRowWidth;
            maxHeight = eachRowHeight * len;
            minHeight = pagingBtnHeight * 2 + this._colorLA_textHeight;
            if(minHeight > maxHeight){
              minHeight = maxHeight;
            }
            
            //Calculation final row text size.
            minWidth = xPos + markerSize + TextRuler.measure('M...', labelFont).width; 
          }
        }
      }
      if(minWidth > maxWidth){
        minWidth = maxWidth;
      }
      if(this._colorLA_isStyleChanged === true){
        this._colorLA_isStyleChanged = false;
      }
      return {
        minHeight : minHeight,
        minWidth: minWidth,
        height: maxHeight,
        width: maxWidth
      };
    };
    
    ColorLegendArea.prototype._colorLAfn_getImageURL = function(index)
    {
        var imageURL = "";

        var imageURLNumber = this._colorLA_imageInfo.imagePalette.length;
        if(imageURLNumber > 0)
        {
            imageURL = this._colorLA_imageInfo.imagePalette[index%imageURLNumber];
        }

        return imageURL;
    };
    
    ColorLegendArea.prototype._colorLAfn_createRowWithColorLabel = function(wrap, index, isShowColorLabel, labelText, maxWidth) {
      var dx = 0, colorLabelType;
      var markerSize = this._colorLA_colorLabelSize * this._colorLA_textHeight;
      var that = this;
      
      if(isShowColorLabel) {
        if(this._colorLA_shapeFeedLength > 0){
          var shapeIndex = index % this._colorLA_shapeFeedLength;
          if(this._colorLA_shapes.length < this._colorLA_shapeFeedLength){
            //less shape to be used
            shapeIndex = shapeIndex % this._colorLA_shapes.length;
          }
          colorLabelType = this._colorLA_shapes[shapeIndex];
        }else{
          if(this._colorLA_options.legendType === 'BubbleColorLegend'){
            colorLabelType = (this._colorLA_shapes[0] === undefined) ? 'square' : this._colorLA_shapes[0];
          }else{
            var tmpShape = this._colorLA_shapes[index % this._colorLA_shapes.length];
            colorLabelType = (tmpShape === undefined) ? 'square' : tmpShape;
            if(colorLabelType === 'square'){
              colorLabelType = "squareWithRadius";
            }
          }
        }
        
        if(!this._colorLA_imageInfo.imageMode)
        {
            var centerPos = this._colorLA_textHeight / 2; 
            var path = wrap.selectAll('path').data([labelText]);
            DrawUtil.createElements(path.enter(),{shape: colorLabelType, className: null} );
            path.attr("transform", function(d,i)
            {
              var color;
              if(that._colorLA_shapeFeedLength > 0) {
                i = Math.floor(index / that._colorLA_shapeFeedLength);
                var t = that._colorLA_colors.length > that._colorLA_colorFeedLength ? that._colorLA_colorFeedLength : that._colorLA_colors.length;
                if(t > 0){
                  color = that._colorLA_colors[i % t];
                }else{
                  color = that._colorLA_colors[0];
                }
              } else {
                color = that._colorLA_colors[index % (that._colorLA_colors.length > that._colorLA_colorFeedLength ? that._colorLA_colorFeedLength : that._colorLA_colors.length)];
              }
              var parameter = {
                  drawingEffect:that._colorLA_options.drawingEffect,
                  graphType:colorLabelType,
                  fillColor : color,
                  direction : 'vertical',
                  rx: markerSize / 2,
                  ry: markerSize / 2,
                  borderWidth: 0,
                  borderColor: "transparent",
                  node:d3.select(this)
    //              visibility: "visible"
              };
              DrawUtil.drawGraph(parameter, that._colorLA_effectManager);
              return 'translate(' + centerPos + ',' + centerPos + ')';
          
            });
        }
        else
        {
            var imageObjs = wrap.select("image");
            if(imageObjs.empty())
            {
                imageObjs = wrap.append("image");
            }

            imageObjs.attr("xlink:xlink:href", this._colorLAfn_getImageURL(index))
                .attr("width",markerSize)
                .attr("height",markerSize);
        }
        
        dx = markerSize + this._colorLA_markerMargin.right * this._colorLA_textHeight;
      }
      // item text label
      var text = wrap.selectAll('text').data([labelText]);
      text.enter().append('text');
      text.attr('x', dx).attr('y', this._colorLA_textHeight).text(function(d) {
          return d;
        });
      
      var labelFont = "font-size:" + this._colorLA_valueLabelFont.fontsize + "; font-weight:" + this._colorLA_valueLabelFont.fontweight + "; font-family:" + this._colorLA_valueLabelFont.fontfamily;
      text.each(function(d) {
        TextRuler.ellipsis(d, this, ((maxWidth === undefined) ? that._colorLA_width-dx : maxWidth), labelFont);
      });
      return wrap;
    };

    //Utility method.
    var _contains = function(a, obj){
      for (var i = 0; i < a.length; i++) {
            if (a[i] === obj) {
                return true;
            }
        }
        return false;
    };
    
    function getCurrentEvent() {
      if (d3.event) {
          return d3.event;
      } else {
          return window.event;
      }
    }
    
  return ColorLegendArea;
});
define('sap/viz/modules/legend/sizeLegendArea',['sap/viz/base/utils/oo', 'sap/viz/modules/Base', 'sap/viz/util/TextUtils','sap/viz/lang/langManager','sap/viz/format/FormatManager','sap/viz/base/utils/TypeUtils', 'sap/viz/util/DrawUtil'],
function Setup(oo, Base, TextRuler, langManager,FormatManager,TypeUtils, DrawUtil) {
  
  var SizeLegendArea = function(styleManager){
    this._sizeLA_width = 400;
    this._sizeLA_height = 200; 
    this._sizeLA_valueLabelFont = {
      'fontfamily' : "'Open Sans', Arial, Helvetica, sans-serif",
      'fontsize' : '14px',
      'fontweight' : 'normal',
      'color' : '#333333'
    };
    this._sizeLA_chartData=[0, 0, 0]; 
    this._sizeLA_scale = undefined;
//    this._sizeLA_colors; 
//    this._sizeLA_shapes; 
    this._sizeLA_guildeLineWidth = 10; 
    this._sizeLA_valuePaddingLeft = 15; 
    //TODO maybe can move this global argument to local
    this._sizeLA_valueLabelHeight = 0; 
    this._sizeLA_options = undefined;
    
    this._sizeLA_effectManager  = null;
    this._sizeLA_styleManager = styleManager;
  };
  
  oo.extend(SizeLegendArea, Base);
    
  SizeLegendArea.prototype.render = function(selection){
    var that = this;
    selection.each(function(){
      if(that._sizeLA_scale === undefined){
        return;
      }
      
      that._sizeLAfn_getThemeStyleDef();
      
      //Smart value label management.
      var textHeight = parseInt(that._sizeLA_valueLabelFont.fontsize, 10); //1em
      var visibleData = [], labelFont = "font-size:" + that._sizeLA_valueLabelFont.fontsize + "; font-weight:" + that._sizeLA_valueLabelFont.fontweight + "; font-family:" + that._sizeLA_valueLabelFont.fontfamily;
      if(that._sizeLA_valueLabelHeight === 0){
        that._sizeLA_valueLabelHeight = TextRuler.measure('M', labelFont).height;
      }
      var visibleCount = Math.floor((that._sizeLA_scale(that._sizeLA_chartData[0]) + textHeight) / that._sizeLA_valueLabelHeight);
      switch(visibleCount){
        case 0:
        case 1:
          visibleData.push(that._sizeLA_chartData[0]);
          break;
        case 2:
          visibleData.push(that._sizeLA_chartData[0]);
          if(that._sizeLA_chartData.length > 1){
            visibleData.push(that._sizeLA_chartData[that._sizeLA_chartData.length -1]);
          }
          break;
        default :
          visibleData = that._sizeLA_chartData;
      }

      var bubbleSizeArr = [], maxWidth = -1, dataWidth, value;
      for(var i = 0, len = visibleData.length; i < len; i++){
        bubbleSizeArr.push(that._sizeLA_scale(visibleData[i])/2);
        value = _isNullValue(visibleData[i]);
        if(TypeUtils.isExist(that._sizeLA_options.formatString)){
            value = FormatManager.format(value , that._sizeLA_options.formatString );
          }
        dataWidth = TextRuler.measure(value, labelFont).width;
        if(dataWidth > maxWidth){
          maxWidth = dataWidth;
        }
      }
      var maxBubbleSize = bubbleSizeArr[0];
      var wrap = d3.select(this);
      var circlesWrap = wrap.selectAll('g.v-circles');
      if(circlesWrap.empty()){
        circlesWrap = wrap.append('g').attr('class', 'v-circles').data([bubbleSizeArr]);
      }
      circlesWrap.attr('transform', 'translate(' + maxBubbleSize + ',' + (maxBubbleSize+textHeight)+ ')');
      
      var parameter = {
        drawingEffect : that._sizeLA_options.drawingEffect,
        graphType : 'circle',
        fillColor : '#748CB2'
      };
      var fillID = that._sizeLA_effectManager.register(parameter);
      var circleElements = circlesWrap.selectAll('path').data(bubbleSizeArr, function(d, i){
        return d;
      });
      circleElements.exit().remove();
      circleElements.enter().append('path').attr('stroke', 'white').attr('stroke-width', 1).attr('fill', fillID).attr('opacity', '1').attr('fill-opacity', '0.85');
      circleElements.attr('d', function(d, i){ 
        return DrawUtil.createMarkerData({type: 'circle', borderWidth: 0, rx: d, ry: d});
      }).attr('transform', function(d, i){
       return ['translate(', 0, ',', maxBubbleSize-d, ')'].join('');
      });

      
      var labelsWrap = wrap.selectAll('g.v-valueLabels');
      if(labelsWrap.empty()){
        labelsWrap = wrap.append('g').attr('class', 'v-valueLabels').data([visibleData]);
      }
      var labelX = (maxBubbleSize*2+that._sizeLA_valuePaddingLeft+that._sizeLA_guildeLineWidth+maxWidth) > that._sizeLA_width ? that._sizeLA_width : (maxBubbleSize*2+that._sizeLA_valuePaddingLeft+that._sizeLA_guildeLineWidth+maxWidth);
      labelsWrap.attr('transform', 'translate('+ labelX +', '+(maxBubbleSize+textHeight*3/2)+')');
      var valueElements = labelsWrap.selectAll('text').data(visibleData, function(d, i){
        return d;
      });
      valueElements.exit().remove();
      valueElements.enter().append('text').attr('text-anchor', 'end');
      valueElements.text(function(d, i){
          var value = _isNullValue(d);
          if(TypeUtils.isExist(that._sizeLA_options.formatString)){
            value = FormatManager.format(value , that._sizeLA_options.formatString );
          }
          return value;
        }).attr('dx', 0).attr('dy', function(d, i){
          var dy = (i-1)*maxBubbleSize - 2;
          if(visibleData.length === 2 && i === 1){
            dy = maxBubbleSize - 2;
          }
          return dy;
        });
      
      var guidelineWrap = wrap.selectAll('g.v-guideLines');
      if(!guidelineWrap.empty()){
        //Empty
        guidelineWrap.remove();
      }
      guidelineWrap = wrap.append('g').attr('class', 'v-guideLines').attr('transform', 'translate(' + maxBubbleSize + ',' + (maxBubbleSize+textHeight)+ ')');
      if(visibleData.length > 0){
        guidelineWrap.append('path').attr('stroke', 'gray').attr('d', 'M 0 '+ -maxBubbleSize +' L '+(maxBubbleSize+that._sizeLA_guildeLineWidth)+" "+ -maxBubbleSize);
      }
      if(visibleData.length > 1){
        guidelineWrap.append('path').attr('stroke', 'gray').attr('d', 'M 0 '+ maxBubbleSize +'L'+(maxBubbleSize+that._sizeLA_guildeLineWidth)+" "+ maxBubbleSize);
      }
      if(visibleData.length > 2){
        guidelineWrap.append('path').attr('stroke', 'gray').attr('d', 'M 0 '+ (maxBubbleSize - bubbleSizeArr[1]) +' L '+maxBubbleSize+" 0"+  ' M '+ maxBubbleSize + " 0 " + " L "+ (maxBubbleSize + that._sizeLA_guildeLineWidth) +" 0");
      }
      
      var defaultValueLabelStyle = that._sizeLA_styleManager.queryDefault('v-label');
      wrap.attr('font-family', defaultValueLabelStyle['font-family']).attr('font-size', defaultValueLabelStyle['font-size']).attr('font-weight', defaultValueLabelStyle['font-weight']).attr('fill', defaultValueLabelStyle.color);
    });
  };
    
  SizeLegendArea.prototype.width = function(_) {
    if(!arguments.length){
      return this._sizeLA_width;
    }
    this._sizeLA_width = _;
    return this;
  };

  SizeLegendArea.prototype.height = function(_) {
    if(!arguments.length){
      return this._sizeLA_height;
    }
    this._sizeLA_height = _;
    return this;
  };
  
  SizeLegendArea.prototype.color = function(_) {
    return this;
  };

  SizeLegendArea.prototype.shapes = function(_) {
    return this;
  };
  
  SizeLegendArea.prototype.properties = function(properties) {
    if(!arguments.length){
      return this._sizeLA_options;
    }
    //TODO use extends...
    this._sizeLA_options = properties;
    return this;
  };
  
  SizeLegendArea.prototype.data = function(_){
    if(!arguments.length){
      return this._sizeLA_chartData;
    }
    this._sizeLA_chartData = _;
    return this;
  };
  
  SizeLegendArea.prototype.scale = function(_){
    if(!arguments.length){
      return this._sizeLA_scale;
    }
    this._sizeLA_scale = _;
    return this;
  };
  
  SizeLegendArea.prototype.effectManager = function(_) {
    if(!arguments.length){
      return this._sizeLA_effectManager;
    }

    this._sizeLA_effectManager = _;
    return this;
  };
  
  SizeLegendArea.prototype._sizeLAfn_getThemeStyleDef = function(){
    var valueLabelStyle = this._sizeLA_styleManager.query('v-label');
    if(valueLabelStyle){
      if(valueLabelStyle['fill']){
        this._sizeLA_valueLabelFont.color = valueLabelStyle['fill'];
      }
      if(valueLabelStyle['font-family']){
        this._sizeLA_valueLabelFont.fontfamily = valueLabelStyle['font-family'];
      }
      if(valueLabelStyle['font-size']){
        this._sizeLA_valueLabelFont.fontsize = valueLabelStyle['font-size'];
      }
      if(valueLabelStyle['font-weight']){
        this._sizeLA_valueLabelFont.fontweight = valueLabelStyle['font-weight'];
      }
    }
  };
  
  SizeLegendArea.prototype.hasData = function(){
    if(this._sizeLA_scale){
       return true;
    }else {
      return false;
    }
  };
  
  SizeLegendArea.prototype.getPreferredSize = function(){

    this._sizeLAfn_getThemeStyleDef();
    var maxWidth = 0, maxHeight = 0, minWidth = 0, minHeight = 0;
    var maxValueWidth = -1, maxBubbleSize, valueSize = [], value = null, space, i, len,
      data = this._sizeLA_chartData, labelFont = "font-size:" + this._sizeLA_valueLabelFont.fontsize + "; font-weight:" + this._sizeLA_valueLabelFont.fontweight + "; font-family:" + this._sizeLA_valueLabelFont.fontfamily;

      /*** start new layout algorithm ***/
      if(this._sizeLA_scale){
        for(i = 0, len = data.length; i < len; i++){
          value = _isNullValue(data[i]);
          if(TypeUtils.isExist(this._sizeLA_options.formatString)){
              value = FormatManager.format(value , this._sizeLA_options.formatString );
            }
          valueSize[i] = TextRuler.measure(value, labelFont);
          if((valueSize[i] === undefined) || (valueSize[i].width > maxValueWidth)) {
            maxValueWidth = valueSize[i].width;
          }
        }
        space =  maxValueWidth + this._sizeLA_valuePaddingLeft + this._sizeLA_guildeLineWidth;
        maxBubbleSize = this._sizeLA_scale(data[0]);
        
        maxHeight = maxBubbleSize + valueSize[len - 1].height;
        maxWidth = maxBubbleSize + space;
        minWidth = maxBubbleSize + this._sizeLA_valuePaddingLeft + this._sizeLA_guildeLineWidth + valueSize[0].width;
        minHeight = maxHeight;
        
        //TODO workaround to add 1em padding in the bottom or right 
        if (this._sizeLA_options.position === 'top' || this._sizeLA_options.position === 'bottom') {
          maxWidth = maxWidth + valueSize[len - 1].height;
          minWidth = minWidth + valueSize[len - 1].height;
        }else{
          maxHeight = maxHeight + valueSize[len - 1].height;
          minHeight = maxHeight;
        }
      }
    return {
      minHeight: minHeight,
      minWidth: minWidth,
      height: maxHeight,
      width: maxWidth
    };
  };
    
  SizeLegendArea.prototype.doLayout = function(size){
    return size;
  };
  
  SizeLegendArea.prototype.destroy = function(){
    this._sizeLA_styleManager = null;
    this._sizeLA_effectManager = null;
  };
    
  var _isNullValue = function(value){
    return (value === null) ? langManager.get('IDS_ISNOVALUE') : value;
  };
  
  return SizeLegendArea;
});
define('sap/viz/modules/legend/mbcLegendArea',['sap/viz/base/utils/oo', 'sap/viz/modules/Base', 'sap/viz/util/TextUtils','sap/viz/lang/langManager','sap/viz/format/FormatManager','sap/viz/base/utils/TypeUtils',
'sap/viz/base/UADetector'],
function Setup(oo, Base, TextRuler, langManager,FormatManager,TypeUtils, UADetector) {
  
  var MBCLegendArea = function(styleManager){
    
    this._mbcLA_width = 400;
    this._mbcLA_height = 200;
    this._mbcLA_valueLabelFont = {
        'fontfamily' : "'Open Sans', Arial, Helvetica, sans-serif",
        'fontsize' : '12px',
        'fontweight' : 'normal',
        'color' : '#333333'
      };
    this._mbcLA_wrap = undefined;
    this._mbcLA_chartData = undefined;
    this._mbcLA_colors = [];
    this._mbcLA_markerSize = {width: 12, height : 12};
    this._mbcLA_paddingBottom = 1;
    this._mbcLA_selectedItem = [];
    this._mbcLA_selectionMode = 'multiple';
    this._mbcLA_posInfo = {
        markerSize: 12, //default marker width is 12px in vertical layout. Opposite, marker height is 12px in horizontal layout.
        markerPaddingRight : 0.5,
        paddingTop : 1,
        maxValueSpace : 1.6,
        minValueSpace : 0.5,
        maxMarkerHeight : 36,  //3em(12*3 px)
        minMarkerHeight : 12,  //10pixel changes to 1em(12px)
        space : 0
      };
    this._mbcLA_nullLabelIndex = -1;
    this._mbcLA_textHeight = 20;
    this._mbcLA_minimized = false;
    
    this._mbcLA_noValueString = langManager.get('IDS_ISNOVALUE');
    this._mbcLA_options = undefined;
    this._mbcLA_effectManager = null;
    this._mbcLA_styleManager = styleManager;

    this._mbcLA_style = {};
    this._mbcLA_style.hovershadow = styleManager.queryDefault('v-hovershadow');
  };

  oo.extend(MBCLegendArea, Base);
  
  MBCLegendArea.prototype.render = function(selection){
    var that = this;
    var calMarkerAndTextInfo = function(labelsData){
      var info = {marker: [], label: []}, xPos = 0, yPos = 0, colors = that._mbcLA_colors.slice(),
        valuePaddingLeft = that._mbcLA_posInfo.markerPaddingRight * that._mbcLA_textHeight,
        eachMarkerCellSize, i, len, val, tVal;
      
      colors = colors.reverse();
      if(that._mbcLA_nullLabelIndex !== -1){
        var firstColor = colors.shift();
        colors.push(firstColor);
      }
      
      if(that._mbcLA_options.position === 'top' || that._mbcLA_options.position === 'bottom'){
        //Horizontial layout
        eachMarkerCellSize = that._mbcLA_markerSize.width + that._mbcLA_paddingBottom;
        var textYPos = that._mbcLA_markerSize.height + valuePaddingLeft + that._mbcLA_textHeight, textWidth,
          labelFont = "font-size:" + that._mbcLA_valueLabelFont.fontsize + "; font-weight:" + that._mbcLA_valueLabelFont.fontweight + "; font-family:" + that._mbcLA_valueLabelFont.fontfamily;
        
        for(i = 0, len = labelsData.length; i < len; i++){
          val = labelsData[i].val; 
          //Marker
          if(val === 'N/A' && len > 1){
            xPos = xPos + eachMarkerCellSize;
          }
          info.marker.push({x: xPos, y: yPos, color: colors[i], val: labelsData[i].val, ctx: labelsData[i].ctx});
          
          //TextL
          if(i === 0 && len > 1){
            textWidth = TextRuler.measure(labelsData[i].ctx.ranges.endValue, labelFont).width;
            tVal = labelsData[i].ctx.ranges.endValue;
            if(TypeUtils.isExist(that._mbcLA_options.formatString)){
              tVal = FormatManager.format(labelsData[i].ctx.ranges.endValue, that._mbcLA_options.formatString);
            }
            info.label.push({val: tVal, x: 0, y: textYPos});
          }
          if(val === 'N/A'){
            val = that._mbcLA_noValueString;
          }
          if(TypeUtils.isExist(that._mbcLA_options.formatString)){
              val = FormatManager.format(val , that._mbcLA_options.formatString );
          }
          textWidth = TextRuler.measure(val, labelFont).width;
          if(val === that._mbcLA_noValueString){
            info.label.push({val: val, x: xPos, y: textYPos});
          }else{
            info.label.push({val: val, x: xPos + eachMarkerCellSize, y: textYPos});
          }
          xPos = xPos + eachMarkerCellSize;
        }
        
        //Handler only one value label. Put it again.
        if(len === 1 && labelsData[0].val !== 'N/A'){
          info.label.push({val: labelsData[0].val, x: xPos - eachMarkerCellSize, y: textYPos});
        }
      }else{
        //Vertical layout
        eachMarkerCellSize = that._mbcLA_markerSize.height + that._mbcLA_paddingBottom; 
        var textXPos = that._mbcLA_markerSize.width + valuePaddingLeft;
        for(i = 0, len = labelsData.length; i < len; i++){
          val = labelsData[i].val; 
          //Marker
          if(val === 'N/A' && len > 1){
            yPos = yPos + eachMarkerCellSize;
          }
          info.marker.push({x: xPos, y: yPos, color: colors[i], val: val, ctx: labelsData[i].ctx});
          //Text
          if(i === 0 && len > 1){
            tVal = labelsData[i].ctx.ranges.endValue;
            if(TypeUtils.isExist(that._mbcLA_options.formatString)){
              tVal = FormatManager.format(labelsData[i].ctx.ranges.endValue, that._mbcLA_options.formatString);
            }
            info.label.push({val: tVal, x: textXPos, y: that._mbcLA_textHeight});
          }
          if(val === 'N/A'){
            val = that._mbcLA_noValueString;
          }
          if(TypeUtils.isExist(that._mbcLA_options.formatString)){
              val = FormatManager.format(val , that._mbcLA_options.formatString );
          }
          if(val === that._mbcLA_noValueString){
            info.label.push({val: val, x: textXPos, y: yPos + that._mbcLA_textHeight - that._mbcLA_paddingBottom});
          }else{
            info.label.push({val: val, x: textXPos, y: yPos + eachMarkerCellSize + that._mbcLA_textHeight - that._mbcLA_paddingBottom});
          }
          yPos = yPos + eachMarkerCellSize;
        }
        
        //Handler only one value label. Put it again.
        if(len === 1 && labelsData[0].val !== 'N/A'){
          info.label.push({val: labelsData[0].val, x: textXPos, y: yPos - eachMarkerCellSize + that._mbcLA_textHeight - that._mbcLA_paddingBottom});
        }
      }
      
      return info;
    };
      selection.each(function(){
        that._mbcLAfn_getThemeStyleDef();
        
        //Calculate marker size.
        that._mbcLAfn_calMarkerSize({width: that._mbcLA_width, height: that._mbcLA_height});
        
        var labelsData = that._mbcLA_chartData, textElements, y = 0, visible = 'visible', j, jlen, valuePaddingLeft = that._mbcLA_posInfo.markerPaddingRight * that._mbcLA_textHeight;
        var wrap = d3.select(this);
        that._mbcLA_wrap = wrap;
        
        var indicatedRectElement = wrap.selectAll('rect.v-indicatedRect');
        if(indicatedRectElement.empty()){
          indicatedRectElement = wrap.append('rect').attr('class', 'v-indicatedRect v-hovershadow');
        }
        indicatedRectElement.attr('visibility', 'hidden')
          .attr('width', that._mbcLA_markerSize.width + 8).attr('height', that._mbcLA_markerSize.height+2);
        
        var infos = calMarkerAndTextInfo(labelsData);
        var makerWrapper = wrap.selectAll('rect.v-marker').data(infos.marker, function(d, i){
          return d.val;
        });
        makerWrapper.exit().remove();
        makerWrapper.enter().append('rect').attr('class', function(d, i){
          return 'v-marker ID_' + i;
        });
        makerWrapper.attr('width', that._mbcLA_markerSize.width)
          .attr('height', that._mbcLA_markerSize.height)
          .attr('x', function(d){
            return d.x;
          })
          .attr('y', function(d){
            return d.y;
          })
          .attr('fill', function(d){
            var parameter = {
              drawingEffect : 'normal',
              fillColor : d.color
            };
            var fillID = that._mbcLA_effectManager.register(parameter);
            return fillID;
          });
        
        var textWrapper = wrap.selectAll('text').data(infos.label, function(d){
          return d.val;
        });
        textWrapper.exit().remove();
        textWrapper.enter().append('text').text(function(d){
          return d.val;
        });
        textWrapper.attr('x', function(d){
          return d.x;
        }).attr('y', function(d){
          return d.y;
        }).attr('visibility', function(d, i){
          var visible = 'visible';
          if(that._mbcLA_minimized && (d.val !== 'N/A')){
            var maxLen = (that._mbcLA_nullLabelIndex === -1) ? that._mbcLA_chartData.length : (that._mbcLA_chartData.length - 1); 
            if(i > 0 && i < maxLen){
              visible = 'hidden';
            }
          }
          return visible;
        });
        
        var defaultValueLabelStyle = that._mbcLA_styleManager.queryDefault('v-label');
        wrap.attr('font-family', defaultValueLabelStyle['font-family']).attr('font-size', defaultValueLabelStyle['font-size']).attr('font-weight', defaultValueLabelStyle['font-weight']).attr('fill', defaultValueLabelStyle.color);
        if (UADetector.isMobile()) {
            wrap.on('touchstart', function(){
              that._mbcLAfn_itemClicked.call(that, arguments);
            }).on('touchend.color', function(){
              that._mbcLAfn_blurHandler.call(that, arguments);
            });
        } else {
            wrap.on('mouseover', function(){
              that._mbcLAfn_hoverHandler.call(that, arguments);
            }).on('mouseout', function(){
              that._mbcLAfn_blurHandler.call(that, arguments);
            }).on('mousedown', function(){
              that._mbcLAfn_itemClicked.call(that, arguments);
            }).on('mouseup', function(){
              that._mbcLAfn_hoverHandler.call(that, arguments);
            });
        }
      });
    };

    MBCLegendArea.prototype._mbcLAfn_hoverHandler = function(){
      if(this._mbcLA_selectionMode === 'single' || this._mbcLA_selectionMode === 'none' || this._mbcLA_options.isHierarchy){
        return;
      }
      var item = d3.select(getCurrentEvent().target);
        var clickedItemClass = item.attr('class');
        
        if(!clickedItemClass || clickedItemClass.search('marker') === -1){
          return;
        }
        var x = item.attr('x'), y = item.attr('y');
        
      var indicatedItem = this._mbcLA_wrap.selectAll('.v-indicatedRect');
      indicatedItem.attr('class', 'v-indicatedRect v-hovershadow').attr('visibility', 'visible')
        .attr('fill', this._mbcLA_style.hovershadow.fill).attr('x', x - 4).attr('y', y- 1);
    };
    
    MBCLegendArea.prototype._mbcLAfn_blurHandler = function(){
      if(this._mbcLA_selectionMode === 'single' || this._mbcLA_selectionMode === 'none' || this._mbcLA_options.isHierarchy){
        return;
      }
      var item = d3.select(getCurrentEvent().target);
        var clickedItemClass = item.attr('class');
        
        if(!clickedItemClass || clickedItemClass.search('marker') === -1){
          return;
        }
        
      var indicatedItem = this._mbcLA_wrap.selectAll('.v-indicatedRect');
      indicatedItem.attr('visibility', 'hidden');
    };
    
    MBCLegendArea.prototype._mbcLAfn_itemClicked = function(){
      if(this._mbcLA_selectionMode === 'single' || this._mbcLA_selectionMode === 'none' || this._mbcLA_options.isHierarchy){
        return;
      }
      var item = d3.select(getCurrentEvent().target);
        var clickedItemClass = item.attr('class');
        
        if(!clickedItemClass || clickedItemClass.search('marker') === -1){
          return;
        }
        var x = item.attr('x'), y = item.attr('y');
        
      var indicatedItem = this._mbcLA_wrap.selectAll('.v-indicatedRect');
      indicatedItem.attr('class', 'v-indicatedRect v-hovershadow-mousedown').attr('visibility', 'visible').attr('fill', '#808080').attr('x', x - 4).attr('y', y- 1);
    };
    
    MBCLegendArea.prototype.clickHandler = function(){
      if(this._mbcLA_selectionMode === 'single' || this._mbcLA_selectionMode === 'none' || this._mbcLA_options.isHierarchy){
        return;
      }

      var isSelected = false,
          target = getCurrentEvent().target;
      
      if(_contains(this._mbcLA_selectedItem, target)){
        //has been selected.
        isSelected = true;
      }else{
        //New selected item
        this._mbcLA_selectedItem.push(target);
      }
      return isSelected;
    };
    
    MBCLegendArea.prototype.width = function(_) {
      if(!arguments.length){
        return this._mbcLA_width;
      }
      this._mbcLA_width = _;
      return this;
    };

    
    MBCLegendArea.prototype.height = function(_) {
      if(!arguments.length){
        return this._mbcLA_height;
      }
      this._mbcLA_height = _;
      return this;
    };
    
    MBCLegendArea.prototype.properties = function(properties) {
      if(!arguments.length){
        return this._mbcLA_options;
      }
      //TODO use extends...
      if(this._mbcLA_options !== undefined && this._mbcLA_options.position !== properties.position){
        //reset default marker size
        this._mbcLA_markerSize = {width: 12, height : 12};
      }
      this._mbcLA_options = properties;
      return this;
    };
    
    MBCLegendArea.prototype.data = function(_){
      if(!arguments.length){
        return this._mbcLA_chartData;
      }
      this._mbcLA_chartData = _;
      return this;
    };
    
    MBCLegendArea.prototype.setSelectionMode = function(_){
      this._mbcLA_selectionMode = _;
    };
    
    MBCLegendArea.prototype.hasData = function(){
      if( this._mbcLA_chartData){
        return true;
      }else {
        return false;
      }
    };
    
    MBCLegendArea.prototype.getPreferredSize = function() {
      var maxWidth = 0, maxHeight = 0, minHeight = 0, minWidth = 0, data = this._mbcLA_chartData, noValueWidth;
      if(data){
        //reset N/A flag
        this._mbcLA_nullLabelIndex = -1;
        
        this._mbcLAfn_getThemeStyleDef();
        this._mbcLA_textHeight = parseInt(this._mbcLA_valueLabelFont.fontsize, 10); //1em
        var textInfos = this._mbcLAfn_calTextSize();
        var len = data.length, maxValueWidth = textInfos.maxValueWidth, valueSize = textInfos.textSize;
        
//        var h = (this._mbcLA_posInfo.maxValueSpace + 1) * this._mbcLA_textHeight;
        var h = this._mbcLA_posInfo.maxMarkerHeight;
        
        if(this._mbcLA_options.position === 'top' || this._mbcLA_options.position === 'bottom'){
          this._mbcLA_markerSize.height = this._mbcLA_posInfo.markerSize;
          maxHeight = minHeight = this._mbcLA_markerSize.height + this._mbcLA_paddingBottom * this._mbcLA_textHeight + this._mbcLA_textHeight;
          if(this._mbcLA_nullLabelIndex !== -1){
            var labelFont = "font-size:" + this._mbcLA_valueLabelFont.fontsize + "; font-weight:" + this._mbcLA_valueLabelFont.fontweight + "; font-family:" + this._mbcLA_valueLabelFont.fontfamily;
            noValueWidth = TextRuler.measure(this._mbcLA_noValueString, labelFont).width;
            maxWidth = (h + this._mbcLA_paddingBottom) * (len+1) + (noValueWidth > h ? noValueWidth : h) - this._mbcLA_paddingBottom * 2;
            minWidth = (this._mbcLA_posInfo.minMarkerHeight + this._mbcLA_paddingBottom) * (len + 1) + (noValueWidth > this._mbcLA_posInfo.minMarkerHeight ? noValueWidth : this._mbcLA_posInfo.minMarkerHeight) - this._mbcLA_paddingBottom * 2;
          }else{
            maxWidth = (h + this._mbcLA_paddingBottom) * len + valueSize[0].width - this._mbcLA_paddingBottom;
            minWidth = (this._mbcLA_posInfo.minMarkerHeight + this._mbcLA_paddingBottom) * len + valueSize[0].width - this._mbcLA_paddingBottom;
          }
        }else{
          this._mbcLA_markerSize.width = this._mbcLA_posInfo.markerSize;
          maxWidth = this._mbcLA_markerSize.width + this._mbcLA_posInfo.markerPaddingRight * this._mbcLA_textHeight + maxValueWidth;
          minWidth = this._mbcLA_markerSize.width + this._mbcLA_posInfo.markerPaddingRight * this._mbcLA_textHeight + (valueSize[0].width > valueSize[len - 1].width ? valueSize[0].width : valueSize[len - 1].width);
          if(this._mbcLA_nullLabelIndex !== -1){
            maxHeight = (h + this._mbcLA_paddingBottom) * (len+1) - this._mbcLA_paddingBottom * 2;
            minHeight = (this._mbcLA_posInfo.minMarkerHeight + this._mbcLA_paddingBottom) * (len+1) - this._mbcLA_paddingBottom * 2;
          }else{
            maxHeight = (h + this._mbcLA_paddingBottom) * len + this._mbcLA_textHeight - this._mbcLA_paddingBottom;
            minHeight = (this._mbcLA_posInfo.minMarkerHeight + this._mbcLA_paddingBottom) * len + this._mbcLA_textHeight - this._mbcLA_paddingBottom;
          }
        }
      }
      return {
        minHeight: minHeight,
        minWidth: minWidth,
        width: maxWidth,
        height: maxHeight
      };
    };
    
    MBCLegendArea.prototype.doLayout = function(size){
      // Calculate marker size.
      this._mbcLAfn_calMarkerSize(size);
      var textInfos = this._mbcLAfn_calTextSize();
      
      var actualWidth = 0, actualHeight = 0, textWidth = 0, len = textInfos.textSize.length;
      if(this._mbcLA_minimized === true){
        textWidth = (textInfos.textSize[0].width > textInfos.textSize[len-1].width) ? textInfos.textSize[0].width : textInfos.textSize[len-1].width;
      }else{
        textWidth = textInfos.maxValueWidth;
      }
        
      actualWidth = this._mbcLA_markerSize.width + this._mbcLA_posInfo.markerPaddingRight * this._mbcLA_textHeight + textWidth;
      if(this._mbcLA_nullLabelIndex !== -1){
        actualHeight = (this._mbcLA_markerSize.height + this._mbcLA_paddingBottom) * (len+1) + this._mbcLA_textHeight;
      }else{
        actualHeight = (this._mbcLA_markerSize.height + this._mbcLA_paddingBottom) * len + this._mbcLA_textHeight;
      }
      return {
        width : actualWidth,
        height : actualHeight
      };
    };
    
    MBCLegendArea.prototype.color = function(_) {
      if(!arguments.length){
        return this._mbcLA_colors;
      }
      this._mbcLA_colors = _;  
      return this;
    };
    
    MBCLegendArea.prototype.effectManager = function(_) {
      if(!arguments.length){
        return this._mbcLA_effectManager;
      }
      this._mbcLA_effectManager = _;

      return this;
    };
    
    MBCLegendArea.prototype._mbcLAfn_calTextSize = function(){
      var maxValueWidth = -1, valueSize = [], data = this._mbcLA_chartData, labelFont = "font-size:" + this._mbcLA_valueLabelFont.fontsize + "; font-weight:" + this._mbcLA_valueLabelFont.fontweight + "; font-family:" + this._mbcLA_valueLabelFont.fontfamily;
      var len = data.length;
      for ( var i = 0; i < len; i++) {
        if(data[i].val === 'N/A'){
          valueSize[i] = TextRuler.measure(this._mbcLA_noValueString, labelFont);
          this._mbcLA_nullLabelIndex = i;
        }else{
          var value = data[i].val;
          if(TypeUtils.isExist(this._mbcLA_options.formatString)){
              value = FormatManager.format(value , this._mbcLA_options.formatString );
            }
          valueSize[i] = TextRuler.measure(value, labelFont);
          
        }
        if ((valueSize[i] === undefined) || (valueSize[i].width > maxValueWidth)) {
          maxValueWidth = valueSize[i].width;
        }
      }
      return {
        maxValueWidth : maxValueWidth,
        textSize : valueSize
      };
    };
    
    MBCLegendArea.prototype._mbcLAfn_calMarkerSize = function(size){
      var len = this._mbcLA_chartData.length, h = 0, space = 0, areaSize, value;
      this._mbcLA_minimized = false;
      var maxValueSpace = this._mbcLA_posInfo.maxValueSpace * this._mbcLA_textHeight;
      var minValueSpace = this._mbcLA_posInfo.minValueSpace * this._mbcLA_textHeight;
      
      if(this._mbcLA_options.position === 'top' || this._mbcLA_options.position === 'bottom'){
        areaSize = size.width;
        var labelFont = "font-size:" + this._mbcLA_valueLabelFont.fontsize + "; font-weight:" + this._mbcLA_valueLabelFont.fontweight + "; font-family:" + this._mbcLA_valueLabelFont.fontfamily;
        
        if(this._mbcLA_nullLabelIndex !== -1){
          h = (areaSize - this._mbcLA_paddingBottom * (len - 1) - TextRuler.measure(this._mbcLA_noValueString, labelFont).width) / (len + 1);
        }else{
          value = this._mbcLA_chartData[this._mbcLA_chartData.length - 1].val;
          if(TypeUtils.isExist(this._mbcLA_options.formatString)){
            value = FormatManager.format(value , this._mbcLA_options.formatString );
          }
          h = (areaSize - this._mbcLA_paddingBottom * (len - 1) - TextRuler.measure(value, labelFont).width) / len;
        }
        
        //Check marker size
        if(h > this._mbcLA_posInfo.maxMarkerHeight){
          h = this._mbcLA_posInfo.maxMarkerHeight;
        }
        
        for(var i = 0; i < len; i++){
          if(i === 0 && len > 1){
            if(TextRuler.measure(this._mbcLA_chartData[i].ctx.ranges.endValue, labelFont).width > h){
              this._mbcLA_minimized = true;
              break;
            }
          }
          
          value = this._mbcLA_chartData[i].val;
          if(TypeUtils.isExist(this._mbcLA_options.formatString)){
            value = FormatManager.format(value , this._mbcLA_options.formatString );
          }
          if(TextRuler.measure(value, labelFont).width > h){
            this._mbcLA_minimized = true;
            break;
          }
        }
      }else{
        areaSize = size.height;
        
        var isFontOverflow = false;
        if(this._mbcLA_textHeight > this._mbcLA_posInfo.maxMarkerHeight){
          isFontOverflow = true;
        }
        //Calculate marker size
        if(this._mbcLA_nullLabelIndex !== -1){
          //No value
          h = (areaSize - this._mbcLA_paddingBottom * (len - 1) - (isFontOverflow ? (this._mbcLA_textHeight - this._mbcLA_posInfo.maxMarkerHeight): 0))/(len + 1);
        }else{
          h = (areaSize - this._mbcLA_paddingBottom * (len - 1) - this._mbcLA_textHeight) / len;
        }
        //Check marker size
        if(h > this._mbcLA_posInfo.maxMarkerHeight){
          h = this._mbcLA_posInfo.maxMarkerHeight;
        }
        if(h < this._mbcLA_textHeight){
          isFontOverflow = true;
        }
        if(isFontOverflow){
          this._mbcLA_minimized = true;
        }
      }

      this._mbcLA_posInfo.space = space;
      if(this._mbcLA_options.position === 'top' || this._mbcLA_options.position === 'bottom'){
        this._mbcLA_markerSize.width = h;
        this._mbcLA_markerSize.height = this._mbcLA_posInfo.markerSize;
      }else{
        this._mbcLA_markerSize.width = this._mbcLA_posInfo.markerSize;
        this._mbcLA_markerSize.height = h;
      }
    };
    
    MBCLegendArea.prototype._mbcLAfn_getThemeStyleDef = function(){
      var valueLabelStyle = this._mbcLA_styleManager.query('v-label');
      if(valueLabelStyle){
        if(valueLabelStyle['fill']){
          this._mbcLA_valueLabelFont.color = valueLabelStyle['fill'];
        }
        if(valueLabelStyle['font-family']){
          this._mbcLA_valueLabelFont.fontfamily = valueLabelStyle['font-family'];
        }
        if(valueLabelStyle['font-size']){
          this._mbcLA_valueLabelFont.fontsize = valueLabelStyle['font-size'];
        }
        if(valueLabelStyle['font-weight']){
          this._mbcLA_valueLabelFont.fontweight = valueLabelStyle['font-weight'];
        }
      }
    };
    
    MBCLegendArea.prototype.destroy = function(){
      //remove listener
      if(this._mbcLA_wrap){
        this._mbcLA_wrap.on('touchstart', null);
        this._mbcLA_wrap.on('touchend.color', null);
        this._mbcLA_wrap.on('mouseover', null);
        this._mbcLA_wrap.on('mouseup', null);
        this._mbcLA_wrap.on('mousedown', null);
        this._mbcLA_wrap.on('mouseout', null);
        this._mbcLA_wrap = null;  
      }
      this._mbcLA_styleManager = null;
      this._mbcLA_effectManager = null;
      this._mbcLA_selectedItem = null;
    };

  //Utility method.
  var _contains = function(a, obj){
    for (var i = 0; i < a.length; i++) {
          if (a[i] === obj) {
              return true;
          }
      }
      return false;
  };
    
  function getCurrentEvent() {
    if (d3.event) {
      return d3.event;
    } else {
      return window.event;
    }
  }

  return MBCLegendArea;
});
define('sap/viz/mvc/TapGestureDetector',['sap/viz/mvc/GestureDetector','sap/viz/base/Math'],
function Setup(GestureDetector, Math) {
	var ts = GestureDetector.TransitionState;
	var _distance = function(xy1, xy2) {
		var dx = xy1.x - xy2.x;
		var dy = xy1.y - xy2.y;
		return Math.sqrt(dx * dx + dy * dy);
	};

	var _startNewTapSequence = function(tapDetector, event) {
		tapDetector._sequenceStarted = true;
		tapDetector._currentNumberOfTaps = 0;
		tapDetector._firstStartXY = tapDetector.globalLocOfTouchPoints();
	};

	// Defines the maximum distance from current tap to where
	// the first tap
	// starts
	var _maxDistance = 50;
	// Defines the maximum and minimum time for each tap
	var _maxTapTime = 150;
	var _minTapTime = 20;
	// Defines the maximum time gap
	// between the time the previous tap ends and the time the
	// next one starts
	var _maxTapGap = 150;

	/**
	 * This class defines detector for detecting Tapping gesture. Tapping
	 * gesture is detected when required number of fingers tap the screen for
	 * required number of times.
	 * 
	 * @name sap.viz.mvc.TapGestureDetector
	 * @class
	 * @augments sap.viz.mvc.GestureDetector
	 */

	var TapGestureDetector = GestureDetector.extend({
		constructor : function(touchesRequired, tapsRequired) {
			touchesRequired = +touchesRequired;
			tapsRequired = +tapsRequired;
			this._touchesRequired = (touchesRequired > 0 && touchesRequired < 6) ? touchesRequired : 1;
			this._tapsRequired = (tapsRequired > 0) ? tapsRequired : 1;

			this._currentNumberOfTaps = 0;
			this._firstStartXY = undefined;
			this._sequenceStarted = false;
			this._currentStartWhen = 0;
		},

		/**
		 * The number of touches required for tap to be detected.
		 * 
		 * @function
		 * @param {Number}
		 *            numOfTouches
		 * @returns {Number|this}
		 */
		touchesRequired : function(numOfTouches) {
			if (arguments.length) {
				this._touchesRequired = +numOfTouches;
				return this;
			}
			return this._touchesRequired;
		},

		/**
		 * The number of taps required for tap to be detected.
		 * 
		 * @function
		 * @param {Number}
		 *            numOfTaps
		 * @returns {Number|this}
		 */
		tapsRequired : function(numOfTaps) {
			if (arguments.length) {
				this._tapsRequired = +numOfTaps;
				return this;
			}
			return this._tapsRequired;
		},

		doTouchBegin : function(touchStartEvent) {
			if (this.state === ts.Possible) {
				var currentNumOfTouches = this.totalTouches();
				if (currentNumOfTouches === this._touchesRequired) {
					var currentTimeStamp = touchStartEvent.timeStamp;

					// Beginning of the first
					// tap in a tap
					// sequence
					if (this._currentNumberOfTaps == 0) {
						// Record the
						// information of first
						// tap
						// for later comparison
						_startNewTapSequence(this, touchStartEvent);
					}
					// Beginning of a tap (other
					// than the first
					// one) in a tap sequence
					else {
						if (this._currentNumberOfTaps < this._tapsRequired) {
							var distance = _distance(this._firstStartXY, this.globalLocOfTouchPoints());
							var preStartWhen = this._currentStartWhen;

							// If the tap breaks
							// a tap sequence,
							// start a new
							// sequence with it
							if (distance > _maxDistance
									|| (currentTimeStamp - preStartWhen) > (_maxTapTime + _maxTapGap)) {
								_startNewTapSequence(this, touchStartEvent);
							}
						}
					}

					this._currentStartWhen = currentTimeStamp;
				} else { // Fails if touch
					// number doesn't
					// match
					this.state = ts.Failed;
				}
			}
		},

		doTouchEnd : function(touchEndEvent) {
			if (this.state === ts.Possible && this._sequenceStarted) {
				// Fails if the touch ends too
				// far away from
				// where it starts
				if (_distance(this._firstStartXY, this.globalLocOfTouchPoints()) > _maxDistance) {
					this.state = ts.Failed;
					return;
				}
				// Fails if the tap is too short
				// or too long
				var tapTime = touchEndEvent.timeStamp - this._currentStartWhen;
				if (tapTime > _maxTapTime || tapTime < _minTapTime) {
					this.state = ts.Failed;
					return;
				}
				if (++this._currentNumberOfTaps === this._tapsRequired) {
					this.state = ts.Recognized;
				}
			}
		},

		doTouchCancel : function(touchCancelEvent) {
			if (this.state === ts.Possible) {
				this.state = ts.Failed;
			}
		},

		reset : function() {
			this._super();
			this._currentNumberOfTaps = 0;
			this._sequenceStarted = false;
			this._firstStartXY = undefined;
			this._firstStartWhen = 0;
			this._currentStartWhen = 0;
		}
	});
	return TapGestureDetector;
});
define('sap/viz/modules/legend/common',['sap/viz/base/utils/oo', 'sap/viz/modules/Base', 'sap/viz/manifest','sap/viz/util/TextUtils','sap/viz/base/utils/TypeUtils','sap/viz/modules/dispatch',
'sap/viz/base/utils/ObjectUtils','sap/viz/modules/legend/colorLegendArea',
'sap/viz/modules/legend/sizeLegendArea','sap/viz/modules/legend/mbcLegendArea',
'sap/viz/lang/langManager','sap/viz/base/utils/Objects','sap/viz/modules/util/BoundUtil',
'sap/viz/base/UADetector','sap/viz/mvc/TapGestureDetector'],
function Setup(oo, Base, Manifest, TextRuler, TypeUtils, dispatch, ObjectUtils,
               ColorLegendArea, SizeLegendArea, MBCLegendArea, langManager,Objects,
               BoundUtil, UADetector, TapGestureDetector) 
{
  var Legend = function(manifest, ctx) {
    this._legend_imageInfo = {
        imageMode: false,
        imagePalette: [],
        radio: 1
    };

    this._legend_width = 0; 
    this._legend_height = 0;
    this._legend_preferenceSize = { width : 0, height : 0}; 
    this._legend_titleFont = {
      'fontfamily' : "'Open Sans', Arial, Helvetica, sans-serif",
      'fontsize' : '14px',
      'fontweight' : 'bold',
      'color' : '#333333'
    };
    this._legend_valueLabelFont = {
      'fontfamily' : "'Open Sans', Arial, Helvetica, sans-serif",
      'fontsize' : '12px',
      'fontweight' : 'normal',
      'color' : '#333333'
    };
    this._legend_options = {}; 
    this._legend_isVisible = true;  
    this._legend_shapes = []; 
    this._legend_colors = []; 
    this._legend_textHeight = 20; 
    this._legend_margin = {
      top : 0,
      right : 0,
      bottom : 0,
      left : 0
    }; 
    this._legend_titleMarginBottom = 0.5; 
    this._legend_legendAreaPos = {x:0, y:0}; 
    this._legend_sizeInfo = {
      sizeScale: undefined
    };
    this._legend_mbcInfo = {
        colorScale: undefined
    };
    this._legend_hideTitle = false;
    
    //Each row's position [{x: 10, y: 10}, {...}...]
    this._legend_chartData = {title:'', labels:''}; 
    this._legend_bubleSizeData = []; 
    this._legend_data = null;  //original data
    this._legend_shapeFeeds = []; 
    this._legend_colorFeeds = []; 
    this._legend_colorFeedLength = 0; 
    this._legend_shapeFeedLength = 0; 
    this._legend_relayout = true;
    this._legend_ctx = ctx;
    this._legend_legendArea = new ColorLegendArea(ctx.styleManager);
    this._legend_eDispatch = new dispatch('highlightedByLegend');
    this._legend_effectManager = ctx.effectManager;
    this._legend_eventManager = ctx.eventManager;
    this._legend_styleManager = ctx.styleManager;
    this._legend_properties = manifest.props(null);
    this._legend_isHierarchicalChanged = false;
    this._legend_oTapGestureDetector = undefined;
    this._legend_gEnterCol = undefined;
    this.properties(null);
  };
  
  oo.extend(Legend, Base);
  
  Legend.prototype.render = function(selection){
    BoundUtil.drawBound(selection, this._legend_width, this._legend_height);
    this._legendfn_renderLegend(selection);
  };
  
  Legend.prototype.deselectLegend = function(deselectedData){
    //TODO MBC support legend interaction.
    if(!(isMeasureBasedColoringLegend(this._legend_options.legendType) || isSizeLegend(this._legend_options.legendType))){
      this._legend_legendArea.deselectByCtx(deselectedData);
    }
  };
  
  /**
   * ff
   */
  Legend.prototype.width = function(_) {
    if(!arguments.length){
      return this._legend_width;
    }
    this._legend_width = _;
    this._legend_legendArea.width(_);
    this._legend_relayout = true;
    return this;
  };

  Legend.prototype.height = function(_) {
    if(!arguments.length){
      return this._legend_height;
    }
    this._legend_height = _;
    this._legend_legendArea.height(_);
    this._legend_relayout = true;
    return this;
  };

  Legend.prototype.imageInfo = function(_) {
    if(!arguments.length){
      return this._legend_imageInfo;
    }
    this._legend_imageInfo = _;
    this._legend_relayout = true;
    return this;
  };

  Legend.prototype.colorPalette = function(_) {
    if(!arguments.length){
      return this._legend_colors;
    }
    this._legend_colors = _;  
    this._legend_legendArea.color(_);
    return this;
  };

  Legend.prototype.shapes = function(_) {
    if(!arguments.length){
      return this._legend_shapes;
    }
    this._legend_shapes = _;
    this._legend_legendArea.shapes(_);
    return this;
  };

  Legend.prototype.data = function(_) {
    if(!arguments.length){
      return this._legend_data;
    }
    this._legend_data = _;
    this._legendfn_parseFeedsData(_);
    this._legend_legendArea.data(this._legend_chartData.labels);
    return this;
  };
  
  Legend.prototype.properties = function(props) {
    if(!arguments.length){
      return this._legend_properties;
    }
    //TODO use extends...
    if (this._legend_properties && props && this._legend_properties.isHierarchical !== props.isHierarchical){
      this._legend_isHierarchicalChanged = true;
    }
    Objects.extend(true, this._legend_properties, props);
    this._legend_options.visible = this._legend_properties.visible;
    this._legend_isVisible = this._legend_options.visible;
    this._legend_options.isShowTitle = this._legend_properties.title.visible;
    this._legend_options.titleText = this._legend_properties.title.text;
    this._legend_options.isHierarchy = this._legend_properties.isHierarchical;
    this._legend_options.isScrollable = this._legend_properties.isScrollable;
    this._legend_options.position = this._legend_properties.position;
   
    this._legend_options.formatString = this._legend_properties.formatString;
    
    if(this._legend_options.legendType !== this._legend_properties.type){
      this._legend_options.legendType = this._legend_properties.type;
      if(this._legend_data && this._legend_chartData.labels){
        this._legendfn_parseFeedsData(this._legend_data);
        this._legend_legendArea.data(this._legend_chartData.labels);
      }
    }
    this._legend_options.alignment = this._legend_properties.alignment;
    this._legend_options.drawingEffect = this._legend_properties.drawingEffect;
    
    if(isSizeLegend(this._legend_options.legendType)){
      this._legend_legendArea = new SizeLegendArea(this._legend_styleManager);
      
    }else if (isMeasureBasedColoringLegend(this._legend_options.legendType)){
      this._legend_legendArea = new MBCLegendArea(this._legend_styleManager);
    }
    this._legend_legendArea.properties(this._legend_options);
    
    //reset
    this._legend_height = 0;
    this._legend_width = 0;
    return this;
  };

  Legend.prototype.getPreferredSize = function () {
    this._legendfn_getThemeStyleDef();
    return this._legendfn_calculateRowPosition();
  };
  
  Legend.prototype.sizeLegendInfo = function(_){
    if(!arguments.length){
      return this._legend_sizeInfo.sizeScale;
    }
    //Size scale
    this._legend_sizeInfo.sizeScale = _.scale;
    this._legend_legendArea.scale(this._legend_sizeInfo.sizeScale);
    
    //Size data
    if(_.data.length === 0){
      this._legend_isVisible = false;
    }else{
      this._legend_isVisible = this._legend_options.visible;
      this._legend_bubleSizeData = _.data;
      this._legend_legendArea.data(this._legend_bubleSizeData);
    }
    
    //Size legend title
    this._legend_chartData.title = handleNull(_.title);
    
    return this;
  };
  
  /*
   * Measure based coloring
   */
  Legend.prototype.mbcLegendInfo = function(_){
    if(!arguments.length){
      return this._legend_mbcInfo.colorScale;
    }
    if(_.colorScale === undefined){
      this._legend_isVisible = false;
    }else{
      this._legend_isVisible = this._legend_options.visible;
      this._legend_mbcInfo.colorScale = _.colorScale;
      //Legend title
      this._legend_chartData.title = handleNull(_.title);
      this._legendfn_parseMeasureBasedColoringLegend();
      this._legend_legendArea.data(this._legend_chartData.labels);
    }
    return this;
  };
  
  Legend.prototype.setSelectionMode = function(_){
    if(! isSizeLegend(this._legend_options.legendType)){
      this._legend_legendArea.setSelectionMode(_);
    }
  };
  
  /**
   * get/set your event dispatch if you support event
   */
  Legend.prototype.dispatch = function(_){
    if(!arguments.length){
      return this._legend_eDispatch;
    }
    this._legend_eDispatch = _;
    return this;
  };
  
  Legend.prototype.destroy = function() {
    //call sub legend area destroy
    if(this._legend_legendArea && this._legend_legendArea.destroy){
      this._legend_legendArea.destroy();
    }
    if(this._legend_gEnterCol){
      this._legend_gEnterCol.on('click', null);
      //self destroy
      this._legend_gEnterCol = null;  
    }
    this._legend_colorFeeds = null;
    this._legend_data = null;
    this._legend_chartData = null;
    this._legend_legendArea = null;
    this._legend_effectManager = null;
    this._legend_eventManager = null;
    this._legend_styleManager = null;
    //destroy ctx
    if(this._legend_ctx){
      this._legend_ctx.destroy();
      this._legend_ctx = null;
    }    
    
  };
  
  Legend.prototype._legendfn_renderLegend = function(selection){
    var that = this;
    selection.each(function() {
      if ( isColorLegend(that._legend_options.legendType) || isBubbleColorLegend(that._legend_options.legendType) ) {
        if ( that._legend_chartData.labels.length === 0 ) {
          that._legend_isVisible = false;
        }
      }
      
      if ( that._legend_isVisible && _isSizeAcceptable.call(that)) {
        that._legendfn_getThemeStyleDef();
        
        if ( that._legend_relayout ) {
          that._legendfn_calculateRowPosition({'width': that._legend_width, 'height' : that._legend_height});
        }

        var xPos = that._legend_margin.left * that._legend_textHeight, 
            yPos = that._legend_margin.top * that._legend_textHeight,
            paddingRight = that._legend_margin.right * that._legend_textHeight,
            paddingBottom = that._legend_margin.bottom * that._legend_textHeight;
        
        var wrap = d3.select(this).selectAll('g.v-content').data([that._legend_chartData]);
        wrap.enter().append('g').attr('class', 'v-content');//.attr('clip-path', 'url(#legend-edge-clip)');
        if ( that._legend_isHierarchicalChanged ) {
          that._legend_isHierarchicalChanged = false;
          wrap.selectAll('.v-row').remove();
          wrap.selectAll('.v-group').remove();
        }
        //Legend Title
        if ( that._legend_options.isShowTitle && !that._legend_hideTitle ) {
          var titleTextHeight = parseInt(that._legend_titleFont.fontsize, 10);
          var titleStyle = 'font-weight: ' + that._legend_titleFont.fontweight +'; fill:' + that._legend_titleFont.color + '; font-family: ' + that._legend_titleFont.fontfamily + '; font-size: '+that._legend_titleFont.fontsize+";";
          var titleLabel = (that._legend_options.titleText===undefined || that._legend_options.titleText === null) ? that._legend_chartData.title : that._legend_options.titleText;
          
          var labelTitleElement = wrap.selectAll('text.v-title');
          if ( labelTitleElement.empty() ) {
            labelTitleElement = wrap.append('text').attr('class', 'v-title viz-legend-title');
          }
          var defalutTitleFont = that._legend_styleManager.queryDefault('v-title');
          labelTitleElement.text(titleLabel).attr('dx', xPos).attr('dy', yPos + titleTextHeight).attr('visibility', 'visible')
            .attr('font-weight', defalutTitleFont['font-weight']).attr('fill', defalutTitleFont['fill']).attr('font-family', defalutTitleFont['font-family']).attr('font-size', defalutTitleFont['font-size']);
          
          //Show ... in title 
          labelTitleElement.each(function(d) {
            TextRuler.ellipsis(titleLabel, this, that._legend_width - xPos - paddingRight, titleStyle);
          });
        } else {
          wrap.selectAll('text.v-title').attr('visibility', 'hidden');
          if ( that._legend_hideTitle ) {
              that._legend_hideTitle = false;
          } 
        }

        var labelsData = that._legend_chartData.labels;
        // Create Legend Groups
        var gEnterCol = wrap.selectAll('g.v-groups').data([labelsData]);
        that._legend_gEnterCol = gEnterCol;
        gEnterCol.enter().append('g').attr('class', 'v-groups v-label viz-legend-valueLabel');
        gEnterCol.attr('transform', 'translate('+that._legend_legendAreaPos.x+','+that._legend_legendAreaPos.y+')');

        var tmpWidth = ( !that._legend_width ? that._legend_preferenceSize.width : that._legend_width) - xPos - paddingRight;
        var tmpHeight = ( !that._legend_height ? that._legend_preferenceSize.height : that._legend_height) - paddingBottom;
        
        //TODO Need to handle legend in the top/bottom side.
        that._legend_legendArea.properties(that._legend_options).width(tmpWidth).height(tmpHeight-that._legend_legendAreaPos.y).effectManager(that._legend_effectManager);
        if ( isSizeLegend(that._legend_options.legendType) ) {
          that._legend_legendArea.data(that._legend_bubleSizeData).scale(that._legend_sizeInfo.sizeScale);
        } else if ( isMeasureBasedColoringLegend(that._legend_options.legendType) ) {
          that._legend_legendArea.data(labelsData).color(that._legend_mbcInfo.colorScale.range());
        } else {
          that._legend_legendArea.imageInfo(that._legend_imageInfo);
          that._legend_legendArea.data(labelsData).color(that._legend_colors).colorFeedLength(that._legend_colorFeedLength).shapeFeedLength(that._legend_shapeFeedLength);
        }
        //var temp = gEnterCol.call(that._legend_legendArea);
        that._legend_legendArea.render(gEnterCol);
        //Bind click handler in legend labels
        if (UADetector.isMobile()) {
          if(that._legend_oTapGestureDetector === undefined){
              that._legend_oTapGestureDetector = new TapGestureDetector();
              that._legend_oTapGestureDetector.addGestureAction(function(){
                return that._legendfn_mobileClickHandler.call(that, arguments);
              });
              that._legend_oTapGestureDetector.enable(true);

              that._legend_eventManager.addGestureDetector(that._legend_oTapGestureDetector);
          }
        } else {
          gEnterCol.on('click', function(){
            that._legendfn_clickHandler.call(that, arguments);
          });
        }
        
        //Vertical align to center
        if ( that._legend_options.position === 'left' || that._legend_options.position === 'right' ) {
          switch(that._legend_options.alignment){
            case 'start': 
              wrap.attr('transform','translate('+ 0 +','+ 0+')');
              break;
            case 'end':
              wrap.attr('transform', 'translate(' + 0 + ', ' + (((that._legend_height-that._legend_preferenceSize.height) > 0) ? ((that._legend_height-that._legend_preferenceSize.height)) : 0)+')');
              break;
            case 'middle':
              wrap.attr('transform', 'translate(' + 0 + ', '+(((that._legend_height-that._legend_preferenceSize.height)/2 > 0) ? ((that._legend_height-that._legend_preferenceSize.height)/2) : 0)+')');
              break;
          }
        } else {
//          var xpos = (that._legend_width-that._legend_preferenceSize.width)/2;
//          if(xpos < 0){
//            xpos = 0;
//          }
          
          wrap.attr('transform','translate('+ 0 +','+0+')');
        }
      } else {
        //Handle visible is false.
        var elements = d3.select(this).selectAll('g.v-content');
        if (!elements.empty()) {
            elements.remove();
        }
      }
    });
  };

    
  Legend.prototype._legendfn_mobileClickHandler  = function(data) {
    if (!this._legendfn_isValid(getCurrentEvent())) {
        return;
    }
    return this._legendfn_clickHandler(data);
  };

  Legend.prototype._legendfn_clickHandler = function(data) {
    var target = getCurrentEvent().target;
    var className = d3.select(target).attr('class');
    //TODO Use class name to check clicked item. Color legend and mbc legend use the same class name.
    if(className && className.search('v-preBtn') === -1 && className.search('v-nextBtn') === -1){
      var isSelected = this._legend_legendArea.clickHandler();
      var selectedData = d3.select(target).data()[0];
      if(selectedData !== undefined){
        this._legend_eDispatch.highlightedByLegend(selectedData, isSelected);
      }
    }
  };
  
  Legend.prototype._legendfn_isInLegendContent = function(node) {
      var result = false;
      if(node.tagName === 'svg'){
          return false;
      }else{
          if(node === this._legend_gEnterCol.node()){
              return true;
          }
          result = this._legendfn_isInLegendContent(node.parentNode);
      }
      return result;
  };

  Legend.prototype._legendfn_isValid = function(event) {
      return this._legendfn_isInLegendContent(event.target);
  };
    
    
      
  Legend.prototype._legendfn_getThemeStyleDef = function(){
    var titleStyle = this._legend_styleManager.query('v-title');
    if(titleStyle){
      if(titleStyle['fill']){
        this._legend_titleFont.color = titleStyle['fill'];
      }
      if(titleStyle['font-family']){
        this._legend_titleFont.fontfamily = titleStyle['font-family'];
      }
      if(titleStyle['font-size']){
        this._legend_titleFont.fontsize = titleStyle['font-size'];
      }
      if(titleStyle['font-weight']){
        this._legend_titleFont.fontweight = titleStyle['font-weight'];
      }
    }
    
    var valueLabelStyle = this._legend_styleManager.query('v-label');
    if(valueLabelStyle){
      if(valueLabelStyle['fill']){
        this._legend_valueLabelFont.color = valueLabelStyle['fill'];
      }
      if(valueLabelStyle['font-family']){
        this._legend_valueLabelFont.fontfamily = valueLabelStyle['font-family'];
      }
      if(valueLabelStyle['font-size']){
        this._legend_valueLabelFont.fontsize = valueLabelStyle['font-size'];
      }
      if(valueLabelStyle['font-weight']){
        this._legend_valueLabelFont.fontweight = valueLabelStyle['font-weight'];
      }
    }
  };
    
  Legend.prototype._legendfn_parseFeedsData = function(data) {
    if(!data){
      return;
    }
    this._legend_colorFeeds = [];
    this._legend_shapeFeeds = [];
    var aa = data.getAnalysisAxisDataByIdx(0);
    if(aa){ 
      this._legend_colorFeeds = aa.values;
    }
    
    aa = data.getAnalysisAxisDataByIdx(1);
    if(aa){
      this._legend_shapeFeeds = aa.values;
    }
    
    if(isBubbleColorLegend(this._legend_options.legendType)){
      this._legendfn_parseBubbleColorLegendFeeds();
    }else if(!(isSizeLegend(this._legend_options.legendType))){
      this._legendfn_parseColorLegendFeeds();
    }
  };
    
  Legend.prototype._legendfn_parseMeasureBasedColoringLegend = function(){
    var labels = [], item = {
      'val' : undefined,
      'ctx' : {}
    };
    var mbcDomains = this._legend_mbcInfo.colorScale.domain();
    for(var len = mbcDomains.length, i = 0, j = len-1; i < len; i++){
      if(mbcDomains[i].length > 0){
//          item.val = '[ ' + mbcDomains[i][0] + ' ; ' + mbcDomains[i][1] + ( i===len-1 ? ' ]' : ' [');
        item.val = mbcDomains[i][0];
        item.ctx.ranges = {
          startValue : mbcDomains[i][0],
          endValue : mbcDomains[i][1],
          isRightOpen : true,
          isLeftOpen : false
        };
      }else{
        item.val = 'N/A';
        item.ctx.ranges = {};
        if(labels[j+1] !== undefined){
          labels[j+1].ctx.ranges.isRightOpen = false;
        }
      }
      if(j === 0){
        item.ctx.ranges.isRightOpen = false;
      }
      labels[j] = {};
      ObjectUtils.extend(true, labels[j--], item);
    }
    
    //put N/A to the end of array
    if(labels[0].val ===  'N/A'){
      var firstItem = labels.shift();
      labels.push(firstItem);
    }
    
    this._legend_chartData.labels = labels;
  };
    
  Legend.prototype._legendfn_parseBubbleColorLegendFeeds = function(){
      var labels = [], title ='', tmpVal = '', i, j = 0, len, tmpLabel={
        'val' : undefined,
        'ctx' : {
          'path' : {}
        }
      }, dii;
    this._legend_colorFeedLength = 0, this._legend_shapeFeedLength = 0;
    
    if(this._legend_colorFeeds && this._legend_colorFeeds.length > 0 && this._legend_colorFeeds[0].rows.length > 0){
      var firstColorFeed = this._legend_colorFeeds[0];
      title = handleNull(firstColorFeed.col.val);
      
      dii = 'dii_a'+(firstColorFeed.rows[0].ctx.path.aa+1);
      tmpLabel = {
        'val' : firstColorFeed.rows[0].val,
        'ctx' : {
          'path' : { }
        },
        'info' : firstColorFeed.rows[0].info
      };
      tmpLabel.ctx.path[dii] = [firstColorFeed.rows[0].ctx.path.dii];
      
      for(i = 1, len = firstColorFeed.rows.length; i < len; i++){
        tmpVal = firstColorFeed.rows[i].val;
        if(tmpVal === tmpLabel.val || _containsVal(labels, tmpVal)){
          tmpLabel.ctx.path[dii].push(firstColorFeed.rows[i].ctx.path.dii);
        }else{
          labels[j] = {};
          tmpLabel.val = resolveCustomLabel(tmpLabel);
          ObjectUtils.extend(true, labels[j++], tmpLabel);
          //New color label. Add it to uniqueColorLabel and assign its new color
          tmpLabel.val = tmpVal;
          tmpLabel.ctx = {
            path : { }
          };
          tmpLabel.ctx.path[dii] = [firstColorFeed.rows[i].ctx.path.dii];
        }
      }
      //Add the last one
      labels[j] = {};
      tmpLabel.val = resolveCustomLabel(tmpLabel);
      ObjectUtils.extend(true, labels[j], tmpLabel);
      
      this._legend_colorFeedLength = labels.length;
    }
    
    if(this._legend_shapeFeeds && this._legend_shapeFeeds.length > 0) {
      var firstShapeFeed = this._legend_shapeFeeds[0], shapeLabels=[];
      title = (title === '') ? handleNull(firstShapeFeed.col.val) : title + " / " + handleNull(firstShapeFeed.col.val);
      
      dii = 'dii_a'+(firstShapeFeed.rows[0].ctx.path.aa+1);
      tmpLabel = {
        'val' : firstShapeFeed.rows[0].val,
        'ctx' : {
          'path' : {}
        },
        'info' : firstShapeFeed.rows[0].info
      }, j = 0;
      tmpLabel.ctx.path[dii] = [firstShapeFeed.rows[0].ctx.path.dii];
      
      for(i = 1, len = firstShapeFeed.rows.length; i < len; i++){
        tmpVal = firstShapeFeed.rows[i].val;
        if(tmpVal === tmpLabel.val || _containsVal(shapeLabels, tmpVal)){
          tmpLabel.ctx.path[dii].push(firstShapeFeed.rows[i].ctx.path.dii);
        }else{
          shapeLabels[j] = {};
          tmpLabel.val = resolveCustomLabel(tmpLabel);
          ObjectUtils.extend(true, shapeLabels[j++], tmpLabel);
          //New shape label. Add it to uniqueColorLabel and assign its new color
          tmpLabel.val = tmpVal;
          tmpLabel.ctx = {
            path : {}
          };
          tmpLabel.ctx.path[dii] = [firstShapeFeed.rows[i].ctx.path.dii];
        }
      }
      //Add the last one
      shapeLabels[j] = {};
      tmpLabel.val = resolveCustomLabel(tmpLabel);
      ObjectUtils.extend(true, shapeLabels[j], tmpLabel);

      this._legend_shapeFeedLength = shapeLabels.length;
      if(labels.length > 0){
        labels = getCartesian([labels, shapeLabels], ' / ');
      }else{
        labels = shapeLabels;
      }
    }
    
    if(labels.length === 0){
      this._legend_isVisible = false;
    }else{
      this._legend_isVisible = this._legend_options.visible;
    }
     
    this._legend_chartData = {
      'title' : title,
      'labels' : labels
    };
  };
    
  Legend.prototype._legendfn_parseColorLegendFeeds = function(){
    var title, labels = [];
    var colorData = this._legendfn_parseLegendFeed(title, this._legend_colorFeeds, this._legend_colorFeedLength);
    this._legend_colorFeedLength = colorData.feedsLength;
    var shapeData = this._legendfn_parseLegendFeed(title, this._legend_shapeFeeds, this._legend_shapeFeedLength);
    this._legend_shapeFeedLength = shapeData.feedsLength;
    
    //Color and Shape Cartesian
    if(shapeData.labels.length > 0){
      if(colorData.labels.length > 0){
        if(colorData.MNDInfo.MNDIndex === undefined && shapeData.MNDInfo.MNDIndex === undefined){
          //Has color and shape feed and no MND. So use '/'
          labels = getCartesian([colorData.labels, shapeData.labels], ' / ');
          title = colorData.title + " / " + shapeData.title;
        }else {
          if((colorData.MNDInfo.MNDIndex !== undefined && !colorData.MNDInfo.hasOnlyMND) || (shapeData.MNDInfo.MNDIndex !== undefined && !shapeData.MNDInfo.hasOnlyMND)){
            labels = getCartesian([colorData.labels, shapeData.labels], ' - ');
            title = colorData.title + " - " + shapeData.title;
          } else if (colorData.MNDInfo.MNDIndex !== undefined && colorData.MNDInfo.hasOnlyMND){
            labels = shapeData.labels;
            title = shapeData.title;
          } else {
            labels = colorData.labels;
            title = colorData.title;
          }
            
        } 
      }else{
        labels = shapeData.labels;
        title = shapeData.title;
      }
    }else{
      labels = colorData.labels;
      title = colorData.title;
    }

    if(labels.length === 0){
      this._legend_isVisible = false;
    }else{
      this._legend_isVisible = this._legend_options.visible;
    }
    this._legend_chartData = {
      'title' : title,
      'labels' : labels
    };
  };
    
  Legend.prototype._legendfn_parseLegendFeed = function(title, feeds, feedsLength){
    var labels = [], rows = [], dimensionTag = ' / ', measureTag = ' - ';
    var MNDIndex, hasOnlyMND = false, i, j, len;
    //Handle colors feeds
    if(feeds && feeds.length > 0){
      for(i = 0, len = feeds.length; i < len; i++) {
        if(feeds[i].type !== 'MND') {
          if(title === undefined) {
            title = handleNull(feeds[i].col.val);
          } else {
            title = title + dimensionTag + handleNull(feeds[i].col.val);
          }
          
          rows = feeds[i].rows;
          for(j = 0; j < rows.length; j++) {
            if(labels[j] === undefined) {
              labels[j] = {};
              labels[j].val = resolveCustomLabel(rows[j]);
              if (rows[j].dataTransformInfo && rows[j].dataTransformInfo.autoBinning) {
                labels[j].val += ('(' + rows[j].dataTransformInfo.autoBinning.othersNum + ')');
              }
              labels[j].ctx = {
                path : _setPathByaa(rows[j].ctx.path)
              };
              //For hierarchical legend. Keep original value.
              labels[j].orignialVal = [];
              labels[j].orignialVal.push(handleNull(rows[j].val));
            } else {
              if (rows[j].val !== '') {
                labels[j].val = labels[j].val + dimensionTag + resolveCustomLabel(rows[j]);
                labels[j].orignialVal.push(handleNull(rows[j].val));
              }
            }
          }
        } else {
          MNDIndex = i;
        }
      }
      feedsLength = labels.length;
    }
    
    //Handle Colors with MND
    if(MNDIndex !== undefined) {
      //Save color feed with MND status.
      if(labels.length > 0){
        if(feeds[MNDIndex].rows.length > 1){
          if(MNDIndex === 0) {
            title = langManager.get('IDS_DEFAULTMND') + measureTag + title; 
            //MND is the first feed type. Legend label should be 'MND - A/B/C'
            labels = getCartesian([handleNullInArray(feeds[MNDIndex].rows), labels], measureTag);
            feedsLength = feedsLength * feeds[MNDIndex].rows.length;
          } else if(MNDIndex === feeds.length - 1) {
            title = title + measureTag + langManager.get('IDS_DEFAULTMND');
            //MND is the last feed type. Legend label should be 'A/B/C - MND'
            labels = getCartesian([labels, handleNullInArray(feeds[MNDIndex].rows)], measureTag);
            feedsLength = feedsLength * feeds[MNDIndex].rows.length;
          } 
        }
      }else{
        title = langManager.get('IDS_DEFAULTMND');
        rows = feeds[MNDIndex].rows;
        for(j = 0; j < rows.length; j++) {
          labels[j] = {};
          labels[j].val = resolveCustomLabel(rows[j]);
          labels[j].ctx = rows[j].ctx;
          //For hierarchical legend. Keep original value.
          labels[j].orignialVal = [];
          labels[j].orignialVal.push(handleNull(rows[j].val));
        }
        feedsLength = rows.length;
        if(rows.length === 1){
          hasOnlyMND = true;
        }
      }
    }
    
    return {
      'title' : title,
      'labels' : labels,
      'feedsLength' : feedsLength,
      'MNDInfo' : {
        'MNDIndex' : MNDIndex,
        'hasOnlyMND': hasOnlyMND //Only has MND, no cartesian
      }
    };
  };
    
    // Calculate legend row position and return legend max size.
  Legend.prototype._legendfn_calculateRowPosition = function () {
    var maxHeight = 0, 
        maxWidth = 0, 
        minWidth = 0, 
        minHeight = 0, 
        titleSize = { width : 0, height : 0 }, 
        legendAreaSize = {};
        
    var labelFont, xPos, yPos;

    if ( this._legend_isVisible && this._legend_legendArea.hasData()) {
      labelFont = "font-size:" + this._legend_titleFont.fontsize + 
                "; font-weight:" + this._legend_titleFont.fontweight + 
                "; font-family:" + this._legend_titleFont.fontfamily;
                
      this._legend_textHeight = parseInt(this._legend_valueLabelFont.fontsize, 10); //1em
      xPos = this._legend_margin.left * this._legend_textHeight, yPos = this._legend_margin.top * this._legend_textHeight;
      var startYPos = yPos,
        paddingRight = this._legend_margin.right * this._legend_textHeight,
        paddingBottom = this._legend_margin.bottom * this._legend_textHeight;
      
      // Measure title size
      if ( this._legend_options.isShowTitle && 
         ( ( typeof this._legend_options.titleText !== 'undefined' && this._legend_options.titleText !== null) || 
           (typeof this._legend_chartData.title !== 'undefined' && this._legend_chartData.title !== null ))) 
      {
        titleSize = TextRuler.measure( 
          typeof this._legend_options.titleText === 'undefined' || this._legend_options.titleText === null ? 
          this._legend_chartData.title : this._legend_options.titleText, labelFont);
          
//          if ( !this._legend_hideTitle ) {
          yPos = yPos + titleSize.height + this._legend_titleMarginBottom * this._legend_textHeight;
//          }
      }
      
      // Legend Area Position
      this._legend_legendAreaPos = { x : xPos, y: yPos};
      
      // TODO [Christy | 2013/2/26] change return value's name. width,height to maxWidth,maxHeight
      legendAreaSize = this._legend_legendArea.getPreferredSize();
      
      // Calculate legend's max and min size with title
      if ( this._legend_options.position === 'top' || this._legend_options.position === 'bottom' ) {
        maxWidth = xPos + ((titleSize.width > legendAreaSize.width) ? titleSize.width : legendAreaSize.width);
        maxHeight = yPos + legendAreaSize.height;
        
        minWidth = xPos + legendAreaSize.minWidth;
        minHeight = startYPos + legendAreaSize.minHeight;
      }else{
        maxWidth = xPos + ((titleSize.width > legendAreaSize.width) ? titleSize.width : legendAreaSize.width);
        maxHeight = yPos + legendAreaSize.height;
        
        minWidth = xPos + legendAreaSize.minWidth;
        minHeight = startYPos + legendAreaSize.minHeight;
      }
      
      //Smart layout legend title 
      if(this._legend_options.isShowTitle){
        var relLegendAreaSize = {
            width : this._legend_width - xPos - paddingRight,
            height : this._legend_height - yPos - paddingBottom
        };
        if (relLegendAreaSize.height < legendAreaSize.minHeight) {
          // Hide legend title if it's shown.
          this._legend_hideTitle = true;
          this._legend_legendAreaPos = { x : xPos, y: startYPos};
          if( this._legend_height>0 && relLegendAreaSize.height<0 && (this._legend_options.position === 'top' || this._legend_options.position === 'bottom' )){
            maxHeight = legendAreaSize.height + startYPos;
          }
        }else{
          this._legend_hideTitle = false;
        }
      }
      maxWidth = maxWidth + paddingRight;
      minWidth = minWidth + paddingRight;
      maxHeight = maxHeight + paddingBottom;
      minHeight = minHeight + paddingBottom;
    }
     
      this._legend_preferenceSize = {
        width : maxWidth,
        height : maxHeight,
        maxWidth : maxWidth,
        maxHeight : maxHeight,
        minWidth : minWidth,
        minHeight : minHeight
    };
    return this._legend_preferenceSize;
  };
    
  var _setPathByaa = function(path){
    var pathObj = {};
    switch(path.aa){
      case 0:
        pathObj.dii_a1 = path.dii;
        break;
      case 1:
        pathObj.dii_a2 = path.dii;
        break;
      case 2:
        pathObj.dii_a3 = path.dii;
        break;
    }
    return pathObj;
  };
  
  var _containsVal = function(a, obj){
    for (var i = 0; i < a.length; i++) {
          if (a[i].val === obj) {
              return true;
          }
      }
      return false;
  };
  
  var getCartesian = function(arrays, symbol) {
    var result = arrays[0];
    var fff = function(arr) {
      var ar = result;
      result = [];
      for(var i = 0; i < ar.length; i++) {
        for(var j = 0; j < arr.length; j++) {
          var t1 = (ar[i].val === undefined) ? ar[i].val : ar[i].val, t2 = (arr[j].val === undefined) ? arr[j].val : arr[j].val;
          var ctx = {
            path : {}
          };
          ObjectUtils.extend(ctx.path, ar[i].ctx.path, arr[j].ctx.path);
          var res = {
            'val': t1 + symbol + t2, 
            'ctx': ctx,
            'orignialVal': []
          };
          if(ar[i].orignialVal === undefined){
            res.orignialVal.push(ar[i].val);
          }else{
            res.orignialVal = res.orignialVal.concat(ar[i].orignialVal);
          }
          
          if(arr[j].orignialVal === undefined){
            res.orignialVal.push(arr[j].val);
          }else{
            res.orignialVal = res.orignialVal.concat(arr[j].orignialVal);
          }
          
          result.push(res);
        }
      }
    };
    for(var i = 1; i < arrays.length; i++) {
      fff(arrays[i]);
    }

    return result;
  };
  
  var isColorFeeds = function(feedName){
    var result = false;
//      if(Manifest.feeds[feedName].semantic === 'COLOR'){
//        result = true;
//      }
    if(feedName.search('color') !== -1){
      result = true;
    }
    return result;
  };
  
  var isShapeFeeds = function(feedName){
    var result = false;
//      if(Manifest.feeds[feedName].semantic === 'SHAPE'){
//        result = true;
//      }
    if(feedName.search('shape') !== -1){
      result = true;
    }
    return result;
  };
  
  var isColorLegend = function(legendType){
    var result = false;
    if(legendType === 'ColorLegend'){
      result = true;
    }
    return result;  
  };
  
  var isSizeLegend = function(legendType){
    var result = false;
    if(legendType === 'SizeLegend'){
      result = true;
    }
    return result;  
  };
  
  var isBubbleColorLegend = function(legendType){
    var result = false;
    if(legendType === 'BubbleColorLegend'){
      result = true;
    }
    return result;  
  };
  
  var isMeasureBasedColoringLegend = function(legendType){
    var result = false;
    if(legendType === 'MeasureBasedColoringLegend'){
      result = true;
    }
    return result;  
  };
  
  var _isSizeAcceptable = function(){
    return (this._legend_width > 0 && this._legend_height > 0);
  };
  
  //alex su
  var handleNull = function(_){
    var defaultString = langManager.get('IDS_ISNOVALUE');
    if (_ === null || _ === undefined){
      return defaultString;
    }
    else{ 
      return _;
    }
  };
    
  var resolveCustomLabel = function(rawObj){
    var ret;
    if(rawObj.info){
      var clobj = rawObj.info.customlabel;
      if(clobj){
        if(clobj.type === 'url'){
          //Jimmy/12/27/2012 do we still need the orginal value in legend here?
          ret = rawObj.val;
        }else if(clobj.type === 'string'){
          ret = clobj.val;
        }
      }else{
        ret = rawObj.val;
      }
    }else{
      ret = rawObj.val;
    }
    ret = handleNull(ret);
    return ret;  
  };
  
  var handleNullInArray = function(array){
    var result = [];
    for (var i = 0; i < array.length; ++i){
      result[i] = {};
      ObjectUtils.extend(true, result[i], array[i]); 
      result[i].val = handleNull(array[i].val);
    }
    return result;
  };
  
  var getCurrentEvent = function() {
    if ( d3.event ) {
      return d3.event;
    } else {
      return window.event;
    }
  };
  return Legend;
});

define('sap/viz/modules/manifests/legend/Common',['sap/viz/modules/manifests/Module','sap/viz/modules/Constants','sap/viz/modules/legend/common'],
function Setup(Manifest, Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.legend.common',
    'type' : Constants.Type.Supplementary,
    'name' : 'common legend',
    'description': 'The legend is a box containing a symbol and name for each series item or point item in the chart.',
    'properties' : {
      'visible' : {
        'name' : 'visible',
        'supportedValueType' : 'Boolean',
        'defaultValue' : true,
        'description' : 'Set visibility of legend.'
      },
      'title' : {
        'name' : 'title',
      'description' : 'Settings for legend title.',
        'supportedValueType' : 'Object',
        'supportedValues' : {
        'visible' : {
            'name' : 'visible',
            'supportedValueType' : 'Boolean',
            'defaultValue' : false,
            'description' : 'Set visibility of legend title.'
           }, 
          'text':{
            'name' : 'text',
            'supportedValueType' : 'String',
            'defaultValue' : null,
            'description' : 'Set text of legend title.'
           }
        }
      },
      'formatString': {
        'name' : 'formatString',
        'supportedValueType': 'String',
        'defaultValue' : null,
        'description' : 'Set format string of legend. Any character in "MDYHSAmdyhsa#?%0@" is reserved as a token for format code.',
        'isExported': false
      },
      'isHierarchical' : {
        'name' : 'isHierarchical',
        'supportedValueType' : 'Boolean',
        'defaultValue' : false,
        'description' : 'Set hierarchy legend. Supported only when legend is located in the right of chart.',
        'isExported': true,
        'example': "<a href='"+Constants.DocExample.SnippetUrl+"8742' target='_blank'>"+Constants.DocExample.TryThisValue+"</a>"
      },
      'isScrollable' : {
        'name' : 'isScrollable',
        'supportedValueType' : 'Boolean',
        'defaultValue' : false,
        'description' : 'Set scrollable legend. Switch on/off scrollable legend.  If it is switched off, "..." will be used instead when there is no enough room to fit in all legend items.',
        'isExported': true
      },
      'position' : {
        'name' : 'position',
        'supportedValueType' : 'String',
        'supportedValues' : [ 'top', 'bottom', 'right', 'left'],
        'defaultValue' : 'right',
        'description' : 'It is a deprecated property. Please use "legendGroup.layout.position" property to set legend position. ',
        'isExported' : false
      },
      'type' : {
        'name' : 'type',
        'supportedValueType' : 'String',
        'supportedValues' : [ 'ColorLegend', 'BubbleColorLegend', 'SizeLegend', 'MeasureBasedColoringLegend' ],
        'defaultValue' : 'ColorLegend',
        'description' : 'Set legend type of Bubble chart. Non-bubble chart is not supported.',
        'isExported' : false
      },
      'alignment' : {
        'name' : 'alignment',
          'supportedValueType' : 'String',
          'supportedValues' : [ 'start', 'middle', 'end' ],
          'defaultValue' : 'start',
          'description' : 'Set alignment of legend.',
          'isExported' : false
      },
      'drawingEffect':{
        'name' : 'drawingEffect',
         'supportedValueType' : 'String',
          'supportedValues' : [ 'normal', 'glossy' ],
          'defaultValue' : 'normal',
          'description' : 'Set drawing effect of legend.',
          'isExported' : true,
          'example': "<a href='"+Constants.DocExample.SnippetUrl+"9606' target='_blank'>"+Constants.DocExample.TryThisValue+"</a>"
      }
    },
    'css' : {
      '.viz-legend-title.v-title' : {
        'description' : 'Define style for the legend title.',
        'value' : {
          'fill' : '#000000',
          'font-family' : "'Open Sans', Arial, Helvetica, sans-serif",
          'font-size' : '14px',
          'font-weight' : 'bold'
        }
      },
      '.viz-legend-valueLabel.v-label' : {
        'description' : 'Define style for the legend label.',
        'value' : {
          'fill' : '#000000',
          'font-family' : "'Open Sans', Arial, Helvetica, sans-serif",
          'font-size' : '12px',
          'font-weight' : 'normal'
        }
      },
        '.v-hovershadow' : {
            'description' : 'Define style for hovershadow in legend.',
              'value' : {
                'fill' : '#cccccc'
              }
        }
    },
    'configure' : null,
    fn : fn
  };

  Manifest.register(module);
});

define('sap/viz/modules/manifests/layout/Stack',['sap/viz/modules/manifests/Module','sap/viz/modules/layout/stack', 'sap/viz/modules/manifests/layout/Base'],
function Setup ( Manifest, fn ) {
  var module = {
    'id' : "sap.viz.modules.layout.stack",
    'name' : "stack",
    'base' : "sap.viz.modules.layout.base",
    'description' : "The stack layout algorithm",
    'properties' : {},
    'configure' : null,
    'fn' : fn
  };
  Manifest.register(module);
});
define('sap/viz/manifests/BaseChart',['sap/viz/manifests/Viz','sap/viz/modules/manifests/RootContainer','sap/viz/modules/manifests/Title',
'sap/viz/modules/manifests/Legend','sap/viz/modules/manifests/DataLabel',
'sap/viz/modules/manifests/layout/Dock','sap/viz/modules/manifests/legend/Common',
'sap/viz/modules/manifests/layout/Stack'],
function Setup(Manifest) {
  var chart = {
    id : 'riv/base',
    name : 'IDS_BASECHART',
    'abstract' : true,
    modules : {
      root : {
        id : 'sap.viz.modules.rootContainer',
        configure : {
          propertyCategory : 'general'
        },
        modules : {
          title : {
            id : 'sap.viz.modules.title',
            configure : {
              propertyCategory : 'title',
              properties : {
                layout : {
                  position : 'top',
                  priority : 0
                }
              }
            }
          },
          
          layout : {
            id : 'sap.viz.modules.layout.dock'
          },
          
          legends : {
            id : 'sap.viz.modules.legend',
            configure : {
              propertyCategory : 'legendGroup',
              properties : {
                layout : {
                  position : 'right',
                  priority : 1,
                  alignment : 'right'
                }
              }
            },
            modules : {
              layout : {
                id : 'sap.viz.modules.layout.stack'
              },
              legend : {
                id : 'sap.viz.modules.legend.common',
                configure : {
                  propertyCategory : 'legend',
                  properties : {
                    layout : { order : 0 }
                  }
                }
              } 
            }
          }
        }
      }
      
    },
    dependencies : {}
  };

  Manifest.register(chart);
});
define('sap/viz/modules/layout',['sap/viz/base/utils/TypeUtils'],
function Setup(TypeUtils) {
  
  /*
   * Function set that represents a light-weight layout manager
   * who calculates optimal component layout data, rather than
   * operating on components directly.
   */
  var _ = function ( spec ) {
    
    var defaults = {
      resize : true,
      type : 'grid',
      padding : [0,0,0,0],
      hgap : 0,
      vgap : 0
    };  
  
    var hgap = spec.hgap || defaults.hgap,
        vgap = spec.vgap || defaults.vgap,
        padding = spec.padding || defaults.padding,
        bias = spec.bias || 'none';
    
    //Jimmy8/7/2012, different layout function may return different layoutSolution
    //so initialize it in each layout function
    var layoutSolution; // returning data
    
    /*
     * this is a simple border layout which items are position from north to east, then south to west, the center is the last.
     * so the preferred size of north, east, south and west will be considered while the center will be ignored.
     */
    function border2 (config){
      var spec = config.specs;
      var size = config.size;
      var metadata = {};
      for(var item in spec){
        if(spec.hasOwnProperty(item)){
          metadata[spec[item].info] = {
            size: spec[item].preferSize,
            key: item
          };
        }
      }
      border(metadata);
      var ret = {};
      for ( var i in layoutSolution ) {
        if ( layoutSolution.hasOwnProperty(i) ) {
          ret[metadata[i].key] = layoutSolution[i];
        }
      }
      layoutSolution = ret;
    }
    
    /**
     * Represents a border-docking layout method which assigns components
     * with spaces of omni-directional border insets. Padding is leaved
     * prior to layout. Component marked as a bias will be processed first
     * to embody the predominance of it. North and South parts are naturally
     * biased against other parts due to the nature of border layout. So
     * the bias attribute supports up to two values: 'west', 'east' or both
     * (in an array and order matters). The center part is under passive 
     * control and queued last to be processed.
     * 
     * ---------------------------------------
     * |               Padding               |
     * |   -------------------------------   |
     * |   |     |     North       |     |   |
     * |   -------------------------------   |
     * |   |     |                 |     |   |
     * |   |  W  |                 |  E  |   |
     * |   |  e  |     Center      |  a  |   |
     * |   |  s  |                 |  s  |   |
     * |   |  t  |                 |  t  |   |
     * |   |     |                 |     |   |
     * |   |     |                 |     |   |
     * |   -------------------------------   |
     * |   |     |     South       |     |   |
     * |   -------------------------------   |
     * |                                     |
     * ---------------------------------------
     */
    function border( options ) {
      layoutSolution = {};
      var packedSize = {}, // Size without paddings.
          autoResizing = true;
      packedSize.width = spec.size.width - padding[1] - padding[3];
      packedSize.height = spec.size.height - padding[0] - padding[2];
      
      // Enclosing dimension bounds
      var minX = padding[3],
          minY = padding[0],
          maxX = spec.size.width - padding[1],
          maxY = spec.size.height - padding[2];

      var queue = new Array(5);
      var i;
      
      // Layout ordering rule
      if ( bias instanceof Array ) {
        queue[0] = bias[0];
        queue[1] = bias[1];
        queue[2] = 'north';
        queue[3] = 'south';
      } else {
        switch ( bias ) {
        case 'west' :
          queue[0] = 'west';
          queue[1] = 'north';
          queue[2] = 'south';
          queue[3] = 'east';
          break;
        case 'east' :
          queue[0] = 'east';
          queue[1] = 'north';
          queue[2] = 'south';
          queue[3] = 'west';
          break;
        default :
          queue[0] = 'south';
          queue[1] = 'north';
          queue[3] = 'east';
          queue[2] = 'west';
        }
      }
      queue[4] = 'center';
      
      function doLayout( division ) {
        function getAvailableSpacings ( maxSize, minTruncateSize ) {
          if ( arguments.length < 3 ) {
              return 0;
          }
          var spacings = Array.prototype.slice.apply(arguments).slice(2);
          var spacingsByOrder = [];
          var i;
          for (i = 0; i < spacings.length; i++ ) {
            if ( spacings[i].length > 1 ) {
              spacingsByOrder[i] = spacings[i].slice(1);
              spacingsByOrder[i].push(spacings[i][0]);
            }
          }
          
          var availableSpacings = 0;
          var availableSpacingsSum = 0;
          
          //Use longest length 
          var j, spaceLength = spacingsByOrder[0].length;
          for (i = 1; i < spacingsByOrder.length; ++i){
            if (spaceLength < spacingsByOrder[i].length){
              spaceLength = spacingsByOrder[i].length;
            }
          }
          for ( i = 0; i < spaceLength; i++ ) {
            for ( j = 0; j < spacingsByOrder.length; j++ ) {
              if (spacingsByOrder[j][i] !== undefined){
                //omit those undefined value
                availableSpacingsSum += spacingsByOrder[j][i];
              }
            }
            if ( availableSpacingsSum > maxSize ) {
              if (i === 0 && minTruncateSize > 0) {
                if (spacingsByOrder.length > 1 && minTruncateSize + spacingsByOrder[1][0] <= maxSize) {
                  return maxSize - spacingsByOrder[1][0];
                }
                if (spacingsByOrder.length === 1 && minTruncateSize <= maxSize) {
                  return maxSize;
                }
              }
              return availableSpacings;
            }
            availableSpacings += spacingsByOrder[0][i];
          }
          return availableSpacings;
        }

        var node = {}, preferredSize = {};
        var nodeHeight, heightSum, nodeWidth, widthSum, maxHeight, maxWidth;
        if ( division === 'north' && options.north ) {
          node = layoutSolution.north = {};
          preferredSize = options.north.size;
          nodeHeight = preferredSize.height;
          heightSum = nodeHeight;
          
          if ( autoResizing ) {
            if ( preferredSize.spacings && options.south && options.south.size.spacings ) {
                heightSum += options.south.size.height;
            }
            
            if ( preferredSize.maxSizeConstant && heightSum > packedSize.height * preferredSize.maxSizeConstant ) {
              if ( preferredSize.hideOversize ) {
                  nodeHeight = 0;
              } else if ( preferredSize.spacings ) {
                if (options.south && options.south.size.spacings) {
                  if (layoutSolution.south === null) {
                    nodeHeight = 0;
                  } else if (preferredSize.minTruncateSize === 0) {
                    maxHeight = packedSize.height * preferredSize.maxSizeConstant;
                    if (layoutSolution.south) {
                      maxHeight -= layoutSolution.south.bounds.height;
                    }
                    nodeHeight = getAvailableSpacings(maxHeight, 
                        preferredSize.minTruncateSize, preferredSize.spacings);
                  } else {
                    nodeHeight = getAvailableSpacings(
                        packedSize.height * preferredSize.maxSizeConstant, 
                        preferredSize.minTruncateSize, preferredSize.spacings, 
                        options.south.size.spacings);
                  } 
                } else {
                    nodeHeight = getAvailableSpacings(packedSize.height * preferredSize.maxSizeConstant, 
                        preferredSize.minTruncateSize, preferredSize.spacings);
                }
              } else {
                nodeHeight = packedSize.height * preferredSize.maxSizeConstant;
              }
            }
          }
          node.bounds = { 
            x : minX, 
            y : minY,
            width  : maxX - minX,
            height : nodeHeight
          };
          minY += (node.bounds.height + hgap);
          if (node.bounds.height === 0) {
              layoutSolution.north = null;
          }
        }
        
        if ( division === 'east' && options.east ) {
          node = layoutSolution.east = {};
          preferredSize = options.east.size;
          nodeWidth = preferredSize.width;
          widthSum = nodeWidth;
          var x = 0;
          
          if ( autoResizing ) {
            if ( preferredSize.spacings && options.west && options.west.size.spacings ) {
              widthSum += options.west.size.width;
            }
            if ( preferredSize.maxSizeConstant && widthSum > packedSize.width * preferredSize.maxSizeConstant ) {
              if ( preferredSize.hideOversize ) {
                nodeWidth = 0;
              } else if ( preferredSize.spacings ) {
                if ( options.west && options.west.size.spacings ) {
                  if (layoutSolution.west === null) {
                      nodeWidth = 0;
                  } else if (preferredSize.minTruncateSize === 0) {
                    maxWidth = packedSize.width * preferredSize.maxSizeConstant;
                    if (layoutSolution.west) {
                      maxWidth -= layoutSolution.west.bounds.width;
                    }
                    nodeWidth = getAvailableSpacings(maxWidth, 
                        preferredSize.minTruncateSize, preferredSize.spacings);
                  } else {
                    nodeWidth = getAvailableSpacings(
                        packedSize.width * preferredSize.maxSizeConstant, preferredSize.minTruncateSize,
                        preferredSize.spacings, options.west.size.spacings);
                  }
                } else {
                  nodeWidth = getAvailableSpacings(
                    packedSize.width * preferredSize.maxSizeConstant, 
                    preferredSize.minTruncateSize, preferredSize.spacings);
                }
              } else {
                nodeWidth = packedSize.width * preferredSize.maxSizeConstant;
              }
            }
            if ( nodeWidth < preferredSize.minWidth ) { nodeWidth = 0; }
            x = maxX - nodeWidth;
          } else {
            x = layoutSolution.west.bounds.width + layoutSolution.south.bounds.width;
          }
          node.bounds = { 
            x : x,
            y : minY,
            width : nodeWidth,
            height : maxY - minY
          };
          
          if (node.bounds.height < preferredSize.minHeight) {
              node.bounds.width = 0;
          }
          
          maxX -= (node.bounds.width + vgap);
          if (node.bounds.width === 0) {
              layoutSolution.east = null;
          }
        }
        
        if ( division === 'south' && options.south ) {
          node = layoutSolution.south = {};
          preferredSize = options.south.size;
          autoResizing = !preferredSize.manual; // manual size enabled or disabled
          nodeHeight = preferredSize.height, nodeWidth = 0;
          heightSum = nodeHeight;
          
          if ( autoResizing ) {
            if ( preferredSize.spacings && options.north && options.north.size.spacings ) {
              heightSum += options.north.size.height;
            }
            if ( preferredSize.maxSizeConstant && heightSum > packedSize.height * preferredSize.maxSizeConstant ) {
              if ( preferredSize.hideOversize ) {
                  nodeHeight = 0;
              } else if ( preferredSize.spacings ) {
                if ( options.north && options.north.size.spacings ) {
                  if (layoutSolution.north === null) {
                    nodeHeight = 0;
                  } else if(preferredSize.minTruncateSize === 0) {
                    maxHeight = packedSize.height * preferredSize.maxSizeConstant;
                    if (layoutSolution.north) {
                      maxHeight -= layoutSolution.north.bounds.height;
                    }
                    nodeHeight = getAvailableSpacings(maxHeight, 
                        preferredSize.minTruncateSize, preferredSize.spacings);
                  } else {
                    nodeHeight = getAvailableSpacings(
                        packedSize.height * preferredSize.maxSizeConstant, 
                        preferredSize.minTruncateSize, preferredSize.spacings, 
                        options.north.size.spacings);
                  } 
                } else {
                  nodeHeight = getAvailableSpacings(
                    packedSize.height * preferredSize.maxSizeConstant, 
                    preferredSize.minTruncateSize, preferredSize.spacings);
                }
              } else {
                nodeHeight = packedSize.height * preferredSize.maxSizeConstant;
              }
            }
            nodeWidth = maxX - minX;
          } else {
            nodeWidth = preferredSize.width > packedSize.width ? 
                        packedSize.width : preferredSize.width;
            if ( nodeHeight > packedSize.height ) {
              nodeHeight = packedSize.height;
            }
          }
          
          node.bounds = {
            x : minX,
            y : (maxY - nodeHeight) < minY ? minY : (maxY - nodeHeight),
            width  : nodeWidth
          };
          node.bounds.height = nodeHeight;
          maxY -= (node.bounds.height + hgap);
          
          if ( node.bounds.height === 0 ) { layoutSolution.south = null; }
        }
        
        if ( division === 'west' && options.west ) {
          node = layoutSolution.west = {};
          preferredSize = options.west.size;
          nodeWidth = preferredSize.width;
          widthSum = nodeWidth;
          
          if ( autoResizing ) {
            if ( preferredSize.spacings && options.east && options.east.size.spacings ) {
              widthSum += options.east.size.width;
            }
            if ( preferredSize.maxSizeConstant && widthSum > packedSize.width * preferredSize.maxSizeConstant ) {
              if ( preferredSize.hideOversize ) {
                nodeWidth = 0;
              } else if (preferredSize.spacings) {
                if ( options.east && options.east.size.spacings ) {
                  if (layoutSolution.east === null) {
                    nodeWidth = 0;
                  } else if(preferredSize.minTruncateSize === 0) {
                    maxWidth = packedSize.width * preferredSize.maxSizeConstant;
                    if (layoutSolution.east) {
                      maxWidth -= layoutSolution.east.bounds.width;
                    }
                    nodeWidth = getAvailableSpacings(maxWidth, 
                        preferredSize.minTruncateSize, preferredSize.spacings);
                  } else {
                    nodeWidth = getAvailableSpacings(
                        packedSize.width * preferredSize.maxSizeConstant, 
                        preferredSize.minTruncateSize, preferredSize.spacings, options.east.size.spacings);
                  }
                } else {
                  nodeWidth = getAvailableSpacings(packedSize.width * preferredSize.maxSizeConstant, 
                      preferredSize.minTruncateSize, preferredSize.spacings);
                }
              } else {
                nodeWidth = packedSize.width * preferredSize.maxSizeConstant;
              }
            }
          }
          node.bounds = {
            x : minX,
            y : minY,
            width  : nodeWidth,
            height : (minY + preferredSize.height) > maxY ? maxY : (minY + preferredSize.height)
          };
          minX += (node.bounds.width + vgap);
          if (node.bounds.width === 0) {
              layoutSolution.west = null;
          }
        }
        
        if ( division === 'center' && options.center ) {
          node = layoutSolution.center = {};
          var w = !autoResizing && layoutSolution.south ? layoutSolution.south.bounds.width : maxX - minX,
              h = maxY - minY; 
          node.bounds = {
            x : minX,
            y : minY,
            width  : w,
            height : h
          };
        }
      }
            
      for ( i = 0; i < queue.length; i++ ) {
        doLayout(queue[i]);
      }
    }
    
    function grid( options ) {}
    
    /**
     * compared to HTML table, currently we only support cellpadding. we don't (need) support cellspacing 
     * @param {Object} options
     */
    function table( options ) {
      layoutSolution = [];//return layout solution by column * row
      //table layout options
      var columns = TypeUtils.isExist(spec.columns) ? spec.columns : 3;
      var rows = TypeUtils.isExist(spec.rows) ? spec.rows : 2;
      var cellpadding = TypeUtils.isExist(spec.cellpadding) ? spec.cellpadding : 5;
      var paddingThreshold = TypeUtils.isExist(spec.paddingThreshold) ? spec.paddingThreshold : 0.1;
      
      var packedSize = {}; // Size without paddings.
        packedSize.width = spec.size.width - padding[1] - padding[3];
        packedSize.height = spec.size.height - padding[0] - padding[2];
        
        var avgWidth = packedSize.width / columns;
        var avgHeight = packedSize.height / rows;
        //don't make the cellPadding too large
        if ( cellpadding > avgWidth * paddingThreshold || cellpadding > avgHeight * paddingThreshold ) {
          cellpadding = 2;
        }
        var cellWidth = ( packedSize.width - 2 * columns * cellpadding ) / columns;
        cellWidth = cellWidth > 0 ? cellWidth : 0;
        var cellHeight = ( packedSize.height - 2 * rows * cellpadding ) / rows;
        cellHeight = cellHeight > 0 ? cellHeight : 0;
      
        // Enclosing dimension bounds
        var minX = padding[3],
        minY = padding[0],
        maxX = spec.size.width - padding[1],
        maxY = spec.size.height - padding[2];
        
        for ( var col = 0; col < columns; col++ ) {
          var colia = [];//column iteration array
          for ( var row = 0; row < rows; row++ ) {
            var node = {};
            node.bounds = {
              x: col * avgWidth + avgWidth/2 - cellWidth/2,
              y: row * avgHeight + avgHeight/2 - cellHeight/2,
              width: cellWidth,
              height: cellHeight
            };
            colia.push(node);
          }
          layoutSolution.push(colia);
        }
        
    }
    
    switch ( spec.type ) {
        case 'border' : 
          border(spec.prefs);
          break;
        case 'grid' :
          grid(spec.prefs);
          break;
        case 'table' :
          //FIXME Elliott/Jimmy 8/7/2012, table layout has some special options
          //here we will read spec inside table layout function directly. consider
          //making it consistent with others 
          table();
          break;
        case 'border2' : 
          border2 (spec);
          break;
        default :
          grid(spec.prefs);
    }
    
    return layoutSolution;
  };
  
  return _;
  
});
define('sap/viz/modules/xycontainer',['sap/viz/base/utils/oo','sap/viz/modules/Base','sap/viz/modules/Constants','sap/viz/base/utils/TypeUtils','sap/viz/base/utils/Objects','sap/viz/base/utils/FunctionUtils',
'sap/viz/modules/layout','sap/viz/manifest','sap/viz/util/ignite','sap/viz/data/handler/SingleChartDataHandler',
'sap/viz/modules/dispatch','sap/viz/modules/util/BoundUtil','sap/viz/base/utils/log/LogUtil'],
function Setup (oo, Base, Constants, TypeUtils, Objects, Functions, layout, Manifest, ignite, SingleChartDataHandler, dispatch, boundUtil,LOG ) {
  
  var XYContainer = function (manifest, ctx) {
    this._xyc_width = 0; 
    this._xyc_height = 0; 
    this._xyc_properties = {};
    this._xyc_data = {};
    this._xyc_config = {};
    this._xyc_modules = {};
    this._xyc_selections = {};
    this._xyc_parent = null; // a d3 selection
    this._xyc_ctx = ctx;

    this._xyc_eDispatch = new dispatch('initialized', 'showTooltip', 'hideTooltip'); 
    this._xyc_initializedModules = 0;
    this._xyc_innerProperties = manifest.props(null);
    this._xyc_initializedCount = 0;
  };
  
  oo.extend(XYContainer, Base);
  
  XYContainer.prototype.render = function( selection ) {
    this._xyc_relayout();
    this._xyc_initializedCount = 0;
    boundUtil.drawBound(selection, this._xyc_width, this._xyc_height);
    this._xyc_parent = selection;
    if ( TypeUtils.isEmptyObject(this._xyc_modules) ){
      this._xyc_initialize();
    }
    this._xyc_renderSub();
  };
  
  XYContainer.prototype._xyc_relayout = function(){
    var modules = this._xyc_modules;
    var width = this._xyc_width;
    var height = this._xyc_height;
    var selections = this._xyc_selections;
    
    if ( TypeUtils.isEmptyObject(modules) || !width || !height) { return; }
    
    width = width < 0 ? 0 : width;
    height = height < 0 ? 0 : height;
    var prefs = {};
    
    if ( modules.plot ) {
      prefs.center = {};
      if(modules.plot.size){
        modules.plot.size({width:width,height:height});
      }else{
        modules.plot.width(width).height(height);
      }
    }
  
    var lastPlotWidth = -1, 
        lastPlotHeight = -1,
        autoResizing = true; // smart layout enabled by default

    var iLayout;
    //try 3 times FIXME remove '3 times'
    for ( iLayout = 0; iLayout <= 2; iLayout++ ) {
      if ( modules.xAxis ) {
          modules.xAxis.drawable(true);
          prefs.south = { size : modules.xAxis.getPreferredSize() };
          if ( prefs.south.manual ) { autoResizing = false; }
      }
      if ( modules.yAxis ) {
          modules.yAxis.drawable(true);
          prefs.west = { size : modules.yAxis.getPreferredSize() };
      }
      if ( modules.xAxis2 ) {
          modules.xAxis2.drawable(true);
          prefs.north = { size : modules.xAxis2.getPreferredSize() };
      }
      if ( modules.yAxis2 ) {
          modules.yAxis2.drawable(true);
          prefs.east = { size : modules.yAxis2.getPreferredSize() };
      }
      
      var solution = layout({
        type : 'border',
        bias : 'none',
        size : { width : width, height : height },
        prefs : prefs
      });

      // adjust axes start and end padding
      // TODO add more padding
      var rightPadding = 0;
      var rightPaddingxAxis = 0;
      var rightPaddingxAxis2 = 0;
          
      var leftPadding = 0; 
      var leftPaddingxAxis = 0;
      var leftPaddingxAxis2 = 0;

      if ( !solution.west ) {
        if ( modules.xAxis && solution.south ) {
          leftPaddingxAxis = modules.xAxis.startPadding();
        }
        if ( modules.xAxis2 && solution.north ) {
          leftPaddingxAxis2 = modules.xAxis2.startPadding();
        }
        leftPadding = leftPaddingxAxis > leftPaddingxAxis2 ? leftPaddingxAxis : leftPaddingxAxis2;
      }

      if ( !solution.east ) {
        if ( modules.xAxis && solution.south ) {
          rightPaddingxAxis = modules.xAxis.endPadding();
        }
        if ( modules.xAxis2 && solution.north ) {
          rightPaddingxAxis2 = modules.xAxis2.endPadding();
        }
        rightPadding = rightPaddingxAxis > rightPaddingxAxis2 ? rightPaddingxAxis : rightPaddingxAxis2;
      }

      var bottomPadding = 0; 
      var bottomPaddingyAxis = 0;
      var bottomPaddingyAxis2 = 0;
          
      if ( !solution.south ) {
        if ( modules.yAxis && solution.west ) {
          bottomPaddingyAxis = modules.yAxis.startPadding();
        }
        if ( modules.yAxis2 && solution.east ) {
          bottomPaddingyAxis2 = modules.yAxis2.startPadding();
        }
        bottomPadding = bottomPaddingyAxis > bottomPaddingyAxis2 ? bottomPaddingyAxis : bottomPaddingyAxis2;
      }

      var topPadding = 0, yOffset = 0;

      if ( !solution.north ) {
        var topPaddingyAxis = 0, 
            topPaddingyAxis2 = 0;
            
        if ( modules.yAxis && solution.west ) {
          topPaddingyAxis = modules.yAxis.endPadding();
        }
        if ( modules.yAxis2 && solution.east ) {
          topPaddingyAxis2 = modules.yAxis2.endPadding();
        }

        topPadding = topPaddingyAxis2;
        if ( topPaddingyAxis > topPaddingyAxis2 ) {
          topPadding = topPaddingyAxis;
        }

        yOffset += topPadding;
      }

      if ( yOffset ) {
        if ( solution.east ) {
          solution.east.bounds.y += yOffset;
        }

        if ( solution.north ) {
          solution.north.bounds.y += yOffset;
        }

        if ( solution.west ) {
          solution.west.bounds.y += yOffset;
        }

        if ( solution.center ) {
          solution.center.bounds.y += yOffset;
        }
      }

      if ( leftPadding ) {

        if ( solution.north ) {
          solution.north.bounds.x += leftPadding;
        }

        if ( solution.south ) {
          solution.south.bounds.x += leftPadding;
        }

        if ( solution.west ) {
          solution.west.bounds.x += leftPadding;
        }

        if ( solution.center ) {
          solution.center.bounds.x += leftPadding;
        }
      }

      // we have to layout top and bottom axes firstly, because if you change the size of top or bottom axes, the 
      // height of the axis may be changed (vertical label). Left and right axes have no vertical labels.
      if ( solution.east ) {
        // Modifies yAxis height and coordinate to handle vertical offset
        // to ensure joints with xAxis.
        // LOG.profiling("Render:drawing-layout-calculation-formatValue-main-yAxis2");
        var yAxis2Height = solution.east.bounds.height, yAxis2Y = 0;
        if ( solution.south ) {
          if ( !autoResizing ) { yAxis2Height = solution.east.bounds.height - solution.south.bounds.height; }
        }
        if ( solution.north ) {
          if ( !autoResizing ) { yAxis2Height = solution.east.bounds.height - solution.north.bounds.height; }
        }

        yAxis2Y = solution.east.bounds.y;
        
        selections.yAxis2.attr('transform', 
          'translate(' + solution.east.bounds.x + ',' + yAxis2Y + ')');
        
        modules.yAxis2
          .width(solution.east.bounds.width)
          .height(yAxis2Height);
          
        modules.yAxis2.gridlineLength(solution.center.bounds.width); 
        // LOG.profiling("Render:drawing-layout-calculation-formatValue-main-yAxis2");
      } else if(modules.yAxis2) {
          modules.yAxis2.drawable(false);
      }

      if ( solution.north ) {
        // LOG.profiling("Render:drawing-layout-calculation-formatValue-main-xAxis2");
        var xAxis2Width = solution.north.bounds.width, xAxis2X = 0;
        if ( solution.west ) {
          xAxis2X = solution.north.bounds.x + solution.west.bounds.width;
          xAxis2Width = solution.north.bounds.width - solution.west.bounds.width;
        } else {
            xAxis2X = leftPadding;
        }

        selections.xAxis2.attr('transform', 
          'translate(' + xAxis2X + 
          ',' + solution.north.bounds.y + ')');

        modules.xAxis2
          .width(xAxis2Width)
          .height(solution.north.bounds.height);
          
        modules.xAxis2.gridlineLength(solution.center.bounds.height);  
        // LOG.profiling("Render:drawing-layout-calculation-formatValue-main-xAxis2");
      } else if (modules.xAxis2) {
          modules.xAxis2.drawable(false);
      }
            
      if ( solution.west ) {
        // Modifies yAxis height and coordinate to handle vertical offset
        // to ensure joints with xAxis.
        var yAxisHeight = solution.west.bounds.height, yAxisY = 0;
        
        // LOG.profiling("Render:drawing-layout-calculation-formatValue-main-yAxis");
        if ( solution.south ) {
          if ( !autoResizing ) { yAxisHeight = solution.west.bounds.height - solution.south.bounds.height; }
        }
        if ( solution.north ) {
          if ( !autoResizing ) { yAxisHeight = solution.west.bounds.height - solution.north.bounds.height; }
        }
        yAxisY = solution.west.bounds.y;

        selections.yAxis.attr('transform', 'translate(' + solution.west.bounds.x + ',' + yAxisY + ')');
    
        modules.yAxis
          .width(solution.west.bounds.width)
          .height(yAxisHeight);
          
        modules.yAxis.gridlineLength(solution.center.bounds.width); 
        // LOG.profiling("Render:drawing-layout-calculation-formatValue-main-yAxis"); 
      } else if(modules.yAxis) {
          modules.yAxis.drawable(false);
      }

      if ( solution.south ) {

        // LOG.profiling("Render:drawing-layout-calculation-formatValue-main-xAxis");
        var xAxisWidth = 0, xAxisX = 0;
        if ( solution.west ) {
            xAxisX = solution.south.bounds.x + solution.west.bounds.width;
        } else {
            xAxisX = leftPadding;
        }

        selections.xAxis.attr('transform', 
          'translate(' + xAxisX + 
          ',' + solution.south.bounds.y + ')');
          
        modules.xAxis
          .width(solution.south.bounds.width)
          .height(solution.south.bounds.height);
          
        modules.xAxis.gridlineLength(solution.center.bounds.height);
        // LOG.profiling("Render:drawing-layout-calculation-formatValue-main-xAxis");
        
      } else if ( modules.xAxis ) {
        modules.xAxis.drawable(false);
      }
      
      // if (!solution.south && modules.xAxis) {
          // modules.xAxis.drawable(false);
      // }
      // if (!solution.north && modules.xAxis2) {
          // modules.xAxis2.drawable(false);
      // }
            
      if ( solution.center ) {
       
        // LOG.profiling("Render:drawing-layout-calculation-formatValue-main-plot");
        selections.plot.attr('transform', 
          'translate(' + solution.center.bounds.x + 
          ',' + solution.center.bounds.y + ')');
        var plotWidth = solution.center.bounds.width - rightPadding - leftPadding;
        var plotHeight = solution.center.bounds.height - topPadding - bottomPadding;
        if(modules.plot.size){
          modules.plot.size({width:(plotWidth > 0 ? plotWidth : 0),height:(plotHeight > 0 ? plotHeight : 0)});
        }else{
          modules.plot
            .width(plotWidth > 0 ? plotWidth : 0)
            .height(plotHeight > 0 ? plotHeight : 0);
        }

        if ( selections.background ) {
          // LOG.profiling("Render:drawing-layout-calculation-formatValue-main-backgound");
          selections.background.attr('transform', 
            'translate(' + solution.center.bounds.x + 
            ',' + solution.center.bounds.y + ')');
          modules.background
            .width(plotWidth > 0 ? plotWidth : 0)
            .height(plotHeight > 0 ? plotHeight : 0);
         // LOG.profiling("Render:drawing-layout-calculation-formatValue-main-backgound");
        }   
        // LOG.profiling("Render:drawing-layout-calculation-formatValue-main-plot");       
      }
      if ( solution.west ) {
        modules.yAxis.gridlineLength(solution.center.bounds.width - rightPadding - leftPadding); 
      }

      if ( solution.south ) {
        modules.xAxis.gridlineLength(solution.center.bounds.height - topPadding - bottomPadding); 
      }

      var currentPlotWidth = modules.plot.width();
      var currentPlotHeight = modules.plot.height();
      if ( lastPlotWidth === currentPlotWidth  && lastPlotHeight === currentPlotHeight ) {
        break;
      } else {
        lastPlotWidth = currentPlotWidth;
        lastPlotHeight = currentPlotHeight;
      }
    }
  };
  
  XYContainer.prototype._xyc_initialize = function(){
    var config = this._xyc_config;
    var modules = this._xyc_modules;
    var ctx = this._xyc_ctx;
    var data = this._xyc_data;
    var selections = this._xyc_selections;
    var parent = this._xyc_parent;
    
    if ( TypeUtils.isEmptyObject(config) ) { Functions.error('Container configuration missing'); }
    
    this._xyc_initializedModules = 0;
    
    this._xyc_initAxis('xAxis');
    this._xyc_initAxis('yAxis');
    this._xyc_initAxis('xAxis2');
    this._xyc_initAxis('yAxis2');
    this._xyc_initAxis('background');
    
    var plotConfig = config.modules.plot;
    if ( !plotConfig ) { return; }
    var plot = modules.plot = ignite(plotConfig.id, ctx, 
      Constants.CSS.CLASS.MODULEPREFIX + "plot");
    var dataHandler = new SingleChartDataHandler(data); 
    plot.data(dataHandler.getDataAdapter());

    var props;
    if ( plotConfig.configure ) {
      props = this._xyc_resolveProperties(plotConfig.configure);
      plot.properties(props);
    }
    
    if ( plot.dispatch ) {
      var dis =  plot.dispatch();
      if ( dis.initialized ) { this._xyc_initializedModules++; dis.on('initialized.xycontainer', this._xyc_initialized.bind(this));}
      if ( dis.showTooltip ) { dis.on('showTooltip.xycontainer', this._xyc_showTooltip.bind(this));}
      if ( dis.hideTooltip ) { dis.on('hideTooltip.xycontainer', this._xyc_hideTooltip.bind(this));}
    }
    
    var dataLabelConfig =  config.modules.dataLabel;
    if ( TypeUtils.isExist(dataLabelConfig) && TypeUtils.isExist(plot.dataLabel) ) {
      var dataLabel = modules.dataLabel = ignite(dataLabelConfig.id, ctx, Constants.CSS.CLASS.MODULEPREFIX + "datalabel");
      if ( dataLabel.dispatch() ) { this._xyc_initializedModules++; dataLabel.dispatch().on('initialized.xycontainer', this._xyc_initialized.bind(this));}
      plot.dataLabel(dataLabel);
      dataLabel.plot(plot);
      if ( dataLabelConfig.configure ) {
        props = this._xyc_resolveProperties(dataLabelConfig.configure);
        dataLabel.properties(props);
      }
    }
    
    if ( modules.xAxis && !selections.xAxis ) {
      selections.xAxis = parent.append('g')
        .attr('class', Constants.CSS.CLASS.MODULEPREFIX + 'xAxis');
    }
    if ( modules.xAxis2 && !selections.xAxis2 ) {
      selections.xAxis2 = parent.append('g')
        .attr('class', Constants.CSS.CLASS.MODULEPREFIX + 'xAxis2');
    }
    if ( modules.yAxis && !selections.yAxis ) { 
      selections.yAxis = parent.append('g')
        .attr('class', Constants.CSS.CLASS.MODULEPREFIX + 'yAxis');
    }
    if ( modules.yAxis2 && !selections.yAxis2 ) { 
      selections.yAxis2 = parent.append('g')
        .attr('class', Constants.CSS.CLASS.MODULEPREFIX + 'yAxis2');
    }
    if ( modules.plot && !selections.plot ) { 
      selections.plot = parent.append('g')
        .attr('class', Constants.CSS.CLASS.MODULEPREFIX + 'plot');
    }
    if ( modules.background && !selections.background ) {
      selections.background = parent.insert('g', ':first-child')
        .attr('class', Constants.CSS.CLASS.MODULEPREFIX + 'background');
    }  
  };
  
  XYContainer.prototype._xyc_renderSub = function(){
    var selections = this._xyc_selections;
    var modules = this._xyc_modules;
    
    for ( var sel in selections ) {
      if ( selections.hasOwnProperty(sel) ) {
        LOG.profiling("Render:drawing-paint-chart-main-"+sel);
        selections[sel].datum(modules[sel].data()).call(modules[sel]);
        LOG.profiling("Render:drawing-paint-chart-main-"+sel);
      }
    }
    
    if(TypeUtils.isExist(modules.dataLabel)){
      modules.dataLabel();
    }
  };
  
  XYContainer.prototype._xyc_resolveProperties = function(nodeConfig, isContainer){
    var props = {}, // Empty properties basket
        propsCat,   // Property category node
        usrProps,   // User set properties
        sysProps;   // Predefined properties in configure node
    var properties = this._xyc_properties;
    
    if(isContainer){
      //Jimmy/8/15/2012 pay attention to the property structure, for container we will pass
      //all properties instead of properties under propsCat only.
      if ( nodeConfig ) {
        propsCat = nodeConfig.propertyCategory;
        usrProps = properties;
        sysProps = {};
        sysProps[propsCat] = nodeConfig.properties;
        Objects.extend( true, props, sysProps, usrProps ); 
      }else{
        props = properties;
      }
    }else{
      if ( nodeConfig ) {
        propsCat = nodeConfig.propertyCategory;
        usrProps = properties[ propsCat ];
        sysProps = nodeConfig.properties;
        // User properties will override predefined properties 
        Objects.extend( true, props, sysProps, usrProps );
      }
    }
    return props;
  };
  
  XYContainer.prototype._xyc_updateProperties = function(id, isContainer){
    var config = this._xyc_config;
    var modules = this._xyc_modules;
    var properties = this._xyc_properties;
    
    var moduleManifest = config.modules; // Module configurations
    var props, nodeConfig, propsCat;
    if ( moduleManifest[id] && modules[id] ) {
      nodeConfig = moduleManifest[id].configure;
      if (isContainer){
        props = properties;
      }
      else {
        if (nodeConfig){
          propsCat = nodeConfig.propertyCategory;
          props = Objects.extend(true, {}, properties[propsCat]);
        }
        else{
          props = {};
        }
      }
      modules[id].properties(props);
    }
  };
  
  XYContainer.prototype._xyc_updateAxisData = function ( id ) {
    var modules = this._xyc_modules;
    var config = this._xyc_config;
    var data = this._xyc_data;
    
    if ( modules[id] ) {
      var axisConfig = config.modules[id];
      var axisDataConfig = axisConfig.data;
      if ( axisDataConfig ) {
        modules[id].data(data.createDataAdapterForModule(axisDataConfig));
      } 
    }  
  };
    
  XYContainer.prototype._xyc_initAxis = function ( id ) {
    var modules = this._xyc_modules;
    var config = this._xyc_config;
    var ctx = this._xyc_ctx;
    
    if ( !config.modules[id] ) { return; }
    
    var axisConfig = config.modules[id],
        axis = modules[id] = ignite(axisConfig.id, ctx, Constants.CSS.CLASS.MODULEPREFIX + id); // Saves references to axis function.
    
    this._xyc_updateAxisData(id);

    var props = this._xyc_resolveProperties(axisConfig.configure);
    axis.properties(props);
    
    if(axis.dispatch && axis.dispatch()['initialized']){
      this._xyc_initializedModules++;
      axis.dispatch().on('initialized.xycontainer', this._xyc_initialized.bind(this));
    }
  };
  
  XYContainer.prototype._xyc_initialized = function(){
    if ( this._xyc_initializedModules === ++ this._xyc_initializedCount ) {
      this._xyc_initializedCount = 0;
      this._xyc_eDispatch.initialized();
    }
  };
  
  XYContainer.prototype._xyc_showTooltip = function ( evt ) {
    this._xyc_eDispatch.showTooltip(evt);
  };
  
  XYContainer.prototype._xyc_hideTooltip = function ( evt ) {
    this._xyc_eDispatch.hideTooltip(evt);
  };
    
  XYContainer.prototype.width = function (_) {
    if ( !arguments.length ) { return this._xyc_width; }
    this._xyc_width = _;
    if ( this._xyc_height ) { this._xyc_relayout(); }
    return this;
  };
  
  XYContainer.prototype.height = function (_) {
    if ( !arguments.length ) { return this._xyc_height; }
    this._xyc_height = _;
    if ( this._xyc_width ) { this._xyc_relayout(); }
    return this;
  };
  
  XYContainer.prototype.size = function(_) {
    if ( !arguments.length ) { 
      return {
        'width' : this._xyc_width,
        'height' : this._xyc_height
      };
    }
    this._xyc_height = _.height;
    this._xyc_width = _.width;
    this._xyc_relayout();
    return this;
  };
  
  XYContainer.prototype.data = function (_) {
    if ( !arguments.length ) { return this._xyc_data; }
    this._xyc_data = _;
    
    if ( !TypeUtils.isEmptyObject(this._xyc_modules) && !TypeUtils.isEmptyObject(this._xyc_properties) ) {
      //plot exists, we need update its data
      var dataHandler = new SingleChartDataHandler(this._xyc_data); 
      this._xyc_modules['plot'].data(dataHandler.getDataAdapter());
      this._xyc_updateAxisData('xAxis');
      this._xyc_updateAxisData('yAxis');
      this._xyc_updateAxisData('xAxis2');
      this._xyc_updateAxisData('yAxis2');
    }
    
    return this;
  };
  
  XYContainer.prototype.properties = function (xs) {
    if ( !arguments.length ) { return this._xyc_properties; }
    this._xyc_properties = Objects.extend(true, {}, this._xyc_properties, xs);
    if ( !TypeUtils.isEmptyObject(this._xyc_modules) && !TypeUtils.isEmptyObject(this._xyc_data) ) {
      this._xyc_updateProperties('xAxis');
      this._xyc_updateProperties('xAxis2');
      this._xyc_updateProperties('yAxis');
      this._xyc_updateProperties('yAxis2');
      this._xyc_updateProperties('plot');
      this._xyc_updateProperties('dataLabel');
      this._xyc_updateProperties('background');
    }
    return this;
  };
  
  XYContainer.prototype.config = function (_) {
    if ( !arguments.length ) { return this._xyc_config; }
    this._xyc_config = _;
    if ( TypeUtils.isEmptyObject(this._xyc_modules) && 
        !TypeUtils.isEmptyObject(this._xyc_data) && 
        !TypeUtils.isEmptyObject(this._xyc_properties) && 
        this._xyc_parent !== null ) {
      this._xyc_initialize();
    }
    return this;
  };
  
  XYContainer.prototype.modules = function (xs) {
    if ( !arguments.length ) {
      if ( TypeUtils.isEmptyObject(this._xyc_modules) ) {
        this._xyc_initialize();
      } 
      return this._xyc_modules;
    }
    this._xyc_modules = xs;
    return this;
  };
  
  XYContainer.prototype.parent = function (_) {
    if ( !arguments.length ) { return this._xyc_parent; }
    this._xyc_parent = _;
    return this;
  };
  
  XYContainer.prototype.dispatch = function(_){
    if ( !arguments.length) { return this._xyc_eDispatch; }
    this._xyc_eDispatch = _;
    return this;
  };
  
  XYContainer.prototype.rotate = function(_) {
    var plot = this._xyc_modules['plot'];
    if (!arguments.length) { return plot.rotate(); }
    plot.rotate(_);
    return this;
  };
  
  XYContainer.prototype.destroy = function() {
    this._xyc_parent = null;
    this._xyc_selections = null;
    var modules = this._xyc_modules;
    //remove listener
    for(var mkey in modules){
      if(modules.hasOwnProperty(mkey)){
        var m = modules[mkey];
        if(m.dispatch){
          var dis =  m.dispatch();
          if ( dis.initialized ) { dis.on('initialized.xycontainer', null);}
          if ( dis.showTooltip ) { dis.on('showTooltip.xycontainer', null);}
          if ( dis.hideTooltip ) { dis.on('hideTooltip.xycontainer', null);}
        }
      }
    }
    this._xyc_modules = null;
    this._xyc_data = null;
    //destroy ctx
    if(this._xyc_ctx){
      this._xyc_ctx.destroy();
      this._xyc_ctx = null;
    }
  };
  
  return XYContainer;
});
define('sap/viz/modules/manifests/XYContainer',['sap/viz/modules/manifests/Module','sap/viz/modules/Constants','sap/viz/modules/xycontainer'],
function Setup(Manifest, Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.xycontainer',
    'type' : Constants.Type.Container,
    'name' : 'single container',
    'properties' : null,
    'css' : null,
    'configure' : null,
    'events' : {
      'showTooltip' : Constants.Event.TooltipShow.desc,
      'hideTooltip' : Constants.Event.TooltipHide.desc
    },
    fn : fn
  };

  Manifest.register(module);
});
define('sap/viz/modules/manifests/Background',['sap/viz/modules/manifests/Module','sap/viz/modules/Constants','sap/viz/modules/background'],
function Setup(Manifest, Constants, fn) {
  var visibleObj = {
        'name' : 'visible',
        'supportedValueType' : 'Boolean',
        'defaultValue' : true,
        'description' : 'Set visibility of background.'
      };
  var module = {
    'id' : 'sap.viz.modules.background',
    'type' : Constants.Type.Supplementary,
    'name' : 'background',
    'description': 'Settings for the background for the outer chart area.',
    'properties' : {
      'visible' : visibleObj,
    'border' : {
        'name' : 'border',
      'description' : 'Settings for border property.',
        'supportedValueType' : 'Object',
        'supportedValues' : { 
      'left' : {
        'name' : 'left',
        'description' : 'Set left border property.',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'visible' : visibleObj,
        },
          }, 
      'right' : {
        'name' : 'right',
        'description' : 'Set right border property.',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'visible' : visibleObj,
        },
          }, 
      'top' : {
        'name' : 'top',
        'description' : 'Set top border property.',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'visible' : visibleObj,
        },
          }, 
      'bottom' : {
        'name' : 'bottom',
        'description' : 'Set bottom border property.',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'visible' : visibleObj,
        },
          },
          },
    },
        'drawingEffect':{
          'name' : 'drawingEffect',
            'description' : 'Set drawing effect of background.',
          'supportedValueType' : 'String',
            'supportedValues' : [ 'normal', 'glossy' ],
            'defaultValue' : 'normal',
            'isExported' : true,
        },
        'direction':{
          'name' : 'direction',
            'description' : 'Set gradient direction of background, only taking effect when drawingEffect of background has been set to \'golossy\'.',
          'supportedValueType' : 'String',
            'supportedValues' : [ 'horizontal', 'vertical' ],
            'defaultValue' : 'vertical',
        }
    },
    'css' : {
      '.v-background-body.viz-plot-background' : {
        'description' : 'Define style for the plot background body.',
        'value' : {
          'fill' : 'none',
        }
      },
      '.v-background-border.viz-plot-background-border' : {
        'description' : 'Define style for the plot background border.',
        'value' : {
          'stroke' : '#d8d8d8',
          'stroke-width' : 1,
        }
      },
    },
    'configure' : null,
    fn : fn
  };
  Manifest.register(module);
});
define('sap/viz/manifests/BaseSingleChart',['sap/viz/manifests/Viz','sap/viz/manifests/BaseChart','sap/viz/modules/manifests/RootContainer',
'sap/viz/modules/manifests/XYContainer','sap/viz/modules/manifests/Background',
'sap/viz/modules/manifests/legend/Common'],
function Setup(Manifest) {
  var pieChart = {
    id : 'riv/base/single',
    name : 'IDS_BASESINGLECHART',
    base : 'riv/base',
    'abstract' : true,
    modules : {
      root : {
        configure : { propertyCategory : 'general' },
        modules : {
          main : {
            id : 'sap.viz.modules.xycontainer',
            configure : {
              propertyCategory : 'xyContainer',
              properties : {
                layout : {
                  position : 'center',
                  priority : 10
                }
              }
            }
          }
        }
      }
    }
  };

  Manifest.register(pieChart);
});
define('sap/viz/util/NumberUtils',['sap/viz/base/utils/TypeUtils', 'sap/viz/format/FormatManager'],
function Setup(TypeUtils, FormatManager) {
  var NumberUtils = {
    isNoValue: function (n) {
      return TypeUtils.isNaN(n);
    },
    precise: function (f) {
      var result, temp,
          str = f.toString(),
          index = str.indexOf('e');
      if (index >= 0) {
        result = str.substring(index);
        temp = parseFloat(Number(str.substring(0,index)).toFixed(8));
        result = temp.toString() + result;
        result = Number(result);
      } else {
        result = parseFloat(f.toFixed(8));
      }
      return result;
    },
    format : function(value, pattern) {
      var tempValueLeft, tempValueRight='', numLeft, tempPattern, result, formatFun, index;
      if ((typeof value === 'number') &&
        (typeof pattern === 'string') &&
        (pattern.charAt(pattern.length-1) === 'u')) {
        formatFun = d3.format('s');
        tempValueLeft = formatFun(value);

        if (pattern.length>1) {
          tempPattern = pattern.substring(0, pattern.length-1);
        }
        if (isNaN(tempValueLeft.charAt(tempValueLeft.length-1))) {
          tempValueRight = tempValueLeft.substr(tempValueLeft.length-1,1);
          tempValueLeft = tempValueLeft.substr(0,tempValueLeft.length-1);
        } 

        tempValueLeft =  NumberUtils.format(parseFloat(tempValueLeft), tempPattern);

        result = tempValueLeft + tempValueRight;

      }/*
       else if ((Math.abs(value) > 1e8) || 
                       (Math.abs(value) < 1e-6 && Math.abs(value) > 0)){
              tempValueLeft = value.toExponential();
              index = tempValueLeft.indexOf('e');
              tempValueRight = tempValueLeft.substring(index);
              numLeft = parseFloat(tempValueLeft.substring(0,index));
      
              tempValueLeft =  NumberUtils.format(numLeft, pattern);
      
              result = tempValueLeft + tempValueRight;
      
            }*/
       else {
        result = FormatManager.format(NumberUtils.precise(value), pattern); // we always try to convert number to string
      }

      return result;
    }
  };
  return NumberUtils;
});

define('sap/viz/modules/threeD/Vector',[],
function Setup(Point) {
  function Vector() {
    this.values = [];
    for ( var i = 0, len = arguments.length; i < len; i++) {
      this.values.push(arguments[i]);
    }
  }

  Vector.prototype.dotProduct = function(v) {
    var dimension = v.dimension();
    if (dimension !== this.dimension()) {
      throw new Error(
          "The vectors to be dot-producted must have same dimension, but the dimension of this vector is " +
              this.dimension + " and another one is " + dimension + ".");
    }
    var sum = 0;
    for ( var i = 0; i < dimension; i++) {
      sum += this.value(i) * v.value(i);
    }
    return sum;
  };

  Vector.prototype.dimension = function(v) {
    return this.values.length;
  };

  Vector.prototype.value = function(i, d) {
    if (arguments.length >= 2) {
      this.values[i] = d;
    }
    return this.values[i];
  };

  return Vector;
});
define('sap/viz/modules/threeD/Vector4D',['sap/viz/modules/threeD/Vector'],
function Setup(Vector) {
  function Vector4D(p1, p2, p3, p4) {
    Vector.apply(this, arguments);
  }

  Vector4D.prototype = Object.create(Vector.prototype);

  return Vector4D;
});
define('sap/viz/modules/threeD/Point',['sap/viz/modules/threeD/Vector4D'],
function Setup(Vector4D) {
  function Point(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
  }
  Point.prototype.transform = function(m) {
    var vector = new Vector4D(this.x, this.y, this.z, 1);
    this.x = m.row(0).dotProduct(vector);
    this.y = m.row(1).dotProduct(vector);
    this.z = m.row(2).dotProduct(vector);
    return this;
  };

  return Point;
});
define('sap/viz/modules/threeD/matrix',['sap/viz/modules/threeD/Vector4D'],
function Setup(Vector4D) {
  var dimension = 4;
  var length = dimension * dimension;

  function radian(deg) {
    return deg * Math.PI / 180;
  }

  var matrixBuilder = function() {
    var values = new Array(length);

    var matrix = {
      unit : function() {
        for ( var i = 0; i < length; i++) {
          values[i] = (i % (dimension + 1) === 0) ? 1 : 0;
        }
        return matrix;
      },

      value : function(row, col, v) {
        var index = row * dimension + col;
        if (arguments.length >= 3) {
          values[index] = v;
          return matrix;
        }
        return values[index];
      },

      row : function(row) {
        var array = [];
        var start = row * dimension;
        for ( var i = 0; i < dimension; i++) {
          array[i] = values[start + i];
        }
        return new Vector4D(array[0], array[1], array[2], array[3]);
      },

      col : function(col) {
        var array = [];
        for ( var i = 0; i < dimension; i++) {
          array[i] = values[dimension * i + col];
        }
        return new Vector4D(array[0], array[1], array[2], array[3]);
      },

      translate : function(tx, ty, tz) {
        return matrix.transform(matrixBuilder().value(0, 3, tx || 0).value(1,
            3, ty || 0).value(2, 3, tz || 0));
      },

      scale : function(tx, ty, tz) {
        return matrix.transform(matrixBuilder().value(0, 0, tx || 0).value(1,
            1, ty || 0).value(2, 2, tz || 0));
      },

      rotateX : function(deg) {
        var r = radian(deg);
        var sin = Math.sin(r);
        var cos = Math.cos(r);
        return matrix.transform(matrixBuilder().value(1, 1, cos).value(1, 2,
            -sin).value(2, 1, sin).value(2, 2, cos));
      },

      rotateY : function(deg) {
        var r = radian(deg);
        var sin = Math.sin(r);
        var cos = Math.cos(r);
        return matrix.transform(matrixBuilder().value(0, 0, cos).value(0, 2,
            sin).value(2, 0, -sin).value(2, 2, cos));
      },
      
      rotateZ : function(deg){
        var r = radian(deg);
        var sin = Math.sin(r);
        var cos = Math.cos(r);
        return matrix.transform(matrixBuilder().value(0, 0, cos).value(0, 1,
            -sin).value(1, 0, sin).value(1, 1, cos));
      },
      
      transform : function(m) {
        if (m) {
          var rows = [], cols = [], i;
          for ( i = 0; i < dimension; i++) {
            rows.push(m.row(i));
            cols.push(matrix.col(i));
          }
          for ( i = 0; i < dimension; i++) {
            var start = i * dimension;
            for ( var j = 0; j < dimension; j++) {
              var index = start + j;
              values[index] = rows[i].dotProduct(cols[j]);
            }
          }
        }
        return matrix;
      },

      clone : function() {
        var newMatrix = matrixBuilder();
        for ( var i = 0; i < dimension; i++) {
          for ( var j = 0; j < dimension; j++) {
            newMatrix.value(i, j, matrix.value(i, j));
          }
        }
        return newMatrix;
      },

      projection : function() {
        return "matrix(" + matrix.value(0, 0) + "," + matrix.value(1, 0) + "," +
            matrix.value(0, 1) + "," + matrix.value(1, 1) + "," +
            matrix.value(0, 3) + "," + matrix.value(1, 3) + ")";
      },

      translatedProjection : function(){
        return "translate(" + this.value(0,3) + "," + this.value(1,3) +")";
      },
      
      toString : function() {
        var str = "";

        for ( var i = 0; i < length; i++) {
          if (i % 4 !== 0) {
            str += ", ";
          }
          str += values[i];
          if ((i - 3) % 4 === 0) {
            str += "\n";
          }
        }

        return str;
      },
      
      destroy : function() {
        values = null;
      }
    };

    return matrix.unit();
  };

  return matrixBuilder;
});
define('sap/viz/modules/axis/valueAxisCore',['jquery', 'sap/viz/modules/Constants', 'sap/viz/util/TextUtils','sap/viz/util/NumberUtils','sap/viz/base/utils/Objects',
'sap/viz/modules/threeD/Point','sap/viz/modules/threeD/matrix', 'sap/viz/base/UADetector'],
function Setup(jQuery, ModuleConstants, TextUtils, NumberUtils, Objects, Point, matrix, UADetector) {

  var ret = function() {
   
        var m_position;
        var m_axScale = null;

        var m_tickSize = 5;
        var m_textOffset = 6;

        var m_axDefaultTickNum = 7;

        var m_styleLineSrokeWidth = 1;
        var m_styleAxisColor = "#6c6c6c";
        var m_styleGridLineColor = "#d8d8d8";
        var m_styleGridIncisedLineColor = "#ffffff";
        var m_styleAxisLabelColor = "#333333";
        
        var m_axLabelClassName = "viz-axis-label";        
        
        var m_style = null;
        var m_props = { 
            "title": {"visible": false, "text": undefined,},
            "gridline": {"visible": true, "color": m_styleGridLineColor, "showFirstLine": false, "length": 0, "showLastLine": false, "type":"line"},
            "type" : "value",
            "visible" : true,
            "label": {"visible": true, "numberFormat" : "","formatString": "", },
            "position": "left",
            "color": m_styleAxisColor,
            "axisline" : {"visible": true},
            "shapeRendering": true
        };

        var m_vClassNames = 
        {
            axis:"v-axis",
            axisBody:"v-body",
            axisTitle:"v-title",
            axisLabel:"v-label",
            axisLine: "v-valueaxisline",
            gridLine: "v-gridline",
            incisedGridLine: "v-incised-gridline",
            fixedAxisLine: "v-fixed-valueaxisline",
            morphableLabel:ModuleConstants.CSS.CLASS.MORPHABLELABEL
        };
        
        var m_axisLabelClassCombined = m_vClassNames.axisLabel + ' ' + m_axLabelClassName + ' ' + m_vClassNames.morphableLabel;

        var m_matrix = matrix(), labelAngle = null, labelAlign = null, angle = null, tickAngle = null;
        
        var m_spaceLimit = -1;
        axis.spaceLimit = function(_spaceLimit)
        {
            if (!arguments.length) 
                return m_spaceLimit;
            m_spaceLimit = _spaceLimit;
            return axis;
        }

        function axis(selection) {
                
                var axRange = m_axScale.range();//[0, 500]
                var axDomain = m_axScale.domain();//[-100, 2000]

                if(axRange[0] == 0 && axRange[1] == 0)
                {
                    return;//do not draw value axis
                }

                var axTicksLabels = getTicksLabel();

                if(m_position == "bottom")
                {
                    var maxTextHeight = 0;
                    if(m_props.label.visible) {
                        var textArray = [];
                        for(var i = 0; i < axTicksLabels.length; i++)
                        {
                            textArray.push(axTicksLabels[i].text);
                        }
                        maxTextHeight = maxLabelTextHeight(textArray);
                    }
                    if  ((m_spaceLimit != -1) && (maxTextHeight + m_tickSize + 2*m_textOffset + m_styleLineSrokeWidth/2 > m_spaceLimit)) {
                        axTicksLabels = [];
                        maxTextHeight = 0;
                    }

                    for(var i = 0; i < axTicksLabels.length; i++)
                    {
                        var axTick = selection.append("line")
                        .attr("class", m_props.isAxisColorFixed ? m_vClassNames.fixedAxisLine : m_vClassNames.axisLine)
                                    .attr("x1", m_axScale(axTicksLabels[i].value))
                                    .attr("x2", m_axScale(axTicksLabels[i].value))
                                    .attr("y1", 0)
                                    .attr("y2", m_tickSize + 1)//line contains the first but not the last point
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");

                        if(angle){
                            var aAngle = angle * Math.PI /180;
                            var cosAngle = Math.cos(aAngle);
                            var sinAngle = (45 === angle) ? cosAngle : Math.sin(aAngle);
                            var tAngle = tickAngle * Math.PI / 180;
                            var cosTAngle = Math.cos(tAngle);
                            var sinTAngle = Math.sin(tAngle);
                            
                            var tickStartX  =   m_axScale(axTicksLabels[i].value) * sinAngle;
                            tickStartY =  -m_axScale(axTicksLabels[i].value) * cosAngle;
                            var x2 = tickStartX + ( m_tickSize + 1) * cosTAngle,
                              y2 = tickStartY + ( m_tickSize + 1) * sinTAngle;
                              
                            axTick.attr('x1', tickStartX).attr('y1', tickStartY).attr('x2', x2).attr('y2', y2);  
                          }
                        
                        var drawLine = function()
                        {
                             var line = selection.append("line")
                             .attr("class", m_vClassNames.gridLine)
                            .attr("x1", m_axScale(axTicksLabels[i].value))
                            .attr("x2", m_axScale(axTicksLabels[i].value))
                            .attr("y1", -m_props.gridline.length)
                            .attr("y2", 0)
                            .attr("stroke", m_props.gridline.color)
                            .attr("stroke-width", m_props.gridline.size)
                            .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");

                            if(m_props.gridline.type == "dotted")
                            {
                                 line.attr("stroke-dasharray", "3, 2");
                            }
                            
                            if(m_props.gridline.type == "incised")
                            {
                                var line = selection.append("line")
                                .attr("class", m_vClassNames.incisedGridLine)
                                .attr("x1", m_axScale(axTicksLabels[i].value)-1)
                                .attr("x2", m_axScale(axTicksLabels[i].value)-1)
                                .attr("y1", -m_props.gridline.length)
                                .attr("y2", 0)
                                .attr("stroke", m_styleGridIncisedLineColor)
                                .attr("stroke-width", m_props.gridline.size)
                                .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");
                            }
                        };

                        if( i == 0 && m_props.gridline.showFirstLine)
                        {
                             drawLine();
                        }
                        else if ( i == (axTicksLabels.length - 1) && m_props.gridline.showLastLine)
                        {
                             drawLine();
                        }
                        else if ( (i != (axTicksLabels.length - 1))
                               && (i != 0)
                               && m_props.gridline.visible )
                        {
                             drawLine();
                        }
                    }

                    if(m_props.label.visible)
                    {
                        drawTopBottomLabels(selection, "bottom", axTicksLabels, maxTextHeight);
                    }

                    if (m_props.axisline.visible) {
                        var x1 = axRange[0];
                        var x2 = axRange[1];
                        var y1 = 0;
                        var y2 = 0;

                        var endSize = 0;//m_tickSize

                        var dPath  = "M" + x1 + " " + (y1 + endSize);
                            dPath += "L" + x1 + " " + y1;
                            dPath += "L" + x2 + " " + y2;
                            dPath += "L" + x2 + " " + (y2 + endSize);

                        var axLine = selection.append("path")
                                    .attr("class", m_props.isAxisColorFixed ? m_vClassNames.fixedAxisLine : m_vClassNames.axisLine)
                                    .attr("d", dPath)
                                    .attr("fill", "none")
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");
                        
                        if( angle ){
                            var aAngle = angle * Math.PI /180;
                            var cosAngle = Math.cos(aAngle);
                            var sinAngle = (45 == angle)? cosAngle: Math.sin(aAngle); 
                            dPath = 'M ' + axRange[0] + ' ' + y1;
                            dPath += 'L' + (axRange[0] + axRange[1] * sinAngle) + ' ' + (y2 - axRange[1] * cosAngle);
                            dPath += 'Z';
                            
                            axLine.attr('d', dPath);
                        }
                    }
                }
                else if(m_position == "top")
                {
                    var maxTextHeight = 0;
                    if(m_props.label.visible) {
                        var textArray = [];
                        for(var i = 0; i < axTicksLabels.length; i++)
                        {
                            textArray.push(axTicksLabels[i].text);
                        }
                        maxTextHeight = maxLabelTextHeight(textArray);
                    }
                    if ((m_spaceLimit != -1) && (maxTextHeight + m_tickSize + 2*m_textOffset + m_styleLineSrokeWidth/2 > m_spaceLimit)) {
                        axTicksLabels = [];
                        maxTextHeight = 0;
                    }
                    
                    var nOffset = 1;
                    if(m_props.label.visible)
                    {
                        nOffset = 2;
                    }

                    for(var i = 0; i < axTicksLabels.length; i++)
                    {
                        var axTick = selection.append("line")
                        .attr("class", m_props.isAxisColorFixed ? m_vClassNames.fixedAxisLine : m_vClassNames.axisLine)
                                    .attr("x1", m_axScale(axTicksLabels[i].value))
                                    .attr("x2", m_axScale(axTicksLabels[i].value))
                                    .attr("y1", maxTextHeight + nOffset*m_textOffset)
                                    .attr("y2", maxTextHeight + nOffset*m_textOffset + m_tickSize)
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");

                        var drawLine = function()
                        {
                            var gridline = selection.append("line")
                            .attr("class", m_vClassNames.gridLine)
                                        .attr("x1", m_axScale(axTicksLabels[i].value))
                                        .attr("x2", m_axScale(axTicksLabels[i].value))
                                        .attr("y1", maxTextHeight + m_tickSize + nOffset*m_textOffset)
                                        .attr("y2", maxTextHeight + m_tickSize + nOffset*m_textOffset + m_props.gridline.length)
                                        .attr("stroke", m_props.gridline.color)
                                        .attr("stroke-width", m_props.gridline.size)
                                        .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");

                            if(m_props.gridline.type == "dotted")
                            {
                                 gridline.attr("stroke-dasharray", "3, 2");
                            }

                            if(m_props.gridline.type == "incised")
                            {
                                var gridline = selection.append("line")
                                .attr("class", m_vClassNames.incisedGridLine)
                                .attr("x1", m_axScale(axTicksLabels[i].value)-1)
                                .attr("x2", m_axScale(axTicksLabels[i].value)-1)
                                .attr("y1", maxTextHeight + m_tickSize + nOffset*m_textOffset)
                                .attr("y2", maxTextHeight + m_tickSize + nOffset*m_textOffset + m_props.gridline.length)
                                .attr("stroke", m_styleGridIncisedLineColor)
                                .attr("stroke-width", m_props.gridline.size)
                                .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");
                            }
                        };

                        if( i == 0 && m_props.gridline.showFirstLine)
                        {
                             drawLine();
                        }
                        else if ( i == (axTicksLabels.length - 1) && m_props.gridline.showLastLine)
                        {
                             drawLine();
                        }
                        else if ( (i != (axTicksLabels.length - 1))
                               && (i != 0)
                               && m_props.gridline.visible )
                        {
                             drawLine();
                        }
                    }

                    if(m_props.label.visible)
                    {
                        drawTopBottomLabels(selection, "top", axTicksLabels, maxTextHeight);
                    }

                    if (m_props.axisline.visible) {
                        var x1 = axRange[0];
                        var x2 = axRange[1];
                        var y1 = maxTextHeight + m_tickSize + nOffset*m_textOffset;
                        var y2 = maxTextHeight + m_tickSize + nOffset*m_textOffset;

                        var endSize = 0;//m_tickSize
                        var dPath  = "M" + x1 + " " + (y1 - endSize);
                            dPath += "L" + x1 + " " + y1;
                            dPath += "L" + x2 + " " + y2;
                            dPath += "L" + x2 + " " + (y2 - endSize);

                        var axLine = selection.append("path")
                        .attr("class", m_props.isAxisColorFixed ? m_vClassNames.fixedAxisLine : m_vClassNames.axisLine)
                                    .attr("d", dPath)
                                    .attr("fill", "none")
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");
                    }

                }
                else if(m_position == "left")
                {
                    //we must change axTicksLabels, remove some lable array items for label management
                    //console.log(axTicksLabels);
                    axTicksLabels = buildToDrawLabels(axTicksLabels, m_position);

                    //count the max text width
                    var maxTextWidth = 0;
                    if(m_props.label.visible) {
                        var textArray = [];
                        for(var i = 0; i < axTicksLabels.length; i++)
                        {
                            textArray.push(axTicksLabels[i].text);
                        }
                        maxTextWidth = maxLabelTextWidth(textArray);
                    }
                    if ((m_spaceLimit != -1) && (maxTextWidth + m_tickSize + 2*m_textOffset + m_styleLineSrokeWidth/2 > m_spaceLimit)) {
                        axTicksLabels = [];
                        maxTextWidth = 0;
                    }

                    var nOffset = 1;
                    if(m_props.label.visible)
                    {
                        nOffset = 2;
                    }

                    for(var i = 0; i < axTicksLabels.length; i++)
                    {
                        var axTick = selection.append("line")
                                    .attr("class", m_props.isAxisColorFixed ? m_vClassNames.fixedAxisLine : m_vClassNames.axisLine)
                                    .attr("x1", maxTextWidth + nOffset*m_textOffset)
                                    .attr("x2", maxTextWidth + nOffset*m_textOffset + m_tickSize)
                                    .attr("y1", m_axScale(axTicksLabels[i].value))
                                    .attr("y2", m_axScale(axTicksLabels[i].value))
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");

                        var drawLine = function()
                        {
                            var gridline = selection.append("line")
                            .attr("class", m_vClassNames.gridLine)
                                        .attr("y1", m_axScale(axTicksLabels[i].value))
                                        .attr("y2", m_axScale(axTicksLabels[i].value))
                                        .attr("x1", maxTextWidth + nOffset*m_textOffset + m_tickSize)
                                        .attr("x2", maxTextWidth + nOffset*m_textOffset + m_tickSize + m_props.gridline.length)
                                        .attr("stroke", m_props.gridline.color)
                                        .attr("stroke-width", m_props.gridline.size)
                                        .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");

                            if(m_props.gridline.type == "dotted")
                            {
                                 gridline.attr("stroke-dasharray", "3, 2");
                            }

                            if(m_props.gridline.type == "incised")
                            {
                                var gridline = selection.append("line")
                                .attr("class", m_vClassNames.incisedGridLine)
                                .attr("y1", m_axScale(axTicksLabels[i].value)+1)
                                .attr("y2", m_axScale(axTicksLabels[i].value)+1)
                                .attr("x1", maxTextWidth + nOffset*m_textOffset + m_tickSize)
                                .attr("x2", maxTextWidth + nOffset*m_textOffset + m_tickSize + m_props.gridline.length)
                                .attr("stroke", m_styleGridIncisedLineColor)
                                .attr("stroke-width", m_props.gridline.size)
                                .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");
                            }
                            
                        };

                        if( i == 0 && m_props.gridline.showFirstLine)
                        {
                             drawLine();
                        }
                        else if ( i == (axTicksLabels.length - 1) && m_props.gridline.showLastLine)
                        {
                             drawLine();
                        }
                        else if ( (i != (axTicksLabels.length - 1))
                               && (i != 0)
                               && m_props.gridline.visible )
                        {
                             drawLine();
                        }
                        
                        //selection.append("circle").attr("cx", maxTextWidth).attr("cy", m_axScale(axTicksLabels.value[i])). attr("r", 3);
                        if(m_props.label.visible)
                        {
                            var text = selection
						   .append("g")
                           .attr("fill", m_style.defaultStyle.label.fill)
                           .attr("class", m_axisLabelClassCombined)
                           .attr("font-size", m_style.defaultStyle.label['font-size'])
                           .attr("font-weight", m_style.defaultStyle.label['font-weight'])
                           .attr("font-family", m_style.defaultStyle.label['font-family'])                                
                           .append("text")
                           .attr("x", maxTextWidth + m_textOffset)
                           .attr("y", m_axScale(axTicksLabels[i].value))
                           .attr("dominant-baseline", "middle")//"auto")//"hanging")//"central")
                           .attr("text-anchor", "end") // text-align
                           .text(axTicksLabels[i].text);

                            adjustLabelForIE(text);
                        }
                    }

                    if (m_props.axisline.visible) {
                        var x1 = maxTextWidth + nOffset*m_textOffset + m_tickSize;
                        var x2 = maxTextWidth + nOffset*m_textOffset + m_tickSize;
                        var y1 = axRange[0];
                        var y2 = axRange[1];

                        var endSize = 0;//m_tickSizes
                        var dPath  = "M" + (x1 - endSize) + " " + y1;
                            dPath += "L" + x1 + " " + y1;
                            dPath += "L" + x2 + " " + y2;
                            dPath += "L" + (x2 - endSize) + " " + y2;
                        
                        var axLine = selection.append("path")
                        .attr("class", m_props.isAxisColorFixed ? m_vClassNames.fixedAxisLine : m_vClassNames.axisLine)
                                    .attr("d", dPath)
                                    .attr("fill", "none")
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");
                    }
                }
                else if(m_position == "right")
                {
                    //we must change axTicksLabels, remove some lable array items for label management
                    //console.log(axTicksLabels);
                    axTicksLabels = buildToDrawLabels(axTicksLabels, m_position);
                    if(m_props.label.visible) {
                        var textArray = [];
                        for(var i = 0; i < axTicksLabels.length; i++)
                        {
                            textArray.push(axTicksLabels[i].text);
                        }
                        maxTextWidth = maxLabelTextWidth(textArray);
                    }
                    if ((m_spaceLimit != -1) && (maxTextWidth + m_tickSize + 2*m_textOffset + m_styleLineSrokeWidth/2 > m_spaceLimit)) {
                        axTicksLabels = [];
                        maxTextWidth = 0;
                    }

                    for(var i = 0; i < axTicksLabels.length; i++)
                    {
                        var axTick = selection.append("line")
                        .attr("class", m_props.isAxisColorFixed ? m_vClassNames.fixedAxisLine : m_vClassNames.axisLine)
                                    .attr("x1", 0)
                                    .attr("x2", m_tickSize)
                                    .attr("y1", m_axScale(axTicksLabels[i].value))
                                    .attr("y2", m_axScale(axTicksLabels[i].value))
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");

                        var drawLine = function()
                        {
                            var gridline = selection.append("line")
                            .attr("class", m_vClassNames.gridLine)
                                        .attr("y1", m_axScale(axTicksLabels[i].value))
                                        .attr("y2", m_axScale(axTicksLabels[i].value))
                                        .attr("x1", -m_props.gridline.length)
                                        .attr("x2", 0)
                                        .attr("stroke", m_props.gridline.color)
                                        .attr("stroke-width", m_props.gridline.size)
                                        .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");

                            if(m_props.gridline.type == "dotted")
                            {
                                 gridline.attr("stroke-dasharray", "3, 2");
                            }
                            if(m_props.gridline.type == "incised")
                            {
                                var gridline = selection.append("line")
                                .attr("class", m_vClassNames.incisedGridLine)
                                .attr("y1", m_axScale(axTicksLabels[i].value)+1)
                                .attr("y2", m_axScale(axTicksLabels[i].value)+1)
                                .attr("x1", -m_props.gridline.length)
                                .attr("x2", 0)
                                .attr("stroke", m_styleGridIncisedLineColor)
                                .attr("stroke-width", m_props.gridline.size)
                                .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");
                            }
                        };

                        if( i == 0 && m_props.gridline.showFirstLine)
                        {
                             drawLine();
                        }
                        else if ( i == (axTicksLabels.length - 1) && m_props.gridline.showLastLine)
                        {
                             drawLine();
                        }
                        else if ( (i != (axTicksLabels.length - 1))
                               && (i != 0)
                               && m_props.gridline.visible )
                        {
                             drawLine();
                        }

                        //selection.append("circle").attr("cx", m_tickSize + m_textOffset).attr("cy", m_axScale(axTicksLabels.value[i])). attr("r", 3);
                        if(m_props.label.visible)
                        {
                            var text = selection
						    .append("g")							
                            .attr("fill", m_style.defaultStyle.label.fill)
                            .attr("class", m_axisLabelClassCombined)
                            .attr("font-size", m_style.defaultStyle.label['font-size'])
                            .attr("font-weight", m_style.defaultStyle.label['font-weight'])
                            .attr("font-family", m_style.defaultStyle.label['font-family'])                                
                            .append("text")
                            .attr("x", m_tickSize + m_textOffset)
                            .attr("y", m_axScale(axTicksLabels[i].value))
                            .attr("dominant-baseline", "middle")//"auto")//"hanging")//"central")
                            .attr("text-anchor", "start") // text-align
                            .text(axTicksLabels[i].text);

                            adjustLabelForIE(text);
                        }
                    }

                    if (m_props.axisline.visible) {
                        var x1 = 0;
                        var x2 = 0;
                        var y1 = axRange[0];
                        var y2 = axRange[1];

                        var endSize = 0;//m_tickSizes
                        var dPath  = "M" + (x1 + endSize) + " " + y1;
                            dPath += "L" + x1 + " " + y1;
                            dPath += "L" + x2 + " " + y2;
                            dPath += "L" + (x2 + endSize) + " " + y2;

                        var axLine = selection.append("path")
                        .attr("class", m_props.isAxisColorFixed ? m_vClassNames.fixedAxisLine : m_vClassNames.axisLine)
                                .attr("d", dPath)
                                .attr("fill", "none")
                                .attr("stroke", m_props.color)
                                .attr("stroke-width", m_props.lineSize)
                                .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");
                    }
                }
            };

        var adjustLabelForIE = function(text)
        {
            if( UADetector.isIE())
            {
                //dominant-baseline does not work
                var textHeight = m_style.realStyle.label['font-size'].toString();
                var indexPX = textHeight.indexOf("px");
                if(indexPX >= 0)
                {
                    textHeight = textHeight.substr(0, indexPX);
                }

                //textHeight = fastMeasure(text, m_style.realStyle.label).height;
                var y = text.attr("y");
                text.attr("y", Number(y) + textHeight/2);
                text.attr("dominant-baseline", "auto");
            }
        }

        axis.matrix = function(_){
          if(!arguments.length){
            return m_matrix;
          }
          m_matrix = _;
          return axis;
        };
        
        axis.labelAngle = function(_){
          if(!arguments.length){
            return labelAngle;
          }
          labelAngle = _;
          return axis;
        };
        
        axis.tickAngle = function(_){
          if(!arguments.length){
            return tickAngle;
          }
          tickAngle = _;
          return axis;
        };
        
        axis.angle = function(_){
          if(!arguments.length){
            return angle;
          }
          angle = _;
          return axis;
        };
        
        axis.labelAlign = function(_){
          if(!arguments.length){
            return labelAlign;
          }
          labelAlign = _;
          return axis;
        };
        
        axis.position = function(_position) {
            if (!arguments.length) 
                return m_position;
            m_position = _position;
            return axis;
        };
        
        axis.style = function(_style) {
          if(arguments.length == 0)
            return m_style;
          m_style = Objects.extend(true, m_style, _style);
          return axis;
        };

        axis.properties = function(_properties) {
            if (arguments.length == 0)
                return m_props;

            m_props = extendObj(m_props, _properties);
            return axis;
        };

        axis.axScale = function(_axScale) {
            if (!arguments.length) 
                return m_axScale;
            m_axScale = _axScale;
            return axis;
        };

        axis.startPadding = function() {
            if(m_axScale)
            {
                var axTicksLabels = buildToDrawLabels(getTicksLabel(), m_position);
                
                var labelSize = 0;
                if(axTicksLabels.length > 0)
                {
                    labelSize = fastMeasure(axTicksLabels[0].text, m_style.realStyle.label);
                }
                if(labelSize == 0){
                  return 0;
                }
                if(m_position == "top" || m_position == "bottom")
                {
                    return labelSize.width/2;
                }
                else
                {
                    return labelSize.height/2;
                }
            }
            else
            {
                return 0;
            }
        };

        axis.endPadding = function() {
            if(m_axScale)
            {
                var axTicksLabels = buildToDrawLabels(getTicksLabel(), m_position);

                var labelSize = 0;

                if(axTicksLabels.length > 0)
                {
                    labelSize = fastMeasure(axTicksLabels[axTicksLabels.length-1].text, m_style.realStyle.label);
                }
                if(labelSize == 0){
                  return 0;
                }
                if(m_position == "top" || m_position == "bottom")
                {
                    return labelSize.width/2;
                }
                else
                {
                    return labelSize.height/2;
                }
            }
            else
            {
                return 0;
            }
        };

        axis.getPreferredSize = function() {

            var axDomain = m_axScale.domain();//[0, 100]
            var axRange = m_axScale.range();//[0, 200]

            var axisWidth = 0;
            var axisHeight = 0;

            var axisSpacings = [];

            if( !(axRange[0] == 0 && axRange[1] == 0) )
            {

                var absRange = Math.abs(axRange[0] - axRange[1]);
                
                if(m_position == "bottom" || m_position == "top")
                {
                    axisWidth = absRange + m_styleLineSrokeWidth;
                    if(m_props.label.visible)
                    {
						var axTicksLabels = buildToDrawLabels(getTicksLabel(), m_position);
                        var textArray = [];
                        for(var i = 0; i < axTicksLabels.length; i++)
                        {
                            textArray.push(axTicksLabels[i].text);
                        }
                        axisHeight = maxLabelTextHeight(textArray) + m_tickSize + 2*m_textOffset + m_styleLineSrokeWidth/2;
                    }
                    else
                    {
                        axisHeight = m_tickSize + m_textOffset + m_styleLineSrokeWidth/2;
                    }
                    axisSpacings.push(axisHeight);
                }
                else if(m_position == "left" || m_position == "right")
                {
                    if(m_props.label.visible)
                    {
                        var axTicksLabels = buildToDrawLabels(getTicksLabel(), m_position);
                        var textArray = [];
                        for(var i = 0; i < axTicksLabels.length; i++)
                        {
                            textArray.push(axTicksLabels[i].text);
                        }
                        
                        if( fastMeasure(textArray[0], m_style.realStyle.label).height > absRange ){
                            axisWidth = m_tickSize + 2*m_textOffset;
                        }else{
                            axisWidth =  maxLabelTextWidth(textArray) + m_tickSize + 2*m_textOffset + m_styleLineSrokeWidth/2;;
                        }
                    }
                    else
                    {
                        axisWidth = m_tickSize + m_textOffset + m_styleLineSrokeWidth/2;
                    }
                    axisSpacings.push(axisWidth);

                    axisHeight = absRange + m_styleLineSrokeWidth;
                }
            }

            return {
                width : axisWidth,
                height : axisHeight,
                spacings : axisSpacings,

            };
        };
        
        axis.destroy = function() {
          m_selection = null;
          m_axScale = null;
        };

        var buildToDrawLabels = function(axTicksLabels, type)
        {
            if(axTicksLabels.length > 0)
            {
                if(m_axScale (axTicksLabels[0].value) > m_axScale (axTicksLabels[axTicksLabels.length-1].value))
                {
                    axTicksLabels.reverse();
                }
            }
            //build the "todraw" array
            //count all the labels y1 and y2, and save them.
            var allTicksLabels = [];
            for(var i = 0; i < axTicksLabels.length; i++)
            {   
              if(!NumberUtils.isNoValue(axTicksLabels[i].value)){
                var item = {};
                item.value = axTicksLabels[i].value;
                item.text = axTicksLabels[i].text;

                //count y1 and y2
                var itemSize = fastMeasure (item.text, m_style.realStyle.label);
                var center = m_axScale (item.value);

                if (type == 'left' || type == 'right') {
                    item.start =  center - itemSize.height/2;
                    item.end =   center + itemSize.height/2;
                } else {
                    item.start = center - itemSize.width/2;
                    item.end = center + itemSize.width/2;
                }
                
                allTicksLabels.push(item);
              }
            }
            //console.log(allTicksLabels);

            var ticksLabelsToDraw = [];
            ticksLabelsToDraw = calculateLabelsToDraw(allTicksLabels);

            //console.log(ticksLabelsToDraw);
            return ticksLabelsToDraw;
        };

        var drawTopBottomLabels = function(selection, type, ticksLabels, maxTextHeight)
        {
            if(ticksLabels.length == 0)
            {
                return;
            }
            var ticksLabelsToDraw = buildToDrawLabels(ticksLabels, type);

            //console.log(ticksLabelsToDraw);
            for(var i = 0; i < ticksLabelsToDraw.length; i++)
            {
              if(angle){
                var aAngle = angle * Math.PI /180;
                var cosAngle = Math.cos(aAngle);
                var sinAngle = (45 === angle) ? cosAngle : Math.sin(aAngle);
                var tAngle = tickAngle * Math.PI / 180;
                var cosTAngle = Math.cos(tAngle);
                var sinTAngle = Math.sin(tAngle);
                
                var tickStartX  =    m_axScale(ticksLabelsToDraw[i].value) * sinAngle;
                tickStartY =  -  m_axScale(ticksLabelsToDraw[i].value) * cosAngle;
                
                var item = selection
			      .append("g")				
                  .attr("fill", m_style.defaultStyle.label.fill)
                  .attr("class", m_axisLabelClassCombined)
                  .attr("font-size", m_style.defaultStyle.label['font-size'])
                  .attr("font-weight", m_style.defaultStyle.label['font-weight'])
                  .attr("font-family", m_style.defaultStyle.label['font-family'])                    
                  .append('text')
                  .attr('x', tickStartX + ( m_textOffset + m_tickSize) * cosTAngle)
                  .attr('y', tickStartY + ( m_textOffset + m_tickSize) * sinTAngle)
                  .attr("dominant-baseline", "middle")//"auto")//"hanging")//"central")
                  .attr("text-anchor", 'start') // text-align
                  .text(ticksLabelsToDraw[i].text);
          
                  if(tickAngle > 90){
                    item.attr("text-anchor", 'end').attr('transform', 'rotate( ' + (tickAngle - 180) + ' ' +item.attr("x") + ' ' +item.attr("y") + ')');
                  }else{
                    item.attr('transform', 'rotate( ' + (tickAngle) + ' ' +item.attr("x") + ' ' +item.attr("y") + ')');
                  }
              }else{
              //selection.append("circle").attr("cx", m_axScale(axTicksLabels.value[i])).attr("cy", m_textOffset + m_tickSize). attr("r", 3);
                var item = selection
				 .append("g")				
                 .attr("fill", m_style.defaultStyle.label.fill)
                 .attr("class", m_axisLabelClassCombined)
                 .attr("font-size", m_style.defaultStyle.label['font-size'])
                 .attr("font-weight", m_style.defaultStyle.label['font-weight'])
                 .attr("font-family", m_style.defaultStyle.label['font-family'])                    
                 .append("text")
                 .attr("x", m_axScale(ticksLabelsToDraw[i].value))
                 .attr("y", m_textOffset + m_tickSize)
                 .attr("dominant-baseline", "hanging")//"auto")//"hanging")//"central")
                 .attr("text-anchor", "middle") // text-align
                 .text(ticksLabelsToDraw[i].text);

                //IE does not support dominant-baseline
                item.attr("dominant-baseline", "auto");
                item.attr("y", maxTextHeight + m_textOffset);
              }
            }
        };

        var calculateLabelsToDraw = function(allTicksLabels)
        {
            var labelsToDraw = [];
            
            if(allTicksLabels.length > 0)
            {
                //split allTicksLabels if it is required.
                if( !(allTicksLabels[0].value >= 0 && allTicksLabels[allTicksLabels.length - 1].value >= 0) 
                  &&!(allTicksLabels[0].value <= 0 && allTicksLabels[allTicksLabels.length - 1].value <= 0)
                  )
                {
                    var negativeArray = [];
                    var positiveArray = [];
                    for(var i = 0; i < allTicksLabels.length; i++)
                    {
                        if(allTicksLabels[i].value <= 0) {
                            negativeArray.push(allTicksLabels[i]);
                        }

                        if(allTicksLabels[i].value >= 0) {
                            positiveArray.push(allTicksLabels[i]);
                        }
                    }

                    var head;
                    var nal = negativeArray.length;
                    if (negativeArray[0].value <= negativeArray[nal-1].value) {
                        head = negativeArray[0];
                    } else {
                        head = negativeArray[nal-1];
                    }
                    var tail;
                    var pal = positiveArray.length;
                    if (positiveArray[0].value <= positiveArray[pal -1].value) {
                        tail = positiveArray[pal -1];
                    } else {
                        tail = positiveArray[0];
                    }

                    negativeArray = calculateLabelsToDrawHelper(negativeArray);
                    positiveArray = calculateLabelsToDrawHelper(positiveArray);

                    if (negativeArray[0].value > negativeArray[negativeArray.length-1].value) {
                        negativeArray.reverse();
                    }
                    if (positiveArray[0].value > positiveArray[positiveArray.length-1].value) {
                        positiveArray.reverse();
                    }

                    if( negativeArray[negativeArray.length -1].value == 0
                        && positiveArray[0].value == 0)
                    {
                        negativeArray.pop();
                    }

                    var labelsToDrawTemp = negativeArray.concat(positiveArray);
                    if (head.value !== labelsToDrawTemp[0].value) {
                        labelsToDrawTemp.splice(0, 0, head);
                    }
                    if (tail.value !== labelsToDrawTemp[labelsToDrawTemp.length-1].value) {
                        labelsToDrawTemp.push(tail);
                    }
                    if (labelsToDrawTemp[0].start > labelsToDrawTemp[labelsToDrawTemp.length-1].start) {
                        labelsToDrawTemp.reverse();
                    }
                    labelsToDraw = calculateLabelsToDrawHelper(labelsToDrawTemp);
                }
                else
                {
                    labelsToDraw = calculateLabelsToDrawHelper(allTicksLabels);
                }
            }

            //BITVIZA-454 [label management] When the height/width of 
            //vertical/horizontal axis is small that can only hold one axis label, the label 
            //should be hidden.
            if(labelsToDraw.length <= 1)
            {
                labelsToDraw = [];
            }

            return labelsToDraw;
        }

        var calculateLabelsToDrawHelper = function(allTicksLabels)
        {
            //allTicksLabels:
            //[0, X]
            //[-X, 0]
            //[X1, X2] (X1>0, X2>0)
            //[X1, X2] (X1<0, X2<0)

            //now we should decide which label to draw.
            //iBeyond = 0:0,1,2,3,4,5,6,...
            //iBeyond = 1:0, ,2, ,4, ,6,...
            //iBeyond = 2:0, , ,3, , ,6,...
            //...
            //iBeyond = (allTicksLabels.length - 1):0
            var ticksLabelsToDraw = [];

            for(var iBeyond = 0; iBeyond <= (allTicksLabels.length - 1); iBeyond++)
            {
                var isDrawable = true;
                for(var i = 0; i < allTicksLabels.length-1; i+=(iBeyond+1))
                {
                    var item = allTicksLabels[i];
                    if(i != 0)
                    {
                        var previousItem = ticksLabelsToDraw[ticksLabelsToDraw.length-1];
                        if (allTicksLabels[i].start <= previousItem.end)
                        {
                            //for [0.9,1,2,3....], if cannot draw second axis label, just ignore second, then continue
                            if (ticksLabelsToDraw.length > 1) {
                                isDrawable = false;
                                break;
                            }
                        } else {
                            ticksLabelsToDraw.push(item);
                        }
                    } else {
                        //add the first axis tick label
                        ticksLabelsToDraw.push(item);
                    }
                }
                //for [.....5,5.1], always draw the last axis tick label
                var lastItem = allTicksLabels[allTicksLabels.length-1];
                if (lastItem.start < ticksLabelsToDraw[ticksLabelsToDraw.length-1].end) {
                    ticksLabelsToDraw.pop();
                }
                ticksLabelsToDraw.push(lastItem);
                
                if(isDrawable) {//find the labels
                    break;
                } else {
                    ticksLabelsToDraw = [];
                }
            }
            
            return ticksLabelsToDraw;
        }

        var getTicksLabel = function ()
        {
            var axDomain = m_axScale.domain();//[-100, 2000]

            var tickNum = m_axDefaultTickNum;
            if(m_axScale.tickHint)//after perfect
            {
                tickNum = m_axScale.tickHint;
            }

            var axTicksLabels = m_axScale.ticks(tickNum);//[0, 2000, 4000, ...]
            // [21-Sep-2012 Nick ] FIXME Comment out this part to fix bug BITVIZA-383, any particular reason to filter ticks?
            // if it is yes, what kind of criteria should be taken?
//            if(axTicksLabels.length > 20)
//            {
//                //too many ticks. filter some ticks
//                var tempTicks = [];
//                for(var i = 0; i < axTicksLabels.length; i++)
//                {
//                    if(axTicksLabels[i].toString().substr(0,1) == "1"
//                      || axTicksLabels[i].toString().substr(0,1) == "2"
//                      || axTicksLabels[i].toString().substr(0,1) == "5")
//                    {
//                        tempTicks.push(axTicksLabels[i]);
//                    }
//                }
//                axTicksLabels = tempTicks;
//            }

            for(var i=0; i < axTicksLabels.length; i++){
              axTicksLabels[i] = NumberUtils.precise( axTicksLabels[i]);
            }
            var beginLabel;
            var endLabel;
            if(axDomain[0] <= axDomain[axDomain.length -1])
            {
                beginLabel = axDomain[0];
                endLabel = axDomain[axDomain.length -1];
            }
            else
            {
                beginLabel = axDomain[axDomain.length -1];
                endLabel = axDomain[0];
            }

            if(axTicksLabels.length > 0)
            {
                if(axTicksLabels[0] != beginLabel) {
                    //the first label is not the first doamin. Add it.
                    axTicksLabels.unshift(beginLabel);
                }
                
                if(axTicksLabels[axTicksLabels.length -1] != endLabel) {
                    //the last label is not the end. Add it.
                    axTicksLabels.push(endLabel);
                }
            }

            var ticks = [];
            for(var i = 0; i < axTicksLabels.length; i++)
            {
                var tickItem = {};
                tickItem.value = axTicksLabels[i];
                if(m_props.isPercentMode)
                {
                    tickItem.text = NumberUtils.precise(axTicksLabels[i]*100).toString();
                }
                else
                {
                    tickItem.text = NumberUtils.precise(axTicksLabels[i]).toString();
                }
                ticks.push(tickItem);
            }

          //format value label by d3
            if(m_props.label)
            {
                if(!m_props.label.formatString && m_props.label.numberFormat){
                    for(var i = 0; i < axTicksLabels.length; i++)
                    {
                        var formatFun = d3.format(m_props.label.numberFormat);
                        ticks[i].text = (formatFun(axTicksLabels[i]));
                    }
                }else if(m_props.label.formatString){
                    var formatString = m_props.label.formatString;
                    for(var i = 0; i < axTicksLabels.length; i++)
                    {
                        ticks[i].text = (NumberUtils.format(axTicksLabels[i], formatString));
                    }
                }
                
            }
            
            return ticks;
        }

        var maxLabelTextHeight = function (textArray)
        {
            var isVerticalFont = m_props.forceVerticalFont === true ? true: false;
            var maxTextHeight = 0;
            for(var i = 0; i <  textArray.length; i++)
            {
                var tLen =  0 ;
                if( isVerticalFont ){
                  tLen =  fastMeasure(textArray[i], m_style.realStyle.label).width;
                }else{
                  tLen = fastMeasure(textArray[i], m_style.realStyle.label).height;
                }
                if(maxTextHeight < tLen)
                {
                    maxTextHeight = tLen;
                }
            }
            return maxTextHeight;
        }

        var maxLabelTextWidth = function (textArray)
        {
            var isVerticalFont = m_props.forceVerticalFont === true ? true: false;
            var maxTextWidth = 0;
            for(var i = 0; i <  textArray.length; i++)
            {
                var tLen = 0; 
                if( isVerticalFont ){
                  tLen = fastMeasure(textArray[i], m_style.realStyle.label).height;
                } else {
                  tLen = fastMeasure(textArray[i], m_style.realStyle.label).width;
                }
                
                if(maxTextWidth < tLen)
                {
                    maxTextWidth = tLen;
                }
            }
            return maxTextWidth;
        }
        
        var fastMeasure = function(_text, _style)
        {
            return TextUtils.superFastMeasure(_text, _style['font-size'],
                                                _style['font-weight'],
                                                _style['font-family']);
        }        

        var extendObj = function(target, source)
        {
            for(var prop in source)
            {
                if(typeof(source[prop]) === "object")
                {
                    if(target[prop])
                    {
                        target[prop] = extendObj(target[prop], source[prop]);
                    }
                    else
                    {
                        target[prop] = source[prop];
                    }
                }
                else
                {
                    target[prop] = source[prop];
                }
            }
            return target;
        };
        
        return axis;
    };
  return ret;
});

define('sap/viz/modules/axis/categoryAxisCore',['jquery', 'sap/viz/modules/Constants', 'sap/viz/util/TextUtils', 'sap/viz/util/NumberUtils', 'sap/viz/base/utils/Objects', 'sap/viz/lang/langManager',
    'sap/viz/base/utils/TypeUtils', 'sap/viz/modules/threeD/Point', 'sap/viz/modules/threeD/matrix',
    'sap/viz/format/FormatManager', 'sap/viz/base/UADetector'],
  function Setup(jQuery, ModuleConstants, TextUtils, NumberUtils, Objects, langManager, TypeUtils, Point, matrix, FormatManager, UADetector) {

    var ret = function() {

      var m_position;
      var m_axScale;
      var m_selection;

      var m_textOffset;
      var m_tickSize = 5;

      var m_styleLineSrokeWidth = 1;
      var m_styleGridLineColor = "#d8d8d8";
      var m_axLabelClassName = "viz-axis-label";

      var m_labelAreaMouseOverColor = "#cccccc";
      var m_labelAreaMouseDownColor = "#808080";

      var m_disableSpaceLimit = false;

      var m_style = null; //used to hold style passed from axis
      var m_props = {
        "title": {
          "visible": false,
          "text": undefined
        },
        "gridline": {
          "visible": false,
          "color": m_styleGridLineColor,
          "showFirstLine": false,
          "length": 0,
          "showLastLine": false,
          "type": "line"
        },
        "type": "value",
        "visible": true,
        "label": {
          "visible": true,
          "formatString": "",
          hideStrategy: ''
        },
        "position": "left",
        "color": "#333333",
        "forceLabelArea": false,
        "shapeRendering": true,
        "forceVerticalFont": false
      };

      var m_vClassNames = {
        axis: "v-axis",
        axisBody: "v-body",
        axisTitle: "v-title",
        axisLabel: "v-label",
        axisLine: "v-categoryaxisline",
        gridLine: "v-gridline",
        morphableLabel: ModuleConstants.CSS.CLASS.MORPHABLELABEL
      };

      var m_axisLabelClassCombined = m_vClassNames.axisLabel + ' ' + m_axLabelClassName + ' ' + m_vClassNames.morphableLabel;

      var m_matrix = matrix(),
        labelAngle = null,
        labelAlign = null,
        angle = null,
        tickAngle = null;

      var m_spaceLimit = -1;

      var adjustScale = function(spaceLimit) {
        //we have to adjust the scale because we may not draw all the levels.
        var scaleToDraw = [];
        var isMultilayer = m_axScale.length > 1 ? true : false;
        if (isMultilayer) {
          m_textOffset = 6;
        } else {
          m_textOffset = 11;
        }

        for (var iScale = 0; iScale < m_axScale.length; iScale++) {
          var axDomain = m_axScale[iScale].domain; //["a", "b"]
          var axRange = m_axScale[iScale].range; //[[0, 100], [100. 200], ...]

          //count the max text size
          var re = maxLabelTextHeight(axDomain, axRange, true);
          var isVertical = re.isVertical;

          if (m_position === "left" || m_position === "right") {
            m_axScale[iScale].labelsToDraw = buildLeftRightToDrawLabels(axDomain, axRange, isMultilayer, spaceLimit);
          } else {
            m_axScale[iScale].labelsToDraw = buildTopBottomToDrawLabels(axDomain, axRange, isVertical, isMultilayer, spaceLimit);
          }

          if (iScale === 0) {
            scaleToDraw.push(m_axScale[iScale]);
            if (spaceLimit >= 0) {
              break;
            }
          } else if (m_axScale[iScale].labelsToDraw.length === m_axScale[iScale].domain.length) {
            scaleToDraw.push(m_axScale[iScale]);
          }
          //for mekko chart ,the scale is not equal. So if a label can be draw, we should draw the whole layer.
          else if (m_axScale[iScale].labelsToDraw.length > 0 && TypeUtils.isExist(m_axScale.noEqual) && m_axScale.noEqual === true) {
            scaleToDraw.push(m_axScale[iScale]);
          }
        }
        return scaleToDraw;
      };

      var drawGridLine = function(selection, x1, y1, x2, y2) {
        var gridline = selection.append("line")
          .attr("class", m_vClassNames.gridLine)
          .attr("y1", y1)
          .attr("y2", y2)
          .attr("x1", x1)
          .attr("x2", x2)
          .attr("stroke", m_props.gridline.color)
          .attr("stroke-width", m_props.gridline.size)
          .attr("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
        if (m_props.gridline.type === "dotted") {
          gridline.attr("stroke-dasharray", "3, 2");
        }
      };

      function axis(selection) {
        m_selection = selection;
        //we have to adjust the scale
        var scaleToDraw = adjustScale();
        var isTruncated = false;

        var i;
        //---we should dicide show or hide somethings because of the spaceLimit
        if (m_spaceLimit >= 0) {
          var scaleToAdjust = [];
          var preferredSize = axis.getPreferredSize();
          var spacings = preferredSize.spacings;
          var minTruncateSize = preferredSize.minTruncateSize;
          var spaceLeft = m_spaceLimit;


          for (i = 0; i < spacings.length; i++) {
            if (spaceLeft >= spacings[i]) {
              scaleToAdjust.push(scaleToDraw[i]);
              spaceLeft -= spacings[i];
              spaceLeft = NumberUtils.precise(spaceLeft);
            } else {
              if (i === 0 && minTruncateSize > 0 && spaceLeft >= minTruncateSize) {
                isTruncated = true;
              }
              break;
            }
          }

          if (scaleToAdjust.length === 0 && scaleToDraw.length > 0 && !isTruncated) {
            //scaleToAdjust.push(scaleToDraw[0]);//always draw one
            var lastDomain = [];
            for (i = 0; i < scaleToDraw[0].domain.length; i++) {
              lastDomain.push('');
            }
            scaleToAdjust.push({
              domain: lastDomain,
              range: scaleToDraw[0].range
            });
          }

          scaleToDraw = scaleToAdjust;
          if (isTruncated) {
            scaleToDraw = adjustScale(m_spaceLimit);
          }
        }
        //------------------------------------------------------
        var isMultilayer = scaleToDraw.length > 1 ? true : false;
        var lastLevelWidth, lastLevelHeight;
        var iScale, axDomain, axRange;
        var re, maxTextWidth, lineOffset, isVertical, maxTextHeight;
        var x1, x2, y1, y2, dPath;
        var axLine, axTick1, axTick2;
        var labelsToDraw, customlabelCfg, m_label, labelG, axLabels, axTexts;
        if (m_position === "left") {
          lastLevelWidth = 0;

          for (iScale = 0; iScale < scaleToDraw.length; iScale++) {
            if (!m_props.label.visible && iScale !== (scaleToDraw.length - 1)) {
              continue;
            }

            axDomain = scaleToDraw[iScale].domain; //["a", "b"]
            axRange = scaleToDraw[iScale].range; //[[0, 100], [100. 200], ...]

            //count the max text size
            re = maxLabelTextWidth(axDomain, axRange);
            maxTextWidth = isTruncated ? maxLabelTextSize(scaleToDraw[iScale].labelsToDraw, false).maxWidth : re.maxLabelTextWidth;

            lineOffset = maxTextWidth + 2 * m_textOffset;
            if (!m_props.label.visible) {
              maxTextWidth = 0;
              lineOffset = 0;
            }

           lineOffset = isTruncated ? m_spaceLimit : lineOffset;

            if (iScale === (scaleToDraw.length - 1)) {
              if (m_props.gridline.showFirstLine) {
                drawGridLine(selection,
                  lastLevelWidth + lineOffset,
                  axRange[axRange.length - 1][1],
                  lastLevelWidth + lineOffset + m_props.gridline.length,
                  axRange[axRange.length - 1][1]);
              }

              if (m_props.gridline.showLastLine) {
                drawGridLine(selection,
                  lastLevelWidth + lineOffset,
                  axRange[0][0],
                  lastLevelWidth + lineOffset + m_props.gridline.length,
                  axRange[0][0]);
              }
            }

            ///////////////drawing the most inner vertical line////////////////
            if (scaleToDraw.length === 1) {
              ////////////////in single case, also include the first and last tick////////
              //<path d="M150 0 L75 200 L225 200 Z" />
              x1 = lastLevelWidth + lineOffset;
              x2 = lastLevelWidth + lineOffset;
              y1 = axRange[0][0];
              y2 = axRange[axRange.length - 1][1];
              if (m_props.axisline.visible) {
                dPath = "M" + (x1 - m_tickSize) + " " + y1;
                dPath += "L" + x1 + " " + y1;
                dPath += "L" + x2 + " " + y2;
                dPath += "L" + (x2 - m_tickSize) + " " + y2;

                axLine = selection.append("path");
                axLine.each(function() {
                  this.setAttribute("class", m_vClassNames.axisLine);
                  this.setAttribute("d", dPath);
                  this.setAttribute("fill", "none");
                  this.setAttribute("stroke", m_props.color);
                  this.setAttribute("stroke-width", m_props.lineSize);
                  this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");

                });
              }

            } else if (scaleToDraw.length >= 2 && (iScale === scaleToDraw.length - 1)) {
              axLine = selection.append("line");
              axLine.each(function() {
                this.setAttribute("x1", lastLevelWidth + lineOffset);
                this.setAttribute("x2", lastLevelWidth + lineOffset);
                this.setAttribute("y1", axRange[0][0]);
                this.setAttribute("y2", axRange[axRange.length - 1][1]);
                this.setAttribute("class", m_vClassNames.axisLine + " " + "domain");
                this.setAttribute("stroke", m_props.color);
                this.setAttribute("stroke-width", m_props.lineSize);
                this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
              });

            }
            /////////////// end of drawing the most inner vertical line////////////////


            ///////////////drawing vertical line for each level, based on lastLevelWidth///// 
            if (scaleToDraw.length >= 2 && m_props.label.visible) {
              axLine = selection.append("line");
              axLine.each(function() {
                this.setAttribute("x1", lastLevelWidth);
                this.setAttribute("x2", lastLevelWidth);
                this.setAttribute("y1", axRange[0][0]);
                this.setAttribute("y2", axRange[axRange.length - 1][1]);
                this.setAttribute("class", m_vClassNames.axisLine + " " + "domain");
                this.setAttribute("stroke", m_props.color);
                this.setAttribute("stroke-width", m_props.lineSize);
                this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
              });


            }
            ///////////////end of drawing vertical line for each level, based on lastLevelWidth/////

            //draw gridline in the last scaleToDraw///////////////////////
            //FIXME Jimmy/9/22/2012 currently the grid line only used for
            //multi charts. we have a bug for the last gridline here, if for example
            //we draw gridline for yaxis on [i][1], then the last gridline
            //will override xaxis. so we have to seperate last gridline
            if (m_props.gridline.visible && iScale === (scaleToDraw.length - 1)) {
              for (i = 0; i < axDomain.length; i++) {
                drawGridLine(selection,
                  lastLevelWidth + lineOffset,
                  axRange[i][0],
                  lastLevelWidth + lineOffset + m_props.gridline.length,
                  axRange[i][0]);
                if ((i === (axDomain.length - 1)) || (axRange[i][1] !== axRange[i + 1][0])) {
                  drawGridLine(selection,
                    lastLevelWidth + lineOffset,
                    axRange[i][1],
                    lastLevelWidth + lineOffset + m_props.gridline.length,
                    axRange[i][1]);
                }
              }
              //we need an extra line to close the gridline area, otherwise, if we have only one axis, the gridline area will be kept open
              drawGridLine(selection,
                lastLevelWidth + lineOffset + m_props.gridline.length,
                axRange[0][0],
                lastLevelWidth + lineOffset + m_props.gridline.length,
                axRange[i - 1][1]
              );
            }
            //end draw gridline in the last scaleToDraw///////////////////////


            for (i = 0; i < axDomain.length; i++) {
              /////////////////////////////draw tick for single case, horizontal line for multi case////////
              if ((scaleToDraw.length === 1 || (scaleToDraw.length !== 1 && !m_props.label.visible)) && m_props.axisTick.visible) //draw ticks
              {

                //Jimmy/9/22/2012 to @Catkin, in which scenario axRange[i][0] will not be equal with axRange[i-1][1]?
                if (i > 0 && (axRange[i][0] !== axRange[i - 1][1])) {
                  axTick1 = selection.append("line");
                  axTick1.each(function() {
                    this.setAttribute("class", m_vClassNames.axisLine);
                    this.setAttribute("x1", lineOffset - m_tickSize);
                    this.setAttribute("x2", lineOffset);
                    this.setAttribute("y1", axRange[i][0]);
                    this.setAttribute("y2", axRange[i][0]);
                    this.setAttribute("stroke", m_props.color);
                    this.setAttribute("stroke-width", m_props.lineSize);
                    this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                  });

                }

                ////////////////in single case, first and last tick is already drawn in path, ignore them here////////
                if (i !== (axDomain.length - 1)) {
                  axTick2 = selection.append("line");
                  axTick2.each(function() {
                    this.setAttribute("class", m_vClassNames.axisLine);
                    this.setAttribute("x1", lineOffset - m_tickSize);
                    this.setAttribute("x2", lineOffset);
                    this.setAttribute("y1", axRange[i][1]);
                    this.setAttribute("y2", axRange[i][1]);
                    this.setAttribute("stroke", m_props.color);
                    this.setAttribute("stroke-width", m_props.lineSize);
                    this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                  });
                }
              }

              if (scaleToDraw.length >= 2 && m_props.label.visible) {
                axLine = selection.append("line");
                axLine.each(function() {
                  this.setAttribute("class", m_vClassNames.axisLine);
                  this.setAttribute("x1", lastLevelWidth);
                  this.setAttribute("x2", lastLevelWidth + lineOffset);
                  this.setAttribute("y1", axRange[i][0]);
                  this.setAttribute("y2", axRange[i][0]);
                  this.setAttribute("stroke", m_props.color);
                  this.setAttribute("stroke-width", m_props.lineSize);
                  this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                });

                //Jimmy/9/22/2012 to @Catkin, in which scenario axRange[i][1] will not be equal with axRange[i+1][0]?
                if ((i === (axDomain.length - 1)) || (axRange[i][1] !== axRange[i + 1][0])) {
                  axLine = selection.append("line");
                  axLine.each(function() {
                    this.setAttribute("class", m_vClassNames.axisLine);
                    this.setAttribute("x1", lastLevelWidth);
                    this.setAttribute("x2", lastLevelWidth + lineOffset);
                    this.setAttribute("y1", axRange[i][1]);
                    this.setAttribute("y2", axRange[i][1]);
                    this.setAttribute("stroke", m_props.color);
                    this.setAttribute("stroke-width", m_props.lineSize);
                    this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                  });
                }
              }
              /////////////////////////////draw tick for single case, horizontal line for multi case////////
            }

            labelsToDraw = scaleToDraw[iScale].labelsToDraw;
            for (i = 0; i < labelsToDraw.length; i++) {
              customlabelCfg = labelsToDraw[i].custom;
              if (!(customlabelCfg && customlabelCfg.type === 'url')) {
                m_label = TypeUtils.isExist(labelsToDraw[i].text) ? labelsToDraw[i].text : '';
                if (m_props.label.visible) {
                  labelG = selection;

                  var offsetForBorder = 1;
                  var labelRectX = lastLevelWidth + offsetForBorder;

                  if(m_props.enableLabelSelection){
                      var isTextSize = m_props.forceLabelArea || labelsToDraw[i].height > labelsToDraw[i].rectHeight;
                      var rect = labelG.append("rect");
                      if (isTextSize) {
                        rect.each(function() {
                          this.setAttribute("x", lastLevelWidth + maxTextWidth - labelsToDraw[i].width + m_textOffset - offsetForBorder);
                          this.setAttribute("y", labelsToDraw[i].y - labelsToDraw[i].height / 2 - offsetForBorder);
                          this.setAttribute("width", labelsToDraw[i].width + 2 * offsetForBorder);
                          this.setAttribute("height", labelsToDraw[i].height + 2 * offsetForBorder);
                          this.setAttribute("opacity", 0);
                          this.setAttribute("class", "v-labelarea");
                        });
                      } else {
                        rect.each(function() {
                          this.setAttribute("x", labelRectX);
                          this.setAttribute("y", labelsToDraw[i].startY + offsetForBorder);
                          this.setAttribute("width", lineOffset - offsetForBorder);
                          this.setAttribute("height", (labelsToDraw[i].rectHeight - offsetForBorder) < 0 ? 0 : (labelsToDraw[i].rectHeight - offsetForBorder));
                          this.setAttribute("opacity", 0);
                          this.setAttribute("class", "v-labelarea");
                        });
                      }
                      rect.node().labelContexts = labelsToDraw[i].labelContexts;
                  }
                  
                  axLabels = labelG.append("g");
                  axLabels.each(function() {
                    this.setAttribute("fill", m_style.defaultStyle.label.fill);
                    this.setAttribute("class", m_axisLabelClassCombined);
                    this.setAttribute("font-size", m_style.defaultStyle.label['font-size']);
                    this.setAttribute("font-weight", m_style.defaultStyle.label['font-weight']);
                    this.setAttribute("font-family", m_style.defaultStyle.label['font-family']);
                  });
                  axTexts = axLabels.append("text").text(m_label);
                  axTexts.each(function() {
                    this.setAttribute("pointer-events", "none");
                    this.setAttribute("x", lastLevelWidth + maxTextWidth + m_textOffset);
                    this.setAttribute("y", labelsToDraw[i].y);
                    this.setAttribute("dominant-baseline", "middle"); //"auto")//"hanging")//"central")
                    this.setAttribute("text-anchor", "end"); // text-align
                  });

                  adjustLabelForIE(axTexts);
                }
              }
              //else{ //draw as an icon, same size as text }
            }

            lastLevelWidth += (maxTextWidth + 2 * m_textOffset);
          }
        } else if (m_position === "right") {
          lastLevelWidth = 0;

          for (iScale = (scaleToDraw.length - 1); iScale >= 0; iScale--) {
            if (!m_props.label.visible && iScale !== (scaleToDraw.length - 1)) {
              continue;
            }

            axDomain = scaleToDraw[iScale].domain; //["a", "b"]
            axRange = scaleToDraw[iScale].range; //[[0, 100], [100. 200], ...]

            //count the max text size
            re = maxLabelTextWidth(axDomain, axRange);
            maxTextWidth = isTruncated ? maxLabelTextSize(scaleToDraw[iScale].labelsToDraw, false).maxWidth : re.maxLabelTextWidth;

            lineOffset = maxTextWidth + 2 * m_textOffset;
            if (!m_props.label.visible) {
              maxTextWidth = 0;
              lineOffset = 0;
            }

            lineOffset = isTruncated ? m_spaceLimit : lineOffset;

            if (iScale === (scaleToDraw.length - 1)) {
              if (m_props.gridline.showFirstLine) {
                drawGridLine(selection,
                  lastLevelWidth,
                  axRange[axRange.length - 1][1],
                  lastLevelWidth - m_props.gridline.length,
                  axRange[axRange.length - 1][1]);
              }

              if (m_props.gridline.showLastLine) {
                drawGridLine(selection,
                  lastLevelWidth,
                  axRange[0][0],
                  lastLevelWidth - m_props.gridline.length,
                  axRange[0][0]);
              }
            }

            if ((scaleToDraw.length === 1)) {
              //<path d="M150 0 L75 200 L225 200 Z" />
              x1 = lastLevelWidth;
              x2 = lastLevelWidth;
              y1 = axRange[0][0];
              y2 = axRange[axRange.length - 1][1];

              dPath = "M" + (x1 + m_tickSize) + " " + y1;
              dPath += "L" + x1 + " " + y1;
              dPath += "L" + x2 + " " + y2;
              dPath += "L" + (x1 + m_tickSize) + " " + y2;

              axLine = selection.append("path");
              axLine.each(function() {
                this.setAttribute("class", m_vClassNames.axisLine);
                this.setAttribute("d", dPath);
                this.setAttribute("fill", "none");
                this.setAttribute("stroke", m_props.color);
                this.setAttribute("stroke-width", m_props.lineSize);
                this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
              });

            } else if (scaleToDraw.length >= 2 && (iScale === (scaleToDraw.length - 1))) {
              axLine = selection.append("line");
              axLine.each(function() {
                this.setAttribute("class", m_vClassNames.axisLine);
                this.setAttribute("x1", lastLevelWidth);
                this.setAttribute("x2", lastLevelWidth);
                this.setAttribute("y1", axRange[0][0]);
                this.setAttribute("y2", axRange[axRange.length - 1][1]);
                this.setAttribute("stroke", m_props.color);
                this.setAttribute("stroke-width", m_props.lineSize);
                this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
              });

            }

            if (scaleToDraw.length >= 2 && m_props.label.visible) {
              axLine = selection.append("line");
              axLine.each(function() {
                this.setAttribute("class", m_vClassNames.axisLine);
                this.setAttribute("x1", lastLevelWidth + lineOffset);
                this.setAttribute("x2", lastLevelWidth + lineOffset);
                this.setAttribute("y1", axRange[0][0]);
                this.setAttribute("y2", axRange[axRange.length - 1][1]);
                this.setAttribute("stroke", m_props.color);
                this.setAttribute("stroke-width", m_props.lineSize);
                this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
              });

            }

            if (m_props.gridline.visible && iScale === (scaleToDraw.length - 1)) {
              for (i = 0; i < axDomain.length; i++) {
                drawGridLine(selection,
                  lastLevelWidth + lineOffset,
                  axRange[i][0],
                  lastLevelWidth + lineOffset + m_props.gridline.length,
                  axRange[i][0]);
                if ((i === (axDomain.length - 1)) || (axRange[i][1] !== axRange[i + 1][0])) {
                  drawGridLine(selection,
                    lastLevelWidth + lineOffset,
                    axRange[i][1],
                    lastLevelWidth + lineOffset + m_props.gridline.length,
                    axRange[i][1]);
                }
              }

            }

            for (i = 0; i < axDomain.length; i++) {
              if ((scaleToDraw.length === 1 || (scaleToDraw.length !== 1 && !m_props.label.visible)) && m_props.axisTick.visible) //draw ticks
              {
                if (i > 0 && (axRange[i][0] !== axRange[i - 1][1])) {
                  axTick1 = selection.append("line");
                  axTick1.each(function() {
                    this.setAttribute("class", m_vClassNames.axisLine);
                    this.setAttribute("x1", 0);
                    this.setAttribute("x2", m_tickSize);
                    this.setAttribute("y1", axRange[i][0]);
                    this.setAttribute("y2", axRange[i][0]);
                    this.setAttribute("stroke", m_props.color);
                    this.setAttribute("stroke-width", m_props.lineSize);
                    this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                  });
                }
                if (i !== (axDomain.length - 1)) {
                  axTick2 = selection.append("line");
                  axTick2.each(function() {
                    this.setAttribute("class", m_vClassNames.axisLine);
                    this.setAttribute("x1", 0);
                    this.setAttribute("x2", m_tickSize);
                    this.setAttribute("y1", axRange[i][1]);
                    this.setAttribute("y2", axRange[i][1]);
                    this.setAttribute("stroke", m_props.color);
                    this.setAttribute("stroke-width", m_props.lineSize);
                    this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                  });
                }
              }

              if (scaleToDraw.length >= 2 && m_props.label.visible) {
                axLine = selection.append("line");
                axLine.each(function() {
                  this.setAttribute("class", m_vClassNames.axisLine);
                  this.setAttribute("x1", lastLevelWidth);
                  this.setAttribute("x2", lastLevelWidth + lineOffset);
                  this.setAttribute("y1", axRange[i][0]);
                  this.setAttribute("y2", axRange[i][0]);
                  this.setAttribute("stroke", m_props.color);
                  this.setAttribute("stroke-width", 1);
                  this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                });

                if ((i === (axDomain.length - 1)) || (axRange[i][1] !== axRange[i + 1][0])) {
                  axLine = selection.append("line");
                  axLine.each(function() {
                    this.setAttribute("class", m_vClassNames.axisLine);
                    this.setAttribute("x1", lastLevelWidth);
                    this.setAttribute("x2", lastLevelWidth + lineOffset);
                    this.setAttribute("y1", axRange[i][1]);
                    this.setAttribute("y2", axRange[i][1]);
                    this.setAttribute("stroke", m_props.color);
                    this.setAttribute("stroke-width", m_props.lineSize);
                    this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                  });
                }
              }
            }

            labelsToDraw = scaleToDraw[iScale].labelsToDraw;
            for (i = 0; i < labelsToDraw.length; i++) {
              customlabelCfg = labelsToDraw[i].custom;
              if (!(customlabelCfg && customlabelCfg.type === 'url')) {
                m_label = TypeUtils.isExist(labelsToDraw[i].text) ? labelsToDraw[i].text : '';
                if (m_props.label.visible) {
                  labelG = selection;

                  axLabels = labelG.append("g");
                  axLabels.each(function() {
                    this.setAttribute("fill", m_style.defaultStyle.label.fill);
                    this.setAttribute("class", m_axisLabelClassCombined);
                    this.setAttribute("font-size", m_style.defaultStyle.label['font-size']);
                    this.setAttribute("font-weight", m_style.defaultStyle.label['font-weight']);
                    this.setAttribute("font-family", m_style.defaultStyle.label['font-family']);
                  });
                  axTexts = axLabels.append("text").text(m_label);
                  axTexts.each(function() {
                    this.setAttribute("x", lastLevelWidth + m_textOffset);
                    this.setAttribute("y", labelsToDraw[i].y);
                    this.setAttribute("text-anchor", "start"); // text-align
                    this.setAttribute("dominant-baseline", "middle"); //"auto")//"hanging")//"central")
                  });


                  adjustLabelForIE(axTexts);
                }
              }
              // else {//draw as an icon, same size as text}
            }

            lastLevelWidth += (maxTextWidth + 2 * m_textOffset);
          }
        } else if (m_position === "bottom") {
          lastLevelHeight = 0;

          for (iScale = (scaleToDraw.length - 1); iScale >= 0; iScale--) {
            if (!m_props.label.visible && iScale !== (scaleToDraw.length - 1)) {
              continue;
            }

            axDomain = scaleToDraw[iScale].domain; //["a", "b"]
            axRange = scaleToDraw[iScale].range; //[[0, 100], [100. 200], ...]

            //count the max text size
            re = maxLabelTextHeight(axDomain, axRange);
            isVertical = re.isVertical;
            maxTextHeight = isTruncated ? maxLabelTextSize(scaleToDraw[iScale].labelsToDraw, isVertical).maxHeight : re.maxLabelTextHeight;

            lineOffset = maxTextHeight + 2 * m_textOffset;
            if (!m_props.label.visible) {
              maxTextHeight = 0;
              lineOffset = 0;
            }

            lineOffset = isTruncated ? m_spaceLimit : lineOffset;

            if (iScale === (scaleToDraw.length - 1)) {
              if (m_props.gridline.showFirstLine) {
                drawGridLine(selection,
                  axRange[0][0],
                  lastLevelHeight,
                  axRange[0][0],
                  lastLevelHeight - m_props.gridline.length);
              }

              if (m_props.gridline.showLastLine) {
                drawGridLine(selection,
                  axRange[axRange.length - 1][0],
                  lastLevelHeight,
                  axRange[axRange.length - 1][0],
                  lastLevelHeight - m_props.gridline.length);
              }
            }

            var aAngle, cosAngle, sinAngle;
            if (scaleToDraw.length === 1) {
              x1 = axRange[0][0];
              x2 = axRange[axRange.length - 1][1];
              y1 = lastLevelHeight;
              y2 = lastLevelHeight;

              dPath = "M" + x1 + " " + (y1 + m_tickSize);
              dPath += "L" + x1 + " " + y1;
              dPath += "L" + x2 + " " + y2;
              dPath += "L" + x2 + " " + (y2 + m_tickSize);
              if (m_props.axisline.visible) {
                axLine = selection.append("path");
                if (angle) {
                  aAngle = angle * Math.PI / 180;
                  cosAngle = Math.cos(aAngle);
                  sinAngle = (45 === angle) ? cosAngle : Math.sin(aAngle);
                  dPath = 'M ' + axRange[0][0] + ' ' + lastLevelHeight;
                  dPath += 'L' + (axRange[0][0] + axRange[axRange.length - 1][1] * sinAngle) + ' ' + (lastLevelHeight - axRange[axRange.length - 1][1] * cosAngle);
                  dPath += 'Z';
                }
                axLine.each(function() {
                  this.setAttribute("class", m_vClassNames.axisLine);
                  this.setAttribute("d", dPath);
                  this.setAttribute("fill", "none");
                  this.setAttribute("stroke", m_props.color);
                  this.setAttribute("stroke-width", m_props.lineSize);
                  this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                });

              }
            } else if (scaleToDraw.length >= 2 && (iScale === scaleToDraw.length - 1)) {
              axLine = selection.append("line");
              axLine.each(function() {
                this.setAttribute("class", m_vClassNames.axisLine);
                this.setAttribute("x1", axRange[0][0]);
                this.setAttribute("x2", axRange[axRange.length - 1][1]);
                this.setAttribute("y1", lastLevelHeight);
                this.setAttribute("y2", lastLevelHeight);
                this.setAttribute("stroke", m_props.color);
                this.setAttribute("stroke-width", m_props.lineSize);
                this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
              });
            }

            if (scaleToDraw.length >= 2 && m_props.label.visible) {
              axLine = selection.append("line");
              axLine.each(function() {
                this.setAttribute("class", m_vClassNames.axisLine);
                this.setAttribute("x1", axRange[0][0]);
                this.setAttribute("x2", axRange[axRange.length - 1][1]);
                this.setAttribute("y1", lastLevelHeight + lineOffset);
                this.setAttribute("y2", lastLevelHeight + lineOffset);
                this.setAttribute("stroke", m_props.color);
                this.setAttribute("stroke-width", m_props.lineSize);
                this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
              });
            }

            //draw gridline in the last scaleToDraw///////////////////////
            if (m_props.gridline.visible && iScale === (scaleToDraw.length - 1)) {
              for (i = 0; i < axDomain.length; i++) {
                drawGridLine(selection,
                  axRange[i][0],
                  lastLevelHeight + lineOffset,
                  axRange[i][0],
                  lastLevelHeight + lineOffset + m_props.gridline.length
                );
                if ((i === (axDomain.length - 1)) || (axRange[i][1] !== axRange[i + 1][0])) {
                  drawGridLine(selection,
                    axRange[i][1],
                    lastLevelHeight + lineOffset,
                    axRange[i][1],
                    lastLevelHeight + lineOffset + m_props.gridline.length
                  );
                }
              }
            }
            //end draw gridline in the last scaleToDraw///////////////////////


            for (i = 0; i < axDomain.length; i++) {
              if ((scaleToDraw.length === 1 || (scaleToDraw.length !== 1 && !m_props.label.visible)) && m_props.axisTick.visible) //draw ticks
              {
                if (i > 0 && (axRange[i][0] !== axRange[i - 1][1])) {
                  axTick1 = selection.append("line");
                  axTick1.each(function() {
                    this.setAttribute("class", m_vClassNames.axisLine);
                    this.setAttribute("x1", axRange[i][0]);
                    this.setAttribute("x2", axRange[i][0]);
                    this.setAttribute("y1", 0);
                    this.setAttribute("y2", m_tickSize);
                    this.setAttribute("stroke", m_props.color);
                    this.setAttribute("stroke-width", m_props.lineSize);
                    this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                  });
                }
                if (i !== (axDomain.length - 1)) {
                  axTick2 = selection.append("line");
                  axTick2.each(function() {
                    this.setAttribute("class", m_vClassNames.axisLine);
                    this.setAttribute("x1", axRange[i][1]);
                    this.setAttribute("x2", axRange[i][1]);
                    this.setAttribute("y1", 0);
                    this.setAttribute("y2", m_tickSize);
                    this.setAttribute("stroke", m_props.color);
                    this.setAttribute("stroke-width", m_props.lineSize);
                    this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                  });

                  if (angle) {
                    aAngle = angle * Math.PI / 180;
                    cosAngle = Math.cos(aAngle);
                    sinAngle = (45 === angle) ? cosAngle : Math.sin(aAngle);
                    var tAngle = tickAngle * Math.PI / 180;
                    var cosTAngle = Math.cos(tAngle);
                    var sinTAngle = Math.sin(tAngle);

                    var tickStartX = axRange[i][1] * sinAngle;
                    var tickStartY = -axRange[i][1] * cosAngle;
                    x2 = tickStartX + m_tickSize * cosTAngle;
                    y2 = tickStartY + m_tickSize * sinTAngle;

                    axTick2.attr('x1', tickStartX).attr('y1', tickStartY).attr('x2', x2).attr('y2', y2);
                  }

                }
              }

              if (scaleToDraw.length >= 2 && m_props.label.visible) {
                axLine = selection.append("line");
                axLine.each(function() {
                  this.setAttribute("class", m_vClassNames.axisLine);
                  this.setAttribute("x1", axRange[i][0]);
                  this.setAttribute("x2", axRange[i][0]);
                  this.setAttribute("y1", lastLevelHeight);
                  this.setAttribute("y2", lastLevelHeight + lineOffset);
                  this.setAttribute("stroke", m_props.color);
                  this.setAttribute("stroke-width", m_props.lineSize);
                  this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                });

                if ((i === (axDomain.length - 1)) || (axRange[i][1] !== axRange[i + 1][0])) {
                  axLine = selection.append("line");
                  axLine.each(function() {
                    this.setAttribute("class", m_vClassNames.axisLine);
                    this.setAttribute("x1", axRange[i][1]);
                    this.setAttribute("x2", axRange[i][1]);
                    this.setAttribute("y1", lastLevelHeight);
                    this.setAttribute("y2", lastLevelHeight + lineOffset);
                    this.setAttribute("stroke", m_props.color);
                    this.setAttribute("stroke-width", m_props.lineSize);
                    this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                  });
                }
              }
            }

            labelsToDraw = scaleToDraw[iScale].labelsToDraw;
            drawTopBottomLabels(selection, labelsToDraw, lastLevelHeight, maxTextHeight, axDomain, isVertical, scaleToDraw.length !== 1);

            lastLevelHeight += (maxTextHeight + 2 * m_textOffset);
          }
        } else if (m_position === "top") {
          lastLevelHeight = 0;

          for (iScale = 0; iScale < scaleToDraw.length; iScale++) {
            if (!m_props.label.visible && iScale !== (scaleToDraw.length - 1)) {
              continue;
            }

            axDomain = scaleToDraw[iScale].domain; //["a", "b"]
            axRange = scaleToDraw[iScale].range; //[[0, 100], [100. 200], ...]

            //count the max text size
            re = maxLabelTextHeight(axDomain, axRange);
            isVertical = re.isVertical;
            maxTextHeight = isTruncated ? maxLabelTextSize(scaleToDraw[iScale].labelsToDraw, isVertical).maxHeight : re.maxLabelTextHeight;

            lineOffset = maxTextHeight + 2 * m_textOffset;
            if (!m_props.label.visible) {
              maxTextHeight = 0;
              lineOffset = 0;
            }

            lineOffset = isTruncated ? m_spaceLimit : lineOffset;

            if (iScale === (scaleToDraw.length - 1)) {
              if (m_props.gridline.showFirstLine) {
                drawGridLine(selection,
                  axRange[0][0],
                  lineOffset + lastLevelHeight,
                  axRange[0][0],
                  lineOffset + lastLevelHeight + m_props.gridline.length
                );
              }

              if (m_props.gridline.showLastLine) {
                drawGridLine(selection,
                  axRange[axRange.length - 1][1],
                  lineOffset + lastLevelHeight,
                  axRange[axRange.length - 1][1],
                  lineOffset + lastLevelHeight + m_props.gridline.length
                );
              }
            }

            if ((scaleToDraw.length === 1)) {
              x1 = axRange[0][0];
              x2 = axRange[axRange.length - 1][1];
              y1 = lineOffset + lastLevelHeight;
              y2 = lineOffset + lastLevelHeight;

              dPath = "M" + x1 + " " + (y1 - m_tickSize);
              dPath += "L" + x1 + " " + y1;
              dPath += "L" + x2 + " " + y2;
              dPath += "L" + x2 + " " + (y2 - m_tickSize);

              axLine = selection.append("path");
              axLine.each(function() {
                this.setAttribute("class", m_vClassNames.axisLine);
                this.setAttribute("d", dPath);
                this.setAttribute("fill", "none");
                this.setAttribute("stroke", m_props.color);
                this.setAttribute("stroke-width", m_props.lineSize);
                this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
              });
            } else if (scaleToDraw.length >= 2 && (iScale === scaleToDraw.length - 1)) {
              axLine = selection.append("line");
              axLine.each(function() {
                this.setAttribute("class", m_vClassNames.axisLine);
                this.setAttribute("x1", axRange[0][0]);
                this.setAttribute("x2", axRange[axRange.length - 1][1]);
                this.setAttribute("y1", lineOffset + lastLevelHeight);
                this.setAttribute("y2", lineOffset + lastLevelHeight);
                this.setAttribute("stroke", m_props.color);
                this.setAttribute("stroke-width", m_props.lineSize);
                this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
              });
            }

            if (scaleToDraw.length >= 2 && m_props.label.visible) {
              axLine = selection.append("line");
              axLine.each(function() {
                this.setAttribute("class", m_vClassNames.axisLine);
                this.setAttribute("x1", axRange[0][0]);
                this.setAttribute("x2", axRange[axRange.length - 1][1]);
                this.setAttribute("y1", lastLevelHeight);
                this.setAttribute("y2", lastLevelHeight);
                this.setAttribute("stroke", m_props.color);
                this.setAttribute("stroke-width", m_props.lineSize);
                this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
              });

            }

            //draw gridline in the last scaleToDraw///////////////////////
            if (m_props.gridline.visible && iScale === (scaleToDraw.length - 1)) {
              for (i = 0; i < axDomain.length; i++) {
                drawGridLine(selection,
                  axRange[i][0],
                  lastLevelHeight + lineOffset,
                  axRange[i][0],
                  lastLevelHeight + lineOffset + m_props.gridline.length
                );
                if ((i === (axDomain.length - 1)) || (axRange[i][1] !== axRange[i + 1][0])) {
                  drawGridLine(selection,
                    axRange[i][1],
                    lastLevelHeight + lineOffset,
                    axRange[i][1],
                    lastLevelHeight + lineOffset + m_props.gridline.length
                  );
                }
              }
              //we need an extra line to close the gridline area, otherwise, if we have only one axis, the gridline area will be kept open
              drawGridLine(selection,
                axRange[0][0],
                lastLevelHeight + lineOffset + m_props.gridline.length,
                axRange[i - 1][1],
                lastLevelHeight + lineOffset + m_props.gridline.length
              );
            }
            //end draw gridline in the last scaleToDraw///////////////////////

            for (i = 0; i < axDomain.length; i++) {
              if ((scaleToDraw.length === 1 || (scaleToDraw.length !== 1 && !m_props.label.visible)) && m_props.axisTick.visible) //draw ticks
              {
                if (i > 0 && (axRange[i][0] !== axRange[i - 1][1])) {
                  axTick1 = selection.append("line");
                  axTick1.each(function() {
                    this.setAttribute("class", m_vClassNames.axisLine);
                    this.setAttribute("x1", axRange[i][0]);
                    this.setAttribute("x2", axRange[i][0]);
                    this.setAttribute("y1", lineOffset);
                    this.setAttribute("y2", lineOffset - m_tickSize);
                    this.setAttribute("stroke", m_props.color);
                    this.setAttribute("stroke-width", m_props.lineSize);
                    this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                  });

                }

                ////////////////in single case, first and last tick is already drawn in path, ignore them here////////
                if (i !== (axDomain.length - 1)) {
                  axTick2 = selection.append("line");
                  axTick2.each(function() {
                    this.setAttribute("class", m_vClassNames.axisLine);
                    this.setAttribute("x1", axRange[i][1]);
                    this.setAttribute("x2", axRange[i][1]);
                    this.setAttribute("y1", lineOffset);
                    this.setAttribute("y2", lineOffset - m_tickSize);
                    this.setAttribute("stroke", m_props.color);
                    this.setAttribute("stroke-width", m_props.lineSize);
                    this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                  });
                }
              }

              if (scaleToDraw.length >= 2 && m_props.label.visible) {
                axLine = selection.append("line");
                axLine.each(function() {
                  this.setAttribute("class", m_vClassNames.axisLine);
                  this.setAttribute("x1", axRange[i][0]);
                  this.setAttribute("x2", axRange[i][0]);
                  this.setAttribute("y1", lastLevelHeight);
                  this.setAttribute("y2", lastLevelHeight + lineOffset);
                  this.setAttribute("stroke", m_props.color);
                  this.setAttribute("stroke-width", m_props.lineSize);
                  this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                });

                //Jimmy/9/22/2012 to @Catkin, in which scenario axRange[i][1] will not be equal with axRange[i+1][0]?
                if ((i === (axDomain.length - 1)) || (axRange[i][1] !== axRange[i + 1][0])) {
                  axLine = selection.append("line");
                  axLine.each(function() {
                    this.setAttribute("class", m_vClassNames.axisLine);
                    this.setAttribute("x1", axRange[i][1]);
                    this.setAttribute("x2", axRange[i][1]);
                    this.setAttribute("y1", lastLevelHeight);
                    this.setAttribute("y2", lastLevelHeight + lineOffset);
                    this.setAttribute("stroke", m_props.color);
                    this.setAttribute("stroke-width", m_props.lineSize);
                    this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                  });
                }
              }
            }

            labelsToDraw = scaleToDraw[iScale].labelsToDraw;
            drawTopBottomLabels(selection, labelsToDraw, lastLevelHeight, maxTextHeight, axDomain, isVertical, scaleToDraw.length !== 1);
            lastLevelHeight += (maxTextHeight + 2 * m_textOffset);
          }
        }
      }
      
      axis.spaceLimit = function(_spaceLimit) {
        if (!arguments.length){
          return m_spaceLimit;
        }

        if (!m_disableSpaceLimit) {
          m_spaceLimit = _spaceLimit;
        }

        return axis;
      };

      var adjustLabelForIE = function(text) {
        if (UADetector.isIE()) {
          //dominant-baseline does not work
          var textHeight = m_style.realStyle.label['font-size'].toString();
          var indexPX = textHeight.indexOf("px");
          if (indexPX >= 0) {
            textHeight = textHeight.substr(0, indexPX);
          }

          //textHeight = fastMeasure(text, m_style.realStyle.label).height;
          var y = text.attr("y");
          text.attr("y", Number(y) + textHeight / 2);
          text.attr("dominant-baseline", "auto");
        }
      };

      //get customlabel text from from the rawObj, if the type is url, return the original text
      var getCustomlabelText = function(rawObj) {
        var ret;
        if (rawObj.info) {
          var clobj = rawObj.info.customlabel;
          if (clobj) {
            if (clobj.type === 'url') {
              ret = rawObj.val;
            } else if (clobj.type === 'string') {
              ret = clobj.val;
            }
          } else {
            ret = rawObj.val;
          }
        } else {
          ret = rawObj.val;
        }
        if (ret === '') {
          ret = ' ';
        }
        //so we will first resolve customlabel and then do format
        ret = isInvalidString(ret) ? langManager.get('IDS_ISNOVALUE') : ret;
        ret = FormatManager.format(ret, m_props.label.formatString);
        return ret;
      };

      var getCustomlabelCfg = function(rawObj) {
        if (rawObj.info && rawObj.info.customlabel) {
          return rawObj.info.customlabel;
        }
      };

      var getTruncatedText = function(text, limit) {
        var style = 'font-weight: ' + m_style.realStyle.label['font-weight'] + '; font-family: ' + m_style.realStyle.label['font-family'] + '; font-size: ' + m_style.realStyle.label['font-size'] + ';';
        return TextUtils.ellipsis(text, undefined, limit, style);
      };

      var buildLeftRightToDrawLabels = function(allLabels, allLabelsLocation, isMultilayer, spaceLimit) {
        //Jimmy/12/26/2012 extend allLabels from stringArray to objectArray to support customlabel
        //we always draw the bottom label for yAxis.

        //build the "todraw" array
        //count all the labels y1 and y2, and save them.
        var fullHeight = 0;
        var allTicksLabels = [];
        var i, item;
        for (i = 0; i < allLabels.length; i++) {
          item = {};
          item.text = getCustomlabelText(allLabels[i]);
          item.custom = getCustomlabelCfg(allLabels[i]);
          item.labelContexts = allLabels[i].labelContexts;
          if (spaceLimit >= 0) {
            item.text = getTruncatedText(item.text, spaceLimit - 2 * m_textOffset);
          }
          //count y1 and y2
          var itemMeasure = fastMeasure(item.text, m_style.realStyle.label);
          var centerY = allLabelsLocation[i][0] + (allLabelsLocation[i][1] - allLabelsLocation[i][0]) / 2;
          item.width = itemMeasure.width;
          item.height = itemMeasure.height;
          item.startY = allLabelsLocation[i][0];
          item.rectHeight = allLabelsLocation[i][1] - allLabelsLocation[i][0];
          item.y = centerY;
          item.y1 = centerY - item.height / 2;
          item.y2 = centerY + item.height / 2;
          item.originalIndex = i;
          allLabels[i].drawLabel = false;
          allTicksLabels.push(item);

          fullHeight += item.rectHeight;
        }


        //now we should decide which label to draw.
        //iBeyond = 0:0,1,2,3,4,5,6,...
        //iBeyond = 1:0, ,2, ,4, ,6,...
        //iBeyond = 2:0, , ,3, , ,6,...
        //...
        //iBeyond = (allTicksLabels.length - 1):0
        var ticksLabelsToDraw = [], previousIndex, iBeyond;
        if (m_props.label.hideStrategy !== 'greedy') {
          //we must filter those labels which have already overflown the border.
          var filteredTicksLabels = allTicksLabels.concat();
          for (i = filteredTicksLabels.length - 1; i > -1; --i) {
            if (allLabelsLocation[0] && allLabelsLocation.length &&
              (filteredTicksLabels[i].y2 > allLabelsLocation[allLabelsLocation.length - 1][1] || filteredTicksLabels[i].y1 < allLabelsLocation[0][0])) {
              filteredTicksLabels.splice(i, 1);
            }
          }

          for (iBeyond = 0; iBeyond <= (filteredTicksLabels.length - 1); iBeyond++) {
            var isDrawable = true;
            for (i = (filteredTicksLabels.length - 1); i >= 0; i -= (iBeyond + 1)) {
              item = filteredTicksLabels[i];
              if (i !== (filteredTicksLabels.length - 1)) {
                previousIndex = i + (iBeyond + 1);

                if (filteredTicksLabels[i].y2 >= filteredTicksLabels[previousIndex].y1) {
                  isDrawable = false;
                  break;
                }
              }
              if (item.height > fullHeight) {
                break;
              }

              ticksLabelsToDraw.push(item);
              allLabels[item.originalIndex].drawLabel = true;
            }
            if (isDrawable) {
              break;
            } else {
              ticksLabelsToDraw = [];
            }
          }
        } else {

          for (previousIndex = iBeyond = (allTicksLabels.length - 1); iBeyond >= 0; iBeyond--) {
            item = allTicksLabels[iBeyond];

            if (previousIndex === iBeyond && allLabelsLocation[iBeyond][1] !== allLabelsLocation[iBeyond][0]) {
              if (isMultilayer && item.y1 > allLabelsLocation[iBeyond][0] && item.y2 < allLabelsLocation[iBeyond][1]) {
                ticksLabelsToDraw.push(item);
                allLabels[item.originalIndex].drawLabel = true;
              } else if (!isMultilayer) {
                if (item.height <= fullHeight) {
                  ticksLabelsToDraw.push(item);
                  allLabels[item.originalIndex].drawLabel = true;
                }
              }
            } else {
              if (item.y2 <= allTicksLabels[previousIndex].y1 && allLabelsLocation[iBeyond][1] !== allLabelsLocation[iBeyond][0]) {
                if (isMultilayer) {
                  //if have more than one layers, need to detecte whether the label is between gridlines
                  if (item.y1 > allLabelsLocation[iBeyond][0] && item.y2 < allLabelsLocation[iBeyond][1]) {
                    ticksLabelsToDraw.push(item);
                    allLabels[item.originalIndex].drawLabel = true;
                    previousIndex = iBeyond;
                  }
                } else {
                  //if have only one layer , just need to detecte whether overlap is exist
                  ticksLabelsToDraw.push(item);
                  allLabels[item.originalIndex].drawLabel = true;
                  previousIndex = iBeyond;
                }
              }
            }
          }
          //for greedy situation, we must filter it after because each cell has different width/height.
          for (i = ticksLabelsToDraw.length - 1; i > -1; --i) {
            if (allLabelsLocation[0] && allLabelsLocation.length &&
              (ticksLabelsToDraw[i].y2 > allLabelsLocation[allLabelsLocation.length - 1][1] || ticksLabelsToDraw[i].y1 < allLabelsLocation[0][0])) {
              allLabels[ticksLabelsToDraw[i].originalIndex].drawLabel = false;
              ticksLabelsToDraw.splice(i, 1);
            }
          }

        }
        return ticksLabelsToDraw;
      };

      var buildTopBottomToDrawLabels = function(allLabels, allLabelsLocation, isVertical, isMultilayer, spaceLimit) {
        //Jimmy/12/26/2012 extend allLabels from stringArray to objectArray to support customlabel
        //we always draw the first label for xAxis.

        //build the "todraw" array
        //count all the labels y1 and y2, and save them.
        var fullWidth = 0;
        var allTicksLabels = [];
        var i, item;
        for (i = 0; i < allLabels.length; i++) {
          item = {};
          item.text = getCustomlabelText(allLabels[i]);
          item.custom = getCustomlabelCfg(allLabels[i]);
          item.labelContexts = allLabels[i].labelContexts;

          if (spaceLimit >= 0) {
            item.text = getTruncatedText(item.text, spaceLimit - 2 * m_textOffset);
          }

          //count x1 and x2
          var itemMeasure = fastMeasure(item.text, m_style.realStyle.label);
          if (isVertical) {
            item.width = itemMeasure.height;
            item.height = itemMeasure.width;
          } else {
            item.width = itemMeasure.width;
            item.height = itemMeasure.height;
          }

          var centerX = allLabelsLocation[i][0] + (allLabelsLocation[i][1] - allLabelsLocation[i][0]) / 2;

          item.x = centerX;
          item.x1 = centerX - item.width / 2;
          item.x2 = centerX + item.width / 2;

          item.startX = allLabelsLocation[i][0];
          item.rectWidth = allLabelsLocation[i][1] - allLabelsLocation[i][0];
          item.originalIndex = i;
          allLabels[i].drawLabel = false;

          allTicksLabels.push(item);

          fullWidth += item.rectWidth;
        }

        //now we should decide which label to draw.
        //iBeyond = 0:0,1,2,3,4,5,6,...
        //iBeyond = 1:0, ,2, ,4, ,6,...
        //iBeyond = 2:0, , ,3, , ,6,...
        //...
        //iBeyond = (allTicksLabels.length - 1):0
        var ticksLabelsToDraw = [], previousIndex, iBeyond;
        if (m_props.label.hideStrategy !== 'greedy') {
          //we must filter those labels which have already overflown the border.
          var filteredTicksLabels = allTicksLabels.concat();
          for (i = filteredTicksLabels.length - 1; i > -1; --i) {
            if (allLabelsLocation[0] && allLabelsLocation.length &&
              (filteredTicksLabels[i].x2 > allLabelsLocation[allLabelsLocation.length - 1][1] || filteredTicksLabels[i].x1 < allLabelsLocation[0][0])) {
              filteredTicksLabels.splice(i, 1);
            }
          }
          for (iBeyond = 0; iBeyond <= (filteredTicksLabels.length - 1); iBeyond++) {
            var isDrawable = true;
            for (i = 0; i < filteredTicksLabels.length; i += (iBeyond + 1)) {
              item = filteredTicksLabels[i];
              if (i !== 0) {
                previousIndex = i - (iBeyond + 1);

                if (filteredTicksLabels[i].x1 <= filteredTicksLabels[previousIndex].x2 || allLabelsLocation[iBeyond][1] === allLabelsLocation[iBeyond][0]) {
                  isDrawable = false;
                  break;
                }
              }

              if (item.width > fullWidth) {
                break;
              }

              ticksLabelsToDraw.push(item);
              allLabels[item.originalIndex].drawLabel = true;
            }
            if (isDrawable) {
              break;
            } else {
              ticksLabelsToDraw = [];
            }
          }
        } else {

          for (previousIndex = iBeyond = (allTicksLabels.length - 1); iBeyond >= 0; iBeyond--) {
            item = allTicksLabels[iBeyond];

            if (previousIndex === iBeyond && allLabelsLocation[iBeyond][1] !== allLabelsLocation[iBeyond][0]) {
              if (isMultilayer && item.x1 > allLabelsLocation[iBeyond][0] && item.x2 < allLabelsLocation[iBeyond][1]) {
                ticksLabelsToDraw.push(item);
                allLabels[item.originalIndex].drawLabel = true;
              } else if (!isMultilayer) {
                if (item.width <= fullWidth) {
                  ticksLabelsToDraw.push(item);
                  allLabels[item.originalIndex].drawLabel = true;
                }
              }
            } else {
              if (item.x2 <= allTicksLabels[previousIndex].x1 && allLabelsLocation[iBeyond][1] !== allLabelsLocation[iBeyond][0]) {
                if (isMultilayer) {
                  //if have more than one layers, need to detecte whether the label is between gridlines
                  if (item.x1 > allLabelsLocation[iBeyond][0] && item.x2 < allLabelsLocation[iBeyond][1]) {
                    ticksLabelsToDraw.push(item);
                    allLabels[item.originalIndex].drawLabel = true;
                    previousIndex = iBeyond;
                  }
                } else {
                  //if have only one layer , just need to detecte whether overlap is exist
                  ticksLabelsToDraw.push(item);
                  allLabels[item.originalIndex].drawLabel = true;
                  previousIndex = iBeyond;
                }
              }
            }
          }
          //for greedy situation, we must filter it after because each cell has different width/height.

          for (i = ticksLabelsToDraw.length - 1; i > -1; --i) {
            if (allLabelsLocation[0] && allLabelsLocation.length &&
              (ticksLabelsToDraw[i].x2 > allLabelsLocation[allLabelsLocation.length - 1][1] || ticksLabelsToDraw[i].x1 < allLabelsLocation[0][0])) {
              allLabels[ticksLabelsToDraw[i].originalIndex].drawLabel = false;
              ticksLabelsToDraw.splice(i, 1);
            }
          }
        }

        return ticksLabelsToDraw;
      };

      var drawTopBottomLabels = function(selection, labelsToDraw, lastLevelHeight, maxTextHeight, axDomain, isVertical, isHierarchical) {
        if (labelsToDraw === undefined) {
          return;
        }

        for (var i = 0; i < labelsToDraw.length; i++) {
          var label = TypeUtils.isExist(labelsToDraw[i].text) ? labelsToDraw[i].text : '';
          var axLabels;
          if (m_props.label.visible) {
            if (angle) {
              var labelAreaOffset = 2;

              var aAngle = angle * Math.PI / 180;
              var cosAngle = Math.cos(aAngle);
              var sinAngle = (45 === angle) ? cosAngle : Math.sin(aAngle);
              var tAngle = tickAngle * Math.PI / 180;
              var cosTAngle = Math.cos(tAngle);
              var sinTAngle = Math.sin(tAngle);

              var tickStartX = labelsToDraw[i].x * sinAngle;
              var tickStartY = -labelsToDraw[i].x * cosAngle;
              
              var labelTextX = tickStartX + (m_tickSize + m_textOffset) * cosTAngle;
              var labelTextY = tickStartY + lastLevelHeight + (m_textOffset + m_tickSize) * sinTAngle;

              var labelAreaX = labelTextX - labelAreaOffset;
              var labelAreaY = labelTextY - labelsToDraw[i].width / 2 - labelAreaOffset;
              var labelAreaWidth = labelsToDraw[i].height + 2 * labelAreaOffset; //the text is vertical
              var labelAreaHeight = labelsToDraw[i].width + 2 * labelAreaOffset;

              //for debug
              if (tickAngle > 90) {
                labelAreaX -= (labelAreaWidth - 2 * labelAreaOffset);
              }

              //label G
              axLabels = selection.append("g");
              axLabels.each(function() {
                this.setAttribute("fill", m_style.defaultStyle.label.fill);
                this.setAttribute("class", m_axisLabelClassCombined);
                this.setAttribute("font-size", m_style.defaultStyle.label['font-size']);
                this.setAttribute("font-weight", m_style.defaultStyle.label['font-weight']);
                this.setAttribute("font-family", m_style.defaultStyle.label['font-family']);
              });

              if(m_props.enableLabelSelection){
                  //draw labelArea
                  var labelArea = axLabels.append("rect");
                  labelArea.each(function() {
                    this.setAttribute("x", labelAreaX);
                    this.setAttribute("y", labelAreaY);
                    this.setAttribute("width", labelAreaWidth);
                    this.setAttribute("height", labelAreaHeight);
                    this.setAttribute("opacity", 0);
                    this.setAttribute("class", "v-labelarea");
                  });
                  labelArea.node().labelContexts = labelsToDraw[i].labelContexts;
              }
              
              //draw label text
              var axLabelText = axLabels.append("text").text(label);
              axLabelText.each(function() {
                this.setAttribute("x", labelTextX);
                this.setAttribute("y", labelTextY);
                this.setAttribute("dominant-baseline", "middle"); //"auto")//"hanging")//"central")
                this.setAttribute("text-anchor", 'start'); // text-align
                this.setAttribute("pointer-events", "none");
              });


              if (tickAngle > 90) {
                axLabelText.attr("text-anchor", 'end');
                axLabels.attr('transform', 'rotate( ' + (tickAngle - 180) + ' ' + labelTextX + ' ' + labelTextY + ')');
              } else {
                axLabels.attr('transform', 'rotate( ' + (tickAngle) + ' ' + labelTextX + ' ' + labelTextY + ')');
              }
            } else {
              var labelG = selection;
              var offsetForBorder = 1, isTextSize, rect;
              if(m_props.enableLabelSelection){
                  if (m_position === "bottom") {
    
                    isTextSize = m_props.forceLabelArea || labelsToDraw[i].width > labelsToDraw[i].rectWidth;
                    rect = labelG.append("rect");
                    if (isTextSize) {
                      rect.each(function() {
                        this.setAttribute("x", labelsToDraw[i].x - labelsToDraw[i].width / 2 - offsetForBorder);
                        this.setAttribute("y", lastLevelHeight + maxTextHeight / 2 - offsetForBorder - m_textOffset / 2);
                        this.setAttribute("width", labelsToDraw[i].width + 2 * offsetForBorder);
                        this.setAttribute("height", labelsToDraw[i].height + 2 * offsetForBorder);
                        this.setAttribute("opacity", 0);
                        this.setAttribute("class", "v-labelarea");
                      });
                    } else {
                      rect.each(function() {
                        this.setAttribute("x", labelsToDraw[i].startX);
                        this.setAttribute("y", lastLevelHeight + offsetForBorder);
                        this.setAttribute("width", labelsToDraw[i].rectWidth);
                        this.setAttribute("height", maxTextHeight + 2 * m_textOffset - offsetForBorder);
                        this.setAttribute("opacity", 0);
                        this.setAttribute("class", "v-labelarea");
                      });
                    }
                    rect.node().labelContexts = labelsToDraw[i].labelContexts;
                  } else if (m_position === "top") {
                    if (labelsToDraw[i].labelContexts.length > 0) {
    
                      isTextSize = m_props.forceLabelArea || labelsToDraw[i].width > labelsToDraw[i].rectWidth;
                      rect = labelG.append("rect");
                      if (isTextSize) {
                        rect.each(function() {
                          this.setAttribute("x", labelsToDraw[i].x - labelsToDraw[i].width / 2 - offsetForBorder);
                          this.setAttribute("y", lastLevelHeight + maxTextHeight / 2 + m_textOffset / 2 - offsetForBorder);
                          this.setAttribute("width", labelsToDraw[i].width + 2 * offsetForBorder);
                          this.setAttribute("height", labelsToDraw[i].height + 2 * offsetForBorder);
                          this.setAttribute("opacity", 0);
                          this.setAttribute("class", "v-labelarea");
                        });
                      } else {
                        rect.each(function() {
                          this.setAttribute("x", labelsToDraw[i].startX);
                          this.setAttribute("y", lastLevelHeight);
                          this.setAttribute("width", labelsToDraw[i].rectWidth);
                          this.setAttribute("height", maxTextHeight + 2 * m_textOffset);
                          this.setAttribute("opacity", 0);
                          this.setAttribute("class", "v-labelarea");
                        });
                      }
    
                      rect.node().labelContexts = labelsToDraw[i].labelContexts;
                    }
                  }
              }

              axLabels = labelG.append("g");
              axLabels.each(function() {
                this.setAttribute("fill", m_style.defaultStyle.label.fill);
                this.setAttribute("class", m_axisLabelClassCombined);
                this.setAttribute("font-size", m_style.defaultStyle.label['font-size']);
                this.setAttribute("font-weight", m_style.defaultStyle.label['font-weight']);
                this.setAttribute("font-family", m_style.defaultStyle.label['font-family']);
              });
              var axTexts = axLabels.append("text").text(label);
              axTexts.each(function() {

                this.setAttribute("pointer-events", "none");
                this.setAttribute("x", labelsToDraw[i].x);
                this.setAttribute("y", lastLevelHeight + maxTextHeight / 2 + m_textOffset);
                this.setAttribute("dominant-baseline", "middle"); //"auto")//"hanging")//"central")
                this.setAttribute("text-anchor", "middle"); // text-align
              });


              if (isVertical) {
                if (!isHierarchical) {
                  if (m_position === 'top') {
                    axTexts.attr('text-anchor', 'start')
                      .attr("y", lastLevelHeight + maxTextHeight + m_textOffset);
                  } else if (m_position === 'bottom') {
                    axTexts.attr("y", lastLevelHeight + m_textOffset).attr('text-anchor', 'end');
                  }
                }

                var ac = "-90";
                axTexts.attr("transform", "rotate( " + ac + " " + axTexts.attr("x") + " " + axTexts.attr("y") + " )");

              }
              adjustLabelForIE(axTexts);
            }
          }
        }
      };

      axis.mouseover = function(target) {
        //high light the target
        target.setAttribute("opacity", 1);
        target.setAttribute("class", "v-labelarea v-hovershadow");
        target.setAttribute("fill", m_labelAreaMouseOverColor);
      };

      axis.mouseout = function(target) {
        //un high light all the label areas
        target.setAttribute("class", "v-labelarea");
        target.setAttribute("opacity", 0);
      };

      axis.cleanLabelAreas = function() {
        if (m_selection) {
          m_selection.selectAll(".v-labelarea")
            .attr("class", "v-labelarea")
            .attr("opacity", 0);
        }
      };

      axis.mouseup = function(target) {
        //un high light the target
        target.setAttribute("opacity", 1);
        target.setAttribute("class", "v-labelarea v-hovershadow");
        target.setAttribute("fill", m_labelAreaMouseOverColor);
      };

      axis.mousedown = function(target) {
        //high light the target
        target.setAttribute("opacity", 1);
        target.setAttribute("class", "v-labelarea v-hovershadow-mousedown");
        target.setAttribute("fill", m_labelAreaMouseDownColor);
      };

      axis.position = function(_position) {
        if (!arguments.length){
          return m_position;
        }
        m_position = _position;
        return axis;
      };

      axis.properties = function(_properties) {
        if (arguments.length === 0){
          return m_props;
        }

        m_props = Objects.extend(true, m_props, _properties);
        return axis;
      };

      axis.style = function(_style) {
        if (arguments.length === 0){
          return m_style;
        }
        m_style = Objects.extend(true, m_style, _style);
        return axis;
      };

      axis.axScale = function(_axScale) {
        if (!arguments.length){
          return m_axScale;
        }
        m_axScale = _axScale;
        return axis;
      };

      axis.getPreferredSize = function() {

        var scaleToDraw = adjustScale();

        var axisWidth = 0;
        var axisHeight = 0;

        var axisSpacings = [];
        var minTruncateSize = 0;

        for (var i = 0; i < scaleToDraw.length; i++) {
          if (!m_props.label.visible && i !== (scaleToDraw.length - 1)) {
            continue;
          }

          var axDomain = scaleToDraw[i].domain; //["a", "b"]
          var axRange = scaleToDraw[i].range; //[[0, 100], [100. 200], ...]

          if (axDomain.length === 0 || axRange.length === 0) {
            continue;
          }

          if (m_position === "bottom" || m_position === "top") {
            axisWidth = Math.abs(axRange[axRange.length - 1][1] - axRange[0][0]) + m_styleLineSrokeWidth;

            var offsetHeight = 0;
            if (m_props.label.visible) {
              var maxHeight;
              if (i === 0) {
                maxHeight = maxLabelTextHeight(axDomain, axRange, undefined, true);
                minTruncateSize = maxHeight.minTruncateSize;
              } else {
                maxHeight = maxLabelTextHeight(axDomain, axRange);
              }
              offsetHeight += maxHeight.maxLabelTextHeight;
            }

            offsetHeight = offsetHeight > 0 ? offsetHeight + 2 * m_textOffset : offsetHeight;
            axisHeight += offsetHeight;

            axisSpacings.push(offsetHeight);
          } else if (m_position === "left" || m_position === "right") {
            var offsetWidth = 0;

            if (m_props.label.visible) {
              var maxWidth;
              if (i === 0) {
                maxWidth = maxLabelTextWidth(axDomain, axRange, true);
                minTruncateSize = maxWidth.minTruncateSize;
              } else {
                maxWidth = maxLabelTextWidth(axDomain, axRange);
              }
              offsetWidth += maxWidth.maxLabelTextWidth;
            }
            offsetWidth = offsetWidth > 0 ? offsetWidth + 2 * m_textOffset : offsetWidth;

            axisWidth += offsetWidth;
            axisSpacings.push(offsetWidth);

            axisHeight = Math.abs(axRange[axRange.length - 1][1] - axRange[0][0]) + m_styleLineSrokeWidth;
          }
        }

        //--------------
        if (m_spaceLimit >= 0) {
          var spacings = axisSpacings;
          var spaceLeft = m_spaceLimit;

          var spacingToDraw = 0;


          for (i = 0; i < spacings.length; i++) {
            if (spaceLeft >= spacings[i]) {
              spacingToDraw += spacings[i];
              spaceLeft -= spacings[i];
              spaceLeft = NumberUtils.precise(spaceLeft);
            } else {
              break;
            }
          }

          if (spacingToDraw === 0 && spacings.length > 0) {
            if (minTruncateSize && minTruncateSize + 2 * m_textOffset < m_spaceLimit) {
              spacingToDraw = m_spaceLimit;
            } else {
              spacingToDraw += spacings[0];
            }
          }


          if (m_position === "bottom" || m_position === "top") {
            axisHeight = spacingToDraw;
          } else if (m_position === "left" || m_position === "right") {
            axisWidth = spacingToDraw;
          }
        }

        //------------------------------------
        if (!m_props.isTruncateAvailable) {
          minTruncateSize = 0;
        } else if (minTruncateSize > 0) {
          minTruncateSize += 2 * m_textOffset;
        }

        return {
          width: axisWidth,
          height: axisHeight,
          spacings: axisSpacings,
          minTruncateSize: minTruncateSize
        };
      };

      axis.matrix = function(_) {
        if (!arguments.length) {
          return m_matrix;
        }
        m_matrix = _;
        return axis;
      };

      axis.labelAngle = function(_) {
        if (!arguments.length) {
          return labelAngle;
        }
        labelAngle = _;
        return axis;
      };

      axis.tickAngle = function(_) {
        if (!arguments.length) {
          return tickAngle;
        }
        tickAngle = _;
        return axis;
      };

      axis.angle = function(_) {
        if (!arguments.length) {
          return angle;
        }
        angle = _;
        return axis;
      };

      axis.labelAlign = function(_) {
        if (!arguments.length) {
          return labelAlign;
        }
        labelAlign = _;
        return axis;
      };

      axis.destroy = function() {
        m_selection = null;
        //Jimmy: its name is confuse, makes people think it's a d3 scale
        m_axScale = null;
      };

      var resolveMaxAndMinInDomain = function(domain, rangeArray, checkEach, checkTruncate) {
        var heightArray = [];
        var widthArray = [];
        var isVerticalFont = false;
        var minTruncateSize = 0;
        for (var i = 0; i < domain.length; i++) {
          var tHeight = 0;
          var tWidth = 0;

          if (domain[i].drawLabel || checkEach) {
            var originalStr = getCustomlabelText(domain[i]);
            var tSize = fastMeasure(originalStr, m_style.realStyle.label);

            tHeight = tSize.height;
            tWidth = tSize.width;
            var interval = rangeArray[i][1] - rangeArray[i][0];

            if (checkTruncate) {
              var truncateSize;
              if (originalStr.length > 3) {
                truncateSize = fastMeasure(originalStr.slice(0, 3).concat('...'), m_style.realStyle.label).width;
                truncateSize = truncateSize > tSize.width ? tSize.width : truncateSize;
              } else {
                truncateSize = tSize.width;
              }

              minTruncateSize = truncateSize > minTruncateSize ? truncateSize : minTruncateSize;
            }

            if ((tHeight < tWidth) && interval !== 0 && tWidth > interval) {
              if (m_position === "top" || m_position === "bottom") {
                isVerticalFont = true;
              }
            }
          }

          heightArray.push(tHeight);
          widthArray.push(tWidth);
        }

        return {
          'heights': heightArray,
          'widths': widthArray,
          'isVerticalFont': isVerticalFont,
          'minTruncateSize': minTruncateSize
        };
      };

      var maxLabelTextHeight = function(domain, rangeArray, checkEach, checkTruncate) {
        //Jimmy/10/26/2012 we extend domain from string array to object to support customlabel
        var re = {
          "maxLabelTextHeight": 0,
          "isVertical": false
        };
        var maxTextHeight = 0;
        var isVerticalFont = false;
        var sizes = resolveMaxAndMinInDomain(domain, rangeArray, checkEach, checkTruncate);
        isVerticalFont = m_props.forceVerticalFont === true ? true : sizes.isVerticalFont;

        for (var i = 0; i < domain.length; i++) {
          if (domain[i].drawLabel || checkEach) {
            if (isVerticalFont) {
              if (maxTextHeight < sizes.widths[i]) {
                maxTextHeight = sizes.widths[i];
              }
            } else {
              if (maxTextHeight < sizes.heights[i]) {
                maxTextHeight = sizes.heights[i];
              }
            }
          }
        }
        re.maxLabelTextHeight = maxTextHeight;
        re.isVertical = isVerticalFont;
        re.minTruncateSize = re.isVertical ? sizes.minTruncateSize : -1;
        return re;
      };

      var maxLabelTextWidth = function(domain, rangeArray, checkTruncate) {
        var re = {
          "maxLabelTextWidth": 0,
          "isVertical": false
        };
        var maxTextWidth = 0;
        var isVerticalFont = false;
        var sizes = resolveMaxAndMinInDomain(domain, rangeArray, undefined, checkTruncate);
        isVerticalFont = m_props.forceVerticalFont === true ? true : sizes.isVerticalFont;

        for (var i = 0; i < domain.length; i++) {
          if (domain[i].drawLabel) {
            if (isVerticalFont) {
              if (maxTextWidth < sizes.heights[i]) {
                maxTextWidth = sizes.heights[i];
              }
            } else {
              if (maxTextWidth < sizes.widths[i]) {
                maxTextWidth = sizes.widths[i];
              }
            }
          }
        }

        re.maxLabelTextWidth = maxTextWidth;
        re.isVertical = isVerticalFont;
        re.minTruncateSize = sizes.minTruncateSize;
        return re;
      };

      var maxLabelTextSize = function(labels, isVertical) {
        var maxWidth = 0,
          maxHeight = 0;
        for (var i = 0; i < labels.length; i++) {
          var tSize = fastMeasure(labels[i].text, m_style.realStyle.label);
          maxWidth = tSize.width > maxWidth ? tSize.width : maxWidth;
          maxHeight = tSize.height > maxHeight ? tSize.height : maxHeight;
        }
        return {
          maxWidth: isVertical ? maxHeight : maxWidth,
          maxHeight: isVertical ? maxWidth : maxHeight
        };
      };

      var fastMeasure = function(_text, _style) {
        return TextUtils.superFastMeasure(_text, _style['font-size'],
          _style['font-weight'],
          _style['font-family']);
      };

      var isInvalidString = function(str) {
        if (typeof(str) !== "string" && NumberUtils.isNoValue(str)) {
          return true;
        }
        return false;
      };

      return axis;
    };

    return ret;
  });
define('sap/viz/modules/util/ClippathUtil',['sap/viz/base/utils/ObjectUtils'],
function Setup(ObjectUtils) 
{
  var className = 'v-clippath';
  var ClipPathUtil = {
      drawClippath : function(selection, width, height, x , y) {
        if ( selection.select('.' + className).node() === null ) {
          var id = 'clip-path-' + ObjectUtils.guid();
          var clipath = selection.insert('clipPath', ':first-child').attr('class', className).attr('id', id);
          clipath.append('rect').attr('x', x).attr('y', y).attr('width', width).attr('height', height);
          return id;
        } else {
          selection.select('.' + className).select('rect').attr('width', width).attr('height', height).attr('x', x).attr('y', y);
          return selection.select('.' + className).attr('id');
        }
      }
  };
  
  return ClipPathUtil;
  
});
define('sap/viz/modules/util/IndicatorUtil',['sap/viz/modules/util/ClippathUtil'],
function Setup(ClippathUtil) {
		var IndicatorUtil = {
		};
		
		function AxisIndicator(options) {
			this.axisType = options.axisType;
			this.position = options.position;
			this.scrollbarHandle = null;
			this.indicatorHandle = null;
			this.scrollbarHeight = options.scrollbarHeight;
			this.scrollbarColor = options.scrollbarColor;
			this.scrollbarBorderWidth = options.scrollbarBorderWidth;
			this.scrollbarBorderColor = options.scrollbarBorderColor;
			this.indicatorLineWidth = options.indicatorLineWidth;
			this.indicatorLineColor = options.indicatorLineColor;
			this.container = options.container;
			this.indicatorOffset = options.indicatorOffset;
			this.CLASS_INDICATOR_LINE = options.classIndicatorLine;
			this.axisWidth = options.axisWidth;
			this.axisHeight = options.axisHeight;
		}

		IndicatorUtil.createIndicator = function (options) {
			if (options.indicatorType === "AxisIndicator") {
				return new AxisIndicator(options);
			}
		};
		
		AxisIndicator.prototype.draw = function () {
      if (this.container.select('.' + this.CLASS_INDICATOR_LINE).node() === null) {
        this.indicatorHandle = this.container.append('line').attr('class', this.CLASS_INDICATOR_LINE).attr('stroke', this.indicatorLineColor).attr('stroke-width', this.indicatorLineWidth);
      }

      var clippathid;
      if (this.position === 'bottom') {
        this.indicatorHandle.attr('x1', 0).attr('y1', this.indicatorOffset /2).attr('x2', this.axisWidth).attr('y2', this.indicatorOffset /2);
        clippathid = ClippathUtil.drawClippath(this.container, this.axisWidth - 20, this.indicatorOffset , 10, 0);
        this.scrollbarHandle = this.container.append('rect').attr('x', 0).attr('y', (this.indicatorOffset  - this.scrollbarHeight)/2).attr('width', 10).attr('height', this.scrollbarHeight).attr('fill', this.scrollbarColor).attr('stroke-width', this.scrollbarBorderWidth).attr('stroke', this.scrollbarBorderColor);
      } else {
        this.indicatorHandle.attr('x1', this.indicatorOffset /2).attr('y1', 0).attr('x2', this.indicatorOffset /2).attr('y2', this.axisHeight).attr('stroke', this.indicatorLineColor).attr('stroke-width', this.indicatorLineWidth);
        clippathid = ClippathUtil.drawClippath(this.container, this.scrollbarHeight, this.axisHeight - 20, (this.indicatorOffset  - this.scrollbarHeight)/2, 10);
        this.scrollbarHandle = this.container.append('rect').attr('x', (this.indicatorOffset  - this.scrollbarHeight)/2).attr('y', 10).attr('width', this.scrollbarHeight).attr('height', (this.axisHeight - 20)).attr('fill', this.scrollbarColor).attr('stroke-width', this.scrollbarBorderWidth).attr('stroke', this.scrollbarBorderColor);
      }
      
      this.scrollbarHandle.attr('clip-path', 'url(#' + clippathid + ')');
		};
		
		AxisIndicator.prototype.update = function(range, start){
      var length = 0;
      if( !this.position) {
        return;
      }
      this.container.attr('visibility' ,'visible');
      if (this.position === 'top' || this.position === 'bottom'){
        length = this.axisWidth * (this.axisWidth  - 20) / range;
        if( this.axisType === 'value') {
          this.scrollbarHandle.attr('x', length + 10);
        }else{
          var x =  - (start * (this.axisWidth - 20) / range ) + 10;
          this.scrollbarHandle.attr('width', length).attr('x', x);
        }
           
      } else {
        length =  this.axisHeight * (this.axisHeight  - 20) / range;
        var y = -( start * (this.axisHeight - 20) / range ) + 10;
        this.scrollbarHandle.attr('height', length).attr('y', y);
      }
    };  
    
    AxisIndicator.prototype.hide = function(flag){
      if (flag) {
        this.container.attr('visibility', 'hidden');
      } else {
        if (this.position === 'top' || this.position === 'bottom') {
          if (this.axisType === 'value') {
            var xPosition = this.scrollbarHandle.attr('x');
            if (xPosition >= (this.axisWidth  - 16)) {
              this.container.transition().duration(300).attr('visibility', 'hidden');
            }
            
          } else {
            var sWidth = this.scrollbarHandle.attr('width');
            if (sWidth >= ( this.axisWidth - 20)) {
              this.container.transition().duration(300).attr('visibility', 'hidden');
            }
          }
          
        } else {
          if (this.axisType === 'value') {
            var yPosition = this.scrollbarHandle.attr('y');
            if (yPosition <= 10) {
              this.container.transition().duration(300).attr('visibility', 'hidden');
            }
          } else {
            var sHeight = this.scrollbarHandle.attr('height');
            if( sHeight >= (this.axisHeight - 20)) {
              this.container.transition().duration(300).attr('visibility', 'hidden');
            }           
          }
        } 
      }
    };
      
    return IndicatorUtil;

});


define('sap/viz/modules/axis/regularAxis',['jquery', 'sap/viz/util/TextUtils','sap/viz/base/utils/TypeUtils','sap/viz/util/Objects','sap/viz/base/utils/Objects','sap/viz/modules/axis/valueAxisCore','sap/viz/modules/axis/categoryAxisCore',
'sap/viz/lang/langManager','sap/viz/util/NumberUtils',
'sap/viz/modules/dispatch','sap/viz/format/FormatManager','sap/viz/modules/threeD/matrix',
'sap/viz/modules/util/BoundUtil', 'sap/viz/base/UADetector', 'sap/viz/modules/util/ClippathUtil', 'sap/viz/modules/util/IndicatorUtil'],
function Setup(jQuery, TextUtils, TypeUtils,VizObjects, Objects, valueAxisCore, categoryAxisCore, langManager, NumberUtils, dispatch, FormatManager, matrix, BoundUtil, UADetector, ClippathUtil, IndicatorUtil) {

  var ret = function(manifest, ctx) {
        //we should build the axis Data Module, and then draw the axis.
        var m_AxisDM = null;
        var m_axisCore;

        var parent = null;
        var m_width = 0;
        var m_height = 0;

        var m_isDrawBody = true;

        var m_spaceLimit = -1;

        var m_axClassName = "viz-axis";
        var m_axBodyClassName = "viz-axis-body";
        var m_axTitleClassName = "viz-axis-title";
        var m_axIndicatorClassName = "viz-axis-indicator";

        var m_vClassNames = 
        {
            axis:"v-axis",
            axisBody:"v-body",
            axisTitle:"v-title",
            axisLabel:"v-label"
        };

        var m_titleOffset = 11;

        var m_data = { };
        var m_dataAxis = { };
        
        var m_isTitleVisible = true;
        
        var m_props = manifest.props(null);
        
        var m_drawable = true;

        var eDispatch = new dispatch('initialized');
        
        var m_defaultColor = m_props.color;

        var m_scale = null;
        var m_titleWidth = null;

        var m_effectManager;
        if(ctx)
        {
           m_effectManager = ctx.effectManager;
        }
        
        var m_title = null;
        
        var m_style = {
            "realStyle": {},
            "defaultStyle": {}
        };
        
        var indicatorOffset = 8,
          previousOffset = {x: 0, y: 0},
          originalAxisCorePreferredSize = null,
          indicatorScrollbarHeight = 2, 
          indicatorLineWidth = 1, 
          indicatorScrollbarBorderWidth = 1, 
          indicatorScrobllbarBorderColor = '#707070', 
          indicatorScrollbarColor = '#bbbbbb', 
          indicatorLineColor = '#bebebe';
        
        var getThemeStyleDef = function () {
          if(ctx)  {
              m_style.realStyle.title = Objects.extend(true, {}, ctx.styleManager.query(m_vClassNames.axisTitle));
              m_style.realStyle.label = Objects.extend(true, {}, ctx.styleManager.query(m_vClassNames.axisLabel));

              m_style.defaultStyle.title = Objects.extend(true, {}, ctx.styleManager.queryDefault(m_vClassNames.axisTitle));
              m_style.defaultStyle.label = Objects.extend(true, {}, ctx.styleManager.queryDefault(m_vClassNames.axisLabel));

              m_style.realStyle.titleString = ctx.styleManager.query(m_vClassNames.axisTitle).toString();
              m_style.realStyle.labelString = ctx.styleManager.query(m_vClassNames.axisLabel).toString();

              m_style.defaultStyle.titleString = ctx.styleManager.queryDefault(m_vClassNames.axisTitle).toString();
              m_style.defaultStyle.labelString = ctx.styleManager.queryDefault(m_vClassNames.axisLabel).toString();

              if (m_props.title.applyAxislineColor){
                m_style.realStyle.title.fill = m_props.color;
                m_style.defaultStyle.title.fill = m_props.color;
              }
          }
        };

        var m_matrix = matrix(), labelAngle = null, labelAlign = null, angle = null, tickAngle = null;
        
        var drawAll = function()
        {
            if(!m_drawable)
            {
                //do not draw bacause of smart layout
                return false;
            }
            else
            {
                if(!drawBody() && !drawTitle())
                {
                    return false;
                }
            }

            return true;
        };

        var drawTitle = function() 
        {
            return m_props.title.visible && m_props.visible;
        };

        var drawBody = function() 
        {
            if(!m_isDrawBody)
            {
                return false;
            }

            var rangeArray = m_scale.range();
            var domainArray = m_scale.domain();
            var rangeBand = null;
            if(m_props.type === "category")
            {
                rangeBand = m_scale.rangeBand();
            }

            var hasData = false;
            if(!m_props.isIndependentMode)
            {
                if(m_dataAxis)
                {
                    hasData = true;
                }
            }
            else
            {
                if(m_data)
                {
                    hasData = true;
                }
            }

            return !(!m_props.visible ||
                   (rangeArray[0] === 0 && rangeArray[rangeArray.length-1] === 0 && rangeArray.length >=2 ) ||
                   (rangeArray.length === 1 && rangeArray[0] === 0 &&
                    domainArray.length === 1 && domainArray[0] === 0 && m_props.type === "value") ||
                   ((!rangeBand || !hasData) && rangeArray.length === 1 && rangeArray[0] === 0 &&
                     domainArray.length === 1 && domainArray[0] === 0 && m_props.type === "category")    
                );
        };
        

        var buildAxisTitle = function() {
            //build axis title Text
            var title = "";
            if (m_props.title.text !== undefined && m_props.title.text !== null) {
                title = m_props.title.text;
            } else {
                if (m_props.type === "value") {
                    if (m_title) {
                        title = m_title;
                    } else {
                        title = langManager.get('IDS_ISNOVALUE');
                    }
                } else//let us build the title!
                {
                    var dataset = [];
                    if (m_props.isIndependentMode) {
                        if (m_data) {
                            for (var dataObj in m_data) {
                                if (m_data.hasOwnProperty(dataObj)) {
                                    dataset = m_data[dataObj].values;
                                    break;
                                }
                            }
                        }
                    } else {
                        if (m_dataAxis) {
                            dataset = m_dataAxis.values;
                        }
                    }

                    for (var k = 0; k < dataset.length; k++) {
                        if (dataset[k].type) {
                            if (dataset[k].type === "MND" && k === 0) {
                                title += langManager.get('IDS_DEFAULTMND') + ((dataset.length === 1) ? "" : " - ");
                            } else if (dataset[k].type === "MND" && k === (dataset.length - 1)) {
                                title += " - " + langManager.get('IDS_DEFAULTMND');
                            }
                        } else {
                            if (dataset[k].col.val) {
                                title += dataset[k].col.val;
                            } else {
                                title += langManager.get('IDS_ISNOVALUE');
                            }

                            if (k !== (dataset.length - 1) && !dataset[k + 1].type) {
                                title += " / ";
                            }
                        }
                    }
                }
            }
            m_title = title;
            return title;
        }; 

        var getRange = function () {
          if( m_props.type === 'value') {
            var range = m_scale.range();
            return Math.abs( range[0] - range[range.length - 1]);
           } else {
            return m_scale.rangeBand() * m_scale.range().length;
           }
         };
        
        var indicatorInstance;
        var axis = function (selection) {
                var axisPreferredSize = axis.getPreferredSize();
                var basicWidth = (m_width < axisPreferredSize.width) ? m_width : axisPreferredSize.width;
                var basicHeight = (m_height < axisPreferredSize.height) ? m_height : axisPreferredSize.height;
                BoundUtil.drawBound(selection, basicWidth, basicHeight);
                previousOffset = {x : 0, y: 0};
                var spadding = axis.startPadding(), epadding = axis.endPadding();
                
                if (UADetector.isMobile()) {
                  var clippathid, tmpWidth, tmpHeight;
                  tmpWidth = Math.ceil(axisPreferredSize.width);
                  tmpHeight = Math.ceil(axisPreferredSize.height);
                  
                  if (m_props.gridline && m_props.gridline.length) {
                    if (m_props.position === 'bottom') {
                        clippathid = ClippathUtil.drawClippath(selection, tmpWidth + spadding + epadding, tmpHeight + m_props.gridline.length + 1, (spadding === 0)?(-1):(-spadding), -m_props.gridline.length);
                    } else if (m_props.position === 'left') {
                        clippathid = ClippathUtil.drawClippath(selection, tmpWidth + m_props.gridline.length + 1 , tmpHeight + spadding + epadding, 0, (spadding === 0)?(-1):(-spadding));
                    }
                    
                    if (m_props.position === 'bottom' || m_props.position === 'left') {
                      selection.attr('clip-path', 'url(#' +clippathid + ')' );
                    }
                  }
                }
                
                parent = selection;
                if (m_props.indicator.enable && UADetector.isMobile()) {
                  parent.append('g').attr('class', m_axIndicatorClassName);
                }
                draw(parent);
                
                //in axis, we cannot use data driven way like
                //        var e = selectDIV.selectAll("p")
                //.data(pdata,function(d){return d;});
             
                //e.enter().append("p")
                //.text(function(d){return d;});

                //e.exit().remove();
                //to control the redraw, because axis is not based on data, but based on scale

                //there should be only one axis Class
                
                //draw indicator for mobile device
                if (m_props.indicator.enable && UADetector.isMobile()) {
                  indicatorInstance =  IndicatorUtil.createIndicator({ 
                    indicatorType : 'AxisIndicator',
                    container : parent.select('.' + m_axIndicatorClassName),
                    axisType : m_props.type, 
                    position : m_props.position,
                    axisWidth : axisPreferredSize.width,
                    axisHeight : axisPreferredSize.height,
                    indicatorOffset : indicatorOffset,
                    scrollbarHeight : indicatorScrollbarHeight,
                    scrollbarBorderWidth : indicatorScrollbarBorderWidth,
                    scrollbarBorderColor : indicatorScrobllbarBorderColor, 
                    scrollbarColor : indicatorScrollbarColor, 
                    indicatorLineColor : indicatorLineColor,
                    indicatorLineWidth : indicatorLineWidth,
                    classIndicatorLine : 'v-indicator-line'});
                  
                  indicatorInstance.draw();
                  indicatorInstance.update(getRange(), 0);
                  var axisCorePreferredSize = m_axisCore.getPreferredSize();
                  adjustAxisPosition(axisCorePreferredSize, axisPreferredSize);
                  indicatorInstance.hide(true);
                }
                return axis;    
        }
        
        function adjustAxisPosition(axisCorePreferredSize, axisPreferredSize) {
          if( m_props.position === 'bottom' ){
            parent.select('.' + m_axIndicatorClassName).attr('transform', 'translate(0, ' + (axisCorePreferredSize.height + indicatorOffset) + ')'); 
          } else if (m_props.position === 'left') {
            var indicatorWidth = indicatorScrollbarHeight + indicatorScrollbarBorderWidth * 2;
            if (drawTitle()) {
              parent.select('.' + m_axBodyClassName).attr('transform', 'translate(' + (m_titleWidth + m_titleOffset + indicatorWidth + indicatorOffset) + ', 0)');        
            } else {
              parent.select('.' + m_axBodyClassName).attr('transform', 'translate(' + (indicatorWidth + indicatorOffset) + ', 0)');
            }
            parent.select('.' + m_axIndicatorClassName).attr('transform', 'translate(' + (axisPreferredSize.width - axisCorePreferredSize.width - indicatorOffset) + ', 0)');    
          }
        }
        
        function convertToOffset(transformStr){
          
          return {
            x : transformStr.substring( transformStr.indexOf('(') + 1, transformStr.indexOf(',')),
            y : transformStr.substring( transformStr.indexOf(',') + 1, transformStr.indexOf(')'))
          };
          
        }
        
        axis.stretchFromPlot = function(offsetInfo){
          var transformString, transform;
          if( offsetInfo.offset){
               transform = offsetInfo.offset;
            } else {
              if ( m_props.position === 'top' || m_props.position === 'bottom' ) {
                transformString = offsetInfo.xTransform;
              } else {
                transformString = offsetInfo.yTransform;   
              }
              
              transform = convertToOffset(transformString);
            }
          
          var node = parent.select("." + m_axBodyClassName).node(), nodeTransform =  node.getTransformToElement(node.parentNode);
          if (m_props.position === 'bottom') {
            previousOffset = { x : transform.x,  y: nodeTransform.f};
            parent.select("." + m_axBodyClassName).attr('transform', 'translate( '+ transform.x + ', ' + nodeTransform.f +')');
            if (indicatorInstance) {
              indicatorInstance.update(getRange(), transform.x);
            }
          } else if (m_props.position === 'left') {
            previousOffset = { x :  nodeTransform.e, y: transform.y};
            parent.select("." + m_axBodyClassName).attr('transform', 'translate( '+ nodeTransform.e + ', ' + transform.y +')');
            
            if (indicatorInstance) {
              indicatorInstance.update(getRange(), transform.y );
            }
          }
        };
        
         var draw =  function ( selection ){

                var axisClass = selection.select("." + m_axClassName);

                var rangeArray = m_scale.range();
                var domainArray = m_scale.domain();
                if(!drawAll())
                {
                    //remove all the axis 
                    //to improve the performance, we should remove as less elements as possible.
                    axisClass.remove();
                }
                else
                {
                    //---we should dicide show or hide somethings because of the spaceLimit
                    var spacings = axis.getPreferredSize().spacings;

                    var titleSpace = spacings[0];
                    var bodySpace = 0;
                    for(var i = 1; i < spacings.length; i++)
                    {
                        bodySpace += spacings[i];
                    }

                    if(m_spaceLimit >= 0 && m_spaceLimit < (titleSpace + bodySpace))
                    {
                        m_isTitleVisible = false;
                    }

                    prepareProperties();

                    var core;
                    var coreScale;
                    var re = getCoreAndScale();
                    core = re.core;
                    coreScale = re.coreScale;

                    //the axis body
                    m_axisCore = core()
                                .properties(m_props)
                                .style(m_style)
                                .position(m_props.position)
                                .axScale(coreScale)
                                .spaceLimit(m_spaceLimit)
                                .matrix(m_matrix)
                                .labelAngle(labelAngle)
                                .labelAlign(labelAlign)
                                .angle(angle)
                                .tickAngle(tickAngle);

                    var axisBody;
                    if(axisClass.empty())
                    {
                        axisClass = selection.append("g")
                                 .attr("class", m_axClassName + " "+ m_vClassNames.axis);

                        axisBody = axisClass.append("g")
                                  .attr("class", m_axBodyClassName + " " + m_vClassNames.axisBody);
                    }
                    else
                    {
                        //redraw axis body
                        var e=axisClass.select("." + m_axBodyClassName).remove();

                        axisBody = axisClass.append("g")
                                  .attr("class", m_axBodyClassName + " "+ m_vClassNames.axisBody);

                        axisBody = axisClass.select("." + m_axBodyClassName);
                    }

                    if(drawBody())
                    {
                        axisBody.call(m_axisCore);
                    }

                    var title = m_title;
                    

                    //redraw axis title
                    var titleOffset = m_titleOffset;
                    axisClass.select("." + m_axTitleClassName).remove();

                    if(drawTitle())
                    {
                        if(m_props.title.visible && m_isTitleVisible)
                        {
                            var pSize = null;
                            if (UADetector.isMobile() && originalAxisCorePreferredSize) {
                              pSize = originalAxisCorePreferredSize;
                            } else {
                              pSize = originalAxisCorePreferredSize = m_axisCore.getPreferredSize();
                            }

                            var axTitle = axisClass.append("g")
                                  .attr("class", m_axTitleClassName + " " + m_vClassNames.axisTitle)
                                  .attr("text-anchor", "middle")
                                  .attr("fill", m_style.defaultStyle.title.fill)
                                  .attr("font-size", m_style.defaultStyle.title['font-size'])
                                  .attr("font-weight", m_style.defaultStyle.title['font-weight'])
                                  .attr("font-family", m_style.defaultStyle.title['font-family'])
                                  .append("text"); // text-align
                                  
                            if(m_props.position === "bottom")
                            {
                                if(!drawBody())
                                {
                                    pSize.height = 0;
                                }
                                var indicatorPlotHeight = 0;
                                if (UADetector.isMobile() && m_props.indicator.enable) {
                                  indicatorPlotHeight =  indicatorOffset + indicatorScrollbarHeight + indicatorScrollbarBorderWidth * 2;
                                }
                                  axTitle.attr("x", pSize.width/2)
                                         .attr("y", pSize.height + titleOffset + indicatorPlotHeight)
                                         .attr("dominant-baseline", "hanging");//"auto")//"hanging")//"central");
                                    
                                  if(UADetector.isIE())
                                  {
                                      //dominant-baseline does not work
                                      var textHeight = m_style.realStyle.title['font-size'].toString();
                                      var indexPX = textHeight.indexOf("px");
                                      if(indexPX >= 0)
                                      {
                                          textHeight = textHeight.substr(0, indexPX);
                                      }
                                      axTitle.attr("y", Number(axTitle.attr("y")) + textHeight/2);
                                      axTitle.attr("dominant-baseline", "auto");
                                  }

                                TextUtils.ellipsis(title, axTitle.node(), pSize.width, m_style.realStyle.titleString);
                                
                               if(angle){
                                    var aAngle = angle * Math.PI /180;
                                    var cosAngle = Math.cos(aAngle);
                                    var sinAngle = (45 === angle) ? cosAngle : Math.sin(aAngle);
                                    var tAngle = tickAngle * Math.PI / 180;
                                    var cosTAngle = Math.cos(tAngle);
                                    var sinTAngle = Math.sin(tAngle);
                    
                                    var aaAngle = angle - 90;
                                    if( aaAngle > 90 ){
                                        aaAngle -= 180;
                                    }else if( aaAngle < -90 )(
                                        aaAngle += 180
                                    )
                                    
                                    var size = fastMeasure(title, m_style.realStyle.title)
                                    var x = ( pSize.width)/2 * sinAngle;
                                    var y = - ( pSize.width )/2 * cosAngle;
                                    
                                    x += (pSize.height + titleOffset) * cosTAngle;
                                    y += (pSize.height + titleOffset) * sinTAngle;
                                   
                                    var rotateStr ;
                                    rotateStr = 'rotate( ' + ( aaAngle) + ' ' + x + ' ' + y + ')';
                                    
                                    if(UADetector.isIE()){
                                      var textHeight = m_style.realStyle.title['font-size'].toString();
                                      var indexPX = textHeight.indexOf("px");
                                      if(indexPX >= 0)
                                      {
                                          textHeight = textHeight.substr(0, indexPX);
                                      }
                                      rotateStr += 'translate(0  '+ (textHeight) +')';
                                    }
                                    
                                    axTitle.attr('x', x).attr('y', y).attr('transform', rotateStr);
                                }
                            }
                            else if(m_props.position === "top")
                            {
                                if(!drawBody())
                                {
                                    pSize.height = 0;
                                }

                                titleHieght = fastMeasure(title, m_style.realStyle.title).height;
                                var transOffset = (title !== undefined && title !== null && title !== '' ? titleHieght + titleOffset : 0);

                                axisBody.attr("transform", "translate(0, " + transOffset + ")");

                                axTitle.attr("x", pSize.width/2)
                                  .attr("y", titleHieght)
                                  .attr("dx", "0") // padding-right
                                  .attr("dy", "0") // vertical-align: middle?
                                  .attr("dominant-baseline", "auto");//"auto")//"hanging")//"central")
                                
                                TextUtils.ellipsis(title, axTitle.node(), pSize.width, m_style.realStyle.titleString);
                            }
                            else if(m_props.position === "left")
                            {
                                if(!drawBody())
                                {
                                    pSize.width = 0;
                                }

                                //title is vertical
                                m_titleWidth = titleWidth = fastMeasure(title, m_style.realStyle.title).height;
                                var transOffset = (title !== undefined && title !== null && title !== '' ? titleWidth + titleOffset : 0);
                                
                                indicatorPlotHeight = 0;
                                if (UADetector.isMobile() && m_props.indicator.enable) {
                                  indicatorPlotHeight =  indicatorOffset + indicatorScrollbarHeight + indicatorScrollbarBorderWidth * 2;
                                }
                                axisBody.attr("transform", "translate(" + (transOffset + indicatorPlotHeight) + ", " + 0 + ")");

                                var centerX = titleWidth;
                                var centerY = pSize.height/2;
                                var ac = "-90";

                                //axisClass.append("circle").attr("cx", centerX).attr("cy", centerY). attr("r", 5);
                                axTitle.attr("transform","rotate( " + ac + " " + centerX + " "  + centerY + " )")
                                  .attr("x", centerX)
                                  .attr("y", centerY)
                                  .attr("dominant-baseline", "auto");//"auto")//"hanging")//"central")
                                
                                TextUtils.ellipsis(title, axTitle.node(), pSize.height, m_style.realStyle.titleString);
                            }
                            else// if(m_props.position == "right")
                            {
                                if(!drawBody())
                                {
                                    pSize.width = 0;
                                }

                                //title is vertical
                                titleWidth = fastMeasure(title, m_style.realStyle.title).height;
                                
                                centerX = pSize.width + titleWidth/2 + titleOffset;
                                centerY = pSize.height/2;
                                var ac = "-90";

                                
                                axTitle.attr("transform","rotate( " + ac + " " + centerX + " "  + centerY + " )")
                                  .attr("x", centerX)
                                  .attr("y", centerY - titleWidth/2)
                                  .attr("dominant-baseline", "hanging")//"auto")//"hanging")//"central")

                                if(UADetector.isIE() )
                                {
                                    //dominant-baseline does not work
                                    var textHeight = m_style.realStyle.title['font-size'].toString();
                                    var indexPX = textHeight.indexOf("px");
                                    if(indexPX >= 0)
                                    {
                                        textHeight = textHeight.substr(0, indexPX);
                                    }

                                    centerY = Number(pSize.height/2) + textHeight/2;
                                    axTitle.attr("y", centerY);
                                    axTitle.attr("dominant-baseline", "auto");
                                }

                                TextUtils.ellipsis(title, axTitle.node(), pSize.height, m_style.realStyle.titleString);
                            }
                        }
                    }
                    m_isTitleVisible = true;
                }
                
            eDispatch.initialized();
            
        };
        
        axis.redraw = function (obj) {
          draw(parent);
          if (m_props.indicator.enable) {
            var axisCorePreferredSize = m_axisCore.getPreferredSize();
            var axisPreferredSize = axis.getPreferredSize();
            adjustAxisPosition(axisCorePreferredSize, axisPreferredSize);            
          }
        };
        
        axis.stretchEnd = function (obj) {
          if (indicatorInstance) {
            indicatorInstance.hide(true);
          }
        };
        
        axis.matrix = function(_){
          if(!arguments.length){
            return m_matrix;
          }
          m_matrix = _;
          return axis;
        };
        
        axis.labelAngle = function(_){
          if(!arguments.length){
            return labelAngle;
          }
          labelAngle = pmod( _, 360);
          return axis;
        };
        
        axis.tickAngle = function(_){
          if(!arguments.length){
            return tickAngle;
          }
          tickAngle =pmod( _, 360);
          return axis;
        };
        
        axis.angle = function(_){
          if(!arguments.length){
            return angle;
          }
          angle = pmod( _, 360);
          return axis;
        };
        
        function pmod(a,m)
        {
          var ret = a % m;
          if (0 > ret)
            ret += m;
          return ret;
        }
        
        axis.labelAlign = function(_){
          if(!arguments.length){
            return labelAlign;
          }
          labelAlign = _;
          return axis;
        };
        
        axis.parent = function (_) {
          if ( !arguments.length ) return parent;
          parent = _;
          return axis;
        };

        axis.width = function(_width) {
            if (arguments.length == 0) {
                return m_width;
            }
            else {
                m_width = _width;

                if(m_props.position == "bottom" || m_props.position == "top")
                {
                    if(m_height)
                    {
                        m_spaceLimit = m_height;

                    }
                }
                else if(m_props.position == "left" || m_props.position == "right")
                {
                    if(m_width)
                    {
                        m_spaceLimit = m_width;
                    }
                }

                return axis;
            }
        };

        axis.height = function(_height) {
            if (arguments.length == 0)
                return m_height;
            
            m_height = _height;
            if(m_props.position == "bottom" || m_props.position == "top")
            {
                if(m_height)
                {
                    m_spaceLimit = m_height;

                }
            }
            else if(m_props.position == "left" || m_props.position == "right")
            {
                if(m_width)
                {
                    m_spaceLimit = m_width;
                }
            }

            
            return axis;
        };

        axis.gridlineLength = function(_gridlineLength) {
            if (arguments.length == 0)
                return m_props.gridline.length;
            m_props.gridline.length = _gridlineLength;
            return axis;
        };

        axis.startPadding = function() {
            var padding = 0;
            if(m_props.type == "value")
            {
                padding = valueAxisCore()
                         .properties(m_props)
                         .style(m_style)
                         .position(m_props.position)
                         .axScale(m_scale)
                         .startPadding();
            }
            return padding;
        };

        axis.endPadding = function() {
            var padding = 0;
            if(m_props.type == "value")
            {
                padding = valueAxisCore()
                         .properties(m_props)
                         .style(m_style)
                         .position(m_props.position)
                         .axScale(m_scale)
                         .endPadding();
            }
            return padding;
        };

        axis.mouseover = function(target){
            if(m_props.enableLabelSelection && m_props.type !== "value")
            {
                m_axisCore.mouseover(target);
            }
        };

        axis.mouseout = function(target){
            if(m_props.enableLabelSelection && m_props.type !== "value")
            {
                m_axisCore.mouseout(target);
            }
        };
        
        axis.cleanLabelAreas = function()
        {
            if(m_props.enableLabelSelection && m_props.type !== "value"
               && m_axisCore
               && m_axisCore.cleanLabelAreas)
            {
                m_axisCore.cleanLabelAreas();
            }
        };

        axis.mouseup = function(target){
            if(m_props.enableLabelSelection && m_props.type !== "value")
            {
                m_axisCore.mouseup(target);
            }
        };
        
        axis.mousedown = function(target){
            if(m_props.enableLabelSelection && m_props.type !== "value")
            {
                m_axisCore.mousedown(target);
            }
        };
                        
        axis.size = function(_size) {
            if (arguments.length == 0)
                return {
                           "width" : m_width,
                           "height": m_height,
                       };
            m_width = _size.width;
            m_height = _size.height;
            return axis;
        };
        
        /*
         * Jimmy/9/22/2012 if axis works under independentMode(boxplot for now)
         * it doesn't rely on the data passed through this API from container, instead, boxplot
         * will pass calculated data through dependency 
         */
        axis.independentData = function(_data) {
          if(m_props.isIndependentMode) {
            if (arguments.length == 0)
                return m_data;
            m_data = _data;
          }
        },

        axis.data = function(_data) {
            if (arguments.length == 0)
                return m_data;
            
            if(!m_props.isIndependentMode)
            {
              m_data = _data;
              if(_data.getAnalysisAxisDataByIdx)
              {
                m_dataAxis = m_data.getAnalysisAxisDataByIdx(0);
              }
            }
            return axis;
        };

        axis.title = function(_title) {
            if (arguments.length == 0)
                return m_title;
            m_title = _title;
            return axis;
        };

        axis.properties = function(_properties) {
            if (arguments.length == 0){
                return m_props;
            }
            var scaleRangeMinNaN = false,
                scaleRangeMaxNaN = false;
            if (_properties.scale && _properties.scale.fixedRange) {
                scaleRangeMinNaN = isNaN(Number(_properties.scale.minValue));
                scaleRangeMaxNaN = isNaN(Number(_properties.scale.maxValue));
            }

            Objects.extend(true, m_props, _properties);

            if (scaleRangeMinNaN) {
                m_props.scale.minValue = NaN;
            }
            if (scaleRangeMaxNaN) {
                m_props.scale.maxValue = NaN;
            }

            if(_properties.color)
            {
                m_props.customizedColor = _properties.color;
            }

            if (_properties.label && _properties.label.formatString && TypeUtils.isArray(_properties.label.formatString)) {
              if (TypeUtils.isArray(_properties.label.formatString[0])) {
                m_props.label.formatString = _properties.label.formatString[0][0];
              }
            }
            return axis;
        };

        axis.range = function() {
            var range = null,
                max = Number(m_props.scale.maxValue),
                min = Number(m_props.scale.minValue);
            if ((m_props.type === "value") && (m_props.scale.fixedRange)) {
                if (isNaN(max) || isNaN(min) || max>min) {
                    range = {
                        max : max,
                        min : min,
                        from : 'axis'
                    }; 
                }
            }
            return range;
        }

        axis.scale = function(_scale) {
            if (arguments.length == 0)
                return m_scale;

            m_scale = _scale;
            return axis;
        };

        axis.isDrawBody = function(_isDrawBody) {
            if (arguments.length == 0)
                return m_isDrawBody;

            m_isDrawBody = _isDrawBody;
            return axis;
        };

        axis.color = function(_color) {
          if (arguments.length == 0)
              return m_props.color;
          if (_color !== undefined){
            m_props.isAxisColorFixed = true;
          }
          if (m_props.customizedColor){
            _color = m_props.customizedColor;              
          }
          if(!_color){
              _color = m_defaultColor;
          }

          m_props = Objects.extend(true, m_props, {"color":_color});

          if (m_props.title.applyAxislineColor && _color) {
            m_style.realStyle.title.fill = _color;
            m_style.defaultStyle.title.fill = _color;
          }

          return axis;
        };

        axis.drawable = function(_drawable) {
            //drawable or not because of smart layout
            if (arguments.length == 0)
                return m_drawable;

            m_drawable = _drawable;

            return axis;
        };

        axis.getPreferredSize = function() {
            getThemeStyleDef();
            var rangeArray = [0];
            var domainArray = [0];
            if(m_scale)
            {
                rangeArray = m_scale.range();
                domainArray = m_scale.domain();
            }

            if(!m_scale || (!drawAll()) )            
            {
                return {
                    width : 0,
                    height : 0,
                    manual: false,
                };
            }
            else {
                //body size && title size
                var reCS = getCoreAndScale();
                var axisCore = (reCS.core)()
                              .properties(m_props)
                              .style(m_style)
                              .position(m_props.position)
                              .axScale(reCS.coreScale)
                              .spaceLimit(m_spaceLimit);
                
                var title = buildAxisTitle();
                var resultSize;
                
                
                var titleHeight = 0;
                var titleWidth = 0;
                var titleOffset = 0;
                var axisSpacings = [];

                var sizeCore = axisCore.getPreferredSize();

                
                if(m_props.position == "bottom" || m_props.position == "top")
                {
                    if(!drawBody())
                    {
                        sizeCore.height = 0;
                        sizeCore.spacings = [];
                    }

                    if(m_props.title.visible && m_props.visible)
                    {
                        //title is vertical
                        if(title !== undefined && title !== null && title !== '') {
                            titleHeight = fastMeasure(title, m_style.realStyle.title).height;
                        } else {
                            titleHeight = 0;
                        }
                        titleOffset = titleHeight == 0 ? 0 : m_titleOffset;
                    }

                    var titleSpace = titleHeight + titleOffset;
                    axisSpacings = axisSpacings.concat([titleSpace]);
                    axisSpacings = axisSpacings.concat(sizeCore.spacings);
                    if (m_props.position == "bottom" && UADetector.isMobile() && m_props.indicator.enable) {
                        axisSpacings = axisSpacings.concat([indicatorOffset + indicatorScrollbarHeight + indicatorScrollbarBorderWidth * 2]);
                    }

                    var bodySpace = 0;
                    for(var i = 1; i < axisSpacings.length; i++)
                    {
                        bodySpace += axisSpacings[i];
                    }

                    var fullHeight = titleSpace + bodySpace;
                    var realHeight = fullHeight;
                    
                    if(m_spaceLimit >= 0 && m_spaceLimit < fullHeight)
                    {
                        realHeight = sizeCore.height;//no title
                    }

                    resultSize = {
                        maxSizeConstant : 1 / 3,
                        width: sizeCore.width,
                        height: fullHeight,
                        realHeight: realHeight,
                        spacings: axisSpacings,
                        manual: false,
                        minTruncateSize : sizeCore.minTruncateSize
                    }
                }
                else if(m_props.position == "left" || m_props.position == "right")
                {
                    if(!drawBody())
                    {
                        sizeCore.width = 0;
                        sizeCore.spacings = [];
                    }

                    if(m_props.title.visible && m_props.visible)
                    {
                        //title is vertical
                        if(title !== undefined && title !== null && title !== '') {
                            titleWidth = fastMeasure(title, m_style.realStyle.title).height;
                        } else {
                            titleWidth = 0;
                        }
                        titleOffset = titleWidth == 0 ? 0 : m_titleOffset;
                    }

                    var titleSpace = titleWidth + titleOffset;
                    axisSpacings = axisSpacings.concat([titleSpace]);
                    axisSpacings = axisSpacings.concat(sizeCore.spacings);
                    if (m_props.position == "left" && UADetector.isMobile() && m_props.indicator.enable) {
                        axisSpacings = axisSpacings.concat([indicatorOffset + indicatorScrollbarHeight + indicatorScrollbarBorderWidth * 2]);
                    }

                    var bodySpace = 0;
                    for(var i = 1; i < axisSpacings.length; i++)
                    {
                        bodySpace += axisSpacings[i];
                    }

                    var fullWidth = bodySpace + titleSpace;
                    var realWidth = fullWidth;
                    
                    if(m_spaceLimit >= 0 && m_spaceLimit < fullWidth)
                    {
                        realWidth = sizeCore.width;//no title
                    }
                    

                    resultSize = {
                        maxSizeConstant : 1 / 3,
                        width: fullWidth,
                        realWidth: realWidth,
                        height: sizeCore.height,
                        spacings: axisSpacings,
                        manual: false,
                        minTruncateSize : sizeCore.minTruncateSize
                    };
                }
                if ((m_props.type == 'category') && (m_props.layoutInfo.width > 0) && (m_props.layoutInfo.height > 0) ) {
                    resultSize.width = m_props.layoutInfo.width;
                    resultSize.realWidth = m_props.layoutInfo.width;
                    resultSize.height = m_props.layoutInfo.height;
                    resultSize.realHeight = m_props.layoutInfo.height;
                    resultSize.manual = true;
                }
                
                VizObjects.normalizeNumbersCeil(resultSize);
                return resultSize;
            }
        };

        axis.dispatch = function(_){
          if(!arguments.length)
            return eDispatch;
          eDispatch = _;return axis;
        };
        
        axis.destroy = function() {
            //destroy ctx
            if(ctx){
              ctx.destroy();
              ctx = null;
            }
            //sub destroy
            if(m_axisCore && m_axisCore.destroy){
              m_axisCore.destroy();
            }
            m_vClassNames = null;
            m_matrix.destroy();
            m_matrix = null;
            //self destroy
            parent = null;
            m_axisCore = null;
            m_dataAxis = null;
            m_data = null;
            if(m_scale){
              m_scale.domain([0,1]).range([0,1]);
            }
            m_scale = null;
        };
        
        var fastMeasure = function(_text, _style)
        {
            return TextUtils.superFastMeasure(_text, _style['font-size'],
                                                _style['font-weight'],
                                                _style['font-family']);
        };

        //Alex Su: to build a hierarchical structure basing on raw data.
        function hasMND(data){
          if (data[0].type === 'MND' || data[data.length - 1].type === 'MND'){
            return true;
          } else {
            return false;
          }
        }
        
        function hasOnlyMND(data){
          if (data.length === 1 && data[0].type === 'MND'){
            return true;
          } else {
            return false;
          }
        }
        
        function isMNDBefore(data){
          if (data[0].type === 'MND'){
            return true;
          } else {
            return false;
          }
        }
        
        function getMNDData(data){
          if (! hasMND(data)){
            return;
          }
          if (isMNDBefore(data)){
            return data[0];
          } else {
            return data[data.length - 1];
          }
        }
        
        function processRawData(data){
          if (! hasMND(data) || hasOnlyMND(data)){
            return data;
          }
          var newData = [];
          var i, j, k;
          for (i = 0; i < data.length; ++i){
            newData.push({
              col: data[i].col,
              rows: []
            });
          }
          var mndData = getMNDData(data);
          var mndLength = mndData.rows.length;
          var cateLength;
          if (isMNDBefore(data)){
            cateLength = data[1].rows.length;
            for (i = 0; i < mndLength; ++i){
              for (j = 0; j < cateLength; ++j){
                newData[0].rows.push(data[0].rows[i]);
              }
            }
            for (i = 1; i < data.length; ++i){
              for (j = 0; j < mndLength; ++j){
                //deep copy objects
                for(k = 0; k < data[i].rows.length; k++){
                  var itemDeepCopy = Objects.extend(true, {}, data[i].rows[k]);
                  newData[i].rows.push(itemDeepCopy);
                }
              }
            }
            //add the parent ctx to newData items
            for (i = 1; i < newData.length; ++i){
              for (j = 0; j < newData[i].rows.length; ++j){
                var parentCtx = newData[0].rows[j].ctx;
                var selfCtx = newData[i].rows[j].ctx;

                //merge ctx
                selfCtx = Objects.extend(true, selfCtx, parentCtx);
                newData[i].rows[j].ctx = selfCtx;
              }
            }
          } else {
            cateLength = data[0].rows.length;
            for (i = 0; i < cateLength; ++i){
                var iItem;
                var mNum = data[data.length - 1].rows.length;
                for(iItem = 0; iItem < mNum; iItem++)
                {
                    newData[newData.length - 1].rows.push(Objects.extend(true, {}, data[data.length - 1].rows[iItem]));

                    //add the parent ctx to rows items
                    if(data.length >= 2)
                    {
                        var parentCtx = data[data.length - 2].rows[i].ctx;
                        var selfCtx = Objects.extend(true, {}, data[data.length - 1].rows[iItem].ctx);

                        //merge ctx with data[data.length - 2].rows[i]
                        selfCtx = Objects.extend(true, selfCtx, parentCtx);
                        newData[newData.length - 1].rows[i*mNum + iItem].ctx = selfCtx;
                    }
                }
            }

            for (i = 0; i < data.length - 1; ++i){
              for (j = 0; j < cateLength; ++j){
                for (k = 0; k < mndLength; ++k){
                  newData[i].rows.push(data[i].rows[j]);
                }
              }
            }
          }
          return newData;
        }
        
        function buildHierarchicalData(data){
          var i,j;
          var categoryHierarchicalData = [];
          var rowData, cellData, spaceCount;
          var tempCellCount, tempSpaceCount;
          for (i = 0; i < data.length; ++i){
            rowData = [];
            spaceCount = 0;
            tempSpaceCount = 0;
            tempCellCount = 0;
            var tempLabelContexts = [];
            for (j = 0; j < data[i].rows.length; ++j){
              cellData = {};
              if (i === data.length - 1){
                cellData.value = data[i].rows[j];
                cellData.space = 1;
              } else {
                ++spaceCount;
                ++tempSpaceCount;
                if (i > 0 && tempSpaceCount >= categoryHierarchicalData[i - 1][tempCellCount].space){
                  cellData.value = data[i].rows[j];
                  cellData.space = spaceCount;
                  spaceCount = 0;
                  tempSpaceCount = 0;
                  ++tempCellCount;
                }
                else {
                  if (j + 1 < data[i].rows.length && data[i].rows[j].val === data[i].rows[j + 1].val){

                    if(data[i].rows[j].ctx)
                    {
                        tempLabelContexts.push(data[i].rows[j].ctx);
                    }

                    if(data[i].rows[j].contexts)
                    {
                        tempLabelContexts = tempLabelContexts.concat(data[i].rows[j].contexts);
                    }
                    continue;
                  }
                  else {
                    cellData.value = data[i].rows[j];
                    cellData.space = spaceCount;
                    spaceCount = 0;                  
                  }
                }                
              }

              if(data[i].rows[j].ctx)
              {
                tempLabelContexts.push(data[i].rows[j].ctx);
              }

              if(data[i].rows[j].contexts)
              {
                  tempLabelContexts = tempLabelContexts.concat(data[i].rows[j].contexts);
              }

              cellData.value.labelContexts = tempLabelContexts;
              rowData.push(cellData);
              tempLabelContexts = [];
            }
            categoryHierarchicalData.push(rowData);
          }
          return categoryHierarchicalData;
        }
                
        function processData(data){
          var newData = processRawData(data);
          var hierarchicalData = buildHierarchicalData(newData);
          return hierarchicalData;
        }
        
        function reverseHierarchicalData(hData){
          for (var i = 0; i < hData.length; ++i){
            hData[i].reverse();
          }
        }
        
        var getCoreAndScale = function()
        {
            var re = { };
            var core;
            var coreScale;
            if(m_props.type == "category") //a new scale is required
            {
                coreScale = [];
                //build labels (domain)
                var dataset = [];
                if(m_props.isIndependentMode) {
                    for(dataObj in m_data) {
                        dataset = m_data[dataObj].values;
                    }
                } else {
                    if(m_dataAxis) {
                        dataset = m_dataAxis.values;
                    }
                }
                var hierarchicalData = [];
                if (dataset && dataset.length){
                  hierarchicalData = processData(dataset);
                }
                //reverse domain or not,
                var oRange = m_scale.range();
                //by yuanhao 2012-12-17 ,
                if(oRange[0] > oRange[oRange.length -1 ])
                {
                    reverseHierarchicalData(hierarchicalData);
                }
                //if orRangeBand is 0, which means module do not use ordinal scale like normal, the scale is not equal every unit.
                var dataCount = hierarchicalData.length === 0 ? 0 : hierarchicalData[hierarchicalData.length - 1].length;
                var orRangeBand = m_scale.rangeBand(), orRangeBands = [];
                
                //Alex Su. Handling for boxplot.
                var isBoxPlotWithSingleAAFeed = false;
                if (dataset && dataset.length > 0 && dataset[0].rows.length === 0){
                  isBoxPlotWithSingleAAFeed = true;
                  dataCount = 1;
                  var cellData = {
                      value: {},
                      space: 1
                  };
                  
                  //add ctxs
                  var ctxs = [];
                  if(m_dataAxis.values)
                  {
                      var iItem;
                      for(iItem = 0; iItem < m_dataAxis.values[0].rows.length; iItem++)
                      {
                          ctxs.push(m_dataAxis.values[0].rows[iItem].ctx);
                      }
                  }

                  cellData.value = {
                      val: !m_dataAxis.values ? null : m_dataAxis.values[0].col.val,
                      labelContexts: ctxs
                  };
                  
                  hierarchicalData = [[cellData]];
                }
                
                var di;
                if(!m_scale.noEqual){
                  if (! hasOnlyMND(dataset) && ! isBoxPlotWithSingleAAFeed){
                    for(di = 0; di < dataCount; di++){
                        orRangeBands[di] = orRangeBand;
                    }
                  } else {
                    var tickSpace = parseInt(oRange.length / dataCount, 10);
                    for(di = 0; di < dataCount; di++){
                      orRangeBands[di] = orRangeBand * tickSpace;
                    }
                  }
                }else{
                  for(di = 0; di < dataCount; di++){
                      orRangeBands[di] = Math.abs(oRange[di] - oRange[di+1]);
                  }
                }
                
                function getRangeEnd(rangeStart, startIndex, spaceCount){
                    var sum = rangeStart;
                    for(var ix = 0; ix < spaceCount; ix++){
                        sum +=orRangeBands[startIndex + ix];
                    }
                    return sum;
                }
                var coreScaleItem = {};
                var cgDomain = [];
                var cgRange = [];
                var i, j, spaceCount = 0;
                var startIndex;
                var rangeStart, rangeEnd;
                for (i = 0; i < hierarchicalData.length; ++i){
                  cgDomain = [];
                  cgRange = [];
                  spaceCount = 0;
                  startIndex = 0;
                  for (j = 0; j < hierarchicalData[i].length; ++j){
                    spaceCount = 0;
                    cgDomain.push(hierarchicalData[i][j].value);
                    
                    spaceCount += hierarchicalData[i][j].space;
                    rangeStart = j > 0 ? cgRange[j - 1][1] : 0;
                    rangeEnd = getRangeEnd(rangeStart, startIndex, spaceCount);
                    startIndex += spaceCount;

                    cgRange.push([rangeStart, rangeEnd]);
                  }
                  var coreScaleItem = { 
                      "domain": cgDomain, 
                      "range":  cgRange,
                   };
       
                  coreScale.push(coreScaleItem);//add to the latest
                }
                
                core = categoryAxisCore;
            }
            else //value axis
            {   
                core = valueAxisCore;
                coreScale = m_scale;
            }
            re.core = core;
            re.coreScale = coreScale;
            re.coreScale.noEqual = m_scale.noEqual;
            return re;
        }
        
        function prepareProperties()
        {
            if (!m_effectManager) return;

            if(m_props.customizedColor) {
                m_props.color = m_props.customizedColor;
            }
            var parameter = {
                    drawingEffect : 'normal',
                    fillColor : m_props.color,
            };
            m_props.color = m_effectManager.register(parameter);

            parameter = {
                drawingEffect : 'normal',
                fillColor : m_props.gridline.color,
            };
            m_props.gridline.color = m_effectManager.register(parameter);
            
            parameter = {
                    drawingEffect : 'normal',
                    fillColor : m_style.defaultStyle.label.fill,
            };
            m_style.defaultStyle.label.fill = m_effectManager.register(parameter);

            parameter = {
                    drawingEffect : 'normal',
                    fillColor : m_style.defaultStyle.title.fill,
            };
            m_style.defaultStyle.title.fill = m_effectManager.register(parameter);
        }

        return axis;
    };
  return ret;
});

define('sap/viz/modules/axis',['sap/viz/base/utils/oo',
'sap/viz/modules/Base',
'sap/viz/modules/dispatch',
'sap/viz/modules/axis/regularAxis'],
function Setup(oo, Base, dispatch, regularAxis) {


    var axis = function(manifest, ctx) {
        axis.superclass.constructor.apply(this,arguments);

        this._axis_regularAxisModule = regularAxis(manifest, ctx);

        axis.prototype.initCustomFunList(axis);
        axis.prototype.initRegularAxis(this._axis_regularAxisModule, axis);
    };

    axis.prototype.initCustomFunList = function()
    {
        if(axis.prototype._axis_customFunList)
        {
            return;
        }
        else
        {
            axis.prototype._axis_customFunList = [];
            var propFunction;
            for (propFunction in this)
            {
                if( this.hasOwnProperty( propFunction ) ) 
                {
                    if(typeof(this[propFunction]) === "function")
                    {
                        axis.prototype._axis_customFunList.push(propFunction);
                    }
                } 
            }
        }
    };

    axis.prototype.initRegularAxis = function(regularAxis, self)
    {
        var propFunction;        
        for (propFunction in regularAxis)
        {
            if( regularAxis.hasOwnProperty( propFunction ) ) 
            {
                if(typeof(regularAxis[propFunction]) === "function")
                {
                    if( axis.prototype._axis_customFunList &&
                        axis.prototype._axis_customFunList.indexOf(propFunction) < 0)
                    {
                        self.prototype[propFunction] = regularAxis[propFunction];
                    }
                }
            } 
        }
    };
    
    //the start point

    //please note regularAxis,valueAxisCore and categoryAxisCore do not inherit any object.
    //they will be used independently.
    oo.extend(axis,Base);

    //functions here have higher Priority than functions in initRegularAxis
    axis.prototype.render = function(selection)
    {
        return this._axis_regularAxisModule(selection);
    };
    
    //sample overwritten fun
    //axis.prototype.data = function(selection)
    //{
    //    return null;
    //};

    return axis;
});

define('sap/viz/util/ColorSeriesGenerator',['sap/viz/modules/Constants'],
function Setup(constants) {
    var ColorSeriesGenerator = {
      /**
       * return d3 ordinal scale of sap standard color palette 
       */
      sap32 : function(){
      return d3.scale.ordinal().range(constants.COLOR.SAPColorSingleAxis);
      },
      sap32dualaxis1 : function(){
            return d3.scale.ordinal().range(constants.COLOR.SAPColorDualAxis1);
        },
        sap32dualaxis2 : function(){
            return d3.scale.ordinal().range(constants.COLOR.SAPColorDualAxis2);
        }      
    };

    return ColorSeriesGenerator;
});
define('sap/viz/util/ShapeSeriesGenerator',[],
function Setup(){
  var ShapeSeries = {
    sapShapes : function(){
      return d3.scale.ordinal().range(['circle', 'diamond', 'triangleUp', 'triangleDown', 'triangleLeft', 'triangleRight', 'cross', 'intersection']);
    }
  };
  return ShapeSeries;
});
define('sap/viz/util/Scaler',['sap/viz/util/NumberUtils'],

function Setup(NumberUtils) {
    
    var Scaler = {


        getRoughTickNum : function (_scale, _roughTickNum) 
        {
            var const_minTickNum = 2;
            var roughTickNum = -1;

            if(!_roughTickNum || _roughTickNum < const_minTickNum) {
                var rangeArray = _scale.range();
                var rangeLen = Math.abs(rangeArray[0] - rangeArray[rangeArray.length-1]);
                if(rangeLen > 10) {
                    roughTickNum = const_minTickNum + Math.round(rangeLen/100);
                } else {
                    roughTickNum = const_minTickNum;
                }
            } else {
                roughTickNum = _roughTickNum;
            }
            _scale.tickHint = roughTickNum;
            return roughTickNum;
        },
		
        toFixedNumber : function(item)
        {
            if((typeof item) === "object" && item.length)
            {
                for(var i = 0; i <= (item.length - 1); i++)
                {
                    if((typeof item[i]) === "number")
                    {
                        item[i] =  NumberUtils.precise( item[i]);
                    }
                }
            }
            else if((typeof item) === "number")
            {
                item =  NumberUtils.precise( item );
            }
            return item;
        },		

        adjustGap : function(scaleGap, scale)
        {
            var domainArray = scale.domain();
            var rangeArray = scale.range();

            var rangeLen = Math.abs(rangeArray[0] - rangeArray[rangeArray.length-1]);
            var domainLen = Math.abs(domainArray[0] - domainArray[domainArray.length-1]);

            var gapRadio = scaleGap/rangeLen;
            var domainGap = domainLen * gapRadio;

            if(domainArray[0] > domainArray[domainArray.length-1])
            {
                domainArray[0] += domainGap;
                domainArray[domainArray.length-1] -= domainGap;
            }
            else
            {
                domainArray[0] -= domainGap;
                domainArray[domainArray.length-1] += domainGap;
            }

            scale.domain(domainArray);
        },
        
        /**
         * @param _scale
         *        d3 quantitative scale
         *                
         * @param _roughTickNum
         *        rough tick number
         *                
         * @param _accurateTickNum
         *        accurate tick number
         *
         * @returns d3 quantitative scale which can be divided by ticks perfectly
         */
        perfect : function(_scale, _roughTickNum, _accurateTickNum)
        {
            var qScale = _scale.nice();

            //the function may change the domain, but never change the range.
            var const_minTickNum = 2;
            var const_extendNum = 100;

            var domainArray = _scale.domain();
            domainArray = this.toFixedNumber(domainArray);

            var originalDomainBegin = domainArray[0];
            var originalDomainEnd = domainArray[domainArray.length-1];

            //if the domain is [0,0], we change it to [0,100]
            //if the domain is [-x,-x], we change it to [-x,0]
            //if the domain is [x,x], we change it to [x,0]
            //we do this in modules
            var roughTickNum = -1;
            var accurateTickNum = -1;

            if(!_accurateTickNum || _accurateTickNum < const_minTickNum) {
                roughTickNum = this.getRoughTickNum(_scale, _roughTickNum);
            } else {
                accurateTickNum = _accurateTickNum;
            }

            if(accurateTickNum < 0)
            {
                var ticks = qScale.ticks(roughTickNum);
                ticks = this.toFixedNumber(ticks);

                var adjustDomain = true;
                var distance;
                if(ticks.length === 0)
                {
                    adjustDomain = false;
                }
                else if(ticks.length > 1)
                {
                    distance = ticks[1] - ticks[0];//>0
                }
                else//ticks.length==1
                {
                    var beginDis = Math.abs(domainArray[0] - ticks[0]);//>0
                    var endDis = Math.abs(domainArray[domainArray.length - 1] - ticks[0]);//>0
                    if(beginDis > endDis)
                    {
                        distance = beginDis;
                    }
                    else
                    {
                        distance = endDis;
                    }
                }
                
                var realTickNum = const_minTickNum;
                if(adjustDomain)
                {
                    realTickNum = ticks.length;
                    if(domainArray[0] < domainArray[1])
                    {
                        if(ticks[0] != domainArray[0])
                        {
                            domainArray[0] = ticks[0] - distance;
                            realTickNum++;
                        }

                        if(ticks[ticks.length -1] != domainArray[domainArray.length - 1])
                        {
                            domainArray[domainArray.length - 1] = ticks[ticks.length - 1] + distance;
                            realTickNum++;
                        }
                    }
                    else
                    {
                        if(ticks[0] != domainArray[domainArray.length - 1])
                        {
                            domainArray[domainArray.length - 1] = ticks[0] - distance;
                            realTickNum++;
                        }

                        if(ticks[ticks.length -1] != domainArray[0])
                        {
                            domainArray[0] = ticks[ticks.length - 1] + distance;
                            realTickNum++;
                        }
                    }
                }

                qScale.tickNum = realTickNum;
                qScale.distance = distance;
                qScale.tickHint = realTickNum - 1;

                //to nice the domainArray, avoid the domain contains 0.00060000001
                domainArray[0] = this.toFixedNumber(domainArray[0]);
                domainArray[domainArray.length - 1] = this.toFixedNumber(domainArray[domainArray.length - 1]);
                qScale.domain(domainArray);
                
            }
            else
            {
                //accurateTickNum:
                //1. use it as roughTickNum. 
                //2. adjust the ticNum or not
                this.perfect(qScale, accurateTickNum);
                if(qScale.tickNum > accurateTickNum)
                {
                    //try to make sure qScale.tickNum < accurateTickNum
                    var tempNum = accurateTickNum;
                    for(;tempNum >= const_minTickNum;)
                    {
                        tempNum--;
                        this.perfect(qScale, tempNum);
                        if(qScale.tickNum <= accurateTickNum)
                        {
                            break;
                        }
                    }
                }
                
                //adjust the domain
                if(qScale.tickNum < accurateTickNum)
                {
                    var tickNumToAdd = (accurateTickNum - qScale.tickNum);
                    var domainArray = qScale.domain();
                    //var originalDomainBegin 
                    //var originalDomainEnd

                    for(;tickNumToAdd > 0;)
                    {
                        if(domainArray[0] < domainArray[1])
                        {
                            if(Math.abs(domainArray[1] - originalDomainEnd) > Math.abs(originalDomainBegin - domainArray[0]))
                            {
                                domainArray[0] -= qScale.distance;
                            }
                            else
                            {
                                domainArray[1] += qScale.distance;
                            }
                            tickNumToAdd--;
                            qScale.tickNum++;
                        }
                        else
                        {
                            if(Math.abs(domainArray[1] - originalDomainEnd) > Math.abs(originalDomainBegin - domainArray[0]))
                            {
                                domainArray[0] += qScale.distance;
                            }
                            else
                            {
                                domainArray[1] -= qScale.distance;
                            }
                            tickNumToAdd--;
                            qScale.tickNum++;
                        }
                    }
                    
                    qScale.tickHint = qScale.tickNum - 1;
                    //to nice the domainArray, avoid the domain contains 0.00060000001
                    domainArray[0] =  NumberUtils.precise( domainArray[0]);
                    domainArray[domainArray.length - 1] =  NumberUtils.precise( domainArray[domainArray.length - 1]);
                    qScale.domain(domainArray);
                    
                }
            }
            qScale.perfectDomainBegin = domainArray[0];
            qScale.perfectDomainEnd = domainArray[domainArray.length-1];
            return qScale;
        },
        
        /**
         * @param _scaleA
         *        d3 linear scale
         *                
         * @param _scaleB
         *        d3 linear scale
         */
        perfectDual : function(_scaleA, _scaleB) {

            this.perfect(_scaleA);
            this.perfect(_scaleB);
            
            var domainArrayA = _scaleA.domain();
            var domainArrayB = _scaleB.domain();

            var rangeArrayA = _scaleA.range();
            var rangeArrayB = _scaleB.range();

            if( (domainArrayA[0] > domainArrayA[domainArrayA.length-1]
                && domainArrayB[0] < domainArrayB[domainArrayB.length-1])
                ||
                (domainArrayA[0] < domainArrayA[domainArrayA.length-1]
                && domainArrayB[0] > domainArrayB[domainArrayB.length-1])
                ||
                (domainArrayA[0] < 0
                && domainArrayA[domainArrayA.length-1] < 0)
                ||
                (domainArrayB[0] < 0
                && domainArrayB[domainArrayB.length-1] < 0)
                ||
                (domainArrayA[0] > 0
                && domainArrayA[domainArrayA.length-1] > 0)
                ||
                (domainArrayB[0] > 0
                && domainArrayB[domainArrayB.length-1] > 0)
                || 
                ( Math.abs(rangeArrayA[0] - rangeArrayA[rangeArrayA.length-1])
                != Math.abs(rangeArrayB[0] - rangeArrayB[rangeArrayB.length-1]) )
              )
            {
                //we do not need to do anythings to support this "dual"
                return;
            }

            //now make sure 
            //1. same tickNum before 0
            //2. same tickNum after 0
            var positiveTickNumA = 0;
            var negativeTickNumA = 0;

            var positiveTickNumB = 0;
            var negativeTickNumB = 0;

            var tickNumA = _scaleA.tickNum; //tickNumA >= const_minTickNum
            var tickNumB = _scaleB.tickNum; //tickNumB >= const_minTickNum

            var intervalA = (domainArrayA[domainArrayA.length-1] - domainArrayA[0])/(tickNumA-1);
            intervalA =  NumberUtils.precise( intervalA );

            for(var i = 0; i < tickNumA; i++)
            {
                var tickValue = domainArrayA[0] + i * intervalA;
                if(tickValue > 0)
                {
                    positiveTickNumA++;
                }
                else if(tickValue < 0)
                {
                    negativeTickNumA++;
                }
            }

            var intervalB = (domainArrayB[domainArrayB.length-1] - domainArrayB[0])/(tickNumB-1);
            intervalB =  NumberUtils.precise( intervalB);

            for(var i = 0; i < tickNumB; i++)
            {
                var tickValue = domainArrayB[0] + i * intervalB;
                if(tickValue > 0)
                {
                    positiveTickNumB++;
                }
                else if(tickValue < 0)
                {
                    negativeTickNumB++;
                }
            }

            if(positiveTickNumA > positiveTickNumB)
            {
                var moreInterNum = positiveTickNumA - positiveTickNumB;
                if(domainArrayB[0] < domainArrayB[domainArrayB.length-1])
                {
                    domainArrayB[domainArrayB.length-1] += (moreInterNum * Math.abs(intervalB));
                    _scaleB.tickNum += moreInterNum;
                }
                else if(domainArrayB[0] > domainArrayB[domainArrayB.length-1])
                {
                    domainArrayB[0] += (moreInterNum * Math.abs(intervalB));
                    _scaleB.tickNum += moreInterNum;
                }
            }
            else if(positiveTickNumA < positiveTickNumB)
            {
                var moreInterNum = positiveTickNumB - positiveTickNumA;
                if(domainArrayA[0] < domainArrayA[domainArrayA.length-1])
                {
                    domainArrayA[domainArrayA.length-1] += (moreInterNum * Math.abs(intervalA));
                    _scaleA.tickNum += moreInterNum;
                }
                else if(domainArrayA[0] > domainArrayA[domainArrayA.length-1])
                {
                    domainArrayA[0] += (moreInterNum * Math.abs(intervalA));
                    _scaleA.tickNum += moreInterNum;
                }
            }

            //negative values
            if(negativeTickNumA > negativeTickNumB)
            {
                var moreInterNum = negativeTickNumA - negativeTickNumB;
                if(domainArrayB[0] < domainArrayB[domainArrayB.length-1])
                {
                    domainArrayB[0] -= (moreInterNum * Math.abs(intervalB));
                    _scaleB.tickNum += moreInterNum;
                }
                else if(domainArrayB[0] > domainArrayB[domainArrayB.length-1])
                {
                    domainArrayB[domainArrayB.length-1] -= (moreInterNum * Math.abs(intervalB));
                    _scaleB.tickNum += moreInterNum;
                }
            }
            else if(negativeTickNumA < negativeTickNumB)
            {
                var moreInterNum = negativeTickNumB - negativeTickNumA;
                if(domainArrayA[0] < domainArrayA[domainArrayA.length-1])
                {
                    domainArrayA[0] -= (moreInterNum * Math.abs(intervalA));
                    _scaleA.tickNum += moreInterNum;
                }
                else if(domainArrayA[0] > domainArrayA[domainArrayA.length-1])
                {
                    domainArrayA[domainArrayA.length-1] -= (moreInterNum * Math.abs(intervalA));
                    _scaleA.tickNum += moreInterNum;
                }
            }

            //to nice the domainArray, avoid the domain contains 0.00060000001
            domainArrayA[0] = NumberUtils.precise( domainArrayA[0]);
            domainArrayA[1] = NumberUtils.precise( domainArrayA[1]);
            domainArrayB[0] = NumberUtils.precise( domainArrayB[0]);
            domainArrayB[1] = NumberUtils.precise( domainArrayB[1]);
            
            _scaleA.domain(domainArrayA);
            _scaleB.domain(domainArrayB);

            _scaleA.tickHint = _scaleA.tickNum -1;
            _scaleB.tickHint = _scaleB.tickNum -1;
        }
    };
    
    return Scaler;
});
define('sap/viz/modules/util/tooltipDataHandler',['sap/viz/data/feed/feeder','sap/viz/lang/langManager','sap/viz/modules/Constants'],
function Setup(feeder, langManager, Constants) {
  var tooltipDataHandler = function() {
    var _buffer = [];

    var my = {};

    var defaultString = langManager.get('IDS_ISNOVALUE');

    var handleNull = function(_) {
      if (_ === null || _ === undefined) {
        return defaultString;
      } else {
        return _;
      }
    };

    /**
     * 
     * @param data
     * @param seriesData
     * @param aai1
     * @param colorPalette
     * @param shapePalette
     * @param postProcess
     *          {Function} you can round the data or other thing.
     * @returns TOOD: add desc
     */
    my.generateTooltipData = function(data, seriesData, aai1, colorPalette,
        shapePalette, postProcess) {

      var parseFeedsData = function(data) {
        var barGroupValue;
        var isStacked = false;
        if (seriesData[aai1][0] !== undefined && seriesData[aai1][0].length > 0) {
          barGroupValue = d3.merge([ seriesData[aai1][0], seriesData[aai1][1] ]);
          isStacked = true;
        } else {
          barGroupValue = seriesData[aai1];
        }

        var tooltipData = {
          'body' : [],
          'footer' : []
        };
        var valueLength = barGroupValue.length;
        var isDual = false;
        var division = 0;
        var mvgData = [data.getMeasureValuesGroupDataByIdx(0), data.getMeasureValuesGroupDataByIdx(1)];
        var aaData = [data.getAnalysisAxisDataByIdx(0), data.getAnalysisAxisDataByIdx(1)];
        var MNDHandler = mndHandler(aaData);
        
        if (mvgData[0] && mvgData[1]) {
          isDual = true;
          division = mvgData[0].values.length;
        }
        var isMNDbeforeCate = false;
        var MNDLength;
        var i = 0, j = 0, k = 0,len;
        var measureIndex;
        var body;
        var valueIndex;
        var itemLabel;
        var item;
        var footer;
        var ctx = {path:{}};

        if (!MNDHandler.hasMNDonCate && !MNDHandler.hasMNDonColor) {
          // MND does not feed on either category or color

          if (aaData[1]) {
            measureIndex = 0;
            if (mvgData[0]) {
              for ( i = 0; i < mvgData[0].values.length; ++i) {
                if (mvgData[0].values[i].rows.length > 0) {
                  ctx = {path:{}};
                  ctx.path.mg = mvgData[0].values[i].rows[0][0].ctx.path.mg;
                  ctx.path.mi = mvgData[0].values[i].rows[0][0].ctx.path.mi;
                }
                body = {
                  'name' : handleNull(mvgData[0].values[i].col),
                  'val' : [],
                  'ctx' : ctx
                };
                for ( j = 0, len = mvgData[0].values[i].rows.length; j < len; ++j) {
                  valueIndex = measureIndex * len + j;
                  itemLabel = [];
                  for ( k = 0; k < aaData[1].values.length; ++k) {
                    itemLabel.push(aaData[1].values[k].rows[j]);
                  }
                  item = {
                    'shape' : shapePalette[valueIndex % shapePalette.length],
                    'color' : colorPalette[valueIndex % colorPalette.length],
                    'label' : itemLabel,
                    'value' : barGroupValue[valueIndex].val === ' ' ? defaultString
                        : postProcess === undefined ? handleNull(barGroupValue[valueIndex].val)
                            : postProcess(barGroupValue[valueIndex].val),
                     'valueAxis' : 0
                  };
                  body.val.push(item);
                }
                tooltipData.body.push(body);
                ++measureIndex;
              }
            }
            // for dual chart
            if (mvgData[1]) {
              for ( i = 0; i < mvgData[1].values.length; ++i) {
                if (mvgData[1].values[i].rows.length > 0) {
                  ctx = {path:{}};
                  ctx.path.mg = mvgData[1].values[i].rows[0][0].ctx.path.mg;
                  ctx.path.mi = mvgData[1].values[i].rows[0][0].ctx.path.mi;
                }
                body = {
                  'name' : handleNull(mvgData[1].values[i].col),
                  'val' : [],
                  'ctx' : ctx
                };
                for ( j = 0, len = mvgData[1].values[i].rows.length; j < len; ++j) {
                  valueIndex = measureIndex * len + j;
                  itemLabel = [];
                  for ( k = 0; k < aaData[1].values.length; ++k) {
                    itemLabel.push(aaData[1].values[k].rows[j]);
                  }
                  item = {
                    'shape' : shapePalette[valueIndex % shapePalette.length],
                    'color' : colorPalette[valueIndex % colorPalette.length],
                    'label' : itemLabel,
                    'value' : barGroupValue[valueIndex].val === ' ' ? defaultString
                        : postProcess === undefined ? handleNull(barGroupValue[valueIndex].val)
                            : postProcess(barGroupValue[valueIndex].val),
                     'valueAxis' : 1
                  };
                  body.val.push(item);
                }
                tooltipData.body.push(body);
                ++measureIndex;
              }
            }
          } else {
            if (mvgData[0].values[0].rows.length > 0) {
              ctx = {path:{}};
              ctx.path.mg = mvgData[0].values[0].rows[0][0].ctx.path.mg;
              ctx.path.mi = mvgData[0].values[0].rows[0][0].ctx.path.mi;
            }
            body = {
              'name' : handleNull(mvgData[0].values[0].col),
              'val' : [],
              'ctx' : ctx
            };
            item = {
              'shape' : shapePalette[0 % shapePalette.length],
              'color' : colorPalette[0 % colorPalette.length],
              'label' : null,
              'value' : barGroupValue[0].val === ' ' ? defaultString
                  : postProcess === undefined ? handleNull(barGroupValue[0].val)
                      : postProcess(barGroupValue[0].val),
               'valueAxis' : 0
            };
            body.val.push(item);
            tooltipData.body.push(body);
          }
          for (i = 0, len = aaData[0].values.length; i < len; ++i) {
            footer = {
              'label' : aaData[0].values[i].col,
              'value' : aaData[0].values[i].rows[aai1]
            };
            tooltipData.footer.unshift(footer);
          }

        } else if (MNDHandler.hasMNDonColor) {
          // MND feeds on color
          for (i = 0; i < aaData[1].values.length; ++i) {
            if (aaData[1].values[i].type === 'MND') {
              MNDLength = aaData[1].values[i].rows.length;
              if (i === 0) {
                isMNDbeforeCate = true;
              }
              break;
            }
          }

          measureIndex = 0;
          var colorIndex;
          if (mvgData[0]) {
            for (i = 0; i < mvgData[0].values.length; ++i) {
              if (mvgData[0].values[i].rows.length > 0) {
                ctx = {path:{}};
                ctx.path.mg = mvgData[0].values[i].rows[0][0].ctx.path.mg;
                ctx.path.mi = mvgData[0].values[i].rows[0][0].ctx.path.mi;
              }
              body = {
                'name' : handleNull(mvgData[0].values[i].col),
                'val' : [],
                'ctx' : ctx
              };
              for (j = 0, len = mvgData[0].values[i].rows.length; j < len; ++j) {
                colorIndex = undefined;
                if (isMNDbeforeCate){
                  valueIndex = measureIndex * len + j;
                }
                else if (!isStacked || !isDual){
                  valueIndex = j * MNDLength + measureIndex;
                }
                else {
                  valueIndex = j * division + measureIndex;
                  colorIndex = j * MNDLength + measureIndex;
                }
                itemLabel = [];
                for (k = 0; k < aaData[1].values.length; ++k) {
                  if (aaData[1].values[k].type !== 'MND') {
                    itemLabel.push(aaData[1].values[k].rows[j]);
                  }
                }
                item = {
                  'shape' : colorIndex !== undefined ? shapePalette[colorIndex  % shapePalette.length] 
                : shapePalette[valueIndex % shapePalette.length],
                  'color' : colorIndex !== undefined ? colorPalette[colorIndex % colorPalette.length] 
                  : colorPalette[valueIndex % colorPalette.length],
                  'label' : itemLabel,
                  'value' : barGroupValue[valueIndex].val === ' ' ? defaultString
                      : postProcess === undefined ? handleNull(barGroupValue[valueIndex].val)
                          : postProcess(barGroupValue[valueIndex].val),
                   'valueAxis' : 0
                };
                body.val.push(item);
              }
              tooltipData.body.push(body);
              ++measureIndex;
            }
          }
          // for dual chart
          if (mvgData[1]) {
            for (i = 0; i < mvgData[1].values.length; ++i) {
              if (mvgData[1].values[i].rows.length > 0) {
                ctx = {path:{}};
                ctx.path.mg = mvgData[1].values[i].rows[0][0].ctx.path.mg;
                ctx.path.mi = mvgData[1].values[i].rows[0][0].ctx.path.mi;
              }
              body = {
                'name' : handleNull(mvgData[1].values[i].col),
                'val' : [],
                'ctx' : ctx
              };
              for (j = 0, len = mvgData[1].values[i].rows.length; j < len; ++j) {
                colorIndex = undefined;
                if (isMNDbeforeCate){
                  valueIndex = measureIndex * len + j;
                }
                else if (!isStacked || !isDual){
                  valueIndex = j * MNDLength + measureIndex;
                }
                else {
                  valueIndex = j * (MNDLength - division) + measureIndex - division + parseInt(valueLength * division / MNDLength, 10);
                  colorIndex = j * MNDLength + measureIndex;
                }

                itemLabel = [];
                for (k = 0; k < aaData[1].values.length; ++k) {
                  if (aaData[1].values[k].type !== 'MND') {
                    itemLabel.push(aaData[1].values[k].rows[j]);
                  }
                }
                item = {
                  'shape' : colorIndex !== undefined ? shapePalette[colorIndex % shapePalette.length] 
                : shapePalette[valueIndex  % shapePalette.length],
                  'color' : colorIndex !== undefined ? colorPalette[colorIndex % colorPalette.length] 
                  : colorPalette[valueIndex % colorPalette.length],
                  'label' : itemLabel,
                  'value' : barGroupValue[valueIndex].val === ' ' ? defaultString
                      : postProcess === undefined ? handleNull(barGroupValue[valueIndex].val)
                          : postProcess(barGroupValue[valueIndex].val),
                   'valueAxis' : 1
                };
                body.val.push(item);
              }
              tooltipData.body.push(body);
              ++measureIndex;
            }
          }
          for (i = 0, len = aaData[0].values.length; i < len; ++i) {
            footer = {
              'label' : aaData[0].values[i].col,
              'value' : aaData[0].values[i].rows[aai1]
            };
            tooltipData.footer.unshift(footer);
          }

        } else {
          // MND feeds on category axis
          var bodyName = null;
          var categoryLength;
          for (i = 0; i < aaData[0].values.length; ++i) {
            if (aaData[0].values[i].type === 'MND') {
              MNDLength = aaData[0].values[i].rows.length;
              var groupCount = 0;
              if (seriesData.length !== undefined) {
                groupCount = seriesData.length;
              } else {
                for (j in seriesData) {
                  if (seriesData.hasOwnProperty(j)){
                    ++groupCount;
                  }
                }
              }

              categoryLength = groupCount / MNDLength;
              if (i === 0) {
                isMNDbeforeCate = true;
                bodyName = aaData[0].values[i].rows[parseInt(aai1 / categoryLength, 10)];
              } else {
                // isMNDbeforeCate = false;
                bodyName = aaData[0].values[i].rows[aai1 % MNDLength];
              }
              break;
            }
          }
          body = {
            'name' : bodyName,
            'val' : []
          };

          if (aaData[1]) {
            // there exists color feeds.
            // var measureIndex = 0;
            if (mvgData[0]) {
              for (j = 0, len = mvgData[0].values[0].rows.length; j < len; ++j) {
                valueIndex = j;
                itemLabel = [];
                for (k = 0; k < aaData[1].values.length; ++k) {
                  itemLabel.push(aaData[1].values[k].rows[j]);
                }
                item = {
                  'shape' : shapePalette[valueIndex % shapePalette.length],
                  'color' : colorPalette[valueIndex % colorPalette.length],
                  'label' : itemLabel,
                  'value' : barGroupValue[valueIndex].val === ' ' ? defaultString
                      : postProcess === undefined ? handleNull(barGroupValue[valueIndex].val)
                          : postProcess(barGroupValue[valueIndex].val),
                   'valueAxis' : 0
                };
                body.val.push(item);
              }
            }
          } else {
            // otherwise...
            item = {
              'shape' : shapePalette[0 % shapePalette.length],
              'color' : colorPalette[0 % colorPalette.length],
              'label' : null,
              'value' : barGroupValue[0].val === ' ' ? defaultString
                  : postProcess === undefined ? handleNull(barGroupValue[0].val)
                      : postProcess(barGroupValue[0].val),
               'valueAxis' : 0
            };
            body.val.push(item);
          }
          tooltipData.body.push(body);
          for (i = 0, len = aaData[0].values.length; i < len; ++i) {
            if (aaData[0].values[i].type !== 'MND') {
              footer = {
                'label' : aaData[0].values[i].col,
                'value' : null
              };
              if (isMNDbeforeCate) {
                footer.value = aaData[0].values[i].rows[aai1  % categoryLength];
              } else {
                footer.value = aaData[0].values[i].rows[parseInt(aai1 / MNDLength, 10)];
              }
              tooltipData.footer.unshift(footer);
            }
          }

        }
        return tooltipData;
      };

      var help = function(index) {
        if (_buffer[index] === undefined) {
          _buffer[index] = parseFeedsData(data);
        }
        return _buffer[index];
      };

      return help(aai1);
    };
    return my;
  };

  function mndHandler(aaData) {
    var hasMNDonCate = false;
    var j, len;
    if (aaData[0]){
      for (j = 0, len = aaData[0].values.length; j < len; ++j){
        if (aaData[0].values[j].type && aaData[0].values[j].type === 'MND'){
          hasMNDonCate = true;
        }
      }
    }
     var hasMNDonColor = false;
    if (!hasMNDonCate) {
      if (aaData[1]){
        for (j = 0, len = aaData[1].values.length; j < len; ++j){
          if (aaData[1].values[j].type && aaData[1].values[j].type === 'MND'){
            hasMNDonColor = true;
          }
        }
      }
    }
    return {
      hasMNDonCate : hasMNDonCate,
      hasMNDonColor : hasMNDonColor
    };
  }

  tooltipDataHandler.formatTooltipData = function(data) {
    var tooltipEventData = {
      name : Constants.Event.TooltipShow.name,
      data : data
    };
    return tooltipEventData;
  };

  tooltipDataHandler.dataTransform = function(obj) {
    var data1 = obj['MG1'];
    var data2 = obj['MG2'];

    var transferredDataSet = [];
    var i, j;
    if (obj.hasMND && obj.MNDOnColor && obj.MNDInner) {
      var mg1mnum = 0, mg2mnum = 0, colorAxisDataNum = 0;
      if (obj['MG1Number']) {
        mg1mnum = obj['MG1Number'];
        colorAxisDataNum = data1.length / mg1mnum;
      }
      if (obj['MG2Number']) {
        mg2mnum = obj['MG2Number'];
        colorAxisDataNum = data2.length / mg2mnum;
      }

      for (i = 0; i < colorAxisDataNum; i++) {
        for (j = 0; j < mg1mnum; j++) {
          transferredDataSet.push(data1[i * mg1mnum + j]);
        }
        for (j = 0; j < mg2mnum; j++) {
          transferredDataSet.push(data2[i * mg2mnum + j]);
        }
      }
    } else {
      if (data1) {
        for (i = 0; i < data1.length; i++) {
          transferredDataSet.push(data1[i]);
        }
      }
      if (data2) {
        for (i = 0; i < data2.length; i++) {
          transferredDataSet.push(data2[i]);
        }
      }
    }

    var stackedBarGroup = [];
    // the number of bar in each group
    var barGroupNumber;
    if (data1.length !== 0) {
      barGroupNumber = data1[0].length;
    } else {
      barGroupNumber = data2[0].length;
    }
    for ( j = 0; j < barGroupNumber; j++) {
      var ds = [];
      for (i = 0; i < transferredDataSet.length; i++) {
        ds.push(transferredDataSet[i][j]);
      }
      stackedBarGroup.push(ds);
    }

    return stackedBarGroup;
  };

  return tooltipDataHandler;
});
define('sap/viz/modules/util/defaultSelectionUtil',[],
function Setup() 
{
  var defaultSelectionUtil = {

  };
  
  defaultSelectionUtil.clearSelectionInfo = function(plot, isSelected, elems){
    var i, len;
        if(elems instanceof Array){
          for(i = 0, len = elems.length; i < len; i++){
            InfoProcessor(elems[i], isSelected);
          }
        }else{
          InfoProcessor(elems, isSelected);
        } 
  };
  
  function InfoProcessor(elems, isSelected){
    var j, info;
    if(elems.__data__){
      info = elems.__data__.info;
    }else{
      return;
    }
   
    if(info instanceof Array){
      for(j = 0; j < info.length; j++){
        if(info && info.defaultSelection){
          info.defaultSelection.isSelected = isSelected;
        }
      }
    }else{
      info.defaultSelection.isSelected = isSelected;
    }
  }
  
  return defaultSelectionUtil;
});
define('sap/viz/modules/radar',['sap/viz/base/utils/oo','sap/viz/modules/Base','jquery','sap/viz/base/utils/TypeUtils','sap/viz/util/TextUtils',
'sap/viz/modules/dispatch','sap/viz/modules/axis','sap/viz/util/ColorSeriesGenerator',
'sap/viz/util/ShapeSeriesGenerator','sap/viz/util/Scaler','sap/viz/modules/manifests/Module',
'sap/viz/util/DrawUtil','sap/viz/lang/langManager','sap/viz/modules/util/tooltipDataHandler',
'sap/viz/base/utils/Objects','sap/viz/modules/util/BoundUtil','sap/viz/modules/util/defaultSelectionUtil','sap/viz/modules/Constants'],
function Setup( oo, Base, $, TypeUtils, TextUtils, dispatch, axis, ColorSeries, ShapeSeries, Scaler, global, 
  DrawUtil, langManager, tooltipDataHandler, Objects, BoundUtil, defaultSelUtil,Constants) {

//////////////// shared functions, invisible from outside //////////////////////
    function straightHelper(d3node) {
      d3node.attr("stroke", brush.params.stroke.invisible);
      classRename(d3node,'straight');
    }

    function straight2Helper(d3node) {
      d3node.attr("stroke-width", this._rdr_properties.line.width);
      classRename(d3node,'straight');
    }

    function highlightHelper(d3node) {
      d3node.attr("stroke", brush.params.stroke.heavy)
        .attr("stroke-width", brush.params.weight.natural)
        .attr("opacity", brush.params.opacity.natural);
      classRename(d3node,'highlight');
    }

    function highlight2Helper(d3node) {
      d3node.attr("stroke-width", brush.params.weight.natural)
        .attr("opacity", brush.params.opacity.natural);
      classRename(d3node,'highlight');
    }

    function focusHelper(d3node) {
      d3node.attr("stroke", brush.params.stroke.natural)
            .attr("stroke-width", brush.params.weight.natural);
      classRename(d3node,'focus');
    }

    function classRename(d3node,type){
      var os = d3node.attr('class');
      var i = os.indexOf(CLASSDATAPOINT);
      if (i>=0){
        switch(type){
          case 'focus':
            d3node.attr('class', os.substring(0,i) + CLASSDATAPOINTCOMBINED+" "+CLASSMARKERHOVER);
            break;
          case 'highlight':
            d3node.attr('class', os.substring(0,i) + CLASSDATAPOINTCOMBINED+" "+CLASSMARKERSELECTED);
            break;
          case 'straight':
            d3node.attr('class', os.substring(0,i) + CLASSDATAPOINTCOMBINED);
            break;
        }
      }
    }

    function highlight( series, datapoints, cardinal ) {
      if ( datapoints.length === cardinal ) {
        brush.highlight2.call(this, DEFAULT_WORDING.dot + series, true);//for radar line color not to be changed
      } else {
        brush.highlight.call(this,datapoints);
      }
    }

    var brush = {};

    brush.params = { // UX defined
      stroke : {
        invisible : "transparent",
        natural : "#ffffff",
        heavy : "#333333"
      },
      
      weight : {
        natural : "2px"
      },
      
      opacity : {
        natural : 1,
        low : 0.4
      }
    };
    
    /*
     * Functions of the effects library are
     * state-less. Each of the function accepts
     * one of the two TypeUtils of arguments: 
     * DOM nodes in array, or
     * CSS class with an optional boolean field
     * in determining whether all elements with
     * the given CSS class will be selected.
     */
    brush.dim = function () {
      if ( !arguments.length ) { // select everything
        this._rdr_radar.node.selectAll(DEFAULT_WORDING.dot + STYLES.line.clazz)
          .attr("opacity", brush.params.opacity.low);
        this._rdr_radar.node.selectAll(DEFAULT_WORDING.dot + STYLES.marker.clazz)
          .attr("opacity", brush.params.opacity.low);
      } else if ( arguments[0] instanceof Array ) {
        for ( var i = 0; i < arguments[0].length; i++ ) {
          d3.select(arguments[0][i])
            .attr("opacity", brush.params.opacity.low);
        }
      } else if ( arguments[1] ) {
        this._rdr_radar.node.selectAll(arguments[0])
          .attr("opacity", brush.params.opacity.low);
      } else {
        this._rdr_radar.node.select(arguments[0])
          .attr("opacity", brush.params.opacity.low);
      }
      return brush;
    };
    
    brush.bright = function () {
      if ( !arguments.length ) {
        this._rdr_radar.node.selectAll(DEFAULT_WORDING.dot + STYLES.line.clazz)
          .attr("opacity", brush.params.opacity.natural);
        this._rdr_radar.node.selectAll(DEFAULT_WORDING.dot + STYLES.marker.clazz)
          .attr("opacity", brush.params.opacity.natural);
      } else if ( arguments[0] instanceof Array ) {
        for ( var i = 0; i < arguments[0].length; i++ ) {
          d3.select(arguments[0][i])
            .attr("opacity", brush.params.opacity.natural);
        }
      } else if ( arguments[1] ) {
        this._rdr_radar.node.selectAll(arguments[0])
          .attr("opacity", brush.params.opacity.natural);
      } else {
        this._rdr_radar.node.select(arguments[0])
          .attr("opacity", brush.params.opacity.natural);
      }
      return brush;
    };
    
    // remove all decorations
    brush.straight = function () {
      var that = this;
      if ( !arguments.length ) {
        this._rdr_radar.node.selectAll(DEFAULT_WORDING.dot + STYLES.marker.clazz).each(function(){
            straightHelper.call(that,d3.select(this));
        });
      } else       if ( arguments[0] instanceof Array ) {
        for ( var i = 0; i < arguments[0].length; i++ ) {
          straightHelper.call(this,d3.select(arguments[0][i]));
        }
      } else if ( arguments[1] ) {
        this._rdr_radar.node.selectAll(arguments[0]).each(function(){
            straightHelper.call(that,d3.select(this));
        });
      } else {
        straightHelper.call(this,this._rdr_radar.node.select(arguments[0]));
      }
      return brush;
    };

    // Just recover stroke-width
    brush.straight2 = function () {
      var that = this;
      if ( !arguments.length ) {
        this._rdr_radar.node.selectAll(DEFAULT_WORDING.dot + STYLES.marker.clazz).each(function(){
            straight2Helper.call(that,d3.select(this));
        });
      } else if ( arguments[0] instanceof Array ) {
        for ( var i = 0; i < arguments[0].length; i++ ) {
          straight2Helper.call(this,d3.select(arguments[0][i]));
        }
      } else if ( arguments[1] ) {
        this._rdr_radar.node.selectAll(arguments[0]).each(function(){
            straight2Helper.call(that,d3.select(this));
        });
      } else {
        straight2Helper.call(this,this._rdr_radar.node.select(arguments[0]));
      }
      return brush;
    };

    // Change stroke color and stroke-width
    brush.highlight = function () {
      if ( !arguments.length ){
        return;
      }
      if ( arguments[0] instanceof Array ) {
        for ( var i = 0; i < arguments[0].length; i++ ) {
          highlightHelper(d3.select(arguments[0][i]));
        }
      } else if ( arguments[1] ) {
        this._rdr_radar.node.selectAll(arguments[0]).each(function(){
            highlightHelper(d3.select(this));
        });
      } else {
        highlightHelper(this._rdr_radar.node.select(arguments[0]));
      }
      return brush;
    };

    // Add stroke not changing color
    brush.highlight2 = function () {
      if ( !arguments.length ) {
        return;
      }
      if ( arguments[0] instanceof Array ) {
        for ( var i = 0; i < arguments[0].length; i++ ) {
          highlight2Helper(d3.select(arguments[0][i]));
        }
      } else if ( arguments[1] ) {
        this._rdr_radar.node.selectAll(arguments[0]).each(function(){
            highlight2Helper(d3.select(this));
        });
      } else {
        highlight2Helper(this._rdr_radar.node.select(arguments[0]));
      }
      return brush;
    };

    brush.focus = function () {
      if ( !arguments.length ){ 
        return;
      }
      if ( arguments[0] instanceof Array ) {
        for ( var i = 0; i < arguments[0].length; i++ ) {
          focusHelper(d3.select(arguments[0][i]));
        }
      } else if ( arguments[1] ) {
        this._rdr_radar.node.selectAll(arguments[0]).each(function(){
            focusHelper(d3.select(this));
        });
      } else {
        focusHelper(this._rdr_radar.node.select(arguments[0]));
      }
      return brush;
    };


    var textRuler = function ( text, style ) {
      return TextUtils.fastMeasure(text, style["font-size"] || style.fontSize,
        style["font-weight"] || style.fontWeight, style["font-family"] || style.fontFamily);
    };
    

//////////////////////////////////////////////////

//////////////// CLASS VARS///////////////////////
    var CLASSMARKERSELECTED = "v-datapoint-selected",
        CLASSMARKERHOVER = "v-datapoint-hover",
        CLASSDATAPOINT = "v-datapoint",
        CLASSMORPHABLELINE = Constants.CSS.CLASS.MORPHABLELINE,
        CLASSMORPHABLEDATAPOINT = Constants.CSS.CLASS.MORPHABLEDATAPOINT;
    var CLASSDATAPOINTCOMBINED = CLASSDATAPOINT + ' ' + CLASSMORPHABLEDATAPOINT;
    var LABELAREAMOUSEOVERCOLOR = "#cccccc";
    var LABELAREAMOUSEDOWNCOLOR = "#808080";
    var STYLES = {
        spacing : { hgap : 5, vgap : 5 },
        polaraxis : { 
          clazz : "polar_axis", 
          color : "#6c6c6c", 
          weight : "1px",
          labels : { css : { key : "viz-polar-axis-label", def : null } },
          title : { css: { key : "viz-polar-axis-title", def : null } }
        },
        polargrid : { clazz : "polar_grid", color : "#d8d8d8", weight : "1px" },
        line : { clazz : "v-dataline", width:2 },
        valueaxis : { clazz : "value_axis", title : { css : { key : "viz-axis-title", def : null } }},
        marker : { clazz : CLASSDATAPOINT, css : { key : "viz-radar-marker", def : null },
                   stroke : "transparent" },
        labels : { color : "#333333", fontSize : "14px", fontWeight : "normal", fontFamily : "Arial" },
        tooltip : { radialOffset : 1 * 10  } // 1em
      };
    var DEFAULT_WORDING = {
      dash : " - ",
      dot : ".",
      slash : " / ",
      ellipsis : "...",
      series : "s",
      data : "d",
      measureIndex : " mi",
      and : " & "
    };
    var DEFAULT_RANGES = {
        dataline : {
          weight : [ 1, 7 ]
        },
        marker : {
          size : [ 4, 32 ]
        }
    };
    var DEFAULTTICKNUM = 7;
//////////////////////////////////////////////////

  var Radar = function(manifest,ctx){
    Radar.superclass.constructor.apply(this,arguments);
    this._rdr_width = 0;
    this._rdr_height = 0;
    this._rdr_data = {};
    this._rdr_properties = manifest.props(null);
    this._rdr_parent = undefined;
    this._rdr_radar= {
        clazz : "v-spiderweb",
        node : null,
        color : ColorSeries.sap32(),
        shape : ShapeSeries.sapShapes(),
        radiusLength : 0,
        radians : [],
        series : [],
        categories : [],
        title : { 
          node : null,
          name : "v-polar-axis-title",
          width : 0,
          height : 0,
          customization : false
        },
        labels : {},
        locked : false
    };
    this._rdr_valueaxis= {
        clazz : "v-valueaxis",
        anchor : { x : 0, y : 0 },
        ref : global.get('sap.viz.modules.axis').execute(ctx),
        node : null,
        width : 0,
        height : 0,
        customization : false,
        scale:{
          customization : false,
          minValue: undefined,
          maxValue: undefined
        }
    };
    this._rdr_yscale = undefined;
    this._rdr_colorPalette = [];
    this._rdr_shapePalette = [];
    this._rdr_container = null;
    this._rdr_selections = {};
    this._rdr_selectionMode = 'multiple',
    this._rdr_effectManager = ctx.effectManager;
    this._rdr_styleManager = ctx.styleManager;
    this._rdr_hasDefaultSelection = false;
    this._rdr_eDispatch = dispatch("selectData", "deselectData","showTooltip", "hideTooltip", "initialized", 'startToInit');
  };

  oo.extend(Radar,Base);

    Radar.prototype.render = function ( selection ) {
      BoundUtil.drawBound(selection, this._rdr_width, this._rdr_height);
      this._rdr_eDispatch.startToInit();
      var that = this;
      selection.each(function ( datum ) {
        that._rdr_parent = d3.select(this);
        that._rdr_valueaxis.ref.drawable(true);
        that._rdr_valueaxis.node = null;
        that._rdr_radar.node = null;
        that._rdr_radar.radiusLength = 0;
        that._rdr_container = that._rdr_parent;
        
        that._rdr_parent.select(DEFAULT_WORDING.dot.concat(that._rdr_valueaxis.clazz)).remove();
        that._rdr_parent.select(DEFAULT_WORDING.dot.concat(that._rdr_radar.clazz)).remove();
        that._rdr_parent.select( DEFAULT_WORDING.dot + that._rdr_radar.title.name ).remove();
        
        that._rdr_valueaxis.node = that._rdr_parent.append("g").attr("class", that._rdr_valueaxis.clazz);
        that._rdr_radar.node = that._rdr_parent.append("g").attr("class", that._rdr_radar.clazz + ' v-datashapesgroup');
        that._rdr_radar.title.node = that._rdr_parent.append("text").attr("class", that._rdr_radar.title.name);
        
        STYLES.valueaxis.title.css.def = that._rdr_styleManager.query(STYLES.valueaxis.title.css.key);
        STYLES.polaraxis.labels.css.def = that._rdr_styleManager.query(STYLES.polaraxis.labels.css.key);
        STYLES.polaraxis.title.css.def = that._rdr_styleManager.query(STYLES.polaraxis.title.css.key);
        
        var cardinal, lblW, lblH, r, i, j, pole = {},
            labels = that._rdr_radar.categories, series = that._rdr_radar.series,
            hgap = STYLES.spacing.hgap, vgap = STYLES.spacing.vgap, 
            radians = (that._rdr_radar.radians = []);

        if (!that._rdr_radar.locked) {
          that._rdrfn_rescale(that);
        }

        var ls = []; // Labels array
        for ( i = 0; i < labels.length; i++ ) {
          ls.push( textRuler(labels[i].val, STYLES.polaraxis.labels.css.def) );
        }
        lblW = d3.max( ls, function (_) { return _.width; } );
        lblH = d3.max( ls, function (_) { return _.height; } );

        var props = {
          label : {
            visible : true,
            formatString : that._rdr_properties.valueAxis.label.formatString
          },
          title : {
            visible : that._rdr_properties.valueAxis.title.visible,
            text : that._rdr_properties.valueAxis.title.text
          },
          scale : {
            fixedRange:that._rdr_properties.valueAxis.scale.fixedRange,
            minValue:that._rdr_properties.valueAxis.scale.minValue,
            maxValue:that._rdr_properties.valueAxis.scale.maxValue
          },
          type : "value",
          position : "left",
          gridline : {
            visible : true,
            showFirstLine : true,
            showLastLine : true,
            type : "dotted"
          }
        };
        
        that._rdr_yscale.domain([that._rdr_radar.min, that._rdr_radar.max]).range([200, 0]); // fake radius length
        if (!that._rdr_radar.locked && !that._rdr_radar.manualRange) {
          Scaler.perfect(that._rdr_yscale);
        } 
        
        if ( that._rdr_properties.valueAxis.gridline && that._rdr_properties.valueAxis.gridline.color ) { 
          props.gridline.color = that._rdr_properties.valueAxis.gridline.color;
        }
        that._rdr_valueaxis.ref.scale(that._rdr_yscale).properties(props);
        
        var pre = that._rdr_valueaxis.ref.getPreferredSize();
        that._rdr_valueaxis.width = that._rdr_properties.valueAxis.visible ? pre.width : 0;
        that._rdr_valueaxis.height = that._rdr_properties.valueAxis.visible ? pre.height : 0;
        if ( that._rdr_valueaxis.width > 0.5 * that._rdr_width ){
          that._rdr_valueaxis.width = 0;
        } 
        
        that._rdrfn_arrange({ 
          valueaxis : that._rdr_valueaxis.width, 
          lblW : lblW,
          lblH : lblH, 
          title : {
            width : textRuler( that._rdr_properties.polarAxis.title.visible ? 
              that._rdr_properties.polarAxis.title.text : 0, STYLES.polaraxis.title.css.def ).width,
            height : textRuler( that._rdr_properties.polarAxis.title.visible ? 
              that._rdr_properties.polarAxis.title.text : 0, STYLES.polaraxis.title.css.def).height
          }});
        
        if ( that._rdr_properties.polarAxis.title.visible && that._rdr_radar.title.width && that._rdr_radar.title.height ) {
          that._rdr_radar.title.node
            .text(that._rdr_properties.polarAxis.title.text)
            .attr("text-anchor", "middle")
            .attr("alignment-baseline", "middle");
          that._rdr_styleManager.queryDefault(that._rdr_radar.title.name).toAttrs(that._rdr_radar.title.node);
        }
        
        that._rdr_yscale.range([ that._rdr_radar.radiusLength, 0 ]); // Re-calculate scale
        if(!props.scale.fixedRange){
          Scaler.perfect(that._rdr_yscale);
        }        
        that._rdr_valueaxis.ref.scale(that._rdr_yscale);
        if ( that._rdr_properties.valueAxis.visible && that._rdr_valueaxis.width ) {
          
          pre = that._rdr_valueaxis.ref.getPreferredSize();
          that._rdr_valueaxis.width = pre.width;
          
          that._rdrfn_arrange({ 
            valueaxis : that._rdr_valueaxis.width, 
            lblW : lblW,
            lblH : lblH, 
            title : {
              width : textRuler( that._rdr_properties.polarAxis.title.visible ? 
                that._rdr_properties.polarAxis.title.text : 0, STYLES.polaraxis.title.css.def ).width,
              height : textRuler( that._rdr_properties.polarAxis.title.visible ? 
                that._rdr_properties.polarAxis.title.text : 0, STYLES.polaraxis.title.css.def).height
          }});
          
          if(  that._rdr_valueaxis.width === 0){
            that._rdr_valueaxis.ref.drawable(false);
          }
          
          that._rdr_yscale.range([ that._rdr_radar.radiusLength, 0 ]); // Re-calculate scale
          if(!props.scale.fixedRange){
            Scaler.perfect(that._rdr_yscale);
            var newDomain = that._rdr_yscale.domain();
            that._rdr_radar.max = newDomain[1] >= newDomain[0] ? newDomain[1] : newDomain[0];
            that._rdr_radar.min = newDomain[1] >= newDomain[0] ? newDomain[0] : newDomain[1];
          }

          that._rdr_valueaxis.ref.scale(that._rdr_yscale);
          pre = that._rdr_valueaxis.ref.getPreferredSize();
          that._rdr_valueaxis.ref.width(pre.width);
          that._rdr_valueaxis.ref.height(pre.height);
          that._rdr_valueaxis.node.call(that._rdr_valueaxis.ref);
        }
        
        var line = that._rdr_radar.node.append("g").attr("class", "v-polaraxes-group")
                  .selectAll(STYLES.polaraxis.clazz).data(labels);
        // Create nodes upon new data injected
        line.enter()
          .append("g")
          .attr("transform", function (d , i) {
            var rotation = i / labels.length * 360 - 90;
            if ( rotation > -180 && rotation < 180 ) {
              radians.push({ axisIdx : i,
                radian : -1 * rotation * Math.PI / 180 });
            } else { // rotation > 180 and rotation < 270
              radians.push({ axisIdx : i,
                radian : (360 - rotation) * Math.PI / 180 });
            }
            return "rotate("+ rotation +") translate("+ that._rdr_radar.radiusLength +")";
          });
        line.append("svg:line")
          .attr("x2", -1 * that._rdr_radar.radiusLength)
          .attr("stroke", that._rdr_effectManager.register({
            drawingEffect: "normal",
            fillColor: STYLES.polaraxis.color
          }))
          .attr("stroke-width", STYLES.polaraxis.weight)
          .attr("fill", "transparent");
        
        radians.sort( function (a, b) { return a.radian - b.radian; } );
        
        var angle; // Polar angle
        
        if ( that._rdr_radar.labels.width && that._rdr_radar.labels.height ) {
          //axis label rect area
          line.append('rect')
            .attr('class', 'v-labelarea')
            .attr('width', function(d){
              return textRuler(d.val, STYLES.polaraxis.labels.css.def).width;
            })
            .attr('height', function(d){
              return textRuler(d.val, STYLES.polaraxis.labels.css.def).height;
            })
            .attr('x',  function(d){
              return -textRuler(d.val, STYLES.polaraxis.labels.css.def).width / 2;
            })
            .attr('y', function(d){
              var textInfo = textRuler(d.val, STYLES.polaraxis.labels.css.def);
              return textInfo.y + (textInfo.height + textInfo.y)/2;
            })
            .attr("transform", function (d, i) {
              angle = i / labels.length * 360 - 90;
              if ( angle % 90 === 0 ) {
                if ( angle === -90 || angle === 270 ) {
                  return "rotate(90) translate(0," + (-1 * ( 
                    textRuler(d.val, STYLES.polaraxis.labels.css.def).height / 2 + vgap ) ) +")";
                } else if ( angle === 0 ) {
                  return "translate("+ ( textRuler(d.val, STYLES.polaraxis.labels.css.def).width / 2 + hgap ) +")";
                } else if ( angle === 180 ) {
                  return "rotate(180) translate(" + ( -1 * ( 
                    textRuler(d.val, STYLES.polaraxis.labels.css.def).width / 2 + hgap ) ) +")";
                } else {
                  return "rotate(-90) translate(0," + ( 
                    textRuler(d.val, STYLES.polaraxis.labels.css.def).height / 2 + vgap ) +")";
                }
              }
              if ( (angle > -90 && angle < 0) || (angle > 0 && angle < 90) ) {
                return "rotate("+ (-1 * angle) +") translate(" + 
                  ( textRuler(d.val, STYLES.polaraxis.labels.css.def).width / 2 + hgap ) +",0)";
              }
              return "rotate("+ (-1 * angle) +") translate(" +
                ( -1 * (textRuler(d.val, STYLES.polaraxis.labels.css.def).width / 2 + hgap) ) +",0)";
            })
            .attr("opacity", function(d, i){
              return 0;
            });
          line.selectAll('rect').each(function(d){
            //Set labelContexts to dom element. Consist with category axis.
            this.labelContexts = d.ctx;
          });
          
          //Plot category labels
          line
            .append("text").attr("class", "v-polar-axis-label")
            .text(function (d, i) { return d.val; })
            .attr("pointer-events","none")
            .attr("text-anchor", "middle")
            .attr("alignment-baseline", "middle")
            .attr("transform", function (d, i) {
              angle = i / labels.length * 360 - 90;
              if ( angle % 90 === 0 ) {
                if ( angle === -90 || angle === 270 ) {
                  return "rotate(90) translate(0," + (-1 * ( 
                    textRuler(d.val, STYLES.polaraxis.labels.css.def).height / 2 + vgap ) ) +")";
                } else if ( angle === 0 ) {
                  return "translate("+ ( textRuler(d.val, STYLES.polaraxis.labels.css.def).width / 2 + hgap ) +")";
                } else if ( angle === 180 ) {
                  return "rotate(180) translate(" + ( -1 * ( 
                    textRuler(d.val, STYLES.polaraxis.labels.css.def).width / 2 + hgap ) ) +")";
                } else {
                  return "rotate(-90) translate(0," + ( 
                    textRuler(d.val, STYLES.polaraxis.labels.css.def).height / 2 + vgap ) +")";
                }
              }
              if ( (angle > -90 && angle < 0) || (angle > 0 && angle < 90) ) {
                return "rotate("+ (-1 * angle) +") translate(" + 
                  ( textRuler(d.val, STYLES.polaraxis.labels.css.def).width / 2 + hgap ) +",0)";
              }
              return "rotate("+ (-1 * angle) +") translate(" +
                ( -1 * (textRuler(d.val, STYLES.polaraxis.labels.css.def).width / 2 + hgap) ) +",0)";

            })
            .attr("font-family", that._rdr_styleManager.queryDefault('v-polar-axis-label')["font-family"])
            .attr("font-size", that._rdr_styleManager.queryDefault('v-polar-axis-label')["font-size"])
            .attr("fill", that._rdr_effectManager.register({
              drawingEffect: "normal",
              fillColor: that._rdr_styleManager.queryDefault('v-polar-axis-label').fill
            })); 
          
        }
        var phantomMarker;
        //handle all datapoints with no value
        if(that._rdr_radar.min === 0 && that._rdr_radar.max === 0){
            // create place holder elements for empty values
            phantomMarker = that._rdr_radar.node.append("g")
              .attr("class", "v-phantom-marker-group")
              .selectAll(".v-phantom-marker-series").data(that.vacants)
              .enter().append("g");
              
            phantomMarker
              .attr("class", "v-phantom-marker-series")
              .each(function ( datum, index ) {
                d3.select(this)
                  .selectAll(".v-phantom-marker")
                  .data(datum)
                .enter()
                  .append("path")
                  .attr("class", function (d, i) {
                    return (
                      DEFAULT_WORDING.series + index + " " +       // series index 
                      DEFAULT_WORDING.data + d.order + " " +       // data index 
                      DEFAULT_WORDING.measureIndex + d.ctx.path.mi // measure index
                    );
                  })
                  .attr("fill", "none");
              });
              that._rdr_eDispatch.initialized();
              return;
        }
        
        if ( !that._rdr_radar.min && !that._rdr_radar.max ) {
          that._rdr_eDispatch.initialized();
          return;
        }
        
        // Reset value scales to desired orders
        that._rdr_yscale.domain([ that._rdr_radar.max, that._rdr_radar.min ]);
        if(!props.scale.fixedRange){
            Scaler.perfect(that._rdr_yscale);
        }else{
          if(!that._rdr_yscale.tickNum){
            that._rdr_yscale.tickNum =  DEFAULTTICKNUM;
          }
        }
        cardinal  = that._rdr_radar.categories.length;
        
        // Default polar angle scale
        angle = that._rdrfn_angles([], cardinal, cardinal);
        
        // Path generator of line data on the radar plate
        var polarLine = d3.svg.line.radial()
          .interpolate("linear")
          .radius(that._rdr_yscale)
          .angle(function (d, i) { return angle(i); });

        var tickValues = that._rdr_yscale.ticks( that._rdr_yscale.tickNum ), polarTicks = [], circle = [];
        if(props.scale.fixedRange){
          if(tickValues[tickValues.length-1] !== that._rdr_radar.max){
            tickValues.push(that._rdr_radar.max);
          }
          if(tickValues[0] !== that._rdr_radar.min){
            tickValues.unshift(that._rdr_radar.min);
          }
        }
        for ( i = 0; i < tickValues.length; i++ ) {
          circle = [];
          for ( j = 0; j < labels.length; j++ ) {
            circle.push(tickValues[i]);
          }
          polarTicks.push(circle);
        }

        if ( that._rdr_properties.polarGrid.visible ) {
          that._rdr_radar.node.append("g").attr("class", "v-polargrid-group")
            .selectAll( "." + STYLES.polargrid.clazz )
            .data( polarTicks )
          .enter()
            .append("path")
            .attr("class", STYLES.polargrid.childClazz)
            .attr("d", function (d) { return polarLine(d) + "Z"; })
            .attr("fill", "none")
            .attr("stroke", that._rdr_effectManager.register({
              drawingEffect : "normal",
              fillColor : STYLES.polargrid.color}))
            .attr("stroke-width", STYLES.polargrid.weight);
        }
        
        // Plot actual data
        that._rdr_radar.node.append("g")
          .attr("class", "v-dataline-group")
          .selectAll( "." + STYLES.line.clazz )
          .data(series)
        .enter()
          .append("path")
          .attr("class", function (d, i) {
            return DEFAULT_WORDING.series.concat(i + " ").concat(STYLES.line.clazz + " " + CLASSMORPHABLELINE);
           })
          .attr("d", function (d, i) { // Each d is a data series
            if ( !d.length ){
              return;
            }
            var numbers = [];
            angle = that._rdrfn_angles([], cardinal, cardinal);
            for ( var n = 0; n < d.length; n++ ) {
              if(d[n].val > that._rdr_radar.max){
                numbers.push(that._rdr_radar.max);
              }else if(d[n].val < that._rdr_radar.min){
                numbers.push(that._rdr_radar.min);
              }else{
                numbers.push(d[n].val);
              }
            }
            if ( numbers.length !== that._rdr_radar.categories.length ) {
              angle = that._rdrfn_angles(that.vacants[i], numbers.length, cardinal);
            }
            return polarLine(numbers) + "Z"; 
          })
          .attr("fill", function (d, i) {
            if ( !d.length ) {
              return;
            }
            if ( that._rdr_properties.surface.fill.visible ) {
              return that._rdr_effectManager.register({
                drawingEffect: "normal",
                fillColor: d[0].color
              });
            }
          })
          .attr("fill-opacity", function (d, i) {
            if ( that._rdr_properties.surface.fill.visible ){ 
              return that._rdr_properties.surface.fill.transparency;
            }
            return 0;
          })
          .attr("stroke", function (d, i) { 
            if ( !d.length ){
             return;
           }
            return that._rdr_effectManager.register({
              drawingEffect: "normal",
              fillColor: d[0].color}); 
          })
          .attr("stroke-width", that._rdr_properties.line.width > DEFAULT_RANGES.dataline.weight[1] || 
             that._rdr_properties.line.width < DEFAULT_RANGES.dataline.weight[0] ? 
             STYLES.line.width : that._rdr_properties.line.width
          );
        
        // draw markers
        var markerContainer = that._rdr_radar.node.append("g")
          .attr("class", "v-marker-container")
          .selectAll("." + STYLES.marker.clazz)
          .data(series).enter().append("g");

        markerContainer.attr("class", "v-marker-group").each(function ( datum, index ) { 
          // for each series
          var nulls = that.vacants[index], radians = [];
          $.each(that._rdr_radar.categories, function ( i, d ) { 
            radians.push(i / cardinal * 2 * Math.PI - 0.5 * Math.PI);
          });
          for ( var i = nulls.length - 1; i >= 0; i-- ) {
            radians.splice(nulls[i].order, 1);
          }
          
          d3.select(this).append("g")
            .attr("class", "v-marker-series")
            .selectAll("." + STYLES.marker.clazz)
            .data(datum)
            .enter()
            .append('g').attr('class','v-datashape')
            .attr("transform", function (d, i) {
              var x,y;
              if(d.val> that._rdr_radar.max){
                x = that._rdr_yscale(that._rdr_radar.max) * Math.cos(radians[i]),
                y = that._rdr_yscale(that._rdr_radar.max) * Math.sin(radians[i]);
              }else if(d.val < that._rdr_radar.min){
                x = that._rdr_yscale(that._rdr_radar.min) * Math.cos(radians[i]),
                y = that._rdr_yscale(that._rdr_radar.min) * Math.sin(radians[i]);
              }else{
                x = that._rdr_yscale(d.val) * Math.cos(radians[i]),
                y = that._rdr_yscale(d.val) * Math.sin(radians[i]);
              }
              return "translate("+ x + ", " + y + ") rotate(0)";
            })
            .append("path")
            .attr("class", function (d, i) {
              return (
                DEFAULT_WORDING.series + index + " " +        // series index 
                DEFAULT_WORDING.data + d.order + " " +        // data index 
                DEFAULT_WORDING.measureIndex + d.ctx.path.mi + " " + // measure index
                STYLES.marker.clazz + " " + CLASSMORPHABLEDATAPOINT  // class

              );
            })
            .attr("d", function (d, i) {
              return DrawUtil.createMarkerData({
                type : d.shape,
                rx : STYLES.marker.size / 2,
                ry : STYLES.marker.size / 2,
                borderWidth : 2
              });
            })
            .attr("fill", function (d) {
              var parameters = {
                drawingEffect : that._rdr_properties.drawingEffect,
                graphType : d.shape,
                fillColor : d.color,
                direction : 'vertical'
              };
              return that._rdr_effectManager.register(parameters);
            });
          });
        
        // create place holder elements for empty values
        phantomMarker = that._rdr_radar.node.append("g")
          .attr("class", "v-phantom-marker-group")
          .selectAll(".v-phantom-marker-series").data(that.vacants)
          .enter().append("g");
          
        phantomMarker
          .attr("class", "v-phantom-marker-series")
          .each(function ( datum, index ) {
            d3.select(this)
              .selectAll(".v-phantom-marker")
              .data(datum)
            .enter()
              .append("path")
              .attr("class", function (d, i) {
                return (
                  DEFAULT_WORDING.series + index + " " +       // series index 
                  DEFAULT_WORDING.data + d.order + " " +       // data index 
                  DEFAULT_WORDING.measureIndex + d.ctx.path.mi // measure index
                );
              })
              .attr("fill", "none");
          });
        
        that._rdr_eDispatch.initialized();
      });
      //this._rdr_radar.locked = false;
    };

    Radar.prototype.mouseover = function(target){
      //high light the target
      if(this._rdrfn_isLabelArea(target)){
        target.setAttribute("opacity", 1);
        target.setAttribute("class", "v-labelarea v-hovershadow");
        target.setAttribute("fill", LABELAREAMOUSEOVERCOLOR);
      }
    };
    
    Radar.prototype.mouseout = function(target){
      //un high light all the label areas
      if(this._rdrfn_isLabelArea(target)){
        target.setAttribute("class", "v-labelarea");
        target.setAttribute("opacity", 0);
      }
    };   
  
    Radar.prototype.mouseup = function(target){
      //un high light the target
      if(this._rdrfn_isLabelArea(target)){
        target.setAttribute("opacity", 1);
        target.setAttribute("class", "v-labelarea v-hovershadow");            
        target.setAttribute("fill", LABELAREAMOUSEOVERCOLOR);
      }
    };
    
    Radar.prototype.mousedown = function(target){
      //high light the target
      if(this._rdrfn_isLabelArea(target)){
        target.setAttribute("opacity", 1); 
        target.setAttribute("class", "v-labelarea v-hovershadow-mousedown");
        target.setAttribute("fill", LABELAREAMOUSEDOWNCOLOR);
      }
    };
    
    Radar.prototype.cleanLabelAreas = function(){
      if(this._rdr_parent){
        this._rdr_parent.selectAll(".v-labelarea")
           .attr("class", "v-labelarea")
           .attr("opacity", 0);
      }
    };

    Radar.prototype.dataLabel = function(_){};
    
    Radar.prototype.data = function (_) {
      if ( !arguments.length ) {
        return this._rdr_data;
      }
      this._rdr_data = _, this._rdr_radar.series = [], this._rdr_radar.categories = [],
      //radar.radians = [],
      this._rdr_shapePalette = [], this._rdr_colorPalette = [], this.vacants = [];
      
      // Data processing is effective upon the
      // completion of various customizations.
      if ( !this.caliberated ){ 
        return this;
      }
      // Analysis Axis 1 and one Measure Group 
      // are required to be fed to radar chart.
      var aa1 = this._rdr_data.getAnalysisAxisDataByIdx(0).values,
          mg = this._rdr_data.getMeasureValuesGroupDataByIdx(0).values,
          aa2 = this._rdr_data.getAnalysisAxisDataByIdx(1),
          aa3 = this._rdr_data.getAnalysisAxisDataByIdx(2),
          series = [], depth, cardinal, layer, hierarchy = [],
          feedings = {
            aa2 : { fed : aa2 !== null && aa2.values.length ? true : false, axesFed : false, hasMND : false },
            aa3 : { fed : aa3 !== null && aa3.values.length ? true : false, axesFed : false, hasMND : false }
          }, i, j, x;
      
      this._rdr_radar.mndized = aa1[0].type && aa1[0].type.toLowerCase() === "mnd" ? true : false;
      
      if( mg[0] && mg[0].rows && mg[0].rows[0] && mg[0].rows[0][0] && mg[0].rows[0][0].info &&  mg[0].rows[0][0].info.defaultSelection){
        this._rdr_hasDefaultSelection = true;
      }else{
        this._rdr_hasDefaultSelection = false;
      }
      
      // Extracts dimension labels
      for ( i = 0; i < aa1.length; i++ ) {
        layer = [];
        for ( j = 0; j < aa1[i].rows.length; j++ ) {
          layer.push(aa1[i].rows[j]);
        }
        hierarchy.push(layer);
      }
      
      depth = hierarchy.length, cardinal = hierarchy[0].length;
      if ( depth === 1 ) {
        for ( i = 0; i < cardinal; i++ ) { 
          this._rdr_radar.categories.push(hierarchy[0][i].val === '' || hierarchy[0][i].val === null ?
            { 'val' : langManager.get('IDS_ISNOVALUE'), 'ctx' : [] } : 
            { 'val' : hierarchy[0][i].val, 'ctx' : [ hierarchy[0][i].ctx ]});
        }
      } else { // splice layered dimension labels
        var column = [], columnCtx = [];
        for ( i = 0; i < cardinal; i++ ) {
          for ( j = 0; j < depth; j++ ) {
            column.push(hierarchy[j][i].val);
            columnCtx.push(hierarchy[j][i].ctx);
          }
          this._rdr_radar.categories.push({
            'val' : column.join(DEFAULT_WORDING.slash),
            'ctx' : columnCtx
          });
          column = [];
          columnCtx = [];
        }
      }

      cardinal = mg[0].rows[0].length;

      // deal with two-dimensional data
      if ( this._rdr_radar.mndized ) {
        /*
         * In case of AA1 is MNDized, each of the 
         * analysis axis has the chance of getting 
         * fed by one, two or not any axes at all.
         */
        if ( !feedings.aa2.fed && !feedings.aa3.fed ) {
          this._rdr_colorPalette.push(this._rdr_radar.color(0));
          this._rdr_shapePalette.push(this._rdr_radar.shape(0));
        }
        
        // AA2's always bound to rows in cross-table.
        if ( feedings.aa2.fed ) {
          for ( i = 0; i < aa2.values[0].rows.length; i++ ) {
            this._rdr_colorPalette.push(this._rdr_radar.color(i));
          }
          if ( !feedings.aa3.fed ){
           this._rdr_shapePalette.push(this._rdr_radar.shape(0));
          }
        }
        
        // AA3's usually bound to columns in cross-table.
        if ( feedings.aa3.fed ) {
          for ( i = 0; i < aa3.values[0].rows.length; i++ ) {
            this._rdr_shapePalette.push(this._rdr_radar.shape(i));
          }
          if ( !feedings.aa2.fed ) {
            this._rdr_colorPalette.push(this._rdr_radar.color(0));
          }
        }
        
        for ( i = 0; i < mg.length; i++ ) {
          for ( j = 0; j < mg[i].rows.length; j++ ) {
            for ( x = 0; x < cardinal; x++ ) {
              mg[i].rows[j][x].color = this._rdr_colorPalette[x] || this._rdr_radar.color(0);
              if ( feedings.aa2.fed ) {
                mg[i].rows[j][x].shape = this._rdr_shapePalette[j] || this._rdr_radar.shape(0);
              } else {
                mg[i].rows[j][x].shape = this._rdr_shapePalette[x] || this._rdr_radar.shape(0);
              }
            }
          }
        }
        
        // Transform measure group into series.
        var entry, temp = [], item = [], nulls=[];
        for ( i = 0; i < mg[0].rows.length; i++ ) {
          entry = [];
          for ( j = 0; j < mg.length; j++ ) {
            entry.push(mg[j].rows[i]);
          }
          temp.push(entry);
        }

        for ( i = 0; i < temp.length; i++ ) {
          // process each same row of cross tables
          for ( x = 0; x < cardinal; x++ ) {
            // loops against columns
            for ( j = 0; j < temp[i].length; j++, nulls = [] ) {
              item.push(temp[i][j][x]);
            }
            series.push(item);
            item = [];
          }
        }
        
        var that = this;
        $.each(series, function ( index, item ) {
          var values = item, nulls = [];
          for ( var i = 0; i < values.length; i++ ) {
            values[i].order = i; // actual data index
            if ( values[i].val === null ){
             nulls.push(values[i]);
            }
          }
          for ( i = values.length - 1; i >= 0; i-- ) {
            if ( values[i].val === null ){
             values.splice(i, 1);
            }
          }
          that.vacants.push(nulls);
        });
        
        if ( !this._rdr_radar.title.customization ) { // not customized
          this._rdr_properties.polarAxis.title.text = langManager.get('IDS_DEFAULTMND');
        }
      } else {
        if ( feedings.aa2.fed ) {
          for ( i = 0; i < aa2.values.length; i++ ) {
            if ( aa2.values[i].type && aa2.values[i].type.toLowerCase() === "mnd" ) {
              feedings.aa2.hasMND = true;
            }
          }
          if ( feedings.aa2.hasMND ) {
            if ( aa2.values.length >= 2 ){
             feedings.aa2.axesFed = true;
            }
            else{
             feedings.aa2.axesFed = false;
            }
          } else {
            feedings.aa2.axesFed = true;
          }
        }
        
        if ( feedings.aa3.fed ) {
          for ( i = 0; i < aa3.values.length; i++ ) {
            if ( aa3.values[i].type && 
                 aa3.values[i].type.toLowerCase() === "mnd" ) {
              feedings.aa3.hasMND = true;
            }
          }
          if ( feedings.aa3.hasMND ) {
            if ( aa3.values.length >= 2 ){ 
              feedings.aa3.axesFed = true;
            }
            else{
             feedings.aa3.axesFed = false;
            }
          } else {
            feedings.aa3.axesFed = true;
          }
        }
  
        // Extract series values from measure groups
        var colorCursor = 0, shapeCursor = 0,
            aa2mndized = feedings.aa2.hasMND && !feedings.aa2.axesFed,
            aa3mndized = feedings.aa3.hasMND && !feedings.aa3.axesFed;
        var nullsTemp = [];
            
        for ( i = 0; i < mg.length; i++ ) {
          if ( aa2mndized ){
            this._rdr_colorPalette.push(this._rdr_radar.color(i));
          }
          if ( aa3mndized ){
            this._rdr_shapePalette.push(this._rdr_radar.shape(i));
          } 
          
          for ( j = 0; j < mg[i].rows.length; j++, nullsTemp = []) {
            // filter out null values
            for ( x = 0; x < mg[i].rows[j].length; x++ ) {
              if ( mg[i].rows[j][x].val === null ) {
                nullsTemp.push(mg[i].rows[j][x]);
              }
              mg[i].rows[j][x].order = x;
            }
            series.push(mg[i].rows[j].slice());
            this.vacants.push(nullsTemp);
            
            if ( feedings.aa2.fed ) {
              if ( aa2mndized ) {
                for ( x = 0; x < mg[i].rows[j].length; x++ ) {
                  mg[i].rows[j][x].color = this._rdr_radar.color(i);
                }
              } else if ( feedings.aa2.hasMND && feedings.aa2.axesFed ) {
                colorCursor++;
                this._rdr_colorPalette.push(this._rdr_radar.color(colorCursor));
                for ( x = 0; x < mg[i].rows[j].length; x++ ) {
                  mg[i].rows[j][x].color = this._rdr_radar.color(colorCursor);
                }
              } else {
                this._rdr_colorPalette.push(this._rdr_radar.color(j));
                for ( x = 0; x < mg[i].rows[j].length; x++ ) {
                  mg[i].rows[j][x].color = this._rdr_radar.color(j);
                }
              }
            } else {
              // Default value in case aa2 is fed nothing
              this._rdr_colorPalette.push(this._rdr_radar.color(0));
              for ( x = 0; x < mg[i].rows[j].length; x++ ) {
                mg[i].rows[j][x].color = this._rdr_radar.color(0);
              }
            }
            if ( feedings.aa3.fed ) {
              if ( aa3mndized ) {
                for ( x = 0; x < mg[i].rows[j].length; x++ ) {
                  mg[i].rows[j][x].shape = this._rdr_radar.shape(i);
                }
              } else if ( feedings.aa3.hasMND && feedings.aa3.axesFed ) {
                shapeCursor++;
                this._rdr_shapePalette.push(this._rdr_radar.shape(shapeCursor));
                for ( x = 0; x < mg[i].rows[j].length; x++ ) {
                  mg[i].rows[j][x].shape = this._rdr_radar.shape(shapeCursor);
                }
              } else {
                if ( feedings.aa2.fed ) {
                  if ( feedings.aa2.hasMND ) {
                    this._rdr_shapePalette.push(this._rdr_radar.shape(j));
                    for ( x = 0; x < mg[i].rows[j].length; x++ ) {
                      mg[i].rows[j][x].shape = this._rdr_radar.shape(j);
                    }
                  } else {
                    for ( x = 0; x < mg[i].rows[j].length; x++ ) {
                      this._rdr_shapePalette.push(this._rdr_radar.shape(x));
                      mg[i].rows[j][x].shape = this._rdr_radar.shape(x);
                    }
                  }
                }

              }
            } else {
              this._rdr_shapePalette.push(this._rdr_radar.shape(0));
              for ( x = 0; x < mg[i].rows[j].length; x++ ) {
                mg[i].rows[j][x].shape = this._rdr_radar.shape(0);
              }
            }
          }
        }
        for ( i = 0; i < series.length; i++ ) {
          for ( j = series[i].length - 1; j >= 0; j-- ) {
            for ( var n = 0; n < this.vacants[i].length; n++ ) {
              if ( this.vacants[i][n].order === j ){
                series[i].splice(j, 1);
              }
            }
          }
        }
        if ( !this._rdr_radar.title.customization ) { // not customized
          this._rdr_properties.polarAxis.title.text = this._rdrfn_combine_dimension_titles(aa1);
        }
      }
      if ( !this._rdr_valueaxis.customization ) {
        var measures = [];
        for ( i = 0; i < mg.length; i++ ) {
          measures.push(mg[i].col === '' || mg[i].col === null ? langManager.get('IDS_ISNOVALUE') : mg[i].col);
        }
        this._rdr_properties.valueAxis.title.text = measures.join(DEFAULT_WORDING.and);
      }
      
      this._rdr_radar.series = series;
      this._rdr_radar.feedings = feedings;
      //if ( !this._rdr_radar.locked ) {
        //this._rdrfn_rescale();
      //}
      
      return this;
    };

    Radar.prototype.primaryDataRange = function (_) {
      if ( !arguments.length ){
        this._rdrfn_rescale(this);
        return { 
          min : this._rdr_radar.min, 
          max : this._rdr_radar.max 
        };
       }
      this._rdr_radar.min = _.min;
      this._rdr_radar.max = _.max;
//      this._rdrfn_rescale(_.min, _.max);
      this._rdr_radar.locked = true;
      return this;
    };
    
    Radar.prototype.colorPalette = function (_) {
      if ( !arguments.length ) {
        return this._rdr_colorPalette;
      }
      this._rdr_colorPalette = _;
      return this;
    };
    
    Radar.prototype.shapes = function (_) {
      if ( !arguments.length ){
       return this._rdr_shapePalette;
     }
      this._rdr_shapePalette = _;
      return this;
    };
    
    Radar.prototype.dispatch = function (_) {
      if ( !arguments.length ){ 
        return this._rdr_eDispatch;
      }
      this._rdr_eDispatch = _;
      return this;
    };
    
    Radar.prototype.properties = function (_) {
      if ( !arguments.length ){
        return this._rdr_properties;
      }

      var scaleRangeMinNaN = false,
          scaleRangeMaxNaN = false;
      if (_.valueAxis && _.valueAxis.scale && _.valueAxis.scale.fixedRange) {
          scaleRangeMinNaN = isNaN(Number(_.valueAxis.scale.minValue));
          scaleRangeMaxNaN = isNaN(Number(_.valueAxis.scale.maxValue));
      }

      Objects.extend(true, this._rdr_properties, _);

      if (scaleRangeMinNaN) {
          this._rdr_properties.valueAxis.scale.minValue = NaN;
      }
      if (scaleRangeMaxNaN) {
          this._rdr_properties.valueAxis.scale.maxValue = NaN;
      }

      this._rdr_yscale = d3.scale.linear();
      if ( this._rdr_properties.polarAxis.title.text !== 'Categories'){
        this._rdr_radar.title.customization = true;
      } else {
        this._rdr_radar.title.customization = false;
      }
      
      if ( this._rdr_properties.valueAxis.title.text !== 'Value' ){
        this._rdr_valueaxis.customization = true;
      } else {
        this._rdr_valueaxis.customization = false;
      }

      if ( this._rdr_properties.colorPalette.length ){ 
        this._rdr_radar.color.range(this._rdr_properties.colorPalette);
      }
      if ( this._rdr_properties.shapePalette.length ) {
        this._rdr_radar.shape.range(this._rdr_properties.shapePalette);
      }
      STYLES.marker.size = this._rdr_properties.marker.size;
      if ( STYLES.marker.size > DEFAULT_RANGES.marker.size[1] ||  STYLES.marker.size < DEFAULT_RANGES.marker.size[0]){
        STYLES.marker.size =  6;
      } 
      STYLES.polargrid.color = this._rdr_properties.polarGrid.color;
      this.caliberated = true;
      if (TypeUtils.isExist(this._rdr_properties.valueAxis) && TypeUtils.isExist(this._rdr_properties.valueAxis.label) && TypeUtils.isExist(this._rdr_properties.valueAxis.label.formatString) && TypeUtils.isArray(this._rdr_properties.valueAxis.label.formatString)) {
        var measureAxis = this._rdr_data.getMeasureValuesGroupDataByIdx(0);
        if (measureAxis.values && TypeUtils.isArray(measureAxis.values) && TypeUtils.isArray(measureAxis.values[0].rows)) {
          var iFormatString = this._rdr_properties.valueAxis.label.formatString[measureAxis.values[0].rows[0][0].ctx.path.mg];
          var indexOfiFSX = measureAxis.values[0].rows[0][0].ctx.path.mi >= iFormatString.length ? iFormatString.length -1 : measureAxis.values[0].rows[0][0].ctx.path.mi;
          this._rdr_properties.valueAxis.label.formatString = iFormatString[indexOfiFSX];
        }
      }
      this.data(this._rdr_data);
      return this;
    };
    
    Radar.prototype.afterUIComponentAppear = function(){
      this._rdr_eDispatch.initialized(); 
    };
    
    Radar.prototype.width = function (_) {
      if ( !arguments.length ){
        return this._rdr_width;
      }
      //var changed = this._rdr_width === _ ? false : true;
      this._rdr_width = _;
      // if ( TypeUtils.isEmptyObject(this._rdr_data) && this._rdr_height ) {
      //   this.data(this._rdr_data);
      // }
      //if ( changed /*&& !this._rdr_radar.locked */ ){
       //this._rdrfn_rescale();
      //}
      return this;
    };
    
    Radar.prototype.height = function (_) {
      if ( !arguments.length ) {
        return this._rdr_height;
      }
      //var changed = this._rdr_height === _ ? false : true;
      this._rdr_height = _;
      // if ( TypeUtils.isEmptyObject(this._rdr_data) && this._rdr_width ){
      //   this.data(this._rdr_data);
      // }
      // if ( changed && /*!this._rdr_radar.locked*/ ){
      //  this._rdrfn_rescale();
      // }
      return this;
    };
    
    Radar.prototype.size = function (_) {
      if ( !arguments.length ){
       return {
        width : this._rdr_width, height : this._rdr_height
       };
      }
      this._rdr_width = _.width;
      this._rdr_height = _.height;
      // if ( TypeUtils.isEmptyObject(this._rdr_data) && this._rdr_width && this._rdr_height ){
      //  this.data(this._rdr_data);
      // }
      // if ( this._rdr_width && this._rdr_height && this._rdr_radar.series.length ){
      //  this._rdrfn_rescale();
      // }
      return this;
    };
    
    Radar.prototype.parent = function (_) {
      if ( !arguments.length ){
       return this._rdr_container;
      }
      this._rdr_container = _;
      return this;
    };
    
    Radar.prototype.hoverOnPoint = function ( cursor ) {
      var pole = this._rdr_radar.pole, theta, r,
          radians = this._rdr_radar.radians,
          point = {
            x : cursor.x - pole.x,
            y : pole.y - cursor.y
          };
      r = Math.sqrt( Math.pow(point.x, 2) + Math.pow(point.y, 2) );
      
      // out of radius range
      if ( r > this._rdr_radar.radiusLength ) {
        if ( typeof this.last !== "undefined" && 
            (TypeUtils.isEmptyObject(this._rdr_selections)) ) {
          brush.straight.call(this,DEFAULT_WORDING.dot + DEFAULT_WORDING.data + this.last, true);
        }
        // hide tool tip
        if ( this._rdr_properties.tooltip.enabled ){
          this._rdrfn_showTooltip();
        }
        return;
      }
      
      // range is (-PI, PI]
      theta = Math.atan2( point.y, point.x );
      
      // search for the target interval that the angle locates in
      var bisect = d3.bisector(function (d) { return d.radian; }).right,
          intv = bisect(radians, theta), mid, left, right, target;
      
      if ( intv === 0 ) {
        left = radians.length - 1, right = 0;
        if ( radians[left].radian === Math.PI ) {
          mid = -1 * (Math.PI + Math.abs(radians[right].radian)) / 2;
          target = theta > mid ? target = radians[right].axisIdx : 
                   target = radians[left].axisIdx;
        } else {
          target = radians[0].axisIdx;
        }
      } else if ( intv === radians.length ) {
        target = radians[radians.length - 1].axisIdx;
      } else {
        left = intv - 1, right = intv;
        mid = (radians[left].radian + radians[right].radian) / 2;
        target = theta > mid ? target = radians[right].axisIdx : 
                 target = radians[left].axisIdx;
      }
      
      if ( typeof this.last !== "undefined" && this.last !== target ) {
        brush.straight.call(this,DEFAULT_WORDING.dot + DEFAULT_WORDING.data + this.last, true);
      }
      
      brush.focus.call(this, DEFAULT_WORDING.dot + DEFAULT_WORDING.data + target, true);
      
      if ( !TypeUtils.isEmptyObject(this._rdr_selections) ) {
        brush.dim.call(this,DEFAULT_WORDING.dot + DEFAULT_WORDING.data + target, true);
        for ( var key in this._rdr_selections ) {
          if(this._rdr_selections.hasOwnProperty(key)){
            for ( var i = 0; i < this._rdr_selections[key].length; i++ ){
            brush.highlight.call(this,this._rdr_selections[key]);
            }
          }
        }
      }
      
      // show tool tip if allowed
      if ( this._rdr_properties.tooltip.enabled ){
        this._rdrfn_showTooltip(target);
      }
      
      // Memorize the last processed axis index
      this.last = target;
    };
    
    Radar.prototype.clear = function () {
      if ( !arguments[0] ) {
        brush.straight.call(this).bright.call(this);
        this._rdr_selections = {};
        if(this._rdr_hasDefaultSelection){
          var datapoints = [];
          datapoints.push(this._rdr_radar.node.selectAll(DEFAULT_WORDING.dot + STYLES.line.clazz));
          datapoints.push(this._rdr_radar.node.selectAll(DEFAULT_WORDING.dot + STYLES.marker.clazz));
          defaultSelUtil.clearSelectionInfo(this._rdr_container, false, datapoints);
        }
      } else {
        brush.dim.call(this);
      }
    };
    
    Radar.prototype.highlight = function ( objects ) {
      if ( !this._rdr_radar.min && !this._rdr_radar.max ){
       return;
      }
      var target = objects instanceof Array ? objects : [ objects ], query = /[sS][0-9]+/, key;
      
      this._rdr_selectionMode = typeof arguments[1] === 'boolean' ? 'multiple' : ( 
        typeof arguments[1] === 'string' ? arguments[1].toLowerCase() :
        typeof arguments[2] === 'string' ? arguments[2].toLowerCase() : 'multiple');
          
      brush.highlight.call(this,target);
      
      for ( var i = 0, exists = false; i < target.length; i++, exists = false ) {
        key = target[i].className.baseVal.match(query)[0];
        if ( this._rdr_selections[key] ) {
          for ( var j = 0; j < this._rdr_selections[key].length; j++ ) {
            if ( this._rdr_selections[key][j] === target[i] ){
             exists = true;
            }
          }
          if ( !exists ) {
            this._rdr_selections[key].push(target[i]);
          }
        } else {
          this._rdr_selections[key] = [];
          this._rdr_selections[key].push(target[i]);
        }
      }

      if ( this._rdr_selectionMode === 'single' ){
       return;
      }

      var cardinal, seriesOrder;
      for ( var n in this._rdr_selections ) {
        if ( this._rdr_selections.hasOwnProperty(n) ) {
          seriesOrder = n.substr(1);
          cardinal = this._rdr_radar.series[seriesOrder].length;
          highlight.call(this,n, this._rdr_selections[n], cardinal);
        }
      }
      
      if ( this._rdr_hasDefaultSelection ) {
        defaultSelUtil.clearSelectionInfo(this._rdr_container, true, target);
      }
    };

    Radar.prototype.unhighlight = function ( object ) {
      var target = object instanceof Array ? object : [object];
      brush.straight.call(this,target).dim.call(this,target);
     
      if ( this._rdr_selectionMode === 'single' ) { 
        this._rdr_selections = []; return; 
      }
      var that = this;
      $.each(target, function ( index, item ) {
        var series = item.className.baseVal.match(/[sS][0-9]+/)[0];
      
        for ( var key in that._rdr_selections ) {
          if(that._rdr_selections.hasOwnProperty(key)){
            for ( var i = 0; i < that._rdr_selections[key].length; i++ ) {
              for ( var j = 0; j < object.length; j++ ) {
                if ( that._rdr_selections[key][i] === object[j] ) {
                  that._rdr_selections[key].splice(i, 1);
                  break;
                }
              }
            }
          }
        }
        brush.straight2.call(that,DEFAULT_WORDING.dot + series)
             .dim.call(that,DEFAULT_WORDING.dot + series);
      });
      
      if(this._rdr_hasDefaultSelection){
        defaultSelUtil.clearSelectionInfo(this._rdr_container, false, target);
      }
    };
    
    Radar.prototype.blurOut = function () {
      this._rdr_eDispatch.hideTooltip();
    };

    Radar.prototype.destroy = function () {
      this._rdr_data = null;
      this._rdr_parent = null;
      if(this._rdr_yscale){
       this._rdr_yscale.domain([0,1]).range([0,1]);
      }
      this._rdr_yscale = undefined;
      this._rdr_container = null;
      this._rdr_selections = {};
      if(this._rdr_effectManager){
        this._rdr_effectManager.destroy();
      }
      if(this._rdr_styleManager){
        this._rdr_styleManager.destroy();
      }
    };

    // only deal with domain values
    Radar.prototype._rdrfn_rescale = function (thisRef) {
      var series = thisRef._rdr_radar.series;
          // min = arguments[0], 
          // max = arguments[1];
      var newDomain, tempMax, tempMin;
      var dataMax = d3.max( d3.merge( d3.merge(series) ), function (_) { return _.val; } ),
          dataMin = d3.min( d3.merge( d3.merge(series) ), function (_) { return _.val; } ),
          tempScale = d3.scale.linear();

      tempScale.domain([dataMin, dataMax]).range([200, 0]);
      Scaler.perfect(tempScale);
      newDomain = tempScale.domain();
      dataMax = newDomain[1] >= newDomain[0] ? newDomain[1] : newDomain[0];
      dataMin = newDomain[1] >= newDomain[0] ? newDomain[0] : newDomain[1];

      if (thisRef._rdr_properties.valueAxis.scale.fixedRange === true) {
        tempMax = Number(thisRef._rdr_properties.valueAxis.scale.maxValue);
        tempMin = Number(thisRef._rdr_properties.valueAxis.scale.minValue);
        if (isNaN(tempMax)) {
          tempMax = dataMax;
        }
        if (isNaN(tempMin)) {
          tempMin = dataMin;
        }
        if (tempMax <= tempMin) {
          tempMax = dataMax;
          tempMin = dataMin;
        }
        thisRef._rdr_radar.manualRange = true;
      } else {
        thisRef._rdr_radar.manualRange = false;
        tempMax = dataMax;
        tempMin = dataMin;
      }

      thisRef._rdr_radar.max = tempMax;
      thisRef._rdr_radar.min = tempMin;

      if ( thisRef._rdr_radar.min !== undefined && thisRef._rdr_radar.max !== undefined && thisRef._rdr_radar.min === thisRef._rdr_radar.max ) {
        if ( thisRef._rdr_radar.min === 0 ) {
          thisRef._rdr_radar.max = 1;
        }
        if ( thisRef._rdr_radar.min < 0 ) {
          thisRef._rdr_radar.max = 0;
        }
        if ( thisRef._rdr_radar.min > 0 ) {
          thisRef._rdr_radar.min = 0;
        }
      }
      
      if ( !thisRef._rdr_radar.min || thisRef._rdr_radar.min === "NaN" ) {
        thisRef._rdr_radar.min = 0;
      }
      if ( !thisRef._rdr_radar.max || thisRef._rdr_radar.max === "NaN" ) {
        thisRef._rdr_radar.max = 1;
      }
    };

    /* Layout algorithm. Arguments are preferred widths */
    Radar.prototype._rdrfn_arrange = function () {
      var sizes = arguments[0],
          axisWidth = sizes.valueaxis, lblW = sizes.lblW, lblH = sizes.lblH,
          title = sizes.title,
          pole = {}, w, r, adjust, bbox,
          hgap = STYLES.spacing.hgap, vgap = STYLES.spacing.vgap,
          counter = -1, mem = [];
      var that = this;
      
      (function layout() {
        counter++;
        if ( lblH - 1/3 * that._rdr_height > 0 ){
         lblH = 0;
        }
        if ( title.height - 1/3 * this._rdr_height > 0 ){
         title.height = 0;
        }
        if ( title.width - 2/3 * this._rdr_width > 0 ){
         title.width = 0;
        }
        
        if ( that._rdr_width - that._rdr_height >= 0 ) {
          r = ( that._rdr_height - 2 * (lblH + 2 * vgap) - 
            (title.height !== 0 ? title.height + 2 * vgap : 0) ) / 2;
          w = 2 * r + 2 * (lblW + 2 * hgap) + axisWidth;
          if ( w > that._rdr_width ) {
            adjust = w - that._rdr_width;
            r = ( that._rdr_height - adjust - 2 * (lblH + 2 * vgap) - 
              (title.height !== 0 ? title.height + 2 * vgap : 0) ) / 2;
          }
        } else {
          r = ( that._rdr_width - 2 * (lblW + 2 * hgap) - axisWidth ) / 2;
        }
    
        mem[counter] = r;
        if ( typeof mem[counter - 2] !== 'undefined' && mem[counter - 2] <= 0 ) { return 0; } // prevent infinite loops   
        
        if ( lblW > r || r <= 0 ) {
          lblW = 0, lblH = 0; 
          title.width = 0, title.height = 0; 
          r = layout();
          
          if ( axisWidth > r) {
            axisWidth = 0;
            r = layout();
            if ( that._rdr_width >= that._rdr_height ) {
              if ( r < that._rdr_height / 2 ){
               r = that._rdr_height / 2, vgap = 0;
              }
            } else {
              if ( r < that._rdr_width / 2 ){
               r = that._rdr_width / 2, hgap = 0;
             }
            }
          }
        }
        return r;
      })();
      
      bbox = { // bounding box
        width : axisWidth + 2 * r + 4 * hgap + 2 * lblW,
        height : 2 * ( lblH + r ) + 4 * vgap + 
          (title.height !== 0 ? title.height + 2 * vgap : 0)
      };
      
      this._rdr_radar.radiusLength = r;
      this._rdr_valueaxis.width = axisWidth;
      this._rdr_valueaxis.anchor.x = 0;
      this._rdr_valueaxis.anchor.y = lblH + 2 * vgap;
      this._rdr_radar.title.width = title.width;
      this._rdr_radar.title.height = title.height;
      pole.x = axisWidth + lblW + r + hgap * 2;
      pole.y = lblH + r + vgap * 2;
      title.x = pole.x;
      title.y = pole.y + r + lblH + 2 * vgap + title.height / 2;
      
      var xoffset = 0, yoffset = 0;
      if ( axisWidth ) {
        this._rdr_valueaxis.ref.gridlineLength(pole.x - axisWidth);
        if ( this._rdr_width > this._rdr_height ) {
          xoffset = this._rdr_width / 2 - bbox.width / 2;
          this._rdr_valueaxis.anchor.x += xoffset;
          pole.x += xoffset;
          title.x += xoffset;
        }
      } else {
        if ( this._rdr_width > this._rdr_height ) {
          xoffset = this._rdr_width / 2 - pole.x;
          pole.x += xoffset;
          title.x += xoffset;
        } 
      }
      
      //radar.title.node.attr("transform", "translate(" + title.x + "," + title.y + ")");
      this._rdr_radar.title.node.attr("x", title.x);
      this._rdr_radar.title.node.attr("y", title.y);
      this._rdr_valueaxis.node.attr("transform", "translate(" + 
        this._rdr_valueaxis.anchor.x + "," + this._rdr_valueaxis.anchor.y + ")");
      this._rdr_radar.node.attr("transform", "translate(" + pole.x + "," + pole.y + ")");
      this._rdr_radar.pole = pole;
      this._rdr_radar.labels.width = lblW;
      this._rdr_radar.labels.height = lblH;
    };
    
    /*
     * Creates scale function/object for angular computation.
     * 
     * @param nulls - indexes of empty elements
     * @param N - numbers of non-empty elements
     * @param cardinal - numbers of all elements
     */
    Radar.prototype._rdrfn_angles = function ( nulls, N, cardinal ) {
      var domain = [], intervals = [], i;
      if ( !nulls.length ) {
        return d3.scale.linear()
          .domain([ 0, cardinal ])
          .range([ 0, 2 * Math.PI ]);
      }
      for ( i = 0; i < cardinal; i++ ) {
        domain.push(i);
        intervals.push(i / cardinal * 2 * Math.PI);
      }
      for ( i = nulls.length - 1; i >= 0; i-- ) {
        intervals.splice(nulls[i].order, 1);
      }
      
      return d3.scale.ordinal()
            .domain(domain)
            .range(intervals);
    };

    Radar.prototype._rdrfn_combine_dimension_titles = function( axes ) {
      var str = '';
      for ( var i = 0; i < axes.length; i++ ) {
        str = str.concat(axes[i].col.val === null ? langManager.get('IDS_ISNOVALUE') : axes[i].col.val + 
          DEFAULT_WORDING.slash);
      }
      return str.lastIndexOf(DEFAULT_WORDING.slash) > 0 ? 
             str.substr(0, str.lastIndexOf(DEFAULT_WORDING.slash)) : str;
    };

    Radar.prototype._rdrfn_showTooltip = function () {
      if ( typeof arguments[0] === "undefined" ) { this._rdr_eDispatch.hideTooltip(); return; }
      
      var volume, item = {}, elements, target = arguments[0], anchor = {}, angle = 0,
          r = this._rdr_radar.radiusLength - STYLES.tooltip.radialOffset, 
          translation = this._rdr_container[0][0].getTransformToElement(this._rdr_container[0][0].ownerSVGElement),
          i;
      
      for ( i = 0; i < this._rdr_radar.radians.length; i++ ) {
        if ( this._rdr_radar.radians[i].axisIdx === target ) {
          angle = this._rdr_radar.radians[i].radian; break;
        }
      }
      
      anchor.x = r * Math.cos(angle);
      anchor.y = r * Math.sin(angle);
      var orient = angle <= 0.5 * Math.PI && angle > -0.5 * Math.PI ? "left" : "right";
      
      volume = {
        body : [],
        plotArea : {
          x : translation.e,
          y : translation.f,
          width : this._rdr_width,
          height : this._rdr_height
        },
        point : { // where tool tip arrow points to
          x : anchor.x + this._rdr_radar.pole.x + translation.e,
          y : anchor.y < 0 ? 
              Math.abs(anchor.y) + this._rdr_radar.pole.y + translation.f : 
              this._rdr_radar.pole.y - anchor.y + translation.f, 
          orientation : orient,
          angle : angle,
          range : {
            x : angle === 0.5 * Math.PI || angle === -0.5 * Math.PI ? 0 : 
                Math.abs(anchor.x),
            y : angle === 0 || angle === Math.PI || angle === -1 * Math.PI ? 0 : 
                Math.abs(anchor.y)
          }
        },
        footer : []
      };

      var aa1 = this._rdr_data.getAnalysisAxisDataByIdx(0).values,
          aa2 = this._rdr_radar.feedings.aa2.fed ? this._rdr_data.getAnalysisAxisDataByIdx(1).values : null,
          aa3 = this._rdr_radar.feedings.aa3.fed ? this._rdr_data.getAnalysisAxisDataByIdx(2).values : null,
          mg = this._rdr_data.getMeasureValuesGroupDataByIdx(0).values;
      
      elements = this._rdr_radar.node.selectAll("." + DEFAULT_WORDING.data + target);
      elements[0].sort(function(a,b){
          return a.className.animVal.split(' ')[0].split('s')[1]-b.className.animVal.split(' ')[0].split('s')[1];
      });
      
      var col, row, cardinal, index, j, temp;
      
      if ( this._rdr_radar.mndized ) {
        item = { 
          name : this._rdr_radar.categories[target] === '' || this._rdr_radar.categories[target] === null ? 
                 langManager.get('IDS_ISNOVALUE') : this._rdr_radar.categories[target], 
          val : [],
          ctx : {}
        };
      var that = this;
        // normal case
        elements.each(function (d) {
          var entry = {};
          entry.color = d.color;
          entry.shape = d.shape;
          entry.value = d.val !== null ? d.val : langManager.get('IDS_ISNOVALUE');
          
          if ( !that._rdr_radar.feedings.aa2.fed && !that._rdr_radar.feedings.aa3.fed ) {
            entry.label = null;
          }
          
          if ( that._rdr_radar.feedings.aa2.fed ) {
            index = that._rdr_properties.multichart ? d.ctx.path.dii_a2 : d.ctx.path.dii_a1;
            for ( i = 0, temp = []; i < aa2.length; i++ ) {
              temp.push(aa2[i].rows[index]);
            }
            col = temp;
            if ( !that._rdr_radar.feedings.aa3.fed ){
              entry.label = col;
            } 
          }
          
          if ( that._rdr_radar.feedings.aa3.fed ) {
            index = that._rdr_radar.feedings.aa2.fed ? d.ctx.path.dii_a2 : d.ctx.path.dii_a1;
            for ( i = 0, temp = []; i < aa3.length; i++ ) {
              temp.push(aa3[i].rows[index]);
            }
            if ( that._rdr_radar.feedings.aa2.fed ) {
              row = temp;
              entry.label = [];
              entry.label = entry.label.concat(col);
              entry.label = entry.label.concat(row);
            } else {
              col = temp;
              entry.label = col;
            }
          }
          item.ctx.path = {
            'mg': d.ctx.path.mg,
            'mi': d.ctx.path.mi
          };
          item.val.push(entry);
        });
        
        volume.body.push(item);
      } else {
        if ( !this._rdr_radar.feedings.aa2.axesFed && !this._rdr_radar.feedings.aa3.axesFed ) {
          elements.each(function (d) {
            var entry = {}, item = { name : mg[d.ctx.path.mi].col, val : [], ctx: {} };
            entry.color = d.color;
            entry.shape = d.shape;
            entry.value = d.val !== null ? d.val : langManager.get('IDS_ISNOVALUE');
            entry.label = null;
            
            item.val.push(entry);
            item.ctx.path = {
              'mg': d.ctx.path.mg,
              'mi': d.ctx.path.mi
            };
            volume.body.push(item);
          });
        } else {
          var mi = 0;
          for ( var x = 0; x < mg.length; x++ ) {
            item = { name : mg[x].col === null ? langManager.get('IDS_ISNOVALUE') : mg[x].col, val : [], ctx: {} };
            mi = x;
            
            if(mg[x].rows.length > 0 && mg[x].rows[0][0] !== undefined){
              mi = mg[x].rows[0][0].ctx.path.mi;
              item.ctx.path = {
                'mg': mg[x].rows[0][0].ctx.path.mg,
                'mi': mi
              };
            }
            
            elements.each(function (d) {
              var entry = {};
              entry.color = d.color;
              entry.shape = d.shape;
              entry.value = d.val !== null ? d.val : langManager.get('IDS_ISNOVALUE');
              
              var clazz = d3.select(this)[0][0].className.baseVal
                .match(/\smi[0-9]+/);
              if ( clazz !== null ){
               clazz = clazz[0];
              }
              else {
                return;
              }
              
                temp = [];
                
                if ( clazz === (DEFAULT_WORDING.measureIndex + mi) ) {
                  var aa = aa2 !== null ? aa2 : aa3;
                  for ( i = 0; i < aa.length; i++ ) {
                    if ( d.ctx.path.dii_a2 > aa[i].rows.length - 1 ) {
                      d.ctx.path.dii_a2 = aa[i].rows.length - 1;
                    }
                    temp.push(aa[i].rows[d.ctx.path.dii_a2]);
                  }
                  entry.label = temp;
              } else {
                return;
              }
              item.val.push(entry);
            });
            volume.body.push(item);
          }
        }
        
        var dimension = {};
        for ( i = 0; i < aa1.length; i++ ) {
          dimension = {};
          dimension.label = aa1[i].col;
          dimension.value = aa1[i].rows[target];
          volume.footer.push(dimension);
        }
      }
      this._rdr_eDispatch.showTooltip(tooltipDataHandler.formatTooltipData(volume));
    };
    
    Radar.prototype._rdrfn_isLabelArea = function(target){
      var classname = target.getAttribute('class'), isLabelArea = false;
      if(classname && classname.indexOf('v-labelarea') >= 0){
        isLabelArea = true;
      }
      return isLabelArea;
    };
  return Radar;
});

define('sap/viz/feeds/Radar',['sap/viz/feeds/Manifest','sap/viz/data/feed/Constants'],
function Setup( Manifest, constants ) {
  var colors = {
    id : "regionColor",
    name : "IDS_REGIONCOLOR",
    type : constants.Type.Dimension,
    min : 0,
    max : 2,
    aaIndex : 2,
    acceptMND : 2
  },
  
  shapes = {
    id : "regionShape",
    name : "IDS_REGIONSHAPE",
    type : constants.Type.Dimension,
    min : 0,
    max : 2,
    aaIndex : 3,
    acceptMND : 0
  },
  
  axes = {
    id : "radarAxes",
    name : "IDS_RADARAXES",
    type : constants.Type.Dimension,
    min : 1,
    max : 1,
    aaIndex : 1,
    acceptMND : 1
  },

  values = {
    id : "radarAxesValues",
    name : "IDS_RADARAXESVALUE",
    type : constants.Type.Measure,
    min : 1,
    max : constants.Constraints.INF,
    mgIndex : 1
  };

  var feeds = {
    id : "radar",
    feeds : [ colors, shapes, axes, values ]
  };
  Manifest.register(feeds);
});
define('sap/viz/modules/manifests/Radar',['sap/viz/modules/manifests/Module','sap/viz/modules/Constants','sap/viz/modules/radar','sap/viz/feeds/Radar'],
function Setup( Manifest, Constants, fn ) {
  var module = {
    id : "sap.viz.modules.radar",
    type : Constants.Type.Chart,
    name : "radar",
    description : "Radar module properties",
    properties : {
      drawingEffect : {
        name : 'drawingEffect',
        supportedValueType : 'String',
        supportedValues : [ 'normal', 'glossy' ],
        defaultValue : 'normal',
        description : 'Set drawing effect of radar.',
        isExported : true
      },
      polarGrid : {
        name : "polarGrid",
        supportedValueType : "Object",
        supportedValues : {
          visible : {
            name : "visible",
            supportedValueType : "Boolean",
            defaultValue : true,
            description : "Set polar gridline visibility switch."
          },
          color : {
            name : "color",
            supportedValueType : "String",
            defaultValue : "#d8d8d8",
            description : "Set polar gridline color."
          }
        },
        description : "Settings for Polar gridline customizations."
      },
      valueAxis : {
        name : "valueAxis",
        supportedValueType : "Object",
        supportedValues : {
          visible : {
            name : "visible",
            supportedValueType : "Boolean",
            defaultValue : true,
            description : "Set value axis visibility switch."
          },
          title : {
            name : "title",
            supportedValueType : "Object",
            supportedValues : {
              visible : {
                name : "visible",
                supportedValueType : "Boolean",
                defaultValue : false,
                description : "Set value axis title visibility switch."
              },
              text : {
                name : "text",
                supportedValueType : "String",
                defaultValue : "Value",
                description : "Set value axis title text."
              },
            },
            description : "Settings for value axis title."
          },
          label : {
          	name : "label",
          	supportedValueType : "Object",
          	supportedValues : {
          	  formatString : {
                  name : 'formatString',
              		supportedValueType : 'String | Two-Dimensions-Array',
              		defaultValue : null,
              		description : 'Set format string of value axis. If value is a string, it will be axis format string as before.' + 
                   ' If value is a two dimensions array that each item of array is applied to each item of measure value group,' +
                   ' it is only available for scatter matrix chart and multiple chart with MND in order to display different measure number format in each sub chart.' + 
                   ' If value is a two dimensions array for other charts except scatter matrix and multiple chart, the first value of first array of two dimensions array is as format string to format axis label.' + 
                   ' Any character in "MDYHSAmdyhsau#?%0@" is reserved as a token for format code.' + 
                   ' The end "u" of format string let value format with SI units, the other format string will explained as Excel format string,' + 
                   ' The value that bigger than 1e8 or less than 1e-6 and be not 0 format with Exponential style' +
                   ' The following is a simple sample format string for label for axis as "0.00%" or as one chart may have two measures: [["#,##0.00 DM;-#,##.00 DM","#,##.00;-#,##.00"]].'
                }
            },
            description : "Settings for axis label."
          },
          scale : {
            name : 'scale',
            description : 'Set scale for value axis.',
            supportedValueType : 'Object',
            supportedValues : {
              fixedRange : {
                  name : 'fixedRange',
                  supportedValueType : 'Boolean',
                  defaultValue : false,
                  description : 'Enable/disable fixed axis range according minValue and maxValue.',
              },
              minValue : {
                  name : 'minValue',
                  supportedValueType : 'Number',
                  defaultValue : 0,
                  description : 'Set minValue of yAxis.',
              },
              maxValue : {
                  name : 'maxValue',
                  supportedValueType : 'Number',
                  defaultValue : 0,
                  description : 'Set maxValue of yAxis.',
              }
            }
          },
        },
        description : "Settings for value axis at side bar."
      },
      polarAxis : {
        name : "polarAxis",
        supportedValueType : "Object",
        supportedValues : {
          title : {
            name : "title",
            description: "Settings for polar axis title.",
            supportedValueType : "Object",
            supportedValues : {
              visible : {
                name : "visible",
                supportedValueType : "Boolean",
                defaultValue : false,
                description : "Set category axis visibility switch."
              },
              text : {
                name : "text",
                supportedValueType : "String",
                defaultValue : "Categories",
                description : "Set category axis text."
              }
            }
          }
        },
        description : "Settings for polar axes customizations."
      },
      colorPalette : {
        name : "colorPalette",
        defaultValue : Constants.COLOR.SAPColorSingleAxis,
        description : "Set marker color customizations.",
        'example': "<a href='"+Constants.DocExample.SnippetUrl+"4449' target='_blank'>"+Constants.DocExample.TryThisValue+"</a>"
      },
      shapePalette : {
        name : "shapePalette",
        supportedValueType : "StringArray",
        defaultValue : [ "circle", "diamond", "triangleUp", "triangleDown", 
                  "triangleLeft", "triangleRight", "cross", "intersection" ],
        supportedValues : [ "circle", "diamond", "triangleUp", "triangleDown", 
                  "triangleLeft", "triangleRight", "cross", "intersection" ],
        description : 'Set marker shape customizations.'
      },
      line : {
        name : "line",
        description : "Settings for line customizations.",
        supportedValueType : "Object",
        supportedValues : {
          width : {
            name : 'width',
            supportedValueType : 'PositiveInt',
            defaultValue : 2,
            description : "Line weight settings. Range is [1, 7]"
          }
        }
      },
      surface : {
        name : "surface",
        supportedValueType : "Object",
        supportedValues : {
          fill : {
            name : 'fill',
            supportedValueType : 'Object',
            supportedValues : {
              visible : {
                name : 'visible',
                supportedValueType : 'Boolean',
                defaultValue : true,
                description : 'Set enable/disable fill effect for polar area.'
              },
              transparency : {
                name : 'transparency',
                supportedValueType : 'Double',
                defaultValue : 0.3,
                //min : '0',
                //max : '1',
                description : 'Set alpha value for polar area fill color.'
              },
            }
          }
        },
        description : "Settings for Surface customizations."
      },
      marker : {
        name : "marker",
        //description : "Settings for data point marker customizations.",
        supportedValueType : "Object",
        supportedValues : {
          size : {
            name : "size",
            supportedValueType : "PositiveInt",
            defaultValue : 6,
            min : 4,
            max : 32,
            description : "Set marker size customization."
          }
        },
        description : "Settings for marker/data point graphics."
      },
      tooltip : {
        name : "tooltip",
        supportedValueType : "Object",
        supportedValues : {
          enabled : {
            name : "enabled",
            supportedValueType : "Boolean",
            supportedValues : [ true, false ],
            defaultValue : true,
            description : "Set tooltip enablement."
          }
        },
        'isExported' : false,
        description : "Settings for tooltip customization."
      },
    },
    events : {
      'initialized': Constants.Event.Initialized.desc,
      selectData : Constants.Event.SelectData.desc,
      deselectData : Constants.Event.DeSelectData.desc,
      showTooltip : Constants.Event.TooltipShow.desc,
      hideTooltip : Constants.Event.TooltipHide.desc
    },
    feeds : {
      id : "radar"
    },
    css : {    
      ".viz-axis-title.v-title" : {
        description : "Font style for value axis title.",
        value : {
          fill : "#333333",
          "font-family" : "'Open Sans', Arial, Helvetica, sans-serif",
          "font-size" : "14px",
          "font-weight" : "bold"
        }
      },
      '.viz-axis-label.v-label' : {
        'description' : 'Define style for value axis label.',
        'value' : {
          'fill' : '#333333',
          'font-family' : "'Open Sans', Arial, Helvetica, sans-serif",
          'font-size' : '12px',
          'font-weight' : 'normal'
        }
      },     
      ".viz-polar-axis-label.v-polar-axis-label" : {
        description : "Font styles for polar axis labels.",
        value : {
          "font-family" : "'Open Sans', Arial, Helvetica, sans-serif",
          "fill" : "#333333",
          "font-size" : "11px",
          "font-weight" : "bold"
        }
      },
      ".viz-polar-axis-title.v-polar-axis-title" : {
          description : "Font styles for polar axis title.",
          value : {
            "font-family" : "'Open Sans', Arial, Helvetica, sans-serif",
            "fill" : "#333333",
            "font-size" : "14px",
            "font-weight" : "bold"
          }
        }
    },
    configure : null,
    fn : fn
  };
  Manifest.register(module);
});

define('sap/viz/modules/tooltip',['sap/viz/modules/dispatch','sap/viz/base/utils/Objects','sap/viz/format/FormatManager','sap/viz/base/utils/TypeUtils',
'sap/viz/base/utils/ObjectUtils','sap/viz/lang/langManager'],
function Setup(Dispatch, Objects, formatManager, TypeUtils, ObjectUtils, langManager) {
  var ret =  function(manifest, ctx) {
    var imageInfo =
    {
        imageMode: false,
        imagePalette: [],
        radio: 1
    };

    var _display = {
      singleMeasure : {
        label : {
          font : 'bold 11px sans-serif',
          color : '#333333'
        },
        value : {
          font : 'bold 14px sans-serif',
          color : '#333333'
        },
        padding : {
          vertical : 9,
          horizontal : 10
        }
      },
      multipleMeasure : {
        label : {
          font :  "12px 'Open Sans', Arial, Helvetica, sans-serif",
          color : '#333333'
        },
        value : {
          font : "12px 'Open Sans', Arial, Helvetica, sans-serif",
          color : '#333333'
        },
        padding : {
          vertical : 8,
          horizontal : 10,
          inline : 6,
          symbolGap : 7,
          defaultSpace : 8
        }
      },
      title : {
        color : '#333333',
        font : "bold 13px 'Open Sans', Arial, Helvetica, sans-serif",
        formatString : ''
      },
      footer : {
        label : {
          font :  "bold 10.5px 'Open Sans', Arial, Helvetica, sans-serif",
          color : '#333333'
        },
        value : {
          font : "10.5px 'Open Sans', Arial, Helvetica, sans-serif",
          color : '#333333'
        },
        padding : {
          inline : 6
        }
      },
      valueFormat : [],
      labelFormat : [],
      maxDimensionLabelWidth : 150,
      maxMeasureLabelWidth : 80
    };

    var _shapeLayout = {
      padding : 5,
      radius : 4,
      markerWidth : 12,
      markerHeight : 8,
      borderWidth : 1,
      separationLineBorderWidth : 1
    };

    var _defaultToolTipColors = {
      backgroundColor : '#ffffff',
      borderColor : '#D8D8D8',
      separationLineColor : [ '#ffffff', '#8a8a8a', '#ffffff' ],
      separationLineSingleColor : '#D8D8D8',
      guideLineColor : '#D8D8D8'
    };

    var _svgPathCommand = {
      arcA : 'A',
      lineToA : 'L',
      moveToA : 'M',
      closePath: 'z'
    };
    
    var _symbol = {
      symbolSize : 8,
      hasSymbol : false
    };
    
    var _symbolClassName = 'tooltipsymbol', _paragraphTitleClassName = 'v-body-title tooltipparagraphtitle', _paragraphLabelTextClassName = 'v-body-label tooltipparagraphlabel', _paragraphValueTextClassName = 'v-body-value tooltipparagraphvalue', _footerLabelClassName = 'v-footer-label tooltipfooterlabel', _footerValueClassName = 'v-footer-value tooltipfootervalue', _tooltipBackgroundClassName = 'v-background', _tooltipSeparationLineClassName = 'v-separationline';
    var _cssName = {
        bodyName : 'v-body',
        footerName : 'v-footer'
    };
    
    var vis = null, gWrapper = null;
    var tooltipWidth = 0, tooltipHeight = 0, textMaxWidth = 0, effectManager = ctx.effectManager,
    zone = {
        width : 200,
        height : 100
    },
    
    plotArea = {
        width: 160,
        height: 70,
        x: 0,
        y: 0
    },
    
    _properties = {},
    
    //tooltip border marker orientation
    _orientation = null,

    //variables are for tooltip content truncation case
    _truncationParameter = {
      isTruncated : false,
      currentFooterIndex : -1,
      currentBodyIndex : -1,
      defaultValue : '...',
      font : 'bold 20px Arial',
      color : '#000000'
    },
    
    _tooltipFinalSize = {
      tooltipBodyTitleHeight : 0,
      tooltipBodyLineHeight : 0,
      tooltipFooterLineHeight : 0
    };
    
    var defaultString = langManager.get('IDS_ISNOVALUE');

    var handleNull = function(_) {
      if (_ === null || _ === undefined) {
        return defaultString;
      } else {
        return _;
      }
    };
    
    function clearGlobalValues() {
      _truncationParameter.isTruncated = false;
      _truncationParameter.currentFooterIndex = -1;
      _truncationParameter.currentBodyIndex = -1;
      _tooltipFinalSize.tooltipBodyTitleHeight = 0;
      _tooltipFinalSize.tooltipBodyLineHeight = 0;
      _tooltipFinalSize.tooltipFooterLineHeight = 0;
    }
    
    function tooltip(selection) {
        if (selection !== null && selection !== undefined) {
            vis = d3.select(selection).append('svg').style('position',
                    'absolute').style('direction','ltr').attr('pointer-events', 'none').attr(
                    'width', '0').attr('height', 0).attr('class',
                    'v-m-tooltip');

        }
        // In first view, we should make tooltip invisible.
        tooltip.hideTooltip();
        return tooltip;
    }

    function getTooltipHeightV2(vis, data) {
      var bodyInline = _display.multipleMeasure.padding.inline, 
        multipleVertical = _display.multipleMeasure.padding.vertical,
        multipleLabelFont = _display.multipleMeasure.label.font,
        multipleValueFont = _display.multipleMeasure.value.font,
        footerInline = _display.footer.padding.inline,
        footerLabelFont = _display.footer.label.font,
        titleFont = _display.title.font;
      var tooltipHeight = 0, tooltipBody = data.body, tooltipFooter = data.footer;
       
        
        //First rule, make sure the content contains the first paragraph title and footer if the tooltip height is beyond zone height.
        if (tooltipBody && tooltipBody.length > 0) {
            tooltipHeight = multipleVertical;
          
            if (tooltipFooter && tooltipFooter.length > 0) {
              var firstPlaceHolderHeight = 0;
              if (tooltipBody[0].name !== null) {
                firstPlaceHolderHeight =  getTextBox(vis, tooltipBody[0].name,  titleFont).height + bodyInline + getTextBox(vis, _truncationParameter.defaultValue,  _truncationParameter.font).height;
              }
              
              var footerLineText = '';
              for (var m = 0; m < tooltipFooter.length; m++) {
                if (footerLineText === '' && tooltipFooter[m].label !== null && tooltipFooter[m].label !=='')
                {
                  footerLineText = tooltipFooter[m].label;
                }
                
                if (footerLineText === '' && tooltipFooter[m].value !== null && tooltipFooter[m].value !=='')
                {
                  footerLineText = tooltipFooter[m].value;
                }
              }
              
              if (footerLineText !== '') {
               //var footerlabelBox1 = getTextBox(vis, tooltipFooter[0].label, footerLabelFont);
                _tooltipFinalSize.tooltipFooterLineHeight = getTextBox(vis, footerLineText, footerLabelFont).height;
                
                tooltipHeight += multipleVertical * 3;
                
                tooltipHeight += (tooltipFooter.length * _tooltipFinalSize.tooltipFooterLineHeight + footerInline * (tooltipFooter.length - 1));
            
                tooltipHeight += firstPlaceHolderHeight;
                if (tooltipHeight > zone.height) {
                  _truncationParameter.isTruncated = true;
                  _truncationParameter.currentBodyIndex = 0;
                  
                  var num1 = 0;
                  while (tooltipHeight > zone.height) {
                    tooltipHeight -= _tooltipFinalSize.tooltipFooterLineHeight;
                    tooltipHeight -= footerInline;
                    num1++;
                  }
                  _truncationParameter.currentFooterIndex = tooltipFooter.length - num1 - 1;
                  
                  return tooltipHeight;
                }
                
                tooltipHeight -= firstPlaceHolderHeight;
              }
            } else {
              tooltipHeight += multipleVertical;
            }
            
            var paragraphTitleNum = 0, paragraphLineNum = 0, bodyTitleText = '', bodyLineLabelText = '', bodyLineValueText = '', bodyLineLabelTextFind = false, bodyLineValueTextFind = false;
            for (var i = 0; i < tooltipBody.length; i++) {
              if (bodyTitleText === '' && tooltipBody[i].name !== null && tooltipBody[i].name !== '') {
                bodyTitleText = tooltipBody[i].name;
              }
              
              for (var j = 0; j < tooltipBody[i].val.length; j++) {
                if (bodyLineLabelText === '' && tooltipBody[i].val[j].label !== null && tooltipBody[i].val[j].label !== '') {
                  bodyLineLabelText = tooltipBody[i].val[j].label;
                  bodyLineLabelTextFind = true;
                }
                if (bodyLineValueText === '' && tooltipBody[i].val[j].value !== null && tooltipBody[i].val[j].value !== '') {
                  bodyLineValueText = tooltipBody[i].val[j].value;
                  bodyLineValueTextFind = true;
                }
                
                if (bodyLineLabelTextFind && bodyLineValueTextFind) {
                  break;
                }
              }

              paragraphTitleNum++;
              paragraphLineNum += tooltipBody[i].val.length;
            }
            
            //if (tooltipBody[0].name !== null) {
              //tooltipHeight += (paragraphTitleNum * getTextBox(vis, tooltipBody[0].name,  titleFont).height);
            //}
            
            var bodyLineMaxHeight = getTextBox(vis, bodyLineLabelText,  multipleLabelFont).height;
            var valueHeight = getTextBox(vis, bodyLineValueText,  multipleValueFont).height;
            if (valueHeight > bodyLineMaxHeight) {
              bodyLineMaxHeight = valueHeight;
            }

            tooltipHeight += (paragraphLineNum * bodyLineMaxHeight);

            _tooltipFinalSize.tooltipBodyLineHeight = bodyLineMaxHeight;
            if (bodyTitleText !== '') {
              _tooltipFinalSize.tooltipBodyTitleHeight = getTextBox(vis, bodyTitleText,  titleFont).height;
            } else {
              _tooltipFinalSize.tooltipBodyTitleHeight = bodyLineMaxHeight;
            }
            tooltipHeight += (paragraphTitleNum * _tooltipFinalSize.tooltipBodyTitleHeight);
            tooltipHeight += (bodyInline * (paragraphTitleNum + paragraphLineNum - 1));
          
            if (tooltipHeight > zone.height) {
              _truncationParameter.isTruncated = true;
              
              var num2 = 0;
              while (tooltipHeight > zone.height) {
                tooltipHeight -= bodyLineMaxHeight;
                tooltipHeight -= bodyInline;
                num2++;
              }
              
              _truncationParameter.currentBodyIndex = paragraphTitleNum + paragraphLineNum - num2 - 2;
              var defaultValueBox1 = getTextBox(vis, _truncationParameter.defaultValue, _truncationParameter.font);
              
              return tooltipHeight + (defaultValueBox1.height - bodyLineMaxHeight);
            }
        } else  if (tooltipFooter && tooltipFooter.length > 0) {
          
          var footerLineString = '';
          for (var k = 0; k < tooltipFooter.length; k++) {
            if (footerLineString === '' && tooltipFooter[k].label !== null && tooltipFooter[k].label !=='')
            {
              footerLineString = tooltipFooter[k].label;
            }
            
            if (footerLineString === '' && tooltipFooter[k].value !== null && tooltipFooter[k].value !=='')
            {
              footerLineString = tooltipFooter[k].value;
            }
          }
          
          if (footerLineString !== '') {
            var footerlabelBox2= getTextBox(vis, footerLineString, footerLabelFont);
            _tooltipFinalSize.tooltipFooterLineHeight = footerlabelBox2.height;
            tooltipHeight += multipleVertical;
            tooltipHeight += (tooltipFooter.length * footerlabelBox2.height + footerInline * (tooltipFooter.length - 1));
        
              if (tooltipHeight > zone.height) {
                _truncationParameter.isTruncated = true;
                var num = 0;
                while (tooltipHeight > zone.height) {
                  tooltipHeight -= footerlabelBox2.height;
                  tooltipHeight -= footerInline;
                  num++;
                }
                
                _truncationParameter.currentFooterIndex = tooltipFooter.length - num - 1;
                var defaultValueBox2 = getTextBox(vis, _truncationParameter.defaultValue, _truncationParameter.font);
                
                return tooltipHeight + (defaultValueBox2.height - footerlabelBox2.height);
              }
          }
        }    
        
        return tooltipHeight;
    }
        
    function getTooltipWidthV2(vis, data) {
        var tooltipWidth = 0, multipleHorizontal = _display.multipleMeasure.padding.horizontal, symbolGap = _display.multipleMeasure.padding.symbolGap, defaultSpace = _display.multipleMeasure.padding.defaultSpace, symbolSize = _symbol.symbolSize;
        
        tooltipWidth = textMaxWidth + (multipleHorizontal * 2) + defaultSpace;
        if (_symbol.hasSymbol) {
          tooltipWidth += symbolSize + symbolGap;
        }
        return tooltipWidth;
    }
        
    function getTextMaxWidthV2(vis, data) {
      var maxValue = 0, tmpWidth = 0, tooltipBody = data.body, tooltipFooter = data.footer;
      
      if (tooltipBody) {
        for (var i = 0; i < tooltipBody.length; i++) {
          if (tooltipBody[i].name !== null) {
            tmpWidth = getTextBox(vis, tooltipBody[i].name, _display.title.font).width;
            if (tmpWidth > maxValue) {
              maxValue = tmpWidth;
            }
          }
      
          var paragraphValue = tooltipBody[i].val;
          if (paragraphValue) {
            if (paragraphValue.length === 1 && (paragraphValue[0].value !== null)) {
              var valueBox = getTextBox(vis, paragraphValue[0].value, _display.multipleMeasure.value.font);
              _symbol.symbolSize = valueBox.height * 0.8;
              _symbol.hasSymbol = true;
              if (valueBox.width > maxValue) {
                maxValue = valueBox.width;
              }
            } else if (paragraphValue.length > 1) {
              if (paragraphValue[0].label !== null) {
                if (paragraphValue[0].shape !== null && paragraphValue[0].color !== null) {
                  _symbol.symbolSize = getTextBox(vis, paragraphValue[0].label, _display.multipleMeasure.label.font).height * 0.8;
                  _symbol.hasSymbol = true;
                }
              }
              
              if (paragraphValue[0].value !== null) {
                if (paragraphValue[0].shape !== null && paragraphValue[0].color !== null) {
                  _symbol.symbolSize = getTextBox(vis, paragraphValue[0].value, _display.multipleMeasure.value.font).height * 0.8;
                  _symbol.hasSymbol = true;
                }               
              }
              
              for (var j = 0; j < paragraphValue.length; j++) {
                if ((paragraphValue[j].label !== null) && (paragraphValue[j].value !== null)) {
                  tmpWidth = getTextBox(vis, paragraphValue[j].label, _display.multipleMeasure.label.font).width + getTextBox(vis, paragraphValue[j].value, _display.multipleMeasure.value.font).width;
                  if (tmpWidth > maxValue) {
                    maxValue = tmpWidth;
                  }
                } else if (paragraphValue[j].label !== null) {
                  tmpWidth = getTextBox(vis, paragraphValue[j].label, _display.multipleMeasure.label.font).width;
                  if (tmpWidth > maxValue) {
                    maxValue = tmpWidth;
                  }                    
                } else if (paragraphValue[j].value !== null) {
                  tmpWidth = getTextBox(vis, paragraphValue[j].value, _display.multipleMeasure.value.font).width;
                  if (tmpWidth > maxValue) {
                    maxValue = tmpWidth;
                  }                    
                }
              }
            }
          }
        }
      }
      
      if (tooltipFooter) {
        for (var m = 0; m < tooltipFooter.length; m++) {
          var item = tooltipFooter[m];
          
          if (item.label && item.value) {
            tmpWidth = getTextBox(vis, item.label, _display.footer.label.font).width + getTextBox(vis, item.value, _display.footer.value.font).width;
            if (tmpWidth > maxValue) {
              maxValue = tmpWidth;
            }
          }
        }
      }
    
      return maxValue;
    }
        
    function getSymbolPath(type, size){
      var symbolPath = '', r, rx, ry; 
      switch(type){
        case 'circle' :
          r = size / 2;
          symbolPath = "M0," + r + "A" + r + "," + r + " 0 1,1 0," + (-r) + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
          break;
        case "cross" :
          rx = size / 6;
          ry = size / 6;
          symbolPath = "M" + -3 * rx + "," + -ry + "H" + -rx + "V" + -3 * ry + "H" + rx + "V" + -ry + "H" + 3 * rx + "V" + ry + "H" + rx + "V" + 3 * ry + "H" + -rx + "V" + ry + "H" + -3 * rx + "Z";
          break;
        case "triangle-down" ://TODO: remove duplicate
        case "triangleDown" :
          rx = size / 2;
          ry = size / 2;
          symbolPath = "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
          break;
        case "triangle-up" ://TODO: remove duplicate
        case "triangleUp" :
          rx = size / 2;
          ry = size / 2;
          symbolPath = "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
          break;
        case "diamond" :
          rx = size / 2;
          ry = size / 2;
          symbolPath = "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";
          break;
        case 'squareWithRadius' : 
          r = size / 2;
          var radius = r - 3;
          symbolPath = "M0," +  -r + "L" + -radius + ","+ -r + "Q" + -r +"," + -r + " " + -r + "," + -radius + "L" + -r +"," + radius + "Q" + -r + "," + r + " " + -radius + "," + r + "L" + radius + "," + r +"Q" + r + "," + r + " " + r + "," +radius + "L" + r +"," + -radius + "Q" + r + "," + -r + " "+ radius + "," + -r +"Z";
          break;
        case 'square' :
          r = size / 2;
          symbolPath = "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
          break;
        case "triangle-left" ://TODO: remove duplicate
        case "triangleLeft" :
          rx = size / 2;
          ry = size / 2;
          symbolPath = "M" + -rx + ",0L" + rx + "," + ry + " " + rx + "," + -ry + "Z";
          break;
        case "triangle-right" ://TODO: remove duplicate
        case "triangleRight" :
          rx = size / 2;
          ry = size / 2;
          symbolPath = "M" + rx + ",0L" + -rx + "," + ry + " " + -rx + "," + -ry + "Z";
          break;
        case "intersection" :
          rx = size / 2;
          ry = size / 2;
          symbolPath = "M" + rx + ',' + ry + ' ' +  rx/3 + ',0 ' + rx + ',' + -ry + ' ' + rx / 2 + ',' + -ry + ' 0,' + -ry/3 + ' ' + -rx / 2 + ',' + -ry + ' ' + -rx + ',' + -ry + ' ' + -rx/3 + ',0 ' + -rx + ',' + ry + ' ' + -rx/2 + ',' + ry + ' 0,' + ry/3 + ' ' + rx/2 + ',' + ry;
          break;
      }
      
      return symbolPath;
    }

    var getImageURL = function(index)
    {
        var imageURL = "";

        var imageURLNumber = imageInfo.imagePalette.length;
        if(imageURLNumber > 0)
        {
            imageURL = imageInfo.imagePalette[index%imageURLNumber];
        }

        return imageURL;
    };
      
    function drawSymbolV2(index, vis, pos, symbolType, color, symbolSize, className) {
      if(!imageInfo.imageMode)
      {
          var parameter = {
            drawingEffect: _properties.drawingEffect,
            fillColor : color,
            graphType : symbolType,
            direction : 'vertical'
          };
            
          var fillId =  effectManager.register(parameter);
          vis.append('path').attr('d', getSymbolPath(symbolType, symbolSize)).attr('transform', 'translate(' + pos.x + ',' + pos.y + ')').attr('fill', fillId).attr('class', className);
      }
      else
      {
            var gImage = vis.append('g').attr('transform', 'translate(' + (pos.x - symbolSize/2) + ',' + (pos.y - symbolSize/2) + ')');

            var imageObjs = gImage.select("image");
            if(imageObjs.empty())
            {
                imageObjs = gImage.append("image");
            }

            imageObjs.attr("xlink:xlink:href", getImageURL(index))
                .attr("width",symbolSize)
                .attr("height",symbolSize);
      }
    } 
        
    function drawContentV2(vis, pos, data, markerPos) {
      //Because yStart starts at a offset radius in function drawShape, to substract radius here.
      var xStart = pos.x, yStart = pos.y - _shapeLayout.radius / 2;
      //var markerPos = properties.orientation;
      var markerWidth = _shapeLayout.markerWidth, markerHeight = _shapeLayout.markerHeight;
      
      if (markerPos === 'left') {
        xStart += markerHeight;
      }
      if (markerPos === 'top') {
        yStart += markerHeight;
      }
  
      var multipleHorizontal = _display.multipleMeasure.padding.horizontal, multipleVertical = _display.multipleMeasure.padding.vertical, multipleInline = _display.multipleMeasure.padding.inline, symbolGap = _display.multipleMeasure.padding.symbolGap, 
          defaultSpace = _display.multipleMeasure.padding.defaultSpace;
      var symbolSize = _symbol.symbolSize, hasSymbol = _symbol.hasSymbol;
      var titleColor = _display.title.color, titleFont = _display.title.font;
      var multipleLabelFont = _display.multipleMeasure.label.font, multipleLabelColor = _display.multipleMeasure.label.color, 
          singleLabelFont = _display.singleMeasure.label.font, singleLabelColor = _display.singleMeasure.label.color;
      var multipleValueFont = _display.multipleMeasure.value.font, multipleValueColor = _display.multipleMeasure.value.color, 
          singleValueFont = _display.singleMeasure.value.font, singleValueColor = _display.singleMeasure.value.color;
      var footerInline = _display.footer.padding.inline, footerLabelFont = _display.footer.label.font, 
          footerValueFont = _display.footer.value.font, footerLabelColor = _display.footer.label.color, 
          footerValueColor = _display.footer.value.color;
      var tooltipBody = data.body, tooltipFooter = data.footer;
      var currentBodyIndex = -1, currentFooterIndex = -1;
      var rowPos = {
                x : 0,
                y : 0
            };
        
      var isBreak = false;
        
        if (tooltipBody) {
          var gBody = vis.append('g').attr('class', 'v-body');
          for (var i = 0; i < tooltipBody.length; i++) {
            
            if (isBreak) {
              break;
            }
            
            var paragraph = tooltipBody[i];
            if (paragraph.name !== null) {
              //var titleBox = getTextBox(gBody, paragraph.name, titleFont);
              var titleHeight = _tooltipFinalSize.tooltipBodyTitleHeight;          
              rowPos.x = xStart + multipleHorizontal;
              if (i === 0) {
                rowPos.y = yStart + titleHeight + multipleVertical;
              }
              else {
                rowPos.y += (yStart + titleHeight + multipleInline);
              }
              
              drawTextV2(gBody, rowPos, paragraph.name, titleColor, titleFont, _paragraphTitleClassName);
              currentBodyIndex++;
              if (_truncationParameter.isTruncated && currentBodyIndex === _truncationParameter.currentBodyIndex) {
                var valueBox1 = getTextBox(gBody, _truncationParameter.defaultValue, _truncationParameter.font);
                rowPos.x = xStart + (tooltipWidth - valueBox1.width - multipleHorizontal);
                rowPos.y += (multipleInline + valueBox1.height);
                drawTextV2(gBody, rowPos, _truncationParameter.defaultValue, _truncationParameter.color, _truncationParameter.font, _paragraphValueTextClassName);    
                break;
              }
            }
            
            if (paragraph.val.length > 0) {
              
              if (paragraph.val.length > 1) {
                var labelBox = null, valueBox = null, offset = null;
                for (var j = 0; j < paragraph.val.length; j++) {
                  
                  if ((paragraph.val[j].shape !== null) && (paragraph.val[j].color !== null) && (paragraph.val[j].label !== null) && (paragraph.val[j].value !== null)) {                     
                    labelBox = getTextBox(gBody, paragraph.val[j].label, multipleLabelFont);
                    valueBox = getTextBox(gBody, paragraph.val[j].value, multipleValueFont);
                    offset = (labelBox.height >= valueBox.height) ? labelBox.height: valueBox.height;
                    
                    rowPos.x = xStart + multipleHorizontal + symbolSize / 2;
                    rowPos.y += (multipleInline + offset);
                    //drawSymbol
                    drawSymbolV2(i * paragraph.val.length + j, gBody, {x: rowPos.x, y: (rowPos.y - symbolSize/2)}, paragraph.val[j].shape,  paragraph.val[j].color, symbolSize, _symbolClassName);
                    
                    rowPos.x = xStart + multipleHorizontal + symbolSize + symbolGap;
                    drawTextV2(gBody, rowPos, paragraph.val[j].label, multipleLabelColor, multipleLabelFont, _paragraphLabelTextClassName);
                    
                    rowPos.x = xStart + (tooltipWidth - valueBox.width - multipleHorizontal);
                    drawTextV2(gBody, rowPos, paragraph.val[j].value, multipleValueColor, multipleValueFont, _paragraphValueTextClassName);                          
                  } else if ((paragraph.val[j].shape !== null) && (paragraph.val[j].color !== null) && (paragraph.val[j].label !== null)) {
                    labelBox = getTextBox(gBody, paragraph.val[j].label, multipleLabelFont);
                    rowPos.x = xStart + multipleHorizontal + symbolSize / 2;
                    rowPos.y += (multipleInline + labelBox.height);
                    //drawSymbol
                    drawSymbolV2(i * paragraph.val.length + j, gBody, {x: rowPos.x, y: (rowPos.y - symbolSize/2)}, paragraph.val[j].shape, paragraph.val[j].color, symbolSize, _symbolClassName);
                    
                    rowPos.x = xStart + multipleHorizontal + symbolSize + symbolGap;
                    drawTextV2(gBody, rowPos, paragraph.val[j].label, multipleLabelColor, multipleLabelFont, _paragraphLabelTextClassName);

                  } else if ((paragraph.val[j].shape !== null) && (paragraph.val[j].color !== null) && (paragraph.val[j].value !== null)) {
                    valueBox = getTextBox(gBody, paragraph.val[j].value, multipleValueFont);
                    rowPos.x = xStart + multipleHorizontal + symbolSize / 2;
                    rowPos.y += (multipleInline + valueBox.height);
                    //drawSymbol
                    drawSymbolV2(i * paragraph.val.length + j, gBody, {x: rowPos.x, y: (rowPos.y - symbolSize/2)}, paragraph.val[j].shape, paragraph.val[j].color, symbolSize, _symbolClassName);
                    
                    rowPos.x = xStart + tooltipWidth - valueBox.width - multipleHorizontal;
                    drawTextV2(gBody, rowPos, paragraph.val[j].value, multipleValueColor, multipleValueFont, _paragraphValueTextClassName);
                  
                  } else if ((paragraph.val[j].label !== null) && (paragraph.val[j].value !== null)) {
                    labelBox = getTextBox(gBody, paragraph.val[j].label, multipleLabelFont);
                    valueBox = getTextBox(gBody, paragraph.val[j].value, multipleValueFont);
                    offset = (labelBox.height >= valueBox.height) ? labelBox.height: valueBox.heigth;
     
                    rowPos.x = xStart + multipleHorizontal;
                    rowPos.y += (multipleInline + offset);
                    drawTextV2(gBody, rowPos, paragraph.val[j].label, multipleLabelColor, multipleLabelFont, _paragraphLabelTextClassName);
                    
                    rowPos.x = xStart + (tooltipWidth - valueBox.width - multipleHorizontal);
                    drawTextV2(gBody, rowPos, paragraph.val[j].value, multipleValueColor, multipleValueFont, _paragraphValueTextClassName);
                  }
                  
                  currentBodyIndex++;
                  if (_truncationParameter.isTruncated && currentBodyIndex === _truncationParameter.currentBodyIndex) {
                    var valueBox2 = getTextBox(gBody, _truncationParameter.defaultValue, _truncationParameter.font);
                    rowPos.x = xStart + (tooltipWidth - valueBox2.width - multipleHorizontal);
                    rowPos.y += (multipleInline + valueBox2.height);
                    drawTextV2(gBody, rowPos, _truncationParameter.defaultValue, _truncationParameter.color, _truncationParameter.font, _paragraphValueTextClassName);
                    isBreak = true;
                    break;
                  }  
                }
                
              } else if (paragraph.val.length === 1) {
                if (paragraph.val[0].value !== null) {
                  var tempValueBox = getTextBox(gBody, paragraph.val[0].value, multipleValueFont);
                  rowPos.y += (multipleInline + tempValueBox.height);
                  
                  if (_properties.chartType === 'heatmap' || _properties.chartType === 'treemap' || _properties.chartType === 'tagcloud' || _properties.chartType === 'geo' ||_properties.chartType === 'mekko') {
                    rowPos.x = xStart + (tooltipWidth - tempValueBox.width - multipleHorizontal);

                  } else if (paragraph.val[0].shape !== null && paragraph.val[0].color !== null) {
                    rowPos.x = xStart + multipleHorizontal + symbolSize / 2;
                    drawSymbolV2(i * paragraph.val.length + 0, gBody, {x: rowPos.x, y: (rowPos.y - symbolSize/2)}, paragraph.val[0].shape, paragraph.val[0].color, symbolSize, _symbolClassName);
                    rowPos.x = xStart + (tooltipWidth - tempValueBox.width - multipleHorizontal);
                    
                  }
                  drawTextV2(gBody, rowPos, paragraph.val[0].value, multipleValueColor, multipleValueFont, _paragraphValueTextClassName);
                  
                  currentBodyIndex++;
                  if (_truncationParameter.isTruncated && currentBodyIndex === _truncationParameter.currentBodyIndex) {
                    var valueBox3 = getTextBox(gBody, _truncationParameter.defaultValue, multipleValueFont);
                    rowPos.x = xStart + (tooltipWidth - valueBox3.width - multipleHorizontal);
                    rowPos.y += (multipleInline + valueBox3.height);
                    drawTextV2(gBody, rowPos, _truncationParameter.defaultValue, _truncationParameter.color, _truncationParameter.font, _paragraphValueTextClassName);    
                    break;
                  }
                }
              }
            }
          }
        }
        
        if (tooltipFooter && tooltipFooter.length > 0) {
          //draw seperated line
          var separateLineStart = {
                x: xStart,
                y: rowPos.y + multipleVertical
              };
 
          var separateLineEnd = {
                x: xStart + tooltipWidth,
                y: rowPos.y + multipleVertical
              };
          var gFooter = vis.append('g').attr('class', 'v-footer');      
          if(_properties.chartType === 'geo'){
            if(tooltipBody && tooltipBody.length){
               vis.append('line').attr('class', _tooltipSeparationLineClassName).attr('x1', separateLineStart.x + 1).attr('y1', separateLineStart.y).attr('x2', separateLineEnd.x - 1).attr('y2', separateLineEnd.y).attr('stroke',  _defaultToolTipColors.separationLineSingleColor).attr('stroke-width', _shapeLayout.separationLineBorderWidth).style('shape-rendering', 'crispEdges');
               rowPos.y += (multipleVertical * 2);
            }
          }else{
            vis.append('line').attr('class', _tooltipSeparationLineClassName).attr('x1', separateLineStart.x + 1).attr('y1', separateLineStart.y).attr('x2', separateLineEnd.x - 1).attr('y2', separateLineEnd.y).attr('stroke',  _defaultToolTipColors.separationLineSingleColor).attr('stroke-width', _shapeLayout.separationLineBorderWidth).style('shape-rendering', 'crispEdges');
            rowPos.y += (multipleVertical * 2);
          }
      
          //draw footer
          for (var k = 0; k < tooltipFooter.length; k++) {
            if (TypeUtils.isExist(tooltipFooter[k].label) && TypeUtils.isExist(tooltipFooter[k].value)) {
              //var footerLabelBox = getTextBox(gFooter, tooltipFooter[k].label, footerLabelFont), 
              var footerValueBox = getTextBox(gFooter, tooltipFooter[k].value, footerValueFont);
              rowPos.x = xStart + multipleHorizontal;
              if (k > 0) {
                rowPos.y += footerInline;
              }
              
              rowPos.y += (_tooltipFinalSize.tooltipFooterLineHeight);
              //draw label
              drawTextV2(gFooter, rowPos, tooltipFooter[k].label, footerLabelColor, footerLabelFont, _footerLabelClassName);
              
              rowPos.x = xStart + (tooltipWidth - footerValueBox.width - multipleHorizontal);
              //draw value
              drawTextV2(gFooter,rowPos, tooltipFooter[k].value, footerValueColor, footerValueFont, _footerValueClassName);
              
              currentFooterIndex++;
              if (_truncationParameter.isTruncated && currentFooterIndex === _truncationParameter.currentFooterIndex) {
                break;
              }
            }
          }
        }            
    }
        
    var formatTooltipData = function(data){
      if(TypeUtils.isExist(_properties.formatString)){
        var body = data.body, ibody;
        var indexAxis0 = 0, indexAxis1 = 0, indexOfiFS;
        var formatString = _properties.formatString, iFormatString;
        if(TypeUtils.isExist(body)){
          for(var i=0, len=body.length; i< len; i++){
            ibody = body[i];
            
            if (TypeUtils.isPlainObject(ibody.name)) {
              if(TypeUtils.isExist(formatString)) {
                iFormatString = formatString[ibody.name.ctx.path.mg];
                if(TypeUtils.isExist(iFormatString)){
                  indexOfiFS = ibody.name.ctx.path.mi >= iFormatString.length ? iFormatString.length -1 : ibody.name.ctx.path.mi;
                  for(var j = 0, jlen = ibody.val.length; j < jlen; j++){
                    ibody.val[j].value = formatManager.format(ibody.val[j].value, iFormatString[indexOfiFS]);
                  }
                }
              }
            } else if (TypeUtils.isExist(ibody.ctx)) {
              if(TypeUtils.isExist(formatString)) {
                iFormatString = formatString[ibody.ctx.path.mg];
                if(TypeUtils.isExist(iFormatString)){
                  indexOfiFS = ibody.ctx.path.mi >= iFormatString.length ? iFormatString.length -1 : ibody.ctx.path.mi;
                  for(var k = 0, klen = ibody.val.length; k < klen; k++){
                    ibody.val[k].value = formatManager.format(ibody.val[k].value, iFormatString[indexOfiFS]);
                  }
                }
              }
            } else if (TypeUtils.isArray(ibody.val) && ibody.val.length > 0 && TypeUtils.isPlainObject(ibody.val[0].value)) {
              for(var m = 0, mlen = ibody.val.length; m < mlen; m++) {
                iFormatString = formatString[ibody.val[m].value.ctx.path.mg];
                if(TypeUtils.isExist(iFormatString)) {
                  indexOfiFS = ibody.val[m].value.ctx.path.mi >= iFormatString.length ? iFormatString.length -1 : ibody.val[m].value.ctx.path.mi;
                  ibody.val[m].value = formatManager.format(ibody.val[m].value.val, iFormatString[indexOfiFS]);
                }
              }
          } else {
              var indexOfFS;
              if(TypeUtils.isExist(ibody.val[0].valueAxis)){
                indexOfFS = ibody.val[0].valueAxis;
              }
              else {
                indexOfFS = 0;
              }
              iFormatString = formatString[indexOfFS];
              //if formatstring is unll or undefined ,we will use the default value
              if(TypeUtils.isExist(iFormatString) && TypeUtils.isArray(iFormatString)){
                indexOfiFS = 0;
                if(indexOfFS === 0){
                  indexOfiFS = indexAxis0 >= iFormatString.length ? iFormatString.length -1 : indexAxis0;
                  indexAxis0++;
                }
                else if(indexOfFS === 1){
                  indexOfiFS = indexAxis1 >= iFormatString.length ? iFormatString.length -1 : indexAxis1;
                  indexAxis1++;
                }
                for(var n = 0, nlen = ibody.val.length; n < nlen; n++){
                  ibody.val[n].value = formatManager.format(ibody.val[n].value, iFormatString[indexOfiFS]);
                }
              }
            }
          }
        }
      }
      return data;
    };

    tooltip.imageInfo = function(_) {
      if(!arguments.length){
        return imageInfo;
      }
      imageInfo = _;
      return tooltip;
    };
    
    tooltip.showTooltip = function (eventData) {
      //To fix the bug, tooltip show the last position in android.
      vis.attr('visibility', 'hidden');
      var data = ObjectUtils.extend(true, {}, eventData.data);
      data = formatTooltipData(data);
      if(gWrapper !== null){
        gWrapper.remove();
      }
      
      if (_properties.visible) {
        if (data.plotArea) {
            tooltip.plotArea(data.plotArea);
        }
        
        _orientation = _properties.orientation;
        gWrapper = vis.append('svg:g');
        updateTooltipStyle();
      
        textMaxWidth = getTextMaxWidthV2(vis, data);
        tooltipWidth = getTooltipWidthV2(gWrapper, data);
        
        /*if (_properties.chartType !== 'geo' && tooltipWidth > (plotArea.width * 0.5)) {
          if(gWrapper !== null){
            gWrapper.remove();
          }
          return;
        }*/
        
        tooltipHeight = getTooltipHeightV2(gWrapper, data);
          
        var tmpWidth = tooltipWidth, tmpHeight = tooltipHeight;
        if (_orientation === 'top' || _orientation === 'bottom') {
          tmpHeight += _shapeLayout.markerHeight;
        }
        
        if (_orientation === 'left' || _orientation === 'right') {
          tmpWidth += _shapeLayout.markerHeight;
        }
        vis.attr('width', tmpWidth + _shapeLayout.padding).attr('height', tmpHeight + _shapeLayout.padding);
        
        //appendLinearGradient(gWrapper);
  
        var tooltipPos = calculatePos(data.point, plotArea, zone, tooltipWidth, tooltipHeight);
        drawShape(gWrapper, {x:0,y:0, absoluteMarkerOffset : tooltipPos.absoluteMarkerOffset}, tooltipWidth, tooltipHeight, _orientation);
        drawContentV2(gWrapper, {x:0,y:0}, data, _orientation);
        vis.style('left', tooltipPos.x + 'px').style('top', tooltipPos.y + 'px');
        clearGlobalValues();
        vis.attr('visibility', 'visible');
      }
    };  
    
    tooltip.hideTooltip = function () {
      if (gWrapper !== null) {
        gWrapper.remove();
        vis.attr('width', 0).attr('height', 0);
        gWrapper = null;
      }
    };
    
    function calculateSymbolSize(data) {
      if (data.labels) {
        _symbol.symbolSize = getTextBox(vis, data.labels[0].label, _display.multipleMeasure.label.font).height;
      }
    }
    
    function getScrollTop(){
        var result =0;
        var visNode = vis.node();
        if(visNode && visNode.parentNode && visNode.parentNode.scrollTop>0){
            result = visNode.parentNode.scrollTop;
        }
        return result;
    }
    
    function getScrollLeft(){
        var result =0;
        var visNode = vis.node();
        if(visNode && visNode.parentNode && visNode.parentNode.scrollLeft>0){
            result = visNode.parentNode.scrollLeft;
        }
        return result;
    }
    
      function calculatePos(point, plotArea, zone, tooltipWidth, tooltipHeight) {
      var tooltipPos = {
          x: 0,
          y: 0,
          absoluteMarkerOffset: 0
      };
      
      var chartType = _properties.chartType;
      var markerHeight = _shapeLayout.markerHeight, markerWidth = _shapeLayout.markerWidth;
      var rightOffset = 0,  leftOffset = 0, topOffset = 0, bottomOffset = 0;

//      if (tooltipWidth > zone.width || tooltipHeight > zone.height) {
//        return tooltipPos;
//      } 
      
      if (_properties.chartType === undefined) {
        tooltipPos.x = point.x;
        tooltipPos.y = point.y - tooltipHeight/2;
      } else if (chartType === 'heatmap' || chartType === 'treemap' || chartType === 'tagcloud') {
        
        if (_orientation === 'bottom') {
          var upBorder = zone.height - point.y + tooltipHeight + markerHeight;
          if (upBorder > zone.height) {
            _orientation = 'top';
            tooltipPos.y = point.y;
          } else {
            tooltipPos.y = point.y - tooltipHeight - markerHeight;
          }
        }
        
        var tooltipPosX;
        if (chartType === 'heatmap' || chartType === 'treemap' || chartType === 'tagcloud') 
        {
            tooltipPosX = calculateTooltipPosXForMBCCharts(point, plotArea, zone, tooltipWidth);
        }
        else
        {
            tooltipPosX = calculateTooltipPosX(point, plotArea, zone, tooltipWidth);
        }

        tooltipPos.x = tooltipPosX.x;
        tooltipPos.absoluteMarkerOffset = tooltipPosX.absoluteMarkerOffset;
        
      } else if (chartType === 'line' || chartType === 'verticalboxplot' || chartType === 'verticalbar') {
        if (_orientation === 'left') {
          var rightBorder = point.x + tooltipWidth + markerHeight;
          if (rightBorder > zone.width + getScrollLeft()) {
            _orientation = 'right';
            tooltipPos.x = point.x - tooltipWidth - markerHeight;
          } else {
            tooltipPos.x = point.x;
          }
        }
        var scrollTop = getScrollTop();
        if (tooltipHeight / 2 < plotArea.y - scrollTop) {
          //tooltip marker is over chart top border.
          tooltipPos.y = plotArea.y - (tooltipHeight - markerWidth) / 2;
        } else {
          tooltipPos.y = scrollTop;
        }
        
      } else if (chartType === 'radar') {
        rightOffset = 0;
        leftOffset = 0;
        topOffset = 0;
        bottomOffset = 0;
        var x = 0, y = 0;
        
        _orientation = point.orientation;
        tooltipPos.x = point.x;
        tooltipPos.y = point.y - tooltipHeight / 2;
        
        if (point.orientation === 'right') {
          tooltipPos.x -= (tooltipWidth + markerHeight);
        }
        
        if (point.orientation === 'left') {
          rightOffset = point.x + tooltipWidth + markerHeight - zone.width;

        }
        
        if (point.orientation === 'right') {
          leftOffset = point.x - tooltipWidth - markerHeight;
        }
        
        topOffset = point.y - tooltipHeight / 2;
        bottomOffset = point.y + tooltipHeight / 2 - zone.height;
        
        if (rightOffset <= 0 && leftOffset >= 0 && topOffset >= 0 && bottomOffset <= 0) {
          return tooltipPos;
        }
        
        if (rightOffset > 0 &&  rightOffset > point.range.x) {
          return tooltipPos;
        }
        
        if (leftOffset < 0 && Math.abs(leftOffset) > point.range.x) {
          return tooltipPos;
        }
        
        if (topOffset < 0 && Math.abs(topOffset) > point.range.y) {
          return tooltipPos;
        }
        
        if (bottomOffset > 0 && bottomOffset > point.range.y) {
          return tooltipPos;
        }
        
        var angle = point.angle * 180 / Math.PI, radian = point.angle;
        
        if (angle >= 0) {

          if (angle === 0 && rightOffset > 0) {
            tooltipPos.x -= rightOffset;
          } else if (angle === 90 && topOffset < 0) {
            tooltipPos.y -= topOffset;
          } else if (angle === 180 && leftOffset < 0) {
            tooltipPos.x -= leftOffset;
          } else if (angle > 0 && angle < 90) {
            if (topOffset < 0 && rightOffset > 0) {
              //both tooltip top and right border cross chart top and right border
              var  topOffsetAbs1 = Math.abs(topOffset);
              if (topOffsetAbs1 >= rightOffset) {
                y = topOffsetAbs1;
                x = y / Math.tan(radian);
              } else  {
                x = rightOffset;
                y = x * Math.tan(radian);
                
              }
            } else if (topOffset < 0 && rightOffset <= 0) {
              //only tooltip top border cross chart top border
              y = Math.abs(topOffset);
              x = y / Math.tan(radian);
            } else if (topOffset >= 0 && rightOffset > 0) {
              //only tooltip right border cross chart right border
              x = rightOffset;
              y = x * Math.tan(radian);
            }
            
            tooltipPos.x -=x;
            tooltipPos.y += y;
            
          } else if (angle > 90 && angle < 180) {
            if (topOffset < 0 && leftOffset < 0) {
              //both tooltip top and left border cross chart top and left border
              var topOffsetAbs2 = Math.abs(topOffset), leftOffsetAbs1 = Math.abs(leftOffset);
              if (topOffsetAbs2 >= leftOffsetAbs1) {
                y = topOffsetAbs2;
                x = y / Math.tan(Math.PI - radian);
              } else {
                x = leftOffsetAbs1;
                y = x * Math.tan(Math.PI - radian);
              }
              
            } else if (topOffset < 0 && leftOffset >= 0) {
              //only tooltip top border cross chart top border
              y = Math.abs(topOffset);
              x = y / Math.tan(Math.PI - radian);
              
            } else if (topOffset >= 0 && leftOffset < 0) {
              //only tooltip left border cross chart left border
              x = Math.abs(leftOffset);
              y = x * Math.tan(Math.PI -radian);
            }
            
            tooltipPos.x +=x;
            tooltipPos.y += y;
          }
          
        } else {
          
          var angleAbs = Math.abs(angle);
          if (angleAbs === 0 && rightOffset > 0) {
            tooltipPos.x -= rightOffset;
          } else if (angleAbs === 90 && bottomOffset > 0) {
            tooltipPos.y -= bottomOffset;
          } else if (angleAbs === 180 && leftOffset < 0) {
            tooltipPos.x -= leftOffset;
          } else if (angleAbs > 0 && angleAbs < 90) {
            if (bottomOffset > 0 && rightOffset > 0) {
              //both tooltip bottom and right border cross chart top and right border
              if (bottomOffset >= rightOffset) {
                y = bottomOffset;
                x = y / Math.tan(Math.abs(radian));
              } else  {
                x = rightOffset;
                y = x * Math.tan(Math.abs(radian));
                
              }
            } else if (bottomOffset > 0 && rightOffset <= 0) {
              //only tooltip bottom border cross chart bottom border
              y = bottomOffset;
              x = y / Math.tan(Math.abs(radian));
            } else if (bottomOffset <= 0 && rightOffset > 0) {
              //only tooltip right border cross chart right border
              x = rightOffset;
              y = x * Math.tan(Math.abs(radian));
            }
            
            tooltipPos.x -=x;
            tooltipPos.y -= y;            
          } else if (angleAbs > 90 && angleAbs < 180) {
            if (bottomOffset > 0 && leftOffset < 0) {
              var leftOffsetAbs2 = Math.abs(leftOffset);
              //both tooltip bottomOffset and left border cross chart top and left border
              if (bottomOffset >= leftOffsetAbs2) {
                y = bottomOffset;
                x = y / Math.tan(Math.PI - Math.abs(radian));
              } else {
                x = leftOffsetAbs2;
                y = x * Math.tan(Math.PI - Math.abs(radian));
              }
              
            } else if (bottomOffset > 0 && leftOffset >= 0) {
              //only tooltip bottom border cross chart bottom border
              y = bottomOffset;
              x = y / Math.tan(Math.PI - Math.abs(radian));
              
            } else if (bottomOffset <= 0 && leftOffset < 0) {
              //only tooltip left border cross chart left border
              x = Math.abs(leftOffset);
              y = x * Math.tan(Math.PI -Math.abs(radian));
            }
            
            tooltipPos.x +=x;
            tooltipPos.y -= y;            
          }      
        }
        
      } else if (chartType === 'geo' && _orientation === 'left'){
        // In this style, tooltip will always point to the plot origin horizontally.
       topOffset = point.y - tooltipHeight / 2;
       bottomOffset = point.y + tooltipHeight / 2 - zone.height;
        
        tooltipPos.y = topOffset;
        tooltipPos.x = point.x;
        
        if (point.x + markerHeight + tooltipWidth > zone.width) {
          tooltipPos.x = point.x - tooltipWidth - markerHeight;
          _orientation = 'right';
        }
        /*if (plotArea.x + plotArea.width + tooltipWidth - markerHeight > zone.width) {
          tooltipPos.x = plotArea.x - plotArea.width - tooltipWidth;
          _orientation = 'right';
        } else {
          tooltipPos.x = plotArea.x + plotArea.width - markerHeight;
        }*/
        
      
        if (topOffset < 0) {
          tooltipPos.y = 0;
          tooltipPos.absoluteMarkerOffset = topOffset;
        }
        
        if (bottomOffset > 0) {
          tooltipPos.y = zone.height - tooltipHeight;
          tooltipPos.absoluteMarkerOffset = bottomOffset;
        }
      } else {
        
        if (_properties.orientation === 'left') {
          
          rightOffset = plotArea.x + plotArea.width + tooltipWidth + markerHeight - zone.width;
          topOffset = point.y - tooltipHeight / 2;
          bottomOffset = point.y + tooltipHeight / 2 - zone.height;
          
          tooltipPos.y = point.y - tooltipHeight / 2;
          
          if (chartType === 'pie_with_depth') {
            tooltipPos.x = point.x;
          } else if (rightOffset > 0) {
            tooltipPos.x = zone.width - markerHeight - tooltipWidth;
          } else {
            tooltipPos.x = plotArea.x + plotArea.width - markerHeight;
          }
          
          if (topOffset < 0) {
            tooltipPos.y = 0;
            tooltipPos.absoluteMarkerOffset = topOffset;
          }
          
          if (bottomOffset > 0) {
            tooltipPos.y = zone.height - tooltipHeight;
            tooltipPos.absoluteMarkerOffset = bottomOffset;
          }

        } else if (_properties.orientation === 'bottom') {      
  
          var top = plotArea.y - tooltipHeight;
          if (top < 0) {
            tooltipPos.y = 0;
          } else {
            tooltipPos.y = plotArea.y - tooltipHeight;
          }
          
          var posX;
          if (chartType === 'heatmap' || chartType === 'treemap' || chartType === 'tagcloud') 
          {
              posX = calculateTooltipPosXForMBCCharts(point, plotArea, zone, tooltipWidth);
          }
          else
          {
              posX = calculateTooltipPosX(point, plotArea, zone, tooltipWidth);
          }
          tooltipPos.x = posX.x;
          tooltipPos.absoluteMarkerOffset = posX.absoluteMarkerOffset;
        }
        
      }

      return tooltipPos;
    }
    
    function calculateTooltipPosX(point, plotArea, zone, tooltipWidth) {
      var tooltipPosX = {
          x: 0,
          absoluteMarkerOffset: 0
      };
      
      var leftBorder = tooltipWidth / 2 - (point.x - plotArea.x) + plotArea.width;
      var rightBorder = point.x - plotArea.x + tooltipWidth / 2;
      if (leftBorder > zone.width) {
        tooltipPosX.x = plotArea.x;
        tooltipPosX.absoluteMarkerOffset = point.x - plotArea.x - tooltipWidth / 2;
      } else if (rightBorder > zone.width) {
        tooltipPosX.x = plotArea.x + (plotArea.width - tooltipWidth);
        tooltipPosX.absoluteMarkerOffset = plotArea.width - (point.x - plotArea.x) - tooltipWidth / 2;
      } else {
        tooltipPosX.x = point.x - tooltipWidth / 2;
        tooltipPosX.absoluteMarkerOffset = 0;
      }
      
      return tooltipPosX;
    }

    function calculateTooltipPosXForMBCCharts(point, plotArea, zone, tooltipWidth) {
      var tooltipPosX = {
          x: 0,
          absoluteMarkerOffset: 0
      };
      
      var leftBorder = tooltipWidth - (point.x - plotArea.x) + plotArea.width;
      var rightBorder = point.x - plotArea.x + tooltipWidth;

      if (leftBorder > zone.width) {
        tooltipPosX.x = plotArea.x;
        tooltipPosX.absoluteMarkerOffset = point.x - plotArea.x - tooltipWidth / 2;
      } else if (rightBorder > zone.width) {
        tooltipPosX.x = plotArea.x + (plotArea.width - tooltipWidth);
        
        if(tooltipPosX.x + tooltipWidth > plotArea.width)
        {
            tooltipPosX.absoluteMarkerOffset = point.x - plotArea.x - plotArea.width + tooltipWidth / 2;
        }
        else
        {
            tooltipPosX.absoluteMarkerOffset = plotArea.width - (point.x - plotArea.x) - tooltipWidth / 2;
        }
      } else {
        tooltipPosX.x = point.x - tooltipWidth / 2;
        tooltipPosX.absoluteMarkerOffset = 0;
      }
      
      return tooltipPosX;
    }
    
    function calculateTooltipPosY(point, plotArea, zone, tooltipHeight) {
      var tooltipPosY = {
          y: 0,
          absoluteMarkerOffset: 0
      };
      
      var upBorder = plotArea.height + (tooltipHeight / 2 - (point.y - plotArea.y));
      var downBorder = point.y - plotArea.y + tooltipHeight / 2;
      if (upBorder > zone.height) {
        tooltipPosY.y = plotArea.y;
        tooltipPosY.absoluteMarkerOffset = point.y - plotArea.y - tooltipHeight / 2;
      } else if (downBorder > zone.height) {
        tooltipPosY.y = plotArea.y + plotArea.height - tooltipHeight;
        tooltipPosY.absoluteMarkerOffset = point.y - (plotArea.height - tooltipHeight) - plotArea.y - tooltipHeight / 2;
      } else {
        tooltipPosY.y = point.y - tooltipHeight / 2;
        tooltipPosY.absoluteMarkerOffset = 0;
      }
      
      return tooltipPosY;
    }
    
    function drawShape(vis, pos, width, height, markerPos) {
      
      var xStart = pos.x, yStart = pos.y, offset = pos.absoluteMarkerOffset, radius = _shapeLayout.radius, markerWidth = _shapeLayout.markerWidth, markerHeight = _shapeLayout.markerHeight;
      var space = ' ';
      var lineTo = _svgPathCommand.lineToA, moveTo = _svgPathCommand.moveToA, arc = _svgPathCommand.arcA, closePath = _svgPathCommand.closePath;
      //var markerPos = properties.orientation;
      
      if (markerPos === 'left') {
        xStart += markerHeight;
      }
      if (markerPos === 'top') {
        yStart += markerHeight;
      }

      var path = moveTo + space + xStart + space + (yStart + radius) + space;

      if (markerPos === 'left') {
          path += lineTo + space + xStart + space + (yStart + height / 2 + offset - markerWidth / 2 ) + space;
          path += lineTo + space + (xStart - markerHeight) + space + (yStart + height / 2 + offset ) + space;
          path += lineTo + space + xStart + space + (yStart + height / 2 + offset + markerWidth / 2 ) + space;
      }

      path += lineTo + xStart + space + (yStart + height - radius) + space;

      path += arc + space + radius + space + radius + space + '0' + space + '0' + space + '0' + space + (xStart + radius) + space + (yStart + height) + space;

      if (markerPos === 'bottom') {
          path += lineTo + space + (xStart + width / 2 + offset - markerWidth / 2) + space + (yStart + height) + space;
          path += lineTo + space + (xStart + width / 2 + offset) + space + (yStart + height + markerHeight) + space;
          path += lineTo + space + (xStart + width / 2 + offset + markerWidth / 2) + space + (yStart + height) + space;
      }

      path += lineTo + space + (xStart + width - radius) + space + (yStart + height) + space;

      path += space + arc + space + radius + space + radius + space + '0' + space + '0' + space + '0' + space + (xStart + width) + space + (yStart + height - radius) + space;

      if (markerPos === 'right') {
          path += lineTo + space + (xStart + width) + space + (yStart + height / 2 + offset + markerWidth / 2) + space;
          path += lineTo + space + (xStart + width + markerHeight) + space + (yStart + height / 2 - offset) + space;
          path += lineTo + space + (xStart + width) + space + (yStart + height / 2 + offset - markerWidth / 2) + space;
      }

      path += lineTo + space + (xStart + width) + space + (yStart + radius) + space;

      path += space + arc + space + radius + space + radius + space + '0' + space + '0' + space + '0' + space + (xStart + width - radius) + space + yStart + space;

      if (markerPos === 'top') {
          path += lineTo + space + (xStart + width / 2 + offset + markerWidth / 2) + space + yStart + space;
          path += lineTo + space + (xStart + width / 2 + offset) + space + (yStart - markerHeight) + space;
          path += lineTo + space + (xStart + width / 2 + offset - markerWidth / 2) + space + yStart + space;
      }

      path += lineTo + space + (xStart + radius) + space + yStart + space;

      path += arc + space + radius + space + radius + space + '0' + space + '0' + space + '0' + space + xStart + space + (yStart + radius) + space;

      path += closePath;
      
      //draw the shadow below the tooltip background
      vis.append('path').attr('d', path).attr('class', _tooltipBackgroundClassName).style('-webkit-svg-shadow', '1px 1px 4px rgba(0, 0, 0, 0.25)');
      vis.append('path').attr('d', path).attr('class', _tooltipBackgroundClassName).attr('fill', _defaultToolTipColors.backgroundColor).attr('stroke', _defaultToolTipColors.borderColor).attr('stroke-width', _shapeLayout.borderWidth);

    }

    function getCustomlabel(rawObj){
      var ret;
      if(rawObj.info){
        var clobj = rawObj.info.customlabel;
        if(clobj){
          if(clobj.type === 'url'){
            ret = rawObj.val;
          }else if(clobj.type === 'string'){
            ret = clobj.val;
          }
        }else{
          ret = rawObj.val;
        }
      }else{
        ret = rawObj.val;
      }
      ret = handleNull(ret);
      return ret;
    }
    
    function resolveText(rawObj){
      var ret = [];
      if(TypeUtils.isPlainObject(rawObj)){ 
        ret.push(getCustomlabel(rawObj));
      }else if(TypeUtils.isArray(rawObj)){
        rawObj.forEach(function(iter, index){
          ret.push(resolveText(iter));
        }, this);
      }else{
        ret.push(rawObj);
      }
      return ret;
    }
    
    function getTextBox(vis, text, style) {
      /*[Jimmy/1/2/2013]we extend text to also accepts Object with following structure: 
       * {
       *   val: xxxx
       *   info: xxxx
       * }, same structure as we used in module. then we can support additional info like customlabel in tooltip
       * text can also be array, we will compose each member with '/' (hard coded currently) and measure the final result
       */
      var resolvedTexts = resolveText(text);
      var composedText = resolvedTexts.join('*');
      var textHandler = vis.append('svg:text').attr('x', 0).attr('y', 0).attr('visibility', 'hidden').style('font', style).text(composedText);
      var bbox = textHandler.node().getBBox();
      textHandler.remove();
      return bbox;
    }

    function getTextMaxWidth(vis, data) {
      var maxValue = 0, textWidth = 0;
      if (data.title !== null) {
          if (data.labels.length > 0) {
              var bBox = getTextBox(vis, data.title, _display.title.font);
              var currentMax = bBox.width;

              for (var i = 0, len = data.labels.length; i < len; i++) {
                 textWidth = getTextBox(vis, data.labels[i].label, _display.multipleMeasure.label.font).width + getTextBox(vis, data.labels[i].value, _display.multipleMeasure.value.font).width;
                  if (textWidth > currentMax) {
                      currentMax = textWidth;
                  }
              }
              maxValue = currentMax;
          }
      } else {
          maxValue = getTextBox(vis, data.labels[0].label, _display.singleMeasure.label.font).width;
          textWidth = getTextBox(vis, data.labels[0].value, _display.singleMeasure.value.font).width;

          if (textWidth > maxValue) {
              maxValue = textWidth;
          }
      }
      return maxValue;
    }

    function getTooltipWidth(vis, data) {
      var tooltipWidth = 0, symbolSize = _symbol.symbolSize;
      var singleHorizontal = _display.singleMeasure.padding.horizontal, multipleHorizontal = _display.multipleMeasure.padding.horizontal, symbolGap = _display.multipleMeasure.padding.symbolGap, defaultSpace = _display.multipleMeasure.padding.defaultSpace;
      if (data.title !== null) {
        tooltipWidth = textMaxWidth + (multipleHorizontal * 2) + defaultSpace; //+ radius * 2;
        if (data.shapes && data.colors) {
          tooltipWidth +=  symbolSize + symbolGap;
        }
      } else {
        tooltipWidth = textMaxWidth + (singleHorizontal * 2); 
      }
      return tooltipWidth;
    }

    function getTooltipHeight(vis, data) {
      var inline = _display.multipleMeasure.padding.inline, multipleVertical = _display.multipleMeasure.padding.vertical, singleVertical = _display.singleMeasure.padding.vertical;
      var multipleValueFont = _display.multipleMeasure.value.font, singleValueFont = _display.singleMeasure.value.font;
      var titleFont = _display.title.font;
      var tooltipHeight = 0;
        if (data.title !== null) {
            tooltipHeight = (multipleVertical * 3) + (inline * (data.labels.length - 1)) + getTextBox(vis, data.title, titleFont).height + getTextBox(vis, data.labels[0].value, multipleValueFont).height * data.labels.length;

        } else {
            tooltipHeight = (singleVertical * 3 ) + getTextBox(vis, data.labels[0].value, singleValueFont).height;
        }
        return tooltipHeight;
    }
        
    function appendLinearGradient(vis) {
      var gradient = vis.append('svg:defs').append('svg:linearGradient').attr('id', 'tooltipGradient1').attr('x1', '0%').attr('y1', '0%').attr('x2', '80%').attr('y2', '0%').attr('x3', '100%').attr('y3', '0%');
      gradient.append('svg:stop').attr('offset', '30%').attr('style', 'stop-color:' + _defaultToolTipColors.separationLineColor[0]);
      gradient.append('svg:stop').attr('offset', '60%').attr('style', 'stop-color:' + _defaultToolTipColors.separationLineColor[1]);
      gradient.append('svg:stop').attr('offset', '100%').attr('style', 'stop-color:' + _defaultToolTipColors.separationLineColor[2]);          
    }
  
    function drawSymbol(vis, pos, symbolSize, symbolType, color) {
      var symbolPath = d3.svg.symbol().type(symbolType).size(symbolSize * symbolSize);
      var parameter = {
          drawingEffect: _properties.drawingEffect,
          fillColor : color,
        graphType : symbolType,
          direction : 'vertical'
      };
      var fillId =  effectManager.register(parameter);
      vis.append('path').attr('d', symbolPath).attr('transform', 'translate(' + pos.x + ',' + pos.y + ')').attr('fill', fillId);
    } 
        
    function drawText(vis, pos, text, color, style) {
      vis.append('text').attr('x', pos.x).attr('y', pos.y).attr('fill', color).style('font', style).text(text);
    }
        
    function drawTextV2(vis, pos, text, color, style, className) {
      /*[Jimmy/1/2/2013]we extend text to also accepts Object with following structure: 
       * {
       *   val: xxxx
       *   info: xxxx
       * }, same structure as we used in module. then we can support additional info like customlabel in tooltip
       * text can also be array, we will compose each member with '/' (hard coded currently) and measure the final result
       */
      var resolvedTexts = resolveText(text);
      var composedText = resolvedTexts.join('/');
      vis.append('text').attr('x', pos.x).attr('y', pos.y).attr('fill', color).style('font', style).text(composedText).attr('class', className);
    }
    
    function drawContent(vis, pos, data) {}
        
    tooltip.zone = function(_){
      if(!arguments.length){
        return zone;
      }
      zone = _;
      return this;
    };
  
    tooltip.plotArea = function(_){
      if(!arguments.length){
        return plotArea;
      }
      plotArea = _;
      return this;
    };
        
    tooltip.properties = function (_) {
      if (!arguments.length){
          return _properties;
       }
      Objects.extend(true, _properties, _);
      return this;
    };
    
    tooltip.destroy = function() {
      gWrapper = null;
      vis = null;
      plotArea = null;
      zone = null;
      //destroy ctx
      if(ctx){
        ctx.destroy();
        ctx = null;
      }
    };
    
    function updateTooltipStyle() {
      var cssDef;
      
      cssDef = ctx.styleManager.queryDefault('viz-tooltip-background');
      if (cssDef && (cssDef['fill']) && (_defaultToolTipColors.backgroundColor !== cssDef['fill'])) {
        _defaultToolTipColors.backgroundColor = cssDef['fill'];
      }
      
      cssDef = ctx.styleManager.queryDefault('viz-tooltip-title');
      if (cssDef && (cssDef['fill']) && (_display.title.color !== cssDef['fill'])) {
        _display.title.color = cssDef['fill'];
      }

      cssDef = ctx.styleManager.queryDefault('viz-tooltip-label');
      if (cssDef && cssDef['fill']) {
        _display.singleMeasure.label.color  = cssDef['fill'];
        _display.multipleMeasure.label.color = cssDef['fill'];
      }

      cssDef = ctx.styleManager.queryDefault('viz-tooltip-value');
      if (cssDef && cssDef['fill']) {
        _display.singleMeasure.value.color  = cssDef['fill'];
        _display.multipleMeasure.value.color = cssDef['fill'];
      }
      
      cssDef = ctx.styleManager.queryDefault('v-footer-label');
      if (cssDef && cssDef['fill']) {
        _display.footer.label.color  = cssDef['fill'];
      }
      
      cssDef = ctx.styleManager.queryDefault('v-footer-value');
      if (cssDef && cssDef['fill']) {
        _display.footer.value.color  = cssDef['fill'];
      }
  
      cssDef = ctx.styleManager.queryDefault('v-separationline');
      if (cssDef && cssDef['fill']) {
        _defaultToolTipColors.separationLineSingleColor  = cssDef['fill'];
      }
    }
    
    _properties = manifest.props(null);
    return tooltip;
  };
  return ret;
});
define('sap/viz/modules/manifests/Tooltip',['sap/viz/modules/manifests/Module','sap/viz/modules/Constants','sap/viz/modules/tooltip'],
function Setup(Manifest, Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.tooltip',
    'type' : Constants.Type.Presentation.Tooltip,
    
    'renderto' : Constants.RenderTo.NONE,
    'name' : 'tooltip',
    'description': 'Settings for the tooltip that appears when the user hovers over a series or point.',
    'properties' : {
      'visible' : {
        'name' : 'visible',
          'supportedValueType' : 'Boolean',
          'defaultValue' : true,
          'description' : 'Set visibility of tooltip.'
      },
     'drawingEffect':{
       'name' : 'drawingEffect',
       'supportedValueType' : 'String',
       'supportedValues' : [ 'normal', 'glossy' ],
           'defaultValue' : 'normal',
           'description' : 'Set drawing effect of Tooltip.',
           'isExported' : true
    },
	'formatString': {
	'name' : 'formatString',
	'supportedValueType': 'Two-Dimensions-Array',
  'defaultValue' : null,
	'description' : 'Set format string of tooltip. As we may have dual axis with serveral measures, the first array is applied to primary axis and the second one is applied to the second one.'
		+'If the length of format string list is less than the length of data series, the last format string in the list will be applied to exceeded data series.'+'Any character in "MDYHSAmdyhsa#?%0@" is reserved as a token for format code.'
		+'The following is a simple sample format string for tooltip as one chart has two measures: [["#,##0.00 DM;-#,##.00 DM","#,##.00;-#,##.00"]].',
	'example': "<a href='"+Constants.DocExample.SnippetUrl+"5711' target='_blank'>"+Constants.DocExample.TryThisValue+"</a>"
	}
      },
    'css' : {
      '.viz-tooltip-background.v-background' : {
        'description' : 'Define color for the tooltip background.',
        'value' : {
          'fill' : '#ffffff'
        }
      },
      '.viz-tooltip-title.v-body-title' : {
        'description' : 'Define color for the title of tooltip body.',
        'value' : {
          'fill' : '#333333'
        }
      },
      '.viz-tooltip-label.v-body-label' : {
        'description' : 'Define color for the label of tooltip body.',
        'value' : {
          'fill' : '#333333'
        }
      },
      '.viz-tooltip-value.v-body-value' : {
        'description' : 'Define color for the value of tooltip body.',
        'value' : {
          'fill' : '#333333'
        }
      },
      '.v-footer-label' : {
        'description' : 'Define color for the label of tooltip footer.',
        'value' : {
          'fill' : '#333333'
        }
      },
      '.v-footer-value' : {
        'description' : 'Define color for the value of tooltip footer.',
        'value' : {
          'fill' : '#333333'
        }
      },
      '.v-separationline' : {
        'description' : 'Define color for the value of tooltip separation line.',
        'value' : {
          'stroke' : '#AAAAAA'
        }
      }
    },
    fn : fn
  };

  Manifest.register(module);
});

define('sap/viz/manifests/RadarChart',['sap/viz/manifests/Viz','sap/viz/manifests/BaseSingleChart','sap/viz/modules/manifests/RootContainer',
'sap/viz/modules/manifests/Radar','sap/viz/modules/manifests/Tooltip',
'sap/viz/modules/manifests/Background'],
function Setup(Manifest) {
  var chart = {
    id : 'viz/radar',
    name : 'IDS_RADARCHART',
    base : "riv/base/single",
    modules : {
      root : {
        modules : {
          legends : {
            modules : {
              legend : {
                id : "sap.viz.modules.legend.common",
                data : { aa : [ 2, 3 ] }
              }
            }
          },
          tooltip : {
            id : "sap.viz.modules.tooltip",
            configure : {
            propertyCategory : 'tooltip',
              properties : {
                chartType : "radar",
                orientation : "left"
              }
            }
          },
          
          interaction : {
            id : "sap.viz.modules.controller.interaction",
            configure : {
              clientID : "main",
              propertyCategory : "interaction",
              properties : {
                supportedEventNames : [ "mousemove", "mouseup", "touchstart" ]
              }
            }
          },
          
          main : {
            id : 'sap.viz.modules.xycontainer',
            modules : {
              plot: {
                id : 'sap.viz.modules.radar',
                configure : {
                'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory : 'plotArea'
                }    
              },
              dataLabel : {
                id : 'sap.viz.modules.datalabel',
                configure : {
                  propertyCategory : 'dataLabel',
                  properties : {
                    paintingMode : 'rectCoordinate',
                    visible : false,
                    orientation : 'vertical',
                    position : 'outside',
                    automaticInOutside : false,
                    showZero : true,
                    isStackMode : false,
                    isPercentMode : false,
                    outsideVisible : true,
                    outsidePosition : 'up',
                    positionPreference : true
                  }
                }
              }
            }
          }
        }
      }
    },
    dependencies : {
      attributes : 
      [
        {
          targetModule : "root.legends.legend",
          target : "colorPalette",
          sourceModule : "root.main.plot",
          source : "colorPalette"
        },  {
          targetModule : 'root.legends.legend',
          target : 'shapes',
          sourceModule : 'root.main.plot',
          source : 'shapes'
        }, {
            targetModule : 'root.legends.legend',
            target : 'setSelectionMode',
            sourceModule : 'root.interaction',
            source : 'getSelectionMode'
        } 
      ],
      events : 
      [
        {
          targetModule : "root.interaction",
          listener : "registerEvent",
          sourceModule : "root.main.plot",
          type : "initialized.interaction"
        },{
          targetModule : 'root.interaction',
          listener : 'highlightedByLegend',
          sourceModule : 'root.legends.legend',
          type : 'highlightedByLegend'
        }, {
          targetModule : 'root.legends.legend',
          listener : 'deselectLegend',
          sourceModule : 'root.interaction',
          type : 'deselectLegend'
        }, {
          targetModule : "root.tooltip",
          listener : "showTooltip",
          sourceModule : "root.main.plot",
          type : "showTooltip"
        }, {
          targetModule : "root.tooltip",
          listener : "hideTooltip",
          sourceModule : "root.main.plot",
          type : "hideTooltip"
        }, {
          targetModule : 'root.main.dataLabel',
          listener : 'showLabel',
          sourceModule : 'root.main.plot',
          type : 'initialized.datalabel'
        }, {
          targetModule : 'root.main.dataLabel',
          listener : 'removeLabel',
          sourceModule : 'root.main.plot',
          type : 'startToInit.datalabel'
        }, {
          targetModule : 'root.interaction',
          listener : 'defaultSelection',
          sourceModule : 'root.main.plot',
          type : 'initialized.defaultSelection'
        }
      ]
    }
  };

  Manifest.register(chart);
});
define('sap/viz/modules/tagcloud/rowLayout',['sap/viz/util/TextUtils','sap/viz/util/NumberUtils'],
function Setup(TextRuler, NumberUtils) {
  var rowLayout = function() {
    var width = 300, height = 300, chartData = [], font = '';

    var textDirection = 'Mixed';

    var row = function() {

    };
    
    row.textDirection = function(_) {
      if (!arguments.length) {
        return textDirection;  
      }
        
      textDirection = _;
      return row;
    };
    
    row.width = function(_) {
      if (!arguments.length){
        return width;
      }
      width = _;
      return row;
    };

    row.height = function(_) {
      if (!arguments.length){
        return height;
      }
      height = _;
      return row;
    };

    row.data = function(_) {
      if (!arguments.length){
        return chartData;
      }
      chartData = _;
      return row;
    };

    row.font = function(_) {
      if (!arguments.length){
        return font;
      }
      font = _;
      return row;
    };

    row.layout = function() {
      _layout();
      return row;
    };

    var _layout = function() {
      var tagArr = chartData;
      var d, textSize, i, len;
      var startX = 0;
      var maxRowHeight = 0, startY = 0, newLineIndex = 0;
      for (i = 0, len = tagArr.length; i < len; i++) {
        d = tagArr[i];
        if ( startY <= height) {
          textSize = TextRuler.fastMeasure(tagArr[i].word.val+'i', tagArr[i].fontSize+'px', 'normal', font);
          d.width = textSize.width;
          d.height = textSize.height;
        } else {
          d.width = 0;
          d.height = 0;
          continue;
        }
        if((d.width > width) || (d.height > height) || (NumberUtils.isNoValue(tagArr[i].fontSize))){
          continue;
        }
        
        if (startX + d.width > width) {
          // New Row
          startX = 0;
          _adjustLastLineTagPosition(newLineIndex, i, startY + maxRowHeight);
          
          newLineIndex = i;
          startY = startY + maxRowHeight;
          maxRowHeight = tagArr[i].height;
        }
        if(d.height > maxRowHeight){
          maxRowHeight = d.height;
        }
        d.x = startX;
        d.y = startY;
        startX = startX + d.width;
        d.rotate = undefined;
      }
      _adjustLastLineTagPosition(newLineIndex, i, startY + maxRowHeight);
    };
    
    /*
     * Set last line tag position.
     */
    var _adjustLastLineTagPosition = function(startIndex, endIndex, newYPosition){
      var dArr;
      for(var j = startIndex; j < endIndex; j++){
        dArr = chartData[j];
        if(dArr.y !== undefined){
          dArr.y = newYPosition;
        }
      }
    };
    return row;
  };
  return rowLayout;
});

define('sap/viz/modules/tagcloud/columnLayout',['sap/viz/util/TextUtils','sap/viz/util/NumberUtils'],
function Setup(TextRuler, NumberUtils) {
  var columnLayout = function() {
    var width = 300, height = 300, chartData = [], font = '';
    var textDirection = 'Mixed';

    var column = function() {

    };
    column.textDirection = function(_) {
      if (!arguments.length) {
        return textDirection;  
      }
        
      textDirection = _;
      return column;
    };
    
    column.width = function(_) {
      if (!arguments.length) {
          return width;  
      }
        
      width = _;
      return column;
    };

    column.height = function(_) {
      if (!arguments.length) {
          return height;
      }
        
      height = _;
      return column;
    };

    column.data = function(_) {
      if (!arguments.length) {
          return chartData;  
      }
       
      chartData = _;
      return column;
    };

    column.font = function(_) {
      if (!arguments.length) {
          return font;  
      }
        
      font = _;
      return column;
    };

    column.layout = function() {
      _layout();
      return column;
    };

    var _layout = function() {
      var tagArr = chartData;
      var d, textSize;
      var startX = 0, startY = 0;
      for ( var i = 0, len = tagArr.length; i < len; i++) {
        d = tagArr[i];
        if (startY <= height) {
          textSize = TextRuler.fastMeasure(tagArr[i].word.val+'i', tagArr[i].fontSize+'px', 'normal', font);
          d.width = textSize.width;
          d.height = textSize.height;
        } else {
          d.width = 0;
          d.height = 0;
          continue;
        }
        if((d.width > width) || (d.height > height) || NumberUtils.isNoValue(tagArr[i].fontSize)) {
          continue;
        }
        startY = startY + d.height;
        d.x = startX;
        d.y = startY;
        d.rotate = undefined;
      }
    };
    return column;
  };
  return columnLayout;
});

define('sap/viz/modules/tagcloud/wordleLayout',['sap/viz/util/TextUtils','sap/viz/util/NumberUtils'],
function Setup(TextRuler, NumberUtils) {
  var wordleLayout = function() {
    var width = 300, height = 300, chartData = [], font = '';
    var textDirection = 'Mixed';

    var wordle = function() {

    };
    
    wordle.textDirection = function(_) {
      if (!arguments.length) {
        return textDirection;  
      }
        
      textDirection = _;
      return wordle;
    };
    
    wordle.width = function(_) {
      if (!arguments.length) {
        return width;  
      }
        
      width = _;
      return wordle;
    };

    wordle.height = function(_) {
      if (!arguments.length) {
        return height;
      }
        
      height = _;
      return wordle;
    };

    wordle.data = function(_) {
      if (!arguments.length) {
        return chartData; 
      }
       

      _.sort(function(a, b) {
        if (a.wordSize && b.wordSize) {
          return b.wordSize.val - a.wordSize.val;
        }
      });
      chartData = _;
      return wordle;
    };

    wordle.font = function(_) {
      if (!arguments.length) {
        return font;
      }
       
      font = _;
      return wordle;
    };

    wordle.layout = function() {
      var relayout = false, layoutCount = 0;
      while (!relayout) {
        relayout = _layout(++layoutCount);
      }
      return wordle;
    };

    var _layout = function(layoutCount) {
      var tagArr = chartData, textSize, lastTextSize, d, root, flag;
      for ( var i = 0, len = tagArr.length; i < len; i++) {
        d = tagArr[i];

        if (NumberUtils.isNoValue(d.fontSize)) {
          continue;
        }

        textSize = TextRuler.fastMeasure(tagArr[i].word.val + 'i',
            tagArr[i].fontSize + 'px', 'normal', font);
        
        d.width = textSize.width;
        d.height = textSize.height;

        d.x = undefined;
        d.y = undefined;

        d.rect = new rect(d.width, d.height);

        if (!root) {
          var rotate;
          switch (textDirection){
            case 'Mixed':
              if (d.width <= width && d.height <= height) {
                rotate = false;
              } else if (d.height <= width && d.width <= height) {
                rotate = true;
              }            
            break;
            case 'Vertical':
              if (d.height <= width && d.width <= height) {
                rotate = true;
              }
            break;
            case 'Horizontal':
              if (d.width <= width && d.height <= height) {
                rotate = false;
              }
            break;            
          }
          if (rotate !== undefined) {
            root = d;
            if (rotate){
              d.rect.rotate();
            }
            d.rect.position(width / 2, height / 2);
            flag = true;
          }

        } else {
          if (flag === false && lastTextSize) {
            if(textSize.width >= lastTextSize.width && textSize.height >= lastTextSize.height) {
              continue;
            }
          }
          var list = [];
          list.push(root);
          while (list.length !== 0) {
            var parent = list.shift();

            if (parent.child){
              parent.child.forEach(function(c) {
                if (c){
                  list.push(c);
                }
              });
            }

            flag = placeTag(d, parent, root);
            if (flag){
              break;
            }
          }
        }
        lastTextSize = textSize;
        if ( flag ) {
          d.x = d.rect.x;
          d.y = d.rect.y;

          var baseLineOffset = -textSize.y - (textSize.height / 2), rotated = d.rect.rotated;
          if ( rotated ) {
            d.x -= baseLineOffset;
            d.rotate = 90;
          } else {
            d.y += baseLineOffset;
            d.rotate = 0;
          }
        }
      }

      tagArr.forEach(function(d) {
        delete d.child;
        delete d.rect;
      });

      return true;
    };

    function placeTag(tag, parent, root) {
      var rect = tag.rect;
      var child = parent.child;
      if (!child) {
        child = [];
        parent.child = child;
      }
      var x, y;
      var i, j;
      switch (textDirection){
        case 'Mixed':
          for (j = 0; j < 2; j++) {
            if (j === 1) {
              rect.rotate();            
            }

            for (i = 0; i < 4; i++) {
              if (child[i]){
                continue;
              }

              switch (i) {
              case 0:
                x = parent.x;
                y = parent.rect.y0 - rect.h / 2;
                break;
              case 1:
                y = parent.y;
                x = parent.rect.x1 + rect.w / 2;
                break;
              case 2:
                x = parent.x;
                y = parent.rect.y1 + rect.h / 2;
                break;
              case 3:
                y = parent.y;
                x = parent.rect.x0 - rect.w / 2;
                break;
              }

              rect.position(x, y);

              if (rect.x0 >= 0 && rect.y0 >= 0 && rect.x1 <= width && rect.y1 <= height) {
                if (validPosition(rect, parent, root)) {
                  child[i] = tag;
                  return true;
                }
              }
            }
          }

        break;
        case 'Vertical':
          rect.rotate();            
          for (i = 0; i < 4; i++) {
            if (child[i]){
              continue;
            }

            switch (i) {
            case 0:
              x = parent.x;
              y = parent.rect.y0 - rect.h / 2;
              break;
            case 1:
              y = parent.y;
              x = parent.rect.x1 + rect.w / 2;
              break;
            case 2:
              x = parent.x;
              y = parent.rect.y1 + rect.h / 2;
              break;
            case 3:
              y = parent.y;
              x = parent.rect.x0 - rect.w / 2;
              break;
            }

            rect.position(x, y);

            if (rect.x0 >= 0 && rect.y0 >= 0 && rect.x1 <= width && rect.y1 <= height) {
              if (validPosition(rect, parent, root)) {
                child[i] = tag;
                return true;
              }
            }
          }
          
          break;
        case 'Horizontal':
          for (i = 0; i < 4; i++) {
            if (child[i]){
              continue;
            }

            switch (i) {
            case 0:
              x = parent.x;
              y = parent.rect.y0 - rect.h / 2;
              break;
            case 1:
              y = parent.y;
              x = parent.rect.x1 + rect.w / 2;
              break;
            case 2:
              x = parent.x;
              y = parent.rect.y1 + rect.h / 2;
              break;
            case 3:
              y = parent.y;
              x = parent.rect.x0 - rect.w / 2;
              break;
            }

            rect.position(x, y);

            if (rect.x0 >= 0 && rect.y0 >= 0 && rect.x1 <= width && rect.y1 <= height) {
              if (validPosition(rect, parent, root)) {
                child[i] = tag;
                return true;
              }
            }
          }
        break;            
      }
      //rotate back if placing failed
      if (textDirection === 'Mixed' || textDirection === 'Vertical'){
        rect.rotate();            
      }
      return false;
    }

    function validPosition(rect, parent, root) {
      if (root !== parent){
        if (!rect.notInterects(root.rect)){
          return false;
        }
      }

      for ( var i = 0, child = root.child, len = child ? child.length : 0; i < len; i++) {
        if (child[i] && !validPosition(rect, parent, child[i])){
          return false;
        }
      }

      return true;
    }

    function rect(w, h) {
      this.w = w;
      this.h = h;
      this.rotated = false;
    }

    rect.prototype = {
      position : function(x, y) {
        this.x = x;
        this.y = y;

        var _x = this.w / 2, _y = this.h / 2;
        this.x0 = x - _x;
        this.x1 = x + _x;
        this.y0 = y - _y;
        this.y1 = y + _y;
      },

      notInterects : function(rect) {
        return this.x1 <= rect.x0 || this.x0 >= rect.x1 || this.y1 <= rect.y0 || this.y0 >= rect.y1;
      },

      rotate : function() {
        this.rotated = !this.rotated;
        var t = this.h;
        this.h = this.w;
        this.w = t;
      }
    };

    return wordle;
  };
  return wordleLayout;
});
define('sap/viz/util/MeasureBasedColoring',[],
function Setup() {
  var MeasureBasedColoring = {
     getColorScale:function(minVal, maxVal, hasNoValue, props)
     {
       var colorScale = null;
       var tickNum = props.numberOfTicks;
       if(props.colorPalette && props.colorPalette.length >= props.numberOfTicks)
       {
         var range = props.colorPalette.slice(0, tickNum);
         if(minVal !== maxVal){
            colorScale = d3.scale.quantize().domain([minVal, maxVal])
            .range(range);
         }else{
           colorScale = d3.scale.linear().domain([ minVal, maxVal ])
           .range(range);
         }
       }else{
           colorScale = d3.scale.linear().domain([ minVal, maxVal ])
           .range([ props.startColor, props.endColor ]).nice();

       }
       var colorScaleNice = colorScale.domain(); 
       var t1 = getAccFormat(colorScaleNice[0]), t2 = getAccFormat(colorScaleNice[1]);
       var totalPrecision = t1 > t2 ? t1 : t2;
       totalPrecision++;
       
       var niceDomain = colorScale.domain();
       niceDomain = formatRange(niceDomain, totalPrecision);
       
       minVal = niceDomain[0];
       maxVal = niceDomain[1];
       
       if(minVal === maxVal){
         //only one value in range.
         tickNum = 1;
       }
       var span = maxVal - minVal, ticks = [], step, precision = 0;
       var i, start, len;
       if(span / tickNum > 1){
         if (span % tickNum === 0) {
           // divied properly
           step = format(span / tickNum, totalPrecision + 1);
           precision = getAccFormat(step);
           
           for (i = 0; i < tickNum + 1; i++) {
             ticks.push(minVal + format(i * step, precision));
           }
         } else {
           step = Math.ceil(span / tickNum);
           precision = getAccFormat(step);
           start = Math.floor(minVal / step) * step;
           if(start === 0 || (start + step*tickNum < maxVal)) {
             start = minVal;
           }
           
           for (i = 0; i < tickNum + 1; i++) {
             ticks.push(start + format(i * step, precision));
           }
         }
       }else{
         //Can't be divided with integrate. 
         start = minVal, step = format(span / tickNum, totalPrecision + 1);
         precision = getAccFormat(step);
         
         for(i = 0; i < tickNum; i++){
           ticks.push(start + format(i * step, precision));
         }
         ticks.push(format(maxVal, precision));
       }
       
       //format all values
       for(i = 0, len = ticks.length; i < len; i++){
         ticks[i] = format(ticks[i], precision);
       }
       
       while(minVal < ticks[0]) {ticks[0]--;}
       while(maxVal > ticks[ticks.length - 1]) {ticks[ticks.length - 1]++;}
       
       //reset color scale
       colorScale.domain([ 0, tickNum - 1 ]);
       
       var domainRg = [], rangeRg = [];
       for (i = 0, len = ticks.length - 1; i < len; i++) {
         domainRg.push([ ticks[i], ticks[i + 1] ]);
         rangeRg.push(colorScale(i));
       }

       var fontColorScale = d3.scale.ordinal().domain(domainRg).range(rangeRg);
       if(hasNoValue)
       {
          fontColorScale.domain().push([]);
          fontColorScale.range().push(props.nullColor);
       }
       
       return fontColorScale;
           
     },
    getScale : function(minVal, maxVal, ticksCount, startColor, endColor) {
      return MeasureBasedColoring.getColorScale(minVal, maxVal, false,  {numberOfTicks:ticksCount, startColor:startColor, endColor:endColor});
    }
  };

  
  var formatRange = function(range, precision){
    for(var i = 0, len = range.length; i < len; i++){
      range[i] = format(range[i], precision);
    }
    return range;
  };
  
  var getAccFormat = function(value){
    var t = value.toString().split(".");
    return t.length > 1 ? t[1].length : 0;
  };
  
  var format = function(value, precision){
    return Math.round(Math.pow(10, precision) * value) / Math.pow(10, precision);
  };
  
  return MeasureBasedColoring;
});
define('sap/viz/modules/tagcloud',['sap/viz/base/utils/oo','sap/viz/modules/Base','sap/viz/base/utils/TypeUtils','sap/viz/modules/dispatch','sap/viz/util/ColorSeriesGenerator',
'sap/viz/lang/langManager','sap/viz/modules/tagcloud/rowLayout','sap/viz/modules/tagcloud/columnLayout',
'sap/viz/modules/tagcloud/wordleLayout','sap/viz/util/MeasureBasedColoring',
'sap/viz/util/NumberUtils','sap/viz/base/utils/ObjectUtils','sap/viz/modules/util/tooltipDataHandler',
'sap/viz/base/utils/Objects','sap/viz/modules/util/BoundUtil',
'sap/viz/modules/util/defaultSelectionUtil','sap/viz/modules/Constants'],
function Setup(oo, Base,TypeUtils, dispatch, ColorSeries, langManager, RowLayout, ColumnLayout, WordleLayout, MeasureBasedColoring, NumberUtils, ObjectUtils, tooltipDataHandler, Objects, boundUtil, defaultSelUtil,Constants) {

//////////////// CLASS VARS///////////////////////
	var CLASSDATAPOINT = "v-datapoint",
		CLASSMORPHABLEDATAPOINT = Constants.CSS.CLASS.MORPHABLEDATAPOINT;
	var CLASSDATAPOINTCOMBINED = CLASSDATAPOINT + ' ' + CLASSMORPHABLEDATAPOINT;
	var CSSCLASS_HOVERLINE = 'v-hovershadow';

    var TAGSTYLE = {
      'fontfamily' : "'Open Sans', Arial, Helvetica, sans-serif",
      'color' : '#555555'
    };

    var DEFAULTSTRING = langManager.get('IDS_ISNOVALUE');

	//////////////////////////////////////////////////

	var TagCloud = function(manifest, ctx){
		TagCloud.superclass.constructor.apply(this,arguments);
		this._tag_width = 400;
		this._tag_height = 200;
		this._tag_wrap = null;
		this._tag_chartData = {};
		this._tag_tagArr = [];
		this._tag_maxfont = 48;
		this._tag_minfont = 12;
		this._tag_fontColorScale = undefined;
		this._tag_selectionList = [];
		this._tag_effectManager = ctx.effectManager;
		this._tag_randomSuffix = ObjectUtils.guid();
		this._tag_minFontFamily = Number.MAX_VALUE;
		this._tag_maxFontFamily = Number.MIN_VALUE;
		this._tag_hasNullValue = false;
		this._tag_tooltipVisible = true;
		this._tag_style = {};
		this._tag_opacity = 1;
		this._tag_options = manifest.props(null);
		this._tag_textDirection = this._tag_options.layout.textDirection;
		this._tag_layoutMode = this._tag_options.layout.mode;

		this._tag_eDispatch = new dispatch('initialized', 'showTooltip', 'hideTooltip'); //, 'showTooltip', 'hideTooltip'
		this._tag_decorativeShape = null;
		this._tag_isDataSchemaChanged = false;
		this._tag_isDataLoading = true;
		this._tag_isSizeChanged = false;
		this._tag_isDatasetChanged = false;
		this._tag_hasDefaultSelection = false;

		this._tagfn_getCSSStyle(ctx);
	};

	oo.extend(TagCloud,Base);

	TagCloud.prototype.render = function(selection) {
		var that = this;
      selection.each(function() {
        boundUtil.drawBound(selection, that._tag_width, that._tag_height);

        that._tagfn_calculateTagPosition();
        
        if(that._tag_decorativeShape === null){
          that._tag_decorativeShape = selection.append('rect').attr('fill', that._tag_style.hoverline.fill).attr('class', CSSCLASS_HOVERLINE).style('visibility', 'hidden');
        }else{
          that._tag_decorativeShape.attr('width', 0).attr('height', 0).attr('x', 0).attr('y', 0).style('visibility', 'hidden');
        }
        
        //filter hidden data
        var labelsData = that._tagfn_filterData();
        
        that._tag_wrap = d3.select(this);

        //remove old data item while updateing dataset
        if(that._tag_isDatasetChanged && !that._tag_wrap.selectAll('g.v-datashape').empty()){
          that._tag_wrap.selectAll('g.v-datashape').remove();
        }
        
        that._tag_wrap.attr('style', 'cursor:default');//.on('click', clickHandler).on('mouseover', mouseOverHandler).on('mouseout', mouseOutHandler);
        var wordsWrap = that._tag_wrap.selectAll('g.v-datashape').data(labelsData, function(d, i){
          return (d.word ? d.word.val : "") + " " + (d.wordFontFamily ? d.wordFontFamily.val : "") + " " + (d.wordSize ? d.wordSize.val : "");
        });
        
        wordsWrap.selectAll('text').data(function(d, i){
          return d;
        }).text(function(d, i){ 
          return d.word.val;
        });
        
        var wordsWrapEnter = wordsWrap.enter().append('g').attr('class', 'v-datashape').append('text').text(function(d, i){ 
            return d.word.val;
          })
          .attr('id', function(d, i){
            return 'TAG_ID_' + i + that._tag_randomSuffix;
          })
          .attr('class', CLASSDATAPOINTCOMBINED)
          .attr('visibility', function(d, i){
            var isVisible = 'visible';
            if(NumberUtils.isNoValue(d.fontSize) || d.x === undefined || d.y === undefined){
              isVisible = 'hidden';
            }
            return isVisible;
          })  
          .attr('font-size', function(d, i){
            return d.fontSize;
          }).attr('font-family', TAGSTYLE.fontfamily);

        wordsWrap.exit().attr('transform', 'translate(-1000, -1000)');
        wordsWrap.selectAll('.v-datapoint').attr("fill",function(d, i){
          var color;
          if(that._tag_fontColorScale && d.wordFontFamily !== null && d.wordFontFamily.val !== null){
            var j, len, domain = that._tag_fontColorScale.domain();
            for(j = 0, len = domain.length - 1; j < len; j++){
              if(d.wordFontFamily.val!==null && (domain[j][1] > d.wordFontFamily.val)){
                break;
              }
            }
            color = that._tag_fontColorScale(domain[j]);
          }else{
            color = TAGSTYLE.color;
          }  
          var parameter = {
            fillColor:color,
            drawingEffect:"normal"
          };
          return that._tag_effectManager.register(parameter);
        }).attr('text-anchor', function(){
          if(that._tag_layoutMode === 'Wordle'){
            return 'middle';
          }else{
            return 'start';
          }
        });
        wordsWrap.selectAll('text').attr('fill-opacity', that._tag_opacity);
        
        if(that._tagfn_enableAnimation()){
          wordsWrap.transition().attr('transform', function(d, i){
            var translate = '';
            if(d.x !== undefined && d.y !== undefined && d.y < that._tag_height && d.x < that._tag_width){
              translate = 'translate('+[d.x, d.y]+')';
            }else{
              translate = 'translate(-1000, -1000)';
            }
            if(d.rotate){
              translate = translate + " rotate(" + d.rotate + ")";
            }
            return translate;
          }).duration(800).delay(100).each('end', function(d, i){
            var translate = '';
            if(d.x !== undefined && d.y !== undefined && d.y < that._tag_height && d.x < that._tag_width){
              translate = 'translate('+[d.x, d.y]+')';
            }else{
              translate = 'translate(-1000, -1000)';
            }
            if(d.rotate){
              translate = translate + " rotate(" + d.rotate + ")";
            }
            this.setAttribute('transform', translate);
            
            if(i === labelsData.length-1){
              that._tag_eDispatch.initialized();
            }
          });
        }else{
          wordsWrap.attr('transform', function(d, i){
            var translate = '';
            if(d.x !== undefined && d.y !== undefined){
              translate = 'translate('+[d.x, d.y]+')';
            }else{
              translate = 'translate(-1000, -1000)';
            }
            if(d.rotate){
              translate = translate + " rotate(" + d.rotate + ")";
            }
            return translate;
          });
          //When the endAnimation is called, animation may not be end. 
          //(it looks like a bug of d3 or browsers) 
          setTimeout(that._tag_eDispatch.initialized, 0);
        }
        that._tag_isDataSchemaChanged = false, that._tag_isDataLoading = false, that._tag_isSizeChanged = false, that._tag_isDatasetChanged = false;        
      });
    };

    /**
      * set/get width
      */
     TagCloud.prototype.width = function(_){
          if (!arguments.length){
            return this._tag_width;
          }
          this._tag_isSizeChanged = (!this._tag_isSizeChanged && (_ === this._tag_width)) ? false : true;
          this._tag_width = _;
          return this;
      };

      /**
      * set/get height
      */
    TagCloud.prototype.height = function(_){
        if (!arguments.length){
          return this._tag_height;
         }
        this._tag_isSizeChanged = (!this._tag_isSizeChanged && (_ === this._tag_height)) ? false : true;
        this._tag_height = _;
         return this;        
      };

      /**
      * set/get data, for some modules like Title, it doesn't need data
      */
    TagCloud.prototype.data = function(_){
        if (!arguments.length){
          return this._tag_chartData;
         }
        var data = {};
        data.words = _.getAnalysisAxisDataByIdx(0).values[0];

        var wordsData = _.getMeasureValuesGroupDataByIdx(0);
        if(wordsData && _.getMeasureValuesGroupDataByIdx(0).values.length > 0){
          data.wordsSize = _.getMeasureValuesGroupDataByIdx(0).values[0];
        }else{
          data.wordsSize = undefined;
        }
        
        if ( wordsData.values[0] &&  wordsData.values[0].rows[0][0].info && wordsData.values[0].rows[0][0].info.defaultSelection ) {
          this._tag_hasDefaultSelection = true;
        }else{
          this._tag_hasDefaultSelection = false;
        }
        
        var wordsFontFamilySata = _.getMeasureValuesGroupDataByIdx(1);
        if(wordsFontFamilySata && wordsFontFamilySata.values.length > 0){
          data.wordsFontFamily = _.getMeasureValuesGroupDataByIdx(1).values[0];
        }else{
          data.wordsFontFamily = undefined;
          this._tag_fontColorScale = undefined;
        }
        this._tagfn_parseData(data);
        
        //Check dataset is changed.
        this._tag_isDatasetChanged = true;
        this._tag_isDataSchemaChanged = this._tagfn_isDatasetChanged(data);
        this._tag_chartData = data;
         return this;        
      };

      /**
      * set/get properties
      */
    TagCloud.prototype.properties = function(props){
        if (!arguments.length){
          return this._tag_options;
         }
         Objects.extend(true, this._tag_options, props);
         this._tagfn_parseOption();
         return this;
      };
      
      /**
     * get/set your event dispatch if you support event
     */
    TagCloud.prototype.dispatch = function(_){
        if(!arguments.length){
          return this._tag_eDispatch;
        }
        this._tag_eDispatch = _;
        return this;
      };
      
      
      /*
       * Font color scale.
       */
    TagCloud.prototype.mbcLegendInfo = function(){
        var title = this._tag_chartData.wordsFontFamily ? this._tag_chartData.wordsFontFamily.col : '';
        return {
          'colorScale' : this._tag_fontColorScale,
          'title' : title
        };
      };
      
      /*
       * Add mouse interaction functions.
       */
    TagCloud.prototype.parent = function(){
        return this._tag_wrap;
      };
      

    TagCloud.prototype.highlight = function(elems) {
      if (elems instanceof Array) {
        for ( var i = 0, len = elems.length; i < len; i++) {
          elems[i].setAttribute('fill-opacity', 1);
        }
      } else {
        elems.setAttribute('fill-opacity', 1);
      }

      if (this._tag_hasDefaultSelection) {
        defaultSelUtil.clearSelectionInfo(this._tag_wrap, true, elems);
      }
    };

    TagCloud.prototype.unhighlight = function(elems) {
      if (elems instanceof Array) {
        for ( var i = 0, len = elems.length; i < len; i++) {
          elems[i].setAttribute('fill-opacity', 0.4);
        }
      } else {
        elems.setAttribute('fill-opacity', 0.4);
      }
      if (this._tag_hasDefaultSelection) {
        defaultSelUtil.clearSelectionInfo(this._tag_wrap, false, elems);
      }
    };

    TagCloud.prototype.clear = function(gray) {
      if (gray === null || gray === false || gray === undefined) {
        var words = this._tag_wrap.selectAll('.v-datapoint');
        words.attr('fill-opacity', 1);
        this._tag_opacity = 1;
        if (this._tag_hasDefaultSelection) {
          defaultSelUtil.clearSelectionInfo(this._tag_wrap, false, words);
        }
      } else {
        this._tag_wrap.selectAll('.v-datapoint').attr('fill-opacity', 0.4);
      }
    };
      
    TagCloud.prototype.mouseover = function(elem){
        var item = d3.select(elem);
        var clickedItemID = item.attr('id');
        if(clickedItemID && this._tag_tooltipVisible){
          var tooltipData = this._tagfn_generateTooltipData(item.datum());
          var transform = this._tag_wrap.node().getTransformToElement(this._tag_wrap.node().ownerSVGElement);
          var svgRect = this._tag_wrap.node().ownerSVGElement.getBoundingClientRect();
          var itemRect = item.node().getBoundingClientRect(), wrapRect = this._tag_wrap.node().getBoundingClientRect();
          
          this._tag_decorativeShape.attr('width', itemRect.width).attr('height', itemRect.height).attr('x', itemRect.left - wrapRect.left).attr('y', itemRect.top - wrapRect.top).style('visibility', 'visible');
          tooltipData.point = {
            x: itemRect.left - svgRect.left + itemRect.width/2,
            y: itemRect.top - svgRect.top,
            height: itemRect.height
          };
          
          tooltipData.plotArea = {
            x : transform.e,
          y : transform.f,
          width : this._tag_width,
          height : this._tag_height
          };
          
          this._tag_eDispatch.showTooltip(tooltipDataHandler.formatTooltipData(tooltipData));
        }
    };
      
    TagCloud.prototype.mouseout = function(){
        this._tag_decorativeShape.attr('width', 0).attr('height', 0).attr('x', 0).attr('y', 0).style('visibility', 'hidden');
        if(this._tag_tooltipVisible){
          this._tag_eDispatch.hideTooltip();
        }
    };

    TagCloud.prototype.getDatapointsByRange = function(selectedData){
        var datapoints = this._tag_wrap.selectAll('.v-datapoint')[0], ctxDatapoints = [], ranges = selectedData.ctx.ranges, data;
        for(var i = 0, len = datapoints.length; i < len; i++){
          data = datapoints[i].__data__.wordFontFamily.val;
          if (NumberUtils.isNoValue(selectedData.val)) {
          if (NumberUtils.isNoValue(data)) {
            ctxDatapoints.push(datapoints[i]);
          }
        } else {
          if (data < ranges.endValue && data > ranges.startValue) {
            ctxDatapoints.push(datapoints[i]);
          } else {
            if (!ranges.isLeftOpen && data === ranges.startValue) {
              ctxDatapoints.push(datapoints[i]);
            } else if (!ranges.isRightOpen && data === ranges.endValue) {
              ctxDatapoints.push(datapoints[i]);
            }
          }
        }
        }
        return ctxDatapoints;
    };

    /////////////////////////previous internal functions////////////
    TagCloud.prototype._tagfn_enableAnimation = function(){
      var hasAnmation = false;
      if(this._tag_isDataLoading){
        hasAnmation = this._tag_options.animation.dataLoading;
      }else if(this._tag_isDatasetChanged){
        hasAnmation = this._tag_options.animation.dataUpdating;
      }else if(this._tag_isSizeChanged){
        hasAnmation = this._tag_options.animation.resizing;
      }
      return hasAnmation;
    };

      
      
      /**
       * interfaces for MBC legend selection
       * @param {Object} selectedData 
       * <pre>
       * {
       * ctx: {
       *   ranges: {
       *    endValue:100
       *    isLeftOpen:false
       *    isRightOpen:true
       *    startValue:84
       *   }
       * },
       * val: 84   
       * }
       * @returns {Array} d3 selections in the given range  
       */

    
    TagCloud.prototype._tagfn_isDatasetChanged = function(newData){
      var oldData = this._tag_chartData, isDatasetChanged = false;
      if(oldData.words && newData.words){
        if(oldData.words.rows.length !== newData.words.rows.length){
          isDatasetChanged = true;
        }else if((oldData.wordsFontFamily && !newData.wordsFontFamily) || (!oldData.wordsFontFamily && newData.wordsFontFamily)){
          isDatasetChanged = true;
        }else{
          var oldWords = oldData.words.rows, newWords = newData.words.rows;
          for(var i = 0, iLen = oldWords.length; i < iLen; i++){
            if(oldWords[i].val !== newWords[i].val){
              isDatasetChanged = true;
              break;
            }
          }
        }
      }
      return isDatasetChanged;
    };
      
    TagCloud.prototype._tagfn_parseOption = function() {
      if (this._tag_options.layout instanceof Object){
        this._tag_layoutMode = this._tag_options.layout.mode;
      } else {
        this._tag_layoutMode = this._tag_options.layout;
      }
      if (this._tag_layoutMode !== 'Row' && this._tag_layoutMode !== 'Column' && this._tag_layoutMode !== 'Wordle'){
        this._tag_layoutMode =  'Wordle';          
      }
      this._tag_textDirection = this._tag_options.layout.textDirection;
      if (this._tag_textDirection !== 'Mixed' && this._tag_textDirection !== 'Vertical' && this._tag_textDirection !== 'Horizontal'){
        this._tag_textDirection = 'Mixed';
      }
      this._tag_tooltipVisible = this._tag_options.tooltip.enabled;
      if (this._tag_fontColorScale) {
        this._tagfn_calculateFontFamily(this._tag_minFontFamily, this._tag_maxFontFamily, this._tag_hasNullValue);
      }
    };
    
    TagCloud.prototype._tagfn_filterData = function(){
      var labelsData = [], item;
      for(var i = 0, len = this._tag_tagArr.length; i < len; i++){
        item = this._tag_tagArr[i];
        if(!(NumberUtils.isNoValue(item.fontSize) || item.x === undefined || item.y === undefined || item.y > this._tag_height || item.x > this._tag_width)){
          //Hide this tag, remove it.
          labelsData.push(item);
        }
      }
      return labelsData;
    };
    
    TagCloud.prototype._tagfn_generateTooltipData = function(data){
        var tooltipData = {
            body: [],
            footer: []
        };
        
        if(this._tag_chartData.wordsSize){
          tooltipData.body.push({
            name: this._tag_chartData.wordsSize.col,
            val:[{
              value: this._tagfn_handleNullValue(data.wordSize.val)
            }]
          });
        }
        
        if(this._tag_chartData.wordsFontFamily){
          tooltipData.body.push({
            name:this._tag_chartData.wordsFontFamily.col,
            val:[{
              value: this._tagfn_handleNullValue(data.wordFontFamily.val)
            }]
          });
        }
        
        if(this._tag_chartData.words){
          tooltipData.footer.push({
            label: this._tag_chartData.words.col,
            value: data.word.val
          });
        }
        
        return tooltipData;
      };
        
    TagCloud.prototype._tagfn_parseData = function(data){
      this._tag_tagArr = [];
      var minFontSize, maxFontSize, fontfamilyValue, tagItem;
      this._tag_minFontFamily = undefined, this._tag_maxFontFamily = undefined, this._tag_hasNullValue = false;
      
      for(var i=0, len = data.words.rows.length; i < len; i++){
        if(data.words && data.words.rows[i].val && data.wordsSize && data.wordsSize.rows[0][i] && !NumberUtils.isNoValue(data.wordsSize.rows[0][i].val)){
          tagItem = {};
          tagItem.word = data.words.rows[i];
          tagItem.wordSize = (data.wordsSize ? data.wordsSize.rows[0][i] : undefined);
          tagItem.wordFontFamily = (data.wordsFontFamily ? data.wordsFontFamily.rows[0][i] : undefined);
          
          //For selection event data. We do not need to add dimension ctx.
          tagItem.val = [];//data.words.rows[i].val
          tagItem.ctx = [];
          tagItem.info = [];
        
          if(tagItem.wordSize){
            tagItem.val.push(data.wordsSize.rows[0][i].val);
            tagItem.ctx.push(data.wordsSize.rows[0][i].ctx);
            tagItem.info.push(data.wordsSize.rows[0][i].info);
            
            if(tagItem.wordSize.val !== null){
              if(minFontSize === undefined || tagItem.wordSize.val < minFontSize){
                minFontSize = tagItem.wordSize.val; 
              }
              if(maxFontSize === undefined || tagItem.wordSize.val > maxFontSize){
                maxFontSize = tagItem.wordSize.val; 
              }
            }
          }
          
          if(tagItem.wordFontFamily){
            tagItem.val.push(tagItem.wordFontFamily.val);
            tagItem.ctx.push(tagItem.wordFontFamily.ctx);
            tagItem.info.push(tagItem.wordFontFamily.info);
            
            fontfamilyValue = tagItem.wordFontFamily.val;
            
            if(fontfamilyValue === null){
              this._tag_hasNullValue = true;
            }else{
              if(this._tag_minFontFamily === undefined || fontfamilyValue < this._tag_minFontFamily){
                this._tag_minFontFamily = tagItem.wordFontFamily.val; 
              }
              if(this._tag_maxFontFamily === undefined || fontfamilyValue > this._tag_maxFontFamily){
                this._tag_maxFontFamily = tagItem.wordFontFamily.val; 
              }
            }
          }
          this._tag_tagArr.push(tagItem);
        }
      }
      
      //Linear font weight scale. Add more scale type here.
      this._tagfn_calculateFontSize(minFontSize, maxFontSize);
      if(data.wordsFontFamily){
        this._tagfn_calculateFontFamily(this._tag_minFontFamily, this._tag_maxFontFamily, this._tag_hasNullValue);
      }else{
        this._tag_fontColorScale = undefined;
      }
    };
    
    /*
     * Calculate font size by font-weight
     */
    TagCloud.prototype._tagfn_calculateFontSize = function(min, max){
      //Generate font size arguments
      var count = this._tag_tagArr.length;
      var a, b, fsize;
      
      if (min === 0){
              min = 1;
              max += 1;
          }
      
      if (count > 1) {
        b = (this._tag_maxfont - (this._tag_minfont * (max / min))) / (1 - (max / min));
        a = (this._tag_minfont - b) / min;
      } else {
        b = 0;
        a = this._tag_maxfont / (min < 0 ? -min : min);
      }
      
      for(var i=0, len = this._tag_tagArr.length; i < len; i++){
        //Set Font Size
        if(this._tag_tagArr[i].wordSize && min !== max){
          fsize = Math.round(a * this._tag_tagArr[i].wordSize.val + b);
        }else{
          fsize = this._tag_minfont;
        }
        this._tag_tagArr[i].fontSize = (this._tag_tagArr[i].wordSize.val === null) ? null : fsize;
      }
    };
    
    /*
     * Calculate font color family.
     */
    TagCloud.prototype._tagfn_calculateFontFamily = function(minVal, maxVal, hasNullValue){
      if(minVal === undefined && maxVal === undefined){
        this._tag_fontColorScale = d3.scale.ordinal().domain([[]]).range([TAGSTYLE.color]);
      }else{
        var scaleInfo = {
            numberOfTicks: 5, 
            startColor: this._tag_options.startColor, 
            endColor: this._tag_options.endColor
        };
        if(this._tag_options.colorPalette){
          scaleInfo.colorPalette = this._tag_options.colorPalette;
        }
        this._tag_fontColorScale = MeasureBasedColoring.getColorScale(minVal, maxVal, false, scaleInfo);
        
        if(hasNullValue){
          var domains = this._tag_fontColorScale.domain();
          var ranges = this._tag_fontColorScale.range();
          domains.push([]);
          ranges.push(TAGSTYLE.color);
        }
      }
    };
    
    TagCloud.prototype._tagfn_calculateTagPosition = function(){
      var layout;
      if(this._tag_layoutMode === 'Column'){
        layout = ColumnLayout();
      } else if(this._tag_layoutMode === 'Row'){
        layout = RowLayout();
      } else if(this._tag_layoutMode === 'Wordle'){
        layout = WordleLayout();
      }
      
      if(layout !== undefined){
        //TODO remove me
        var start = (new Date()).valueOf();
        layout.width(this._tag_width).height(this._tag_height).data(this._tag_tagArr).font(TAGSTYLE.fontfamily).textDirection(this._tag_textDirection).layout();
        var end = (new Date()).valueOf();
      }
    };
    
    TagCloud.prototype._tagfn_handleNullValue = function(value){
      return (value === null || value === undefined) ? DEFAULTSTRING : value;
    };

    TagCloud.prototype._tagfn_getCSSStyle = function(ctx) {
      this._tag_style.hoverline = ctx.styleManager.queryDefault(CSSCLASS_HOVERLINE);
    };

    TagCloud.prototype.destroy = function(){
        this._tag_chartData = null;
    };

	return TagCloud;
});
define('sap/viz/feeds/TagCloud',['sap/viz/feeds/Manifest','sap/viz/data/feed/Constants'],
function Setup(Manifest, constants) {
  var feeds = {
    id : "tagCloud",
    feeds : [ {
      'id' : 'tagName',
      'name' : 'IDS_TAGNAME',
      'type' : constants.Type.Dimension,
      'min' : 1,
      'max' : 1,
      'aaIndex' : 1,
      'acceptMND': -1,
      'maxStackedDims' : 1 
      
    }, {
      'id' : 'tagWeight',
      'name' : 'IDS_TAGWEIGHT',
      'type' : constants.Type.Measure,
      'min' : 1,
      'max' : 1,
      'mgIndex' : 1
    }, {
      'id' : 'tagFamily',
      'name' : 'IDS_TAGFAMILY',
      'type' : constants.Type.Measure,
      'min' : 0,
      'max' : 1,
      'mgIndex' : 2
    } ]
  };
  Manifest.register(feeds);
});
define('sap/viz/modules/manifests/TagCloud',['sap/viz/modules/manifests/Module','sap/viz/modules/Constants','sap/viz/modules/tagcloud','sap/viz/feeds/TagCloud'],
function Setup(Manifest, Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.tagcloud',
    'type' : Constants.Type.Chart,
    'name' : 'tagcloud',
    'properties' : {
      'layout':{
        'name' : 'layout',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'mode' : {
            'name' : 'mode',
            'supportedValueType' : 'String',
            'supportedValues' : [ 'Row', 'Column', 'Wordle' ],
            'defaultValue' : 'Wordle',
            'description' : 'Set layout mode of tag cloud.'
          },
          'textDirection':{
            'name' : 'textDirection',
            'supportedValueType' : 'String',
            'supportedValues' : [ 'Mixed', 'Vertical', 'Horizontal' ],
            'defaultValue' : 'Mixed',
            'description' : 'Set text direction of tagcloud. Only taking effect when layout mode is set to \'Wordle\'.'        
          }
        },
        'description' : 'Settings for layout options of tagcloud.'
      },
      'animation' : {
          'name' : 'animation',
          'supportedValueType' : 'Object',
          'supportedValues' : {
            'dataLoading' : {
              'name' : 'dataLoading',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enable/disable data loading animation of plot area.'
            },
            'dataUpdating' : {
              'name' : 'dataUpdating',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enable/disable data updating animation of plot area.'
            },
            'resizing' : {
              'name' : 'resizing',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enable/disable resizing animation of plot area.'
            }
          },
          'description' : 'Settings for animation of plot area.',
          'example': "<a href='"+Constants.DocExample.SnippetUrl+"8535' target='_blank'>"+Constants.DocExample.TryThisValue+"</a>"
        },
      'startColor' : {
          'name' : 'startColor',
          'supportedValueType' : 'String',
          'defaultValue' : "#C2E3A9",
          'description' : 'Set tagCloud start color.'
        },
        'endColor' : {
          'name' : 'endColor',
          'supportedValueType' : 'String',
          'defaultValue' : "#73C03C",
          'description' : 'Set tagCloud endcolor.'
        },
        'colorPalette' : {
          'name' : 'colorPalette',
          'supportedValueType' : 'StringArray',
          'defaultValue' : undefined,
          'description' : 'Set the color palette for sectors. For example, ["#748CB2","#9CC677","#EACF5E","#F9AD79","#D16A7C"].'
        },
        'tooltip' : {
          'name' : 'tooltip',
          'supportedValueType' : 'Object',
          'supportedValues' : {
            'enabled' : {
              'name' : 'enabled',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enabled/disabled tooltip.'
            }
          },
          'isExported' : false,
          'description' : 'Settings for tooltip related properties.'
        }
    },
    'events' : {
      'initialized': Constants.Event.Initialized.desc,
        'selectData' : Constants.Event.SelectData.desc,
        'deselectData' : Constants.Event.DeSelectData.desc,
        'showTooltip' : Constants.Event.TooltipShow.desc,
        'hideTooltip' : Constants.Event.TooltipHide.desc

    },
    'feeds' : {
      id : "tagCloud"
    },
    'css' : {
        '.v-hovershadow' : {
            'description' : 'Define style for hover shadow color.',
            'value' : {
                'fill' : '#cccccc',
            }
        }
    },
    'configure' : null,
    fn : fn
  };
  Manifest.register(module);
});
define('sap/viz/manifests/TagCloudChart',['sap/viz/manifests/Viz','sap/viz/modules/Constants','sap/viz/modules/manifests/RootContainer',
'sap/viz/manifests/BaseSingleChart','sap/viz/modules/manifests/Tooltip','sap/viz/modules/manifests/TagCloud'],
function Setup(Manifest, Constants) {
  var chart = {
    id : 'viz/tagcloud',
    name : 'IDS_TAGCLOUDCHART',
    base : 'riv/base/single',
    modules : {
      root : {
        configure : {
          properties : {
            layout : { adjustPolicy : Constants.LAYOUT_ADJUST_POLICY.RELAYOUT }
          }
        },
        modules : {
          legends : {
            modules : {
            layout : {
              id : 'sap.viz.modules.layout.stack'
            },
              legend : {
                feeds : [],
                configure : {
                  'description': 'The measure based coloring legend is a bar containing segments with different colors and a value scale on side to indicate the relationship between the values and colors in the chart. ',
                  properties : {
                    type : 'MeasureBasedColoringLegend',
					layout:{
						position: 'right',
						priotity: 1
					}
                  },
                  propertiesOverride : {
                    isHierarchical : {
                      isExported : false
                    },
                    isScrollable :  { isExported: false },
                    formatString: {
                      isExported: true
                    }
                  }
                }
              }
            }
          },
          tooltip : {
              id : 'sap.viz.modules.tooltip',
              configure : {
                propertyCategory : 'tooltip',
                properties : {
                  chartType : 'tagcloud',
                  orientation : 'bottom'
                }
              }
            },
        
          interaction : {
            id : 'sap.viz.modules.controller.interaction',
            configure : {
              clientID : "main",
              propertyCategory : 'interaction',
                properties : {
                  supportedEventNames: ['mouseup', 'mouseover', 'mouseout', 'touchstart']
                }
             }
           },
        
          main : {
            modules : {
              dataLabel:null,
              plot : {
                id : 'sap.viz.modules.tagcloud',
                configure : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory : 'plotArea'
                }
              }
            }
          }
        }
      }
    },
    dependencies : {
      attributes : [ {
        targetModule : 'root.legends.legend',
        target : 'mbcLegendInfo',
        sourceModule : 'root.main.plot',
        source : 'mbcLegendInfo'
      }, {
          targetModule : 'root.legends.legend',
          target : 'setSelectionMode',
          sourceModule : 'root.interaction',
          source : 'getSelectionMode'
      } ],
      events : [ {
        targetModule : 'root.interaction',
        listener : 'registerEvent',
        sourceModule : 'root.main.plot',
        type : 'initialized.interaction'
      },  {
          targetModule : 'root.interaction',
          listener : 'highlightedByLegend',
          sourceModule : 'root.legends.legend',
          type : 'highlightedByLegend'
      }, {
              targetModule : 'root.legends.legend',
            listener : 'deselectLegend',
            sourceModule : 'root.interaction',
            type : 'deselectLegend'
      }, {
        targetModule : 'root.tooltip',
        listener : 'showTooltip',
        sourceModule : 'root.main.plot',
        type : 'showTooltip'
      }, {
        targetModule : 'root.tooltip',
        listener : 'hideTooltip',
        sourceModule : 'root.main.plot',
        type : 'hideTooltip'
      }, {
        targetModule : 'root.interaction',
        listener : 'defaultSelection',
        sourceModule : 'root.main.plot',
        type : 'initialized.defaultSelection'
      } ]
    }
  };
  Manifest.register(chart);
});
define('sap/viz/modules/network/graph',[],
    function (){
  function Graph(){
    this.nodes = [];//node:{key:'..', x:'..', y:'..'}
    this.links = [];//link:{source:'{node index}', target:'{node index}', width:'..'}
    this.nodesMap = {};
    this.linksMap = [];
  }
  
  Graph.prototype.clear = function (){
    this.nodes = [];
    this.links = [];
    this.nodesMap = {};
  };
  
  Graph.prototype.addNode = function (node){
    var key = node.key;
    var index;
    if (! this.isNoValue(key) && ! this.hasNode(key)){
      //add ctx for selectData event
      node.val = node.key;
      this.nodes.push(node);
      index = (this.nodesMap[key] = this.nodes.length - 1);
      this.linksMap[index] = [];
    }
    return this;
  };
  
  Graph.prototype.addLink = function (key1,key2){
    var nodesMap = this.nodesMap;
    var index1 = nodesMap[key1], index2 = nodesMap[key2];
    if (! this.isNoValue(key1) && ! this.isNoValue(key2) && 
         key1 !== key2 && ! this.hasLink(index1, index2)){
      this.links.push({source: index1, target: index2});
      this.setLinksMap(index1, index2);
    }
    return this;
  };
  
  Graph.prototype.getRelatedNodes = function (index){
    return this.linksMap[index];
  };

  Graph.prototype.hasNode = function (key){
    return this.nodesMap[key] !== undefined;
  };
  
  Graph.prototype.hasLink = function (index1, index2){
    return this.linksMap[index1].indexOf(index2) > -1;

  };
  
  Graph.prototype.setLinksMap = function (index1, index2){
    this.linksMap[index1].push(index2);
    this.linksMap[index2].push(index1);   
  };
  
  Graph.prototype.isNoValue = function (val){
    return val === null || val === undefined;
  };
  
  return Graph;
});
define('sap/viz/modules/network/basicLayout',["sap/viz/util/NumberUtils","sap/viz/base/utils/TypeUtils"], function(NumberUtils, TypeUtils) {

  var layout = function() {
    this._width = 0;
    this._height = 0;
    this._radius = 0;
    this._graph = null;
    
    this._maxCount = 100;
    
    this._alpha = 0.1;
    this._linkDistance = 20;
    this._linkStrength = 1;
    this._charge = -30;
    this._distances = null;
    this._strengths = null;
    this._charges = null;
    this._gravity = 0.1;
    this._friction = 0.9;
    this._theta = 0.8;

    this._tickfn = null;
  };

  layout.prototype.width = function(_) {
    if (!arguments.length) {
      return this._width;
    }
    this._width = _;
    return this;
  };

  layout.prototype.height = function(_) {
    if (!arguments.length) {
      return this._height;
    }
    this._height = _;
    return this;
  };

  layout.prototype.radius = function(_) {
    if (!arguments.length) {
      return this._radius;
    }
    this._radius = _;
    return this;
  };

  layout.prototype.graph = function(_) {
    if (!arguments.length) {
      return this._graph;
    }
    this._graph = _;
    return this;
  };

  layout.prototype.maxCount = function(_) {
    if (!arguments.length) {
      return this._maxCount;
    }
    this._maxCount = _;
    return this;
  };

  layout.prototype.tickfn = function (_){
    if (!arguments.length) {
      return this._tickfn;
    }
    this._tickfn = _;
    return this;
  };
  
  layout.prototype.alpha = function (_){
    if (!arguments.length) {
      return this._alpha;
    }
    var alpha = this._alpha;
    this._alpha = _;
    if (! alpha){
      d3.timer(this._tick());
    }
    return this;
  };
  
  layout.prototype.calculate = function() {

    this._setCoefficient();

    this._prepare();

    this._d3ForceDirectedPlacement();

  };
  
  layout.prototype.resume = function (){
    this.alpha(0.1);
  };
  
  layout.prototype.stop = function (){
    this.alpha(0);
  };
  
  layout.prototype.destroy = function (){
    this._graph.clear();
    this._graph = null;
    this._tickfn = null;
    this._distances = null;
    this._strengths = null;
    this._charges = null;
  };
  
  layout.prototype._tick = function (){
    var that = this;
    return function (){
      var alpha = that._alpha;
      if ((alpha *= 0.99) < 0.005 || !that._graph) {
        that._alpha = 0;
        return true;
      }    
      that._alpha = alpha;
      var nodes = that._graph.nodes,
        links = that._graph.links,
        charge = that._charge,
        distances = that._distances,
        strengths = that._strengths,
        charges = that._charges,
        gravity = that._gravity,
        friction = that._friction,
        n = nodes.length,
        m = links.length,
        w = that._width,
        h = that._height,
        r = that._radius,
        q,
        i, // current index
        o, // current object
        s, // current source
        t, // current target
        l, // current distance
        k, // current force
        x, // x-distance
        y; // y-distance

      // gauss-seidel relaxation for links
      for (i = 0; i < m; ++i) {
        o = links[i];
        s = o.source;
        t = o.target;
        x = t.px - s.px;
        y = t.py - s.py;
        l = (x * x + y * y);
        if (l) {
          l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
          x *= l;
          y *= l;
          t.x -= x * (k = s.weight / (t.weight + s.weight));
          t.y -= y * k;
          s.x += x * (k = 1 - k);
          s.y += y * k;
        }
      }
      k = alpha * gravity;
      // apply gravity forces
      if (k) {
        x = w / 2;
        y = h / 2;
        i = -1;
        if (k) {
          while (++i < n) {
            o = nodes[i];
            o.x += (x - o.x) * k;
            o.y += (y - o.y) * k;
          }
        }
      }

      // compute quadtree center of mass and apply charge forces
      if (charge) {
        that._forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
        i = -1;
        while (++i < n) {
          if (!(o = nodes[i]).fixed) {
            q.visit(that._repulse(o));
          }
        }
      }

      // position verlet integration
      i = -1;
      while (++i < n) {
        o = nodes[i];
        if (o.fixed) {
          o.x = o.px;
          o.y = o.py;
        } else {
          o.x -= (o.px - (o.px = o.x)) * friction;
          o.y -= (o.py - (o.py = o.y)) * friction;
        }
        if (o.onDrag){
          o.x = o.eventX;
          o.y = o.eventY;
        }
        o.x = Math.max(r, Math.min(w - r, o.x));
        o.y = Math.max(r, Math.min(h - r, o.y));
      }
      if (TypeUtils.isFunction(that._tickfn)){
        that._tickfn();
      }
    };
  };

  layout.prototype._setNodes = function() {
    var nodes = this._graph.nodes;
    for (var i = 0, len = nodes.length; i < len; ++i) {
      nodes[i].x = this._xs[i];
      nodes[i].y = this._ys[i];
    }
  };

  /*jshint bitwise:false */
  layout.prototype._jsHash = function(str) {
    var hash = 1315423911;
    for (var i = 0; i < str.length; i++) {

      hash ^= ((hash << 5) + str.charCodeAt(i) + (hash >> 2));
    }
    return hash;
  };

  /*jshint bitwise:false */
  layout.prototype._rsHash = function(str) {
    var b = 378551;
    var a = 63689;
    var hash = 0;

    for (var i = 0; i < str.length; i++) {
      hash = hash * a + str.charCodeAt(i);
      a *= b;
      hash = hash % 0xFFFFFFFF;
    }

    return hash & 0x7FFFFFFF;
  };
  layout.prototype._randomStr = function(str, hash) {
    var value = 0;
    switch (hash) {
      case 'x':
        value = this._jsHash(str);
        break;
      case 'y':
        value = this._rsHash(str);
        break;
    }
    var constValue = 107;
    return Math.abs((value % constValue) / constValue);
  };

  layout.prototype._setCoefficient = function() {
    var width = this._width,
      height = this._height,
      length = this._graph.nodes.length;
    var linkDistance = Math.sqrt(width * height / length);
    this._linkDistance = linkDistance;
    var charge = -30 * Math.min(width, height) / length;
    this._charge = charge;
  };

  layout.prototype._prepare = function() {
    var nodes = this._graph.nodes,
      links = this._graph.links,
      linkDistance = this._linkDistance,
      linkStrength = this._linkStrength,
      charge = this._charge,
      i,
      n = nodes.length,
      m = links.length,
      w = this._width,
      h = this._height,
      o;
    
    for (i = 0; i < n; ++i) {
      (o = nodes[i]).index = i;
      o.weight = 0;
    }

    for (i = 0; i < m; ++i) {
      o = links[i];
      if (typeof o.source === "number") {
        o.source = nodes[o.source];
      }
      if (typeof o.target === "number") {
        o.target = nodes[o.target];
      }
      ++o.source.weight;
      ++o.target.weight;
    }

    for (i = 0; i < n; ++i) {
      o = nodes[i];
      if (isNaN(o.x)) {
        o.x = this._randomStr(o.key, "x") * w;
      }
      if (isNaN(o.y)) {
        o.y = this._randomStr(o.key, "y") * h;
      }
      if (isNaN(o.px)) {
        o.px = o.x;
      }
      if (isNaN(o.py)) {
        o.py = o.y;
      }
    }

    this._distances = [];
    var distances = this._distances;
    for (i = 0; i < m; ++i) {
      distances[i] = linkDistance;
    }

    this._strengths = [];
    var strengths = this._strengths;
    for (i = 0; i < m; ++i) {
      strengths[i] = linkStrength;
    }

    this._charges = [];
    var charges = this._charges;
    for (i = 0; i < n; ++i) {
      charges[i] = charge;
    }
    this._alpha = 0.1;
  };

  layout.prototype._d3ForceDirectedPlacement = function() {
    var alpha = this._alpha;
    var count = -1, maxCount = this._maxCount;
    while ((alpha *= 0.99) > 0.005 && ++count < maxCount) {
      var nodes = this._graph.nodes,
        links = this._graph.links,
        charge = this._charge,
        distances = this._distances,
        strengths = this._strengths,
        charges = this._charges,
        gravity = this._gravity,
        friction = this._friction,
        n = nodes.length,
        m = links.length,
        w = this._width,
        h = this._height,
        r = this._radius,
        q,
        i, // current index
        o, // current object
        s, // current source
        t, // current target
        l, // current distance
        k, // current force
        x, // x-distance
        y; // y-distance

      // gauss-seidel relaxation for links
      for (i = 0; i < m; ++i) {
        o = links[i];
        s = o.source;
        t = o.target;
        x = t.px - s.px;
        y = t.py - s.py;
        l = (x * x + y * y);
        if (l) {
          l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
          x *= l;
          y *= l;
          t.x -= x * (k = s.weight / (t.weight + s.weight));
          t.y -= y * k;
          s.x += x * (k = 1 - k);
          s.y += y * k;
        }
      }
      k = alpha * gravity;
      // apply gravity forces
      if (k) {
        x = w / 2;
        y = h / 2;
        i = -1;
        if (k) {
          while (++i < n) {
            o = nodes[i];
            o.x += (x - o.x) * k;
            o.y += (y - o.y) * k;
          }
        }
      }

      // compute quadtree center of mass and apply charge forces
      if (charge) {
        this._forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
        i = -1;
        while (++i < n) {
          if (!(o = nodes[i]).fixed) {
            q.visit(this._repulse(o));
          }
        }
      }

      // position verlet integration
      i = -1;
      while (++i < n) {
        o = nodes[i];
        if (o.fixed) {
          o.x = o.px;
          o.y = o.py;
        } else {
          o.x -= (o.px - (o.px = o.x)) * friction;
          o.y -= (o.py - (o.py = o.y)) * friction;
        }
        o.x = Math.max(r, Math.min(w - r, o.x));
        o.y = Math.max(r, Math.min(h - r, o.y));
      }
    }
    this._alpha = 0;
  };

  layout.prototype._repulse = function(node) {
    var theta = this._theta;
    return function(quad, x1, _, x2) {
      if (quad.point !== node) {
        var dx = quad.cx - node.x,
          dy = quad.cy - node.y,
          dn = 1 / Math.sqrt(dx * dx + dy * dy),
          k;

        /* Barnes-Hut criterion. */
        if ((x2 - x1) * dn < theta) {
          k = quad.charge * dn * dn;
          node.px -= dx * k;
          node.py -= dy * k;
          return true;
        }

        if (quad.point && isFinite(dn)) {
          k = quad.pointCharge * dn * dn;
          node.px -= dx * k;
          node.py -= dy * k;
        }
      }
      return !quad.charge;
    };
  };

  layout.prototype._forceAccumulate = function(quad, alpha, charges) {
    var cx = 0,
      cy = 0;
    quad.charge = 0;
    if (!quad.leaf) {
      var nodes = quad.nodes,
        n = nodes.length,
        i = -1,
        c;
      while (++i < n) {
        c = nodes[i];
        if (c === null || c === undefined) {
          continue;
        }
        this._forceAccumulate(c, alpha, charges);
        quad.charge += c.charge;
        cx += c.charge * c.cx;
        cy += c.charge * c.cy;
      }
    }
    if (quad.point) {
      // jitter internal nodes that are coincident
      if (!quad.leaf) {
        quad.point.x += this._randomStr(quad.point.key, "y") - 0.5;
        quad.point.y += this._randomStr(quad.point.key, "x") - 0.5;
      }
      var k = alpha * charges[quad.point.index];
      quad.charge += quad.pointCharge = k;
      cx += k * quad.point.x;
      cy += k * quad.point.y;
    }
    quad.cx = cx / quad.charge;
    quad.cy = cy / quad.charge;
  };

  return layout;
});
define('sap/viz/modules/network',["sap/viz/modules/Constants", "sap/viz/base/utils/oo", "sap/viz/modules/Base",
    "sap/viz/modules/util/BoundUtil", "sap/viz/base/utils/Objects", "sap/viz/modules/dispatch",
    "sap/viz/modules/network/graph", "sap/viz/modules/network/basicLayout", "sap/viz/util/ColorSeriesGenerator", 
    "sap/viz/base/utils/ObjectUtils", "sap/viz/modules/util/ClippathUtil"],
  function(Constants, oo, Base, BoundUtil, Objects, dispatch, Graph, layout, ColorSeriesGenerator, ObjectUtils, ClippathUtil) {

    var CLASS_NETWORK_NODE = "v-network-node";
    var CLASS_NETWORK_LINE = "v-network-line";
    var CLASS_DATAPOINT = Constants.CSS.CLASS.DATAPOINT;
    var CLASS_DATAPOINT_DEFAULT = Constants.CSS.CLASS.DATAPOINTDEFAULT;
    var CLASS_DATAPOINT_SELECTED = Constants.CSS.CLASS.DATAPOINTSELECTED;

    var DRAWING_STYLE = {
      NORMAL: "basic",
      ENHANCED: "enhanced"
    };

    var GRAPHIC_FILTER_ID = ObjectUtils.guid() + "-potShadow";

    var NETWORK_STYLE_BASIC = {
      MARKER_COLOR_DEFAULT: "#FFFFFF",
      MARKER_COLOR_SELECTED: ColorSeriesGenerator.sap32().range()[0],
      MARKER_COLOR_UNSELECTED: "#FFFFFF",
      MARKER_OUTLINE_COLOR_DEFAULT: "#000000",
      MARKER_OUTLINE_COLOR_SELECTED: "#000000",
      MARKER_OUTLINE_COLOR_UNSELECTED: "#D8D8D8",
      MARKER_OUTLINE_WIDTH_DEFAULT: 1,
      MARKER_OUTLINE_WIDTH_SELECTED: 2,
      MARKER_OUTLINE_WIDTH_UNSELECTED: 1,
      MARKER_RADIUS: 5,
      LABEL_COLOR_DEFAULT: "#000000",
      LABEL_COLOR_SELECTED: "#000000",
      LABEL_COLOR_UNSELECTED: "#D8D8D8",
      LABEL_FONT: "12px 'Open Sans', Arial, Helvetica, sans-serif",
      LABEL_OFFSET_X_DEFAULT: 12,
      LABEL_OFFSET_X_SELECTED: 13,
      LABEL_OFFSET_X_UNSELECTED: 12,
      LABEL_OFFSET_Y: 6,
      LINE_COLOR_DEFAULT: "#D8D8D8",
      LINE_COLOR_SELECTED: "#000000",
      LINE_COLOR_UNSELECTED: "#D8D8D8",
      LINE_WIDTH: "1px",
      OPACITY_DEFAULT: 1,
      OPACITY_UNSELECTED: 0.4
    };

    var NETWORK_STYLE_ENHANCED = {
      MARKER_COLOR_DEFAULT: "#D12318",
      MARKER_COLOR_SELECTED: "#D12318",
      MARKER_COLOR_UNSELECTED: "#EC9A99",
      MARKER_OUTLINE_COLOR_DEFAULT: "#FFFFFF",
      MARKER_OUTLINE_COLOR_SELECTED: "#000000",
      MARKER_OUTLINE_COLOR_UNSELECTED: "#FFFFFF",
      MARKER_OUTLINE_WIDTH_DEFAULT: 2,
      MARKER_OUTLINE_WIDTH_SELECTED: 2,
      MARKER_OUTLINE_WIDTH_UNSELECTED: 2,
      MARKER_RADIUS: 4,
      LABEL_COLOR_DEFAULT: "#000000",
      LABEL_COLOR_SELECTED: "#000000",
      LABEL_COLOR_UNSELECTED: "#999999",
      LABEL_FONT: "12px 'Open Sans', Arial, Helvetica, sans-serif",
      LABEL_OFFSET_X_DEFAULT: 12,
      LABEL_OFFSET_X_SELECTED: 12,
      LABEL_OFFSET_X_UNSELECTED: 12,
      LABEL_OFFSET_Y: 6,
      LINE_COLOR_DEFAULT: "#999999",
      LINE_COLOR_SELECTED: "#000000",
      LINE_COLOR_UNSELECTED: "#999999",
      LINE_WIDTH: "1px",
      OPACITY_DEFAULT: 1,
      OPACITY_UNSELECTED: 0.4
    };


    var Network = function(manifest, ctx) {
      Network.superclass.constructor.apply(this, arguments);

      this._ntk_width = 0;
      this._ntk_height = 0;
      this._ntk_properties = manifest.props(null);
      this._ntkfn_parseProperties();
      this._ntk_data = null;
      this._ntk_dispatch = new dispatch("initialized");
      this._ntk_effectManager = ctx.effectManager;
      
      this._ntk_graph = new Graph();
      this._ntk_layout = new layout();

      this._ntk_parent = null;
      this._ntk_nodesWrapper = null;
      this._ntk_linesWrapper = null;
      this._ntk_defs = null;

      this._ntk_isFirstCreation = true;
      this._ntk_isSizeChanged = false;
      this._ntk_isDatasetChanged = false;
      this._ntk_isDataSchemaChanged = false;
      this._ntk_isPropertiesChanged = false;
    };

    oo.extend(Network, Base);

    Network.prototype.render = function(selection) {
      var width = this._ntk_width,
        height = this._ntk_height;
      BoundUtil.drawBound(selection, width, height);
      var clippathid = ClippathUtil.drawClippath(selection, width, height);
      selection.attr('clip-path', "url(#"+ clippathid + ")");
      this._ntk_parent = selection;

      this._ntkfn_renderChart();
      this._ntk_isFirstCreation = false;
      this._ntk_isSizeChanged = false;
      this._ntk_isDatasetChanged = false;
      this._ntk_isDataSchemaChanged = false;
      this._ntk_isPropertiesChanged = false;
      return this;
    };

    Network.prototype.properties = function(_) {
      if (!arguments.length) {
        return this._ntk_properties;
      }
      this._ntk_isPropertiesChanged = true;
      Objects.extend(true, this._ntk_properties, _);
      this._ntkfn_parseProperties();
      return this;
    };

    Network.prototype.parent = function(_) {
      if (!arguments.length) {
        return this._ntk_parent;
      }
      this._ntk_parent = _;
      return this;
    };

    Network.prototype.width = function(_) {
      if (!arguments.length) {
        return this._ntk_width;
      }
      this._ntk_isSizeChanged = (this._ntk_width === _) && !this._ntk_isSizeChanged ? false : true;
      this._ntk_width = _;
      return this;
    };

    Network.prototype.height = function(_) {
      if (!arguments.length) {
        return this._ntk_height;
      }
      this._ntk_isSizeChanged = (this._ntk_height === _) && !this._ntk_isSizeChanged ? false : true;
      this._ntk_height = _;
      return this;
    };

    Network.prototype.data = function(_) {
      if (!arguments.length) {
        return this._ntk_data;
      }
      this._ntk_isDatasetChanged = true;
      this._ntk_data = _;
      this._ntkfn_parseData();
      return this;
    };

    Network.prototype.dispatch = function(_) {
      if (!arguments.length) {
        return this._ntk_dispatch;
      }
      this._ntk_dispatch = _;
      return this;
    };

    Network.prototype.highlight = function(elem) {
      this.clear(true);
      if (elem instanceof Array) {
        return;
      } else {
        var networkStyle = this._ntk_styleDef;
        var node = d3.select(elem);
        node.select("circle")
          .attr("fill", networkStyle.MARKER_COLOR_SELECTED)
          .attr("stroke", networkStyle.MARKER_OUTLINE_COLOR_SELECTED)
          .attr("stroke-width", networkStyle.MARKER_OUTLINE_WIDTH_SELECTED);
        node.select("text")
          .attr("dx", networkStyle.LABEL_OFFSET_X_SELECTED)
          .style("fill", networkStyle.LABEL_COLOR_SELECTED);
        node.classed(CLASS_DATAPOINT_DEFAULT, false);
        node.classed(CLASS_DATAPOINT_SELECTED, true);
        var nodeClass = node.attr("class");
        var index = this._ntkfn_getIndexFromClass(nodeClass);
        this._ntk_parent.selectAll("." + CLASS_NETWORK_LINE + ".NODE_" + index)
          .attr("stroke", networkStyle.LINE_COLOR_SELECTED);
        var neighbors = this._ntk_graph.getRelatedNodes(index);
        for (var i = 0, len = neighbors.length; i < len; ++i) {
          var neighbor = this._ntk_parent.selectAll("." + CLASS_NETWORK_NODE + ".NODE_" + neighbors[i]);
          neighbor.select("circle")
            .attr("fill", networkStyle.MARKER_COLOR_DEFAULT)
            .attr("stroke", networkStyle.MARKER_OUTLINE_COLOR_DEFAULT)
            .attr("stroke-width", networkStyle.MARKER_OUTLINE_WIDTH_DEFAULT);
          neighbor.select("text")
            .attr("dx", networkStyle.LABEL_OFFSET_X_DEFAULT)
            .style("fill", networkStyle.LABEL_COLOR_DEFAULT);     
        }
      }
    };

    Network.prototype.unhighlight = function(elem) {
      this.clear();
    };

    Network.prototype.clear = function(gray) {
      var networkStyle = this._ntk_styleDef;
      if (gray) {
        this._ntk_linesWrapper.attr("stroke", networkStyle.LINE_COLOR_UNSELECTED);
        this._ntk_nodesWrapper.select("circle")
          .attr("fill", networkStyle.MARKER_COLOR_UNSELECTED)
          .attr("stroke", networkStyle.MARKER_OUTLINE_COLOR_UNSELECTED)
          .attr("stroke-width", networkStyle.MARKER_OUTLINE_WIDTH_UNSELECTED);
        this._ntk_nodesWrapper.select("text")
          .attr("dx", networkStyle.LABEL_OFFSET_X_UNSELECTED)
          .style("fill", networkStyle.LABEL_COLOR_UNSELECTED);
      } else {
        this._ntk_linesWrapper.attr("stroke", networkStyle.LINE_COLOR_DEFAULT);
        this._ntk_nodesWrapper.select("circle")
          .attr("fill", networkStyle.MARKER_COLOR_DEFAULT)
          .attr("stroke", networkStyle.MARKER_OUTLINE_COLOR_DEFAULT)
          .attr("stroke-width", networkStyle.MARKER_OUTLINE_WIDTH_DEFAULT);
        this._ntk_nodesWrapper.select("text")
          .attr("dx", networkStyle.LABEL_OFFSET_X_DEFAULT)
          .style("fill", networkStyle.LABEL_COLOR_DEFAULT);     
      }
    };

    Network.prototype.destroy = function() {
      this._ntk_parent = null;
      this._ntk_nodesWrapper = null;
      this._ntk_linesWrapper = null;
      this._ntk_graph.clear();
      this._ntk_graph = null;
      this._ntk_layout.destroy();
      this._ntk_layout = null;
      this._ntk_defs = null;
      if(this._ntk_effectManager && this._ntk_effectManager.destroy){
        this._ntk_effectManager.destroy();
      }
    };

    Network.prototype._ntkfn_renderChart = function() {
      var gPlot = this._ntk_parent;
      var that = this;

      if (this._ntk_isFirstCreation || this._ntk_isDatasetChanged || this._ntk_isPropertiesChanged) {
        gPlot.selectAll('.' + CLASS_NETWORK_NODE).remove();
        gPlot.selectAll('.' + CLASS_NETWORK_LINE).remove();
        if (this._ntk_isEnhancedStyle && !this._ntk_defs){
          this._ntkfn_createGraphicFilter();
        } else if (!this._ntk_isEnhancedStyle && this._ntk_defs){
          gPlot.select("defs").remove();
          this._ntk_defs = null;
        }
        if (this._ntk_isFirstCreation || this._ntk_isDatasetChanged){
          this._ntkfn_layout(50);
        }
      } else if (this._ntk_isSizeChanged) {
        this._ntk_layout.stop();
        this._ntkfn_layout(10);
      }
      var networkStyle = this._ntk_styleDef;

      var lines =
        (this._ntk_linesWrapper = gPlot.selectAll('.' + CLASS_NETWORK_LINE).data(this._ntk_graph.links));
      lines.enter().append("line");
      lines.exit().remove();

      lines.each(function(d) {
        var position = that._ntkfn_calculateLinePosition(d.source.x, d.source.y, d.target.x, d.target.y);
        if (that._ntk_isFirstCreation || that._ntk_isDatasetChanged || that._ntk_isPropertiesChanged) {
          d3.select(this)
            .attr("x1", position.x1)
            .attr("y1", position.y1)
            .attr("x2", position.x2)
            .attr("y2", position.y2)
            .attr("opacity", networkStyle.OPACITY_DEFAULT)
            .attr("class", CLASS_NETWORK_LINE + " NODE_" + d.source.index + " NODE_" + d.target.index)
            .attr("stroke", that._ntkfn_getEffectColor(networkStyle.LINE_COLOR_DEFAULT))
            .attr("stroke-width", networkStyle.LINE_WIDTH_DEFAULT);
        } else if (that._ntk_isSizeChanged) {
          d3.select(this).transition().duration(500)
            .attr("x1", position.x1)
            .attr("y1", position.y1)
            .attr("x2", position.x2)
            .attr("y2", position.y2);
        }
      });

      var nodes =
        (this._ntk_nodesWrapper = gPlot.selectAll('.' + CLASS_NETWORK_NODE).data(this._ntk_graph.nodes));

      nodes.enter().append("g");
      nodes.exit().remove();
      if (this._ntk_isRelayoutWhenDragging){
        this._ntk_layout.tickfn(function (){
          lines.each(function(d) {
            var position = that._ntkfn_calculateLinePosition(d.source.x, d.source.y, d.target.x, d.target.y);
            d3.select(this)
              .attr("x1", position.x1)
              .attr("y1", position.y1)
              .attr("x2", position.x2)
              .attr("y2", position.y2);
          });
          nodes.attr("transform", function (d){return "translate(" + d.x + ", " + d.y + ")";});
        });
      } else {
        this._ntk_layout.tickfn(null);
      }
      nodes.each(function(d) {

        var node = d3.select(this);

        var dragmove, dragend;
        
        if (that._ntk_isRelayoutWhenDragging){
          dragmove = function (d){
            d.x = d3.event.x;
            d.y = d3.event.y;
            d.eventX = d3.event.x;
            d.eventY = d3.event.y;
            d.onDrag = true;
            that._ntk_layout.resume();
          };          
          dragend = function (d){
            d.onDrag = false;
          };
        } else {
          dragmove = function (d) {
            var r = networkStyle.MARKER_RADIUS;
            d.x = Math.max(r, Math.min(that._ntk_width - r, d3.event.x));
            d.y = Math.max(r, Math.min(that._ntk_height - r, d3.event.y));
            lines.each(function(d) {
              var position = that._ntkfn_calculateLinePosition(d.source.x, d.source.y, d.target.x, d.target.y);
              d3.select(this)
                .attr("x1", position.x1)
                .attr("y1", position.y1)
                .attr("x2", position.x2)
                .attr("y2", position.y2);
            });
            node.attr("transform", "translate(" + d.x + ", " + d.y + ")");
          };

          dragend = function (d) {
            d.x = d.originX;
            d.y = d.originY;
            lines.each(function(d) {
              var position = that._ntkfn_calculateLinePosition(d.source.x, d.source.y, d.target.x, d.target.y);
              d3.select(this).transition().duration(500).ease("elastic")
                .attr("x1", position.x1)
                .attr("y1", position.y1)
                .attr("x2", position.x2)
                .attr("y2", position.y2);
            });
            node.transition().duration(500).ease("elastic")
              .attr("transform", "translate(" + d.x + ", " + d.y + ")");

          };
        }

        var drag = d3.behavior.drag()
          .origin(d3.functor(d))
          .on("drag", dragmove)
          .on("dragend", dragend);

        d.originX = d.x;
        d.originY = d.y;

        if (that._ntk_isFirstCreation || that._ntk_isDatasetChanged || that._ntk_isPropertiesChanged) {
          node.attr("transform", "translate(" + d.x + ", " + d.y + ")")
            .attr("class", CLASS_NETWORK_NODE + " NODE_" + d.index + " " + CLASS_DATAPOINT + " " + CLASS_DATAPOINT_DEFAULT);
            
          if (that._ntk_isDraggable){
            node.call(drag);
          }

          var circle = node.append("circle").attr("cx", 0).attr("cy", 0)
            .attr("r", networkStyle.MARKER_RADIUS)
            .attr("fill", that._ntkfn_getEffectColor(networkStyle.MARKER_COLOR_DEFAULT))
            .attr("stroke", networkStyle.MARKER_OUTLINE_COLOR_DEFAULT)
            .attr("stroke-width", networkStyle.MARKER_OUTLINE_WIDTH_DEFAULT);
          
          if (that._ntk_isEnhancedStyle){
            circle.attr("filter","url(#" + GRAPHIC_FILTER_ID + ")");
          }
          
          if (that._ntk_isLabelVisible) {
            node.append("text")
              .text(d.key)
              .style("pointer-events", "none")
              .style("font", networkStyle.LABEL_FONT)
              .attr("dy", networkStyle.LABEL_OFFSET_Y)
              .attr("dx", networkStyle.LABEL_OFFSET_X_DEFAULT)
              .style("fill", that._ntkfn_getEffectColor(networkStyle.LABEL_COLOR_DEFAULT));
          }
        } else if (that._ntk_isSizeChanged) {
          node.transition().duration(500).attr("transform", "translate(" + d.x + ", " + d.y + ")");
        }
      });
      this._ntk_dispatch.initialized();
    };

    Network.prototype._ntkfn_parseData = function() {
      var graph = this._ntk_graph;
      var dimension = this._ntk_data.getAnalysisAxisDataByIdx(0);
      if (dimension) {
        graph.clear();
        var pointGroup1 = dimension.values[0];
        var pointGroup2 = dimension.values[1];
        var len = pointGroup1.rows.length;
        for (var i = 0; i < len; ++i) {
          var key1 = pointGroup1.rows[i].val,
            key2 = pointGroup2.rows[i].val;
          //add ctx for selectData event
          var ctx = Objects.extend(true, {}, pointGroup1.rows[i].ctx);
          graph.addNode({
            key: key1,
            ctx: ctx
          });
          ctx = Objects.extend(true, {}, pointGroup2.rows[i].ctx);
          graph.addNode({
            key: key2,
            ctx: ctx
          });
          graph.addLink(key1, key2);
        }
      }
    };

    Network.prototype._ntkfn_parseProperties = function (){
      this._ntk_isLabelVisible = this._ntk_properties.label.visible;
      this._ntk_isEnhancedStyle = this._ntk_properties.style === DRAWING_STYLE.ENHANCED;
      if (!this._ntk_isEnhancedStyle) {
        this._ntk_properties.style = DRAWING_STYLE.NORMAL;
      }
      this._ntk_styleDef = this._ntk_isEnhancedStyle ? NETWORK_STYLE_ENHANCED : NETWORK_STYLE_BASIC;
      this._ntk_isRelayoutWhenDragging = this._ntk_properties.relayoutWhenDragging;
      this._ntk_isDraggable = this._ntk_properties.draggable;
    };
    
    Network.prototype._ntkfn_layout = function(count) {
      this._ntk_layout.graph(this._ntk_graph).width(this._ntk_width).height(this._ntk_height).radius(this._ntk_styleDef.MARKER_RADIUS).maxCount(count).calculate();
    };

    Network.prototype._ntkfn_getIndexFromClass = function(str) {
      var strs = str.split(" ");
      for (var i = 0, len = strs.length; i < len; ++i) {
        if (strs[i].indexOf("NODE") > -1) {
          return parseInt(strs[i].split("_")[1], 10);
        }
      }
    };

    Network.prototype._ntkfn_calculateLinePosition = function(x1, y1, x2, y2) {
      var dx = x1 - x2,
        dy = y1 - y2;
      var d = Math.sqrt(dx * dx + dy * dy);
      var r = this._ntk_styleDef.MARKER_RADIUS;
      x1 -= r / d * dx;
      y1 -= r / d * dy;
      x2 += r / d * dx;
      y2 += r / d * dy;
      return {
        x1: x1,
        y1: y1,
        x2: x2,
        y2: y2
      };
    };

    Network.prototype._ntkfn_createGraphicFilter = function() {
      var defs = (this._ntk_defs = this._ntk_parent.append("defs"));

      var filter = defs.append("filter")
        .attr("id", GRAPHIC_FILTER_ID)
        .attr("filterUnits", "objectBoundingBox")
        .attr("x", "-6")
        .attr("y", "-6")
        .attr("width", "12")
        .attr("height", "12");

      filter.append("feGaussianBlur")
        .attr("in", "SourceAlpha")
        .attr("stdDeviation", "2")
        .attr("result", "offsetBlur");

      var feMerge = filter.append("feMerge");
      feMerge.append("feMergeNode").attr("in", "offsetBlur");
      feMerge.append("feMergeNode").attr("in", "SourceGraphic");
    };

    Network.prototype._ntkfn_getEffectColor = function (color){
      if (!this._ntk_effectManager){
        return color;
      }
      var parameter = {
        fillColor : color
      };
      return this._ntk_effectManager.register(parameter);
    };
    
    return Network;
  });
define('sap/viz/feeds/Network',['sap/viz/feeds/Manifest','sap/viz/data/feed/Constants'],
function Setup(Manifest, constants) {
  var linkFeed = {
    'id' : 'link',
    'name' : 'IDS_NETLINK',
    'type' : constants.Type.Dimension,
    'min' : 1,
    'max' : 1,
    'aaIndex' : 1,
    'acceptMND': -1,
    'minStackedDims': 2,
    'maxStackedDims' : 2
  };

//  var linkWeightFeed = {
//    'id' : 'linkWeight',
//    'name' : 'IDS_LINKWEIGHT',
//    'type' : constants.Type.Measure,
//    'min' : 0,
//    'max' : 1,
//    'mgIndex' : 1
//  };

  var feeds = {
    id : "network",
    feeds : [ linkFeed ]
  };
  Manifest.register(feeds);
});
define('sap/viz/modules/manifests/Network',['sap/viz/modules/manifests/Module','sap/viz/modules/Constants','sap/viz/modules/network','sap/viz/feeds/Network'],
function Setup(Manifest, Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.network',
    'type' : Constants.Type.Chart,
    'name' : 'network',
    'properties' : {
      'label':{
        'name': 'label',
        'supportedValueType': 'Object',
        'supportedValues': {
          'visible' : {
            'name' : 'visible',
            'supportedValueType' : 'Boolean',
            'defaultValue' : true,
            'description' : 'Set whether to show label or not'
          },
        },
        'description':'Setting for labels in network'
      },
      'style':{
        'name': 'style',
        'supportedValueType': 'String',
        'supportedValues': ['basic', 'enhanced'],
        'defaultValue': 'enhanced',
        'description':'~',
        'isExported':false
      },
      'relayoutWhenDragging' : {
        'name' : 'relayoutWhenDragging',
        'supportedValueType' : 'Boolean',
        'defaultValue' : true,
        'description' : 'Set whether to show label or not'
      },
      'draggable' : {
        'name' : 'draggable',
        'supportedValueType' : 'Boolean',
        'defaultValue' : true,
        'description' : 'Set whether enable dragging or not',
        'isExported' : false
      }

    },
    'events' : {
      'initialized': Constants.Event.Initialized.desc,
        'selectData' : Constants.Event.SelectData.desc,
        'deselectData' : Constants.Event.DeSelectData.desc
    },
    'feeds' : {
      id : "network"
    },
    'css' : {},
    'configure' : null,
    fn : fn
  };
  Manifest.register(module);
});
define('sap/viz/manifests/NetworkChart',['sap/viz/manifests/Viz', 'sap/viz/modules/manifests/RootContainer',
'sap/viz/modules/manifests/Network'],
function Setup(Manifest) {
  var chart = {
    id : 'viz/network',
    name : 'IDS_NETWORKCHART',
    modules : {
      root : {
        id: "sap.viz.modules.rootContainer",
        configure: {
          propertyCategory: "general"
        },
        modules : {
          title : {
            id : 'sap.viz.modules.title',
            configure : {
              propertyCategory : 'title',
              properties : {
                layout : {
                  position : 'top',
                  priority : 0
                }
              }
            }
          },
          layout : {
            id : 'sap.viz.modules.layout.dock'
          },
          interaction : {
            id : "sap.viz.modules.controller.interaction",
            configure : {
              clientID : "main",
              propertyCategory : "interaction",
              properties : {
                supportedEventNames : [ 'mouseup', 'mouseover', 'mouseout', 'touchstart' ],
                selectability:{
                  mode: "single"
                }
              },
              propertiesOverride:{
                selectability:{
                  isExported:false
                }
              }
            }
          },
          
          main : {
            id : 'sap.viz.modules.xycontainer',
            configure: {
              propertyCategory : 'xyContainer',
              properties : {
                layout : {
                  position : 'center',
                  priority : 10
                }
              }
            },
            modules : {
              plot: {
                id : 'sap.viz.modules.network',
                configure : {
                  description: 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory : 'plotArea'
                }    
              }
            }
          }
        }
      }
    },
    dependencies : {
      attributes : 
      [ ],
      events : 
      [
       {
          targetModule : "root.interaction",
          listener : "registerEvent",
          sourceModule : "root.main.plot",
          type : "initialized.interaction"
       }
      ]
    }
  };

  Manifest.register(chart);
});
define('sap/viz/modules/manifests/Axis',['sap/viz/modules/manifests/Module','sap/viz/modules/Constants','sap/viz/base/UADetector','sap/viz/modules/axis'],
function Setup(Manifest, Constants, UADetector, fn) {
  var module = {
    'id' : 'sap.viz.modules.axis',
    'type' : Constants.Type.Supplementary,
    'name' : 'axis',
    'properties' : {
      'isIndependentMode' : {
        'name' : 'isIndependentMode',
        'supportedValueType' : 'Boolean',
        'defaultValue' : false,
        'description' : 'Set whether axis works on independent mode, currently it is used specially for boxplot chart.',
        'isExported' : false
      },
      'isPercentMode' : {
        'name' : 'isPercentMode',
        'supportedValueType' : 'Boolean',
        'defaultValue' : false,
        'description' : 'Show the label 0.1 as 10',
        'isExported' : false
      },
      'lineSize' : {
        'name' : 'lineSize',
        'supportedValueType' : 'String',
        'defaultValue' : '1',
        'description' : 'Set line size of axis.',
        'isExported' : true,
        'example': "<a href='"+Constants.DocExample.SnippetUrl+"88' target='_blank'>"+Constants.DocExample.TryThisValue+"</a>"
      },
      'title' : {
        'name' : 'title',
        'description' : 'Settings for axis title.',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'visible' : {
            'name' : 'visible',
            'supportedValueType' : 'Boolean',
            'defaultValue' : false,
            'description' : 'Set visibility of axis title.'
          }, 
          'text' : {
            'name' : 'text',
            'supportedValueType' : 'String',
            'defaultValue' : null,
            'description' : 'Set text of axis title.'
          },
          'applyAxislineColor' : {
            'name' : 'applyAxislineColor',
            'supportedValueType' : 'Boolean',
            'defaultValue' : false,
            'description' : 'Set title color same with axisline color.',
            'isExported' : false,
          },
        },
      },
      'gridline' : {
        'name' : 'gridline',
        'description' : 'Settings for axis gridline.',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'visible': {
            'name' : 'visible',
            'supportedValueType' : 'Boolean',
            'defaultValue' : true,
            'description' : 'Set visibility of axis gridline.'
          },
          showFirstLine : {
            'name' : 'showFirstLine',
            'supportedValueType' : 'Boolean',
            'defaultValue' : false,
            'description' : 'Set enabled/disabled the first line of gridlines.',
            'isExported' : false,
          },
          showLastLine : {
            'name' : 'showLastLine',
            'supportedValueType' : 'Boolean',
            'defaultValue' : false,
            'description' : 'Set enabled/disabled the last line of gridlines.',
            'isExported' : false,
          },
          'type' : {
            'name' : 'type',
            'supportedValueType' : 'String',
            'supportedValues' : [ 'line', 'dotted', 'incised'],
            'defaultValue' : 'line',
            'description' : 'Set type of gridline.',
            'isExported' : true,
          },
          'color' : {
            'name' : 'color',
            'supportedValueType' : 'String',
            'defaultValue' : '#d8d8d8',
            'description' : 'Set color of gridline.',
            'isExported' : true,
          },
          'size' : {
            'name' : 'size',
            'supportedValueType' : 'String',
            'defaultValue' : '1',
            'description' : 'Set line size of gridline.',
            'isExported' : true,
          },        
        },
      }, 
      'color' : {
        'name' : 'color',
        'supportedValueType' : 'String',
        'defaultValue' : '#6c6c6c',
        'description' : 'Set color of axisline.',
        'isExported' : true,
      },
      'axisline' : {
        'name' : 'axisline',
        'description' : 'Settings for axisline.',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'visible' : {
          'name' : 'visible',
          'supportedValueType' : 'Boolean',
          'defaultValue' : true,
          'description' : 'Set visibility of axisline.'
          },
        },
      },    
      'type' : {
        'name' : 'type',
        'supportedValueType' : 'String',
        'supportedValues' : [ 'value', 'category', ],
        'defaultValue' : 'value',
        'description' : 'Set type of axis.',
        'isExported' : false,
      },
      'visible' : {
        'name' : 'visible',
        'supportedValueType' : 'Boolean',
        'defaultValue' : true,
        'description' : 'Set visibility of axis.',
      },
      'label' : {
        'name' : 'label',
        'description' : 'Settings for axis label.',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'visible' : {
            'name' : 'visible',
            'supportedValueType' : 'Boolean',
            'defaultValue' : true,
            'description' : 'Set visibility of axis label.'
          }, 
          'numberFormat' : {
            'name' : 'numberFormat',
            'supportedValueType' : 'String',
            'defaultValue' : '',
            'description' : 'Set number format of value axis.',
            'isExported' : false
          },
          'formatString' : {
             'name' : 'formatString',
             'supportedValueType' : 'String | Two-Dimensions-Array',
             'defaultValue' : null,
             'description' : 'Set format string of value axis. If value is a string, it will be axis format string as before.' + 
                 ' If value is a two dimensions array that each item of array is applied to each item of measure value group,' +
                 ' it is only available for scatter matrix chart and multiple chart with MND in order to display different measure number format in each sub chart.' + 
                 ' If value is a two dimensions array for other charts except scatter matrix and multiple chart, the first value of first array of two dimensions array is as format string to format axis label.' + 
                 ' Any character in "MDYHSAmdyhsau#?%0@" is reserved as a token for format code.' + 
                 ' The end "u" of format string let value format with SI units, the other format string will explained as Excel format string,' + 
                 ' The value that bigger than 1e8 or less than 1e-6 and be not 0 format with Exponential style' +
                 ' The following is a simple sample format string for label for axis as "0.00%" or as one chart may have two measures: [["#,##0.00 DM;-#,##.00 DM","#,##.00;-#,##.00"]].'
          }
        },
      },
      'indicator' : {
        'name' : 'indicator',
        'description' : 'Settings for axis indicator',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'enable' : {
            'name' : 'enable',
            'supportedValueType' : 'Boolean',
            'defaultValue' : false,
            'description' : 'Set visibility of axis indicator.'
          }
        }
      },
      'position' : {
        'name' : 'position',
        'supportedValueType' : 'String',
        'supportedValues' : [ 'left', 'right', 'top', 'bottom' ],
        'defaultValue' : 'bottom',
        'description' : 'Set position of axis.',
          'isExported' : false,
      },
      'isTruncateAvailable' : {
        'name' : 'isTruncateAvailable',
        'supportedValueType' : 'Boolean',
        'defaultValue' : true,
        'description' : 'Mark truncate logic availability for category axis.',
          'isExported' : false,
      },
      'forceLabelArea' : {
        'name' : 'forceLabelArea',
        'supportedValueType' : 'Boolean',
        'defaultValue' : false,
        'description' : 'Make label area limit to text area.',
        'isExported' : false
      },
      'scale' : {
        'name' : 'scale',
        'description' : 'Set scale for value axis. this property just work on value type axis.',
        'supportedValueType' : 'Object',
        'supportedValues' : {
            'fixedRange' : {
                'name' : 'fixedRange',
                'supportedValueType' : 'Boolean',
                'defaultValue' : false,
                'description' : 'Enable/disable fixed axis range according minValue and maxValue.',
            },
            'minValue' : {
                'name' : 'minValue',
                'supportedValueType' : 'Number',
                'defaultValue' : 0,
                'description' : 'Set minValue of value axis.',
            },
            'maxValue' : {
                'name' : 'maxValue',
                'supportedValueType' : 'Number',
                'defaultValue' : 0,
                'description' : 'Set maxValue of value axis.',
            }
        },
      },
      'layoutInfo' : {
        'name' : 'layoutInfo',
        'description' : 'Settings layoutInfo for category axis. this property just work on category type axis',
        'supportedValueType' : 'Object',
        'supportedValues' : {
            'width' : {
                'name' : 'width',
                'supportedValueType' : 'Number',
                'defaultValue' : 0,
                'description' : 'Set width of xAxis.',
                'isExported' : false
            }, 
            'height' : {
                'name' : 'height',
                'supportedValueType' : 'Number',
                'defaultValue' : 0,
                'description' : 'Set height of xAxis.',
                'isExported' : false
            }
        },
        'isExported' : false
      },
      'enableLabelSelection':{
        'name' : 'enableLabelSelection',
        'supportedValueType' : 'Boolean',
        'defaultValue' : UADetector.isMobile() ? false: true,
        'description' : 'Set whether to enable label selection effect. For mobile, default value will be false.',
        'isExported' : false
      },
      'axisTick' : {
        'name' : 'axisTick',
        'description' : 'Settings for axis ticks.',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'visible' : {
          'name' : 'visible',
          'supportedValueType' : 'Boolean',
          'defaultValue' : UADetector.isMobile() ? false: true,
          'description' : 'Set visibility of axis ticks. For mobile, default value will be false.'
         },
        },
        'isExported' : false
      }
    },
    'css' : {
      '.viz-axis-title.v-title' : {
        'description' : 'Define style for the axis title.',
        'value' : {
          'fill' : '#000000',
          'font-family' : "'Open Sans', Arial, Helvetica, sans-serif",
          'font-size' : '14px',
          'font-weight' : 'bold'
        }
      },
      '.viz-axis-label.v-label' : {
        'description' : 'Define style for the axis label.',
        'value' : {
          'fill' : '#333333',
          'font-family' : "'Open Sans', Arial, Helvetica, sans-serif",
          'font-size' : '12px',
          'font-weight' : 'normal'
        }
      },
      '.v-hovershadow' : {
          'description' : 'Define style for hover shadow color.',
            'value' : {
              'fill' : '#cccccc'
            }
      }
    },
    'configure' : null,
    fn : fn
  };
  Manifest.register(module);
});

define('sap/viz/modules/heatmap',['sap/viz/modules/dispatch','sap/viz/util/ColorSeriesGenerator','sap/viz/modules/util/tooltipDataHandler',
'sap/viz/util/NumberUtils','sap/viz/util/EffectManager','sap/viz/base/utils/TypeUtils',
'sap/viz/util/TextUtils','sap/viz/util/MeasureBasedColoring',
'sap/viz/lang/langManager','sap/viz/base/utils/ObjectUtils','sap/viz/base/utils/Objects',
'sap/viz/modules/util/BoundUtil','sap/viz/modules/util/defaultSelectionUtil','sap/viz/modules/Constants'],
function Setup(dispatch, ColorSeries, tooltipDataHandler, NumberUtils,EffectManager, TypeUtils,TextRuler, MeasureBasedColoring, langManager, ObjectUtils, Objects, BoundUtil, defaultSelUtil,Constants) {
    //heatmap has no MND
    var heatMap = function(manifest, ctx) {
    
      var CLASSDATAPOINT = Constants.CSS.CLASS.DATAPOINT,
          SEL_CLASSDATAPOINT = '.' + CLASSDATAPOINT,
          CLASSMORPHABLEDATAPOINT = Constants.CSS.CLASS.MORPHABLEDATAPOINT;
      var CLASSDATAPOINTCOMBINED = CLASSDATAPOINT + ' ' + CLASSMORPHABLEDATAPOINT;
      var randomSuffix = ObjectUtils.guid();              //diff all the id
        var extendObj = function(target, source)
        {
            for(var prop in source)
            {
                if(typeof(source[prop]) === "object")
                {
                    if(target[prop])
                    {
                        target[prop] = extendObj(target[prop], source[prop]);
                    }
                    else
                    {
                        target[prop] = source[prop];
                    }
                }
                else
                {
                    target[prop] = source[prop];
                }
            }
            return target;
        };      

        var m_selectionList = [];

        var m_width, m_height;
        var m_props =
        {
            "emptycolor":"#e0e0e0",
            'animation': {
                dataLoading : true,
                dataUpdating : true,
                resizing : true,
            },
            'colornumber': 5,
            'discretecolor' : false,
            'guideline' : 
            {
                visible: false,
                color: "#ffff90",
            },
            'drawemptycell': true,
            'colorPalette': [],
            tooltip: {
                enabled: true,
            }
        };
        
        m_props = extendObj(m_props, manifest.props(null));

        var m_propsOutput = manifest.props(null);
        
        var m_styleTooltipFont = "'Open Sans', Arial, Helvetica, sans-serif";

        var m_data;

        var m_HLElement;

        var m_redrawAll = true;

        var m_className = "v-heatmap";
        var m_classEmptyValue = "v-heatmapemptyvalue";

        var m_padding = 1;

        var m_xScale = d3.scale.ordinal();
        var m_yScale = d3.scale.ordinal();

        var m_dispatch = new dispatch('selectData', 'deselectData', 'initialized', 'showTooltip', 'hideTooltip', 'startToInit');

        var hColor = undefined; //Color Scale

        var m_styleLineColor = "#ffffff";
        
        var m_dataXAxis;
        var m_dataYAxis;
        var m_dataRect;

        var m_heatMapBody;//the root class

        var m_selection = null;

        var m_tooltipElement = null;
        var hasDefaultSelection = false;
        var m_guidline = null;

        //we need to draw some recs. So I will build a obj array, each item is a rec.
        var m_heatObjArray = [];

        var m_effectManager = ctx.effectManager;
        
        var m_defaultString = langManager.get('IDS_ISNOVALUE');
        
        var m_dataShape = null;
        
        function chart(selection){

            BoundUtil.drawBound(selection, m_width, m_height);
            m_dispatch.startToInit();
            m_selection = selection;

            //prepare data, and the draw it
//---------------------prepare data start-------------------------------------
            m_heatObjArray = [];
            
            var isOnlyOneCategroy = false;
            if(!m_dataYAxis)
            {
                isOnlyOneCategroy = true;
            }

            if(isOnlyOneCategroy)
            {
                //build labels
                var labelArray = [];
                var vArray = m_dataRect.values[0].rows[0];
                //add the data to m_heatObjArray. the number of rectanges is the number of rectanglecolor.valuies.
                for(var i = 0; i < vArray.length; i++)
                {
                    m_heatObjArray.push(vArray[i]);
                }

                //build labelArray
                for(var i = 0; i < m_heatObjArray.length; i++)
                {
                    var label = "";
                    for(var j = 0; j < m_dataXAxis.values.length; j++)
                    {
                        label += m_dataXAxis.values[j].rows[i].val;
                        if(j != (m_dataXAxis.values.length-1))
                        {
                            label += " / ";
                        }
                    }
                    labelArray.push(label);
                }

                for(var i = 0; i < m_heatObjArray.length; i++)
                {
                    m_heatObjArray[i].label = labelArray[i];
                    m_heatObjArray[i].isOnlyOneCategory = true;
                }
            }
            else
            {
                //for the 2 categories, we have to count the numCol and the numRow.
                var hCol = m_dataXAxis.values[0].rows;
                var hRow = m_dataYAxis.values[0].rows;
                var hData = m_dataRect.values[0].rows;

                var numCol = hCol.length;
                var numRow = hRow.length;

                for(var i = 0; i < numRow; i++)
                {
                    for(var j = 0; j < numCol; j++)
                    {
                        m_heatObjArray.push(hData[i][j]);
                    }
                }
                
                for(var i = 0; i < m_heatObjArray.length; i++)
                {
                  m_heatObjArray[i].isOnlyOneCategory = false;
                }
            }

            // //count the max and min value of m_heatObjArray[i].val
            // var maxVal = -Number.MAX_VALUE;
            // var minVal = Number.MAX_VALUE;

            // for(var iObj = 0; iObj < m_heatObjArray.length; iObj++)
            // {
                // if(!NumberUtils.isNoValue(m_heatObjArray[iObj].val))
                // {
                    // if(maxVal < m_heatObjArray[iObj].val)
                    // {
                        // maxVal = m_heatObjArray[iObj].val;
                    // }

                    // if(minVal > m_heatObjArray[iObj].val)
                    // {
                        // minVal = m_heatObjArray[iObj].val;
                    // }
                // }
            // }

            //var numS = m_props.colornumber;

            hColor = buildColorScale();
            var domainArray = hColor.domain();
            for(var i = 0; i < m_heatObjArray.length; i++)
            {
                var domainValue;
                if(NumberUtils.isNoValue(m_heatObjArray[i].val)) {
                    m_heatObjArray[i].color = m_props.emptycolor;
                } else {
                    for (var j=0; j<domainArray.length; j++) {
                        var tdv = domainArray[j];
                        if ((j == domainArray.length-1) || (domainArray[j+1].length == 0)) {
                            domainValue = tdv;
                            break;
                        }
                        if ((m_heatObjArray[i].val >= tdv[0]) && (m_heatObjArray[i].val < tdv[1])) {
                            domainValue = tdv;
                            break;
                        }
                    }
                    m_heatObjArray[i].color = hColor(domainValue);
                }
                
                
                // for(var j = 0; j < numS; j++)
                // {
                     // if(NumberUtils.isNoValue(m_heatObjArray[i].val))
                    // {
                        // m_heatObjArray[i].color = m_props.emptycolor;
                        // break;
                    // }
                     // else if( m_heatObjArray[i].val == maxVal )
                    // {
                        // m_heatObjArray[i].color = hColor([(minVal + (maxVal-minVal)/numS*(numS-1)), maxVal]);
                        // break;
                    // }
                    // else if(m_heatObjArray[i].val >= (minVal + (maxVal-minVal)/numS*j) && m_heatObjArray[i].val < (minVal + (maxVal-minVal)/numS*(j+1)))
                    // {
                        // m_heatObjArray[i].color = hColor( [(minVal + (maxVal-minVal)/numS*j), (minVal + (maxVal-minVal)/numS*(j+1))]  );
                       
                    // }
                    
                // }
            }

            if(isOnlyOneCategroy)
            {
                //build the rect size. The rule is making the rect width and height have similar values
                var score = -Number.MAX_VALUE;//the bigger the better

                var rHeight;
                var rWidth;
                
                var iRow;
                var iCol;

                var emptyCellNum;

                var scoreArray = [];
                var varianceRec;

                if(m_heatObjArray.length == 1)
                {
                    rHeight = m_height;
                    rWidth = m_width;
                    iCol = 1;
                    iRow = 1;
                }
                else
                {

                    for(iRow = 1; iRow <= m_heatObjArray.length; iRow++)
                    {
                        //count the height
                        rHeight = m_height/iRow;

                        //count the num of one row. 
                        var iCol = Math.ceil(m_heatObjArray.length / iRow);
                        
                        //count the width
                        rWidth = m_width/iCol;

                        emptyCellNum = (iCol * iRow) - m_heatObjArray.length;
                        varianceRec = (rHeight - rWidth)*(rHeight - rWidth);

                        if(varianceRec < 1)
                        {
                            varianceRec = 1; //to avoid 1/varianceRec huge number
                        }

                        var score;
                        if(emptyCellNum == 0 && varianceRec == 0)
                        {
                            score = 1 + 1;
                        }
                        else if(emptyCellNum == 0 && varianceRec != 0)
                        {
                            score = 1 + 1/varianceRec;
                        }
                        else if(emptyCellNum != 0 && varianceRec == 0)
                        {
                            score = 1 + 1;
                        }
                        else
                        {
                            score = 1 + 1/varianceRec;
                        }
                        
                        scoreArray.push(
                        {
                            "iRow":iRow,
                            "iCol":iCol,
                            "rHeight":rHeight,
                            "rWidth":rWidth,
                            "varianceRec":varianceRec,
                            "emptyCellNum":emptyCellNum,
                            "score":score
                        });
                    }
                    //select the best score
                    var maxS = 0;
                    var iChoose = -1;
                    for(var i = 0; i < scoreArray.length; i++)
                    {
                        if(scoreArray[i].score > maxS)
                        {
                            maxS = scoreArray[i].score;
                            iChoose = i;
                        }
                    }

                    rHeight = scoreArray[iChoose].rHeight;
                    rWidth = scoreArray[iChoose].rWidth;
                    iCol = scoreArray[iChoose].iCol;
                    iRow = scoreArray[iChoose].iRow;
                    
                }



                //build the rect height, width, and left, right
                for(var i = 0; i < m_heatObjArray.length; i++)
                {
                    m_heatObjArray[i].width = rWidth;
                    m_heatObjArray[i].height = rHeight;

                    m_heatObjArray[i].left = rWidth * (i%iCol);
                    m_heatObjArray[i].top = rHeight * (Math.floor(i/iCol));
                    m_heatObjArray[i].textContent = TextRuler.ellipsis(m_heatObjArray[i].label, null, m_heatObjArray[i].width - 5, "fill:#ffffff;font-family:'Open Sans', Arial, Helvetica, sans-serif;font-size:12px;");
                }
            }
            else
            {
                //build the rect height, width, and left, right
                for(var i = 0; i < m_heatObjArray.length; i++)
                {
                    m_heatObjArray[i].width = m_width/numCol;
                    m_heatObjArray[i].height = m_height/numRow;

                    m_heatObjArray[i].left = (m_width/numCol) * (i%numCol);
                    //the Y is from the bottom
                    m_heatObjArray[i].top = (m_height-m_height/numRow) - ((m_height/numRow) * (Math.floor(i/numCol)));
                }
            }
//---------------------prepare data end-------------------------------------

            drawHeatMap(selection, isOnlyOneCategroy);
            return chart;
        };

        var disableBorder = function()
        {
            var disableBorder = false;
            //BITVIZA-1437 [Heatmap]When heatmap chart is small like 86*74, the chart content would be blank
            //It is because the HeatMap has more dataponits and borders than the number of the pixels. Setting border to invisible can bypass the issue.
            if(m_heatObjArray.length > 0)
            {
                var itemWidth = m_heatObjArray[0].width;
                var itemHeight = m_heatObjArray[0].height;
                
                var smallerValue = itemWidth;
                if(itemWidth > itemHeight)
                {
                    smallerValue = itemHeight;
                }

                if(smallerValue < 2)
                {
                    disableBorder = true;
                }
            }
            return disableBorder;
        };

        var drawHeatMap = function(selection, isOnlyOneCategroy)
        {

            var drawState = "resizing";//it has 3 states: dataLoading, dataUpdating, resizing
            if(m_redrawAll)
            {
                if(selection.select("." + m_className).empty())
                {
                    drawState = "dataLoading";
                }
                else
                {
                    drawState = "dataUpdating";
                }      
                selection.select("." + m_className).remove();
            }

            var datashapesgroup = selection.selectAll('g.v-datashapesgroup');
            if(!TypeUtils.isExist(datashapesgroup[0][0])){
              datashapesgroup = selection.append('g').attr('class', 'v-datashapesgroup');
            }

            if(!isOnlyOneCategroy)
            {
                m_padding = 0;
            }
            else
            {
                if(m_props.border.visible && !disableBorder())
                {
                    m_padding = 1;
                }
                else
                {
                    m_padding = 0;
                }
            }

            //draw the rects
            if(m_redrawAll)
            {
                m_heatMapBody = datashapesgroup.append("g").attr("class", m_className);
            }
            else
            {
                m_heatMapBody = datashapesgroup.select("." + m_className);
            }

            if(!m_props.drawemptycell)
            {
                //draw a rect
                if(m_redrawAll)
                {
                    m_heatMapBody.append('rect')
                               .attr("x", 0)
                               .attr("y", 0)
                               .attr("width", m_width)
                               .attr("height",m_height)
                               .attr("fill",m_props.emptycolor)
                               .attr("class", m_classEmptyValue)
                               .attr("shape-rendering", "crispEdges");
                }
                else
                {
                    m_heatMapBody.select("." + m_classEmptyValue)
                               .attr("x", 0)
                               .attr("y", 0)
                               .attr("width", m_width)
                               .attr("height",m_height)
                               .attr("fill",m_props.emptycolor)
                               .attr("class", m_classEmptyValue)
                               .attr("shape-rendering", "crispEdges");

                }
            }

            var m_heatObjArrayToDraw = [];
            for(var i = 0; i < m_heatObjArray.length; i++)
            {
                if(!m_props.drawemptycell && !m_heatObjArray[i].val)
                {
                    continue;
                }
                else
                {
                    m_heatObjArray[i].index = i;
                    m_heatObjArrayToDraw.push(m_heatObjArray[i]);
                }
            }
            
            //draw rects 
            var item = m_heatMapBody.selectAll("rect")
                 .data(m_heatObjArrayToDraw,function(d){return d.index;});

            var toDrawItems = item.enter();
            var toDeleteItems = item.exit();

            var axisPaddingOffset = 0;
            var isCrispEdges = true;
            if(m_props.border.visible && !disableBorder() && !isOnlyOneCategroy)
            {
                axisPaddingOffset = 0.5;
                isCrispEdges = false;
            }

            var rects;
            if(m_redrawAll)
            {
              m_dataShape = toDrawItems.append("g").attr("class","v-datashape");
              m_dataShape.attr('transform', function(d) {return 'translate(' + (d.left + m_padding) + ',' + (d.top + m_padding) + ')';});
              
                rects = m_dataShape.append("rect")
                    .attr('id', function(d, i){return ("HM" + d.index + randomSuffix);})
                    .attr('class', CLASSDATAPOINTCOMBINED)
                    .attr("x", axisPaddingOffset)
                    .attr("y", axisPaddingOffset)
                    .attr("width", function(d){return d.width-2*m_padding-2*axisPaddingOffset;})
                    .attr("height",function(d){return d.height-2*m_padding-2*axisPaddingOffset;})
                    .attr("fill",function(d){ 
                        var parameter = {
                            drawingEffect:'normal',
                            fillColor : d.color};
                        return m_effectManager.register(parameter);
                        });
                if(isCrispEdges)
                {
                    rects.attr("shape-rendering", "crispEdges");
                }
            }
            else
            {
                var resizeTime = 0;
                if(drawState === "resizing" && m_props.animation.resizing)
                {
                    resizeTime = 500;
                }

                if (m_dataShape)
                {
                    if(resizeTime > 0)
                    {
                        m_dataShape.transition()
                                   .attr('transform', function(d) {return 'translate(' + (d.left) + ',' + (d.top) + ')';})
                                   .delay(0)
                                   .duration(resizeTime);
                    }
                    else
                    {
                        m_dataShape.attr('transform', function(d) {return 'translate(' + (d.left) + ',' + (d.top) + ')';});
                    }
                }

                rects = item;
                if(resizeTime > 0)
                {
                    rects = item
                        .transition();
                }

                rects = rects.attr("x", axisPaddingOffset)
                .attr('id', function(d, i){return ("HM" + d.index + randomSuffix);})
                .attr('class', CLASSDATAPOINTCOMBINED)                            
                .attr("y", axisPaddingOffset)
                .attr("width", function(d){return d.width-2*m_padding-2*axisPaddingOffset;})
                .attr("height",function(d){return d.height-2*m_padding-2*axisPaddingOffset;})
                .attr("fill",function(d){ 
                    var parameter = {
                        drawingEffect:'normal',
                        fillColor : d.color};
                    return m_effectManager.register(parameter);
                    });
                if(isCrispEdges)
                {
                    rects.attr("shape-rendering", "crispEdges");
                }

                if(resizeTime > 0)
                {
                    rects.delay(0)
                    .duration(resizeTime).each('end',endAnimation);
                }
                //unselect all of them
                //rects.attr('opacity', 1);
            }

            if(isOnlyOneCategroy)
            {
                //labels: remove all and append them
                if(!m_redrawAll)
                {
                     m_heatMapBody.selectAll("text").remove();
                     m_heatMapBody.selectAll("rect").data(m_heatObjArrayToDraw,function(d){return d.index;}).enter();                     
                }

                if (m_dataShape)
                {
                    m_dataShape.append("text")
                                .attr("class", "v-heatmapdatalabel")
                                .attr("x", function(d){return d.width/2;})
                                .attr("y", function(d){return d.height/2;})
                                .attr("text-anchor", "middle") // text-align
                                .text(function(d){return d.textContent;})
                                .attr("fill", "#ffffff")
                                .attr("font-size", "12px")
                                .attr("font-family", "'Open Sans', Arial, Helvetica, sans-serif")
                                .attr('pointer-events', 'none')
                                .each(function(d) {
                                  if(d.textContent !== d.label && d.textContent.length>0) {
                                    this.appendChild(document.createElementNS(this.namespaceURI, "title")).textContent = d.label;
                                  }
                                });
                }
            }
            
            //add the animation for redraw
            if(m_redrawAll)
            {
                var fadeInTime = 0;
                if(drawState === "dataLoading" && m_props.animation.dataLoading)
                {
                    fadeInTime = 1000;
                }
                else if(drawState === "dataUpdating" && m_props.animation.dataUpdating)
                {
                    fadeInTime = 500;
                }

                if(fadeInTime > 0)
                {
                    rects.attr('opacity', 0);
                    rects.transition()
                        .delay(0)
                        .duration(fadeInTime).attr('opacity', 1)
                        .each('end',endAnimation);
                }
                else
                {
                    rects.attr('opacity', 1);
                    endAnimation();
                }
            }
            else
            {
                rects.attr('opacity', 1);
                endAnimation();
            }

            //the HLCell Rectange
            if(m_redrawAll)
            {
                m_HLElement = m_heatMapBody.append('g').attr('class', 'v-element').attr("visibility", "hidden");
                m_HLElement.append('line').attr("x1",0).attr("y1",0).attr("x2",0).attr("y2",0).attr("shape-rendering", "crispEdges").attr("stroke","#6c6c6c");
                m_HLElement.append('line').attr("x1",0).attr("y1",0).attr("x2",0).attr("y2",0).attr("shape-rendering", "crispEdges").attr("stroke","#6c6c6c");
                m_HLElement.append('line').attr("x1",0).attr("y1",0).attr("x2",0).attr("y2",0).attr("shape-rendering", "crispEdges").attr("stroke","#6c6c6c");
                m_HLElement.append('line').attr("x1",0).attr("y1",0).attr("x2",0).attr("y2",0).attr("shape-rendering", "crispEdges").attr("stroke","#6c6c6c");
            }
            else
            {
                if(m_HLElement)
                {
                    m_HLElement.attr("visibility", "hidden");
                }
            }

            //reset the redraw state
            m_redrawAll = false;
        }
        
        var endAnimation = function(d, i)
        {
            if(  (i === (m_heatObjArray.length - 1))//the last datapoint
               || (m_heatObjArray.length === 0) //no data
               || (d === undefined && i === undefined) //not in "each"
              )
            {
                //When the endAnimation is called, animation may not be end. 
                //(it looks like a bug of d3 or browsers) 
                //So the opacity is 0.9999 or something, and then it will be changed to 1
                //We have to use setTimeout here in case defaultselection changes opacity again. 
                //not use m_dispatch.initialized();            
                setTimeout(m_dispatch.initialized, 0);
            }
        };

        function deregisterEvent(){
            
        };
        
        function registerEvent(){
            
        };

        var showTooltip = function(dataIndex){ 
            var dataItem = m_heatObjArray[dataIndex];
            var valXValue = "";
            var valYValue = "";



           var isOnlyOneCategroy = false;
            if(!m_dataYAxis)
            {
                isOnlyOneCategroy = true;
            }

            if(isOnlyOneCategroy)
            {
                valXValue = m_dataXAxis.values[0].rows[dataIndex].val;
                if(m_dataYAxis)
                {
                    valYValue = m_dataYAxis.values[0].rows[dataIndex].val;
                }
            }
            else
            {
                //for the 2 categories, we have to count the numCol and the numRow.
                var hCol = m_dataXAxis.values[0].rows;
                var hRow = m_dataYAxis.values[0].rows;
                var hData = m_dataRect.values[0].rows;

                var numCol = hCol.length;
                var numRow = hRow.length;

                valXValue = m_dataXAxis.values[0].rows[dataIndex%numCol].val;
                valYValue = m_dataYAxis.values[0].rows[Math.floor(dataIndex/numCol)].val;
            }

            m_tooltipElement.select("rect").attr("width", 160).attr("height", 78).attr("fill" , "rgb(255,255,255)");
            m_tooltipElement.attr("transform", "translate(" + (dataItem.left + dataItem.width/2 + 5) + "," + (dataItem.top + dataItem.height/2 + 5) + ")");
            if(!NumberUtils.isNoValue(dataItem.val))
            {
                m_tooltipElement.select(".valText").text(dataItem.val);
                m_tooltipElement.select(".valXValue").text(valXValue);
                m_tooltipElement.select(".valYValue").text(valYValue);

                m_tooltipElement.attr('visibility', 'visible');

                //guideline
                if(m_props.guideline.visible)
                {
                    m_guidline.select(".xGuidline").attr("x1", m_heatObjArray[dataIndex].left + m_heatObjArray[dataIndex].width/2).attr("x2", m_heatObjArray[dataIndex].left + m_heatObjArray[dataIndex].width/2);
                    m_guidline.select(".yGuidline").attr("y1", m_heatObjArray[dataIndex].top + m_heatObjArray[dataIndex].height/2).attr("y2", m_heatObjArray[dataIndex].top + m_heatObjArray[dataIndex].height/2);
                    m_guidline.attr('visibility', 'visible');
                }
            }            
        };

        var stringNoValueHandler = function(str)
        {
            if(str === null || str === undefined)
            {
                str = langManager.get('IDS_ISNOVALUE');
            }
            return str;
        }
        
        var generateTooltipData = function(dataIndex){
            //for heatmap, we only have one measure so that the body's length is always 1
            var tooltipData = {
                body:[],
                footer:[]
            };
            var dataItem = m_heatObjArray[dataIndex];
            var body = {
                    'name': stringNoValueHandler(m_dataRect.values[0].col),
                    val:[{
                        color: dataItem.color,
                        value: NumberUtils.isNoValue(dataItem.val)?m_defaultString:dataItem.val
                    }]
            };
            
            tooltipData.body.push(body);
            
            if(TypeUtils.isExist(m_dataXAxis)){
                for(var tval = m_dataXAxis.values, len = tval.length, i = len -1; i  >= 0; i--){
                    var footer = {};
                    footer.label = tval[i].col;
                    footer.value = tval[i].rows[dataIndex%tval[i].rows.length];
                    tooltipData.footer.push(footer);
                }
            }
            
            if(TypeUtils.isExist(m_dataYAxis)){
                var dataIndexInYAxis = Math.floor(dataIndex / m_dataXAxis.values[0].rows.length);
                for(var tval = m_dataYAxis.values, len = tval.length, i = len -1; i >= 0; i--){
                    var footer = {};
                    footer.label = tval[i].col;
                    footer.value = tval[i].rows[dataIndexInYAxis%tval[i].rows.length];
                    tooltipData.footer.push(footer);
                }
            }
            
            return tooltipData;
        };
        
        var hideTooltip = function(){
            m_tooltipElement.attr('visibility', 'hidden');
            m_guidline.attr('visibility', 'hidden');
        };

        var HLCell = function(item)
        {
            if(!NumberUtils.isNoValue(item.datum().val))
            {
                m_HLElement.attr("visibility", "visible");

                var iLeft = item.datum().left;
                var iRight = item.datum().left + item.datum().width - m_padding;
                var iTop = item.datum().top;
                var iBottom = item.datum().top + item.datum().height  - m_padding;

                m_HLElement.select(".HLLeft").attr("x1",iLeft).attr("y1",iTop).attr("x2",iLeft).attr("y2",iBottom);
                m_HLElement.select(".HLRight").attr("x1",iRight).attr("y1",iTop).attr("x2",iRight).attr("y2",iBottom);
                m_HLElement.select(".HLTop").attr("x1",iLeft).attr("y1",iTop).attr("x2",iRight).attr("y2",iTop);
                m_HLElement.select(".HLBottom").attr("x1",iLeft).attr("y1",iBottom).attr("x2",iRight).attr("y2",iBottom);
            }
        };

        var unHLCell = function(item)
        {
            m_HLElement.attr("visibility", "hidden");
        };

        chart.mouseover = function(elem){
            var item = d3.select(elem);
            var clickedItemID = item.attr('id');
            if(clickedItemID && m_props.tooltip.enabled)
            {
              var tmpLength = clickedItemID.toString().length - randomSuffix.toString().length - 2;
                var dataIndex = clickedItemID.toString().substr(2 , tmpLength);
                
                var transform = m_selection.node().getTransformToElement(m_selection.node().ownerSVGElement);
                var svgBoundingBox = m_selection.node().ownerSVGElement.getBoundingClientRect();
                var rectBoundingBox =  elem.getBoundingClientRect();
                //showTooltip(dataIndex);
                var tooltipData = generateTooltipData(dataIndex);
                tooltipData.point = {
                        x : rectBoundingBox.left - svgBoundingBox.left + rectBoundingBox.width/2,
                        y : (rectBoundingBox.height > 16) ? rectBoundingBox.top - svgBoundingBox.top + 8 : rectBoundingBox.top - svgBoundingBox.top + rectBoundingBox.height/2
                };
                tooltipData.plotArea = {
                        x : transform.e,
                        y : transform.f,
                        width : m_width,
                        height : m_height
                };
                m_dispatch.showTooltip(tooltipDataHandler.formatTooltipData(tooltipData));
                HLCell(item);
            }

        };
        
        chart.afterUIComponentAppear = function(){
          m_dispatch.initialized(); 
        };
        
        
        chart.mouseout = function(elem){
            if(m_props.tooltip.enabled)
            {
                m_dispatch.hideTooltip();
            }

            var item = d3.select(elem);
            unHLCell(item);
        };



        /*
         * Add mouse interaction functions.
         */
        chart.parent = function(){
            return m_selection;
        };

        chart.highlight = function(elems){
            if(elems instanceof Array){
                for(var i = 0, len = elems.length; i < len; i++){
                    elems[i].setAttribute('opacity', 1);
                }
            }else{
                elems.setAttribute('opacity', 1);
            }
            if(hasDefaultSelection){
              defaultSelUtil.clearSelectionInfo(m_selection, true, elems);
            }
        };
        
        chart.unhighlight = function(elems){
            if(elems instanceof Array){
                for(var i = 0, len = elems.length; i < len; i++){
                    elems[i].setAttribute('opacity', 0.4);
                }
            }else{
                elems.setAttribute('opacity', 0.4);
            }
            if(hasDefaultSelection){
              defaultSelUtil.clearSelectionInfo(m_selection, false, elems);
            }
        };
        
        chart.clear = function(gray){
            if( gray == null || gray == false){
              var rects = m_selection.selectAll(SEL_CLASSDATAPOINT);
                  rects.attr('opacity', 1);
              if(hasDefaultSelection){
                defaultSelUtil.clearSelectionInfo(m_selection, false, rects);
              }
            }else{
              m_selection.selectAll(SEL_CLASSDATAPOINT).attr('opacity', 0.4);
            }
        };
        
        chart.width = function(_width){
            if (!arguments.length){
              return m_width;
            }
            m_width = _width;

            makeXScale();
            return chart;
        };

        chart.height = function(_height){
            if (!arguments.length){
              return m_height;
            }
            m_height = _height;
            
            makeYScale();
            return chart;       
        };

        chart.data = function(value){
            if (!arguments.length){
                return m_data;
            }

            m_data = value;
            m_redrawAll = true;
            
            m_dataXAxis = m_data.getAnalysisAxisDataByIdx(0);
            m_dataYAxis = m_data.getAnalysisAxisDataByIdx(1);
            m_dataRect = m_data.getMeasureValuesGroupDataByIdx(0);
            
            if(m_dataRect.values[0].rows[0][0].info && m_dataRect.values[0].rows[0][0].info.defaultSelection){
              hasDefaultSelection = true;
            }else{
              hasDefaultSelection = false;
            }
            
            return chart;
        };

        chart.properties = function(props){
            if (!arguments.length){
                return m_propsOutput;
            }           
            Objects.extend(true, m_props, props);
            Objects.extend(true, m_propsOutput, props);
            m_redrawAll = true;
            return chart;           
        };

        /**
         * interfaces for MBC legend selection
         * @param {Object} selectedData 
         * <pre>
         * {
         * ctx: {
         *   ranges: {
         *    endValue:100
         *    isLeftOpen:false
         *    isRightOpen:true
         *    startValue:84
         *   }
         * },
         * val: 84   
         * }
         * @returns {Array} d3 selections in the given range  
         */
        chart.getDatapointsByRange = function(selectedData){
          var datapoints = m_selection.selectAll(SEL_CLASSDATAPOINT)[0], ctxDatapoints = [], ranges = selectedData.ctx.ranges, data;
          for(var i = 0, len = datapoints.length; i < len; i++){
            data = datapoints[i].__data__.val;
            if(NumberUtils.isNoValue(selectedData.val)){
              if(NumberUtils.isNoValue(data)){
                ctxDatapoints.push(datapoints[i]);
              }
            }else{
              if(data < ranges.endValue && data > ranges.startValue){
                ctxDatapoints.push(datapoints[i]);
              }else{
                if(!ranges.isLeftOpen && data === ranges.startValue) {
                  ctxDatapoints.push(datapoints[i]);
                }else if(!ranges.isRightOpen && data === ranges.endValue){
                  ctxDatapoints.push(datapoints[i]);
                }
              }
            }
          }
          return ctxDatapoints;
        };
         
        chart.mbcLegendInfo = function(){
            var hColor = buildColorScale();
            return {
                'colorScale' : hColor,
                'title': m_dataRect.values[0].col
            };
        };

        chart.getPreferredSize = function(){
            
        };

        chart.categoryScaleX = function(){
            return m_xScale;
        };
       
        chart.isDrawXaxisBody = function(){
            var isOnlyOneCategroy = false;
            if(!m_dataYAxis)
            {
                isOnlyOneCategroy = true;
            }
            return (!isOnlyOneCategroy);
        };

        chart.categoryScaleY = function(){
            return m_yScale;
        };

        chart.dataLabel = function(_){
          
        };
        
        var buildColorScale = function()
        {
            //return a color scale like
            //var domainRg = [ [10,40], [40, 100] ];
            //var rangeRg = ['#ff0000', '#00ff00' ];
            //hColor = d3.scale.ordinal().domain(domainRg).range(rangeRg);

            var hColor = d3.scale.ordinal();

            //we need to draw some recs. So I will build a obj array, each item is a rec.
            var heatObjArray = [];
            
            var isOnlyOneCategroy = false;
            if(!m_dataYAxis)
            {
                isOnlyOneCategroy = true;
            }

            if(isOnlyOneCategroy)
            {
                var hData = m_dataRect.values[0].rows[0];
                //add the data to heatObjArray. the number of rectanges is the number of rectanglecolor.valuies.
                for(var i = 0; i < hData.length; i++)
                {
                    heatObjArray.push(hData[i]);
                }
            }
            else
            {
                //for the 2 categories, we have to count the numCol and the numRow.
                var hCol = m_dataXAxis.values[0].rows;
                var hRow = m_dataYAxis.values[0].rows;
                var hData = m_dataRect.values[0].rows;

                var numCol = hCol.length;
                var numRow = hRow.length;

                for(var i = 0; i < numRow; i++)
                {
                    for(var j = 0; j < numCol; j++)
                    {
                        heatObjArray.push(hData[i][j]);
                    }
                }
            }

            //count the max and min value of heatObjArray[i].val
            var maxVal = -Number.MAX_VALUE;
            var minVal = Number.MAX_VALUE;

            for(var iObj = 0; iObj < heatObjArray.length; iObj++)
            {
                if(!NumberUtils.isNoValue(heatObjArray[iObj].val))
                {
                    if(maxVal < heatObjArray[iObj].val)
                    {
                        maxVal = heatObjArray[iObj].val;
                    }

                    if(minVal > heatObjArray[iObj].val)
                    {
                        minVal = heatObjArray[iObj].val;
                    }
                }
            }
            //has "novalue" or not
            var hasNullValue = false;
            for(var i = 0; i < heatObjArray.length; i++)
            {
                if( NumberUtils.isNoValue(heatObjArray[i].val))
                {
                    hasNullValue = true;
                }
            }
            
            var numS = m_props.colornumber;

            var fontColorScale;
            if(minVal === Number.MAX_VALUE && maxVal === -Number.MAX_VALUE){
                fontColorScale = d3.scale.ordinal().domain([[]]).range([m_props.emptycolor]);
            } else {
                var scaleInfo = {
                    numberOfTicks: numS, 
                    startColor: m_props.startColor, 
                    endColor: m_props.endColor
                };
                if(m_props.colorPalette){
                  scaleInfo.colorPalette = m_props.colorPalette;
                }
                fontColorScale = MeasureBasedColoring.getColorScale(minVal, maxVal, false, scaleInfo);
                if(hasNullValue){
                    var domains = fontColorScale.domain();
                    var ranges = fontColorScale.range();
                    domains.push([]);
                    ranges.push(m_props.emptycolor);
                }
            }
            return fontColorScale;
            // //build the color
            // var heatColor = d3.scale.linear()
                // .domain([minVal, maxVal])
                // .range([m_props.startcolor, m_props.endcolor]);

            // //build a d3.scale.ordinal() for legend
            // var domainRg = [];
            // var rangeRg = [];
            // for(var j = 0; j < (numS-1); j++)
            // {
                // domainRg.push( [minVal + (maxVal-minVal)/numS*j, (minVal + (maxVal-minVal)/numS*(j+1))] );
                // rangeRg.push( heatColor(minVal + (maxVal-minVal)/(numS-1)*j) );
            // }

            // domainRg.push( [minVal + (maxVal-minVal)/numS*(numS-1), maxVal] );
            // rangeRg.push( heatColor(maxVal) );



            // if(m_props.discretecolor)
            // {
                // var colorArray;
                // if(m_props.colorPalette.length == 0)
                // {
                    // colorArray = ColorSeries.sap32().range();
                // }
                // else
                // {
                    // colorArray = m_props.colorPalette;
                // }

                // var j = 0;
                // for(var i = 0; i < rangeRg.length; i++)
                // {
                    // rangeRg[i] = colorArray[j];
                    // j = (j+1)%(colorArray.length);
                // }
            // }

            // if(hasNULL) //no value
            // {
                // domainRg.push([]);
                // rangeRg.push(m_props.emptycolor);
            // }


            // hColor = d3.scale.ordinal().domain(domainRg).range(rangeRg);

            // return hColor;
        }

        var makeXScale = function()
        {
            var isOnlyOneCategroy = false;
            if(!m_dataYAxis)
            {
                isOnlyOneCategroy = true;
            }
            

            var hCol = m_dataXAxis.values[0].rows;
            var dArray = [];
            for(var i = 0; i < hCol.length; i++)
            {
                dArray.push(i);
            }

            m_xScale = m_xScale.domain(dArray)
                                .rangeBands([0, m_width]);
        };

        var makeYScale = function()
        {
            var isOnlyOneCategroy = false;
            if(!m_dataYAxis)
            {
                isOnlyOneCategroy = true;
            }
            
            if(isOnlyOneCategroy)
            {
                //no yAxis
                m_yScale = m_yScale.domain([0,0])
                                .rangeBands([0,0]);
            }
            else
            {
                var hRow = m_dataYAxis.values[0].rows;
                var dArray = [];
                for(var i = 0; i < hRow.length; i++)
                {
                    dArray.push(i);
                }

                //y is from bottom
                m_yScale = m_yScale.domain(dArray)
                                .rangeBands([m_height, 0]);
            }
        };

        /**
         * get/set your event dispatch if you support event
         */
        chart.dispatch = function(_){
            if(!arguments.length)
                return m_dispatch;
            m_dispatch = _;
            return chart;
        };
        
        var extendObj = function(target, source)
        {
            for(var prop in source)
            {
                if(typeof(source[prop]) === "object")
                {
                    if(target[prop])
                    {
                        target[prop] = extendObj(target[prop], source[prop]);
                    }
                    else
                    {
                        target[prop] = source[prop];
                    }
                }
                else
                {
                    target[prop] = source[prop];
                }
            }
            return target;
        };
        
        chart.destroy = function(){
          if(ctx){
            ctx.destroy();
            ctx = null;
          }
          m_data = null;
          m_HLElement = null;
          m_xScale.domain([0,1]).range([0,1]);
          m_xScale = null;
          m_yScale.domain([0,1]).range([0,1]);
          m_yScale = null;
          m_dataXAxis = null;
          m_dataYAxis = null;
          m_dataRect = null;
          m_heatObjArray = [];
          m_selection = null;
          m_dataShape = null;
        };
        
        return chart;
    };

    return heatMap;
});

define('sap/viz/feeds/HeatMap',['sap/viz/feeds/Manifest','sap/viz/data/feed/Constants'],
function Setup(Manifest, constants) {
  var mainLabelAxisFeed = {
      'id' : 'mainLabelAxis',
      'name' : 'IDS_MAINLABELAXISNAME',
      'type' : constants.Type.Dimension,
      'min' : 1,
      'max' : 1,
      'aaIndex' : 1,
       'acceptMND': -1
    };

    var rectangleColorFeed = {
      'id' : 'rectangleColor',
      'name' : 'IDS_RECTANGLECOLOR',
      'type' : constants.Type.Measure,
      'min' : 1,
      'max' : 1,
      'mgIndex' : 1
    };

    var secondLabelAxisFeed = {
      'id' : 'secondaryLabelAxis',
      'name' : 'IDS_SECONDARYAXISLABELNAME',
      'type' : constants.Type.Dimension,
      'min' : 0,
      'max' : 1,
      'aaIndex' : 2,
       'acceptMND': -1
    };
  var feeds = {
    id : "heatMap",
    feeds : [ mainLabelAxisFeed, rectangleColorFeed, secondLabelAxisFeed ]
  };
  Manifest.register(feeds);
});
define('sap/viz/modules/manifests/HeatMap',['sap/viz/modules/manifests/Module','sap/viz/modules/Constants','sap/viz/modules/heatmap','sap/viz/feeds/HeatMap'],
function Setup(Manifest, Constants, fn) {

    var module = {
      'id' : 'sap.viz.modules.heatmap',
      'type' : Constants.Type.Chart,
      'name' : 'heatmap',
      'properties' : {
        'border' : {
          'name' : 'border',
      'description' : 'Settings for border.',
          'supportedValueType' : 'Object',
          'supportedValues' : {
            'visible' : {
                'name' : 'visible',
                'supportedValueType' : 'Boolean',
                'defaultValue' : true,
                'description' : 'Set visibility of zone edge.'
            },
          },
        },

        'animation' : {
          'name' : 'animation',
          'supportedValueType' : 'Object',
          'supportedValues' : {
            'dataLoading' : {
              'name' : 'dataLoading',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enable/disable data loading animation of plot area.'
            },
            'dataUpdating' : {
              'name' : 'dataUpdating',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enable/disable data updating animation of plot area.'
            },
            'resizing' : {
              'name' : 'resizing',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enable/disable resizing animation of plot area.'
            }
          },
          'description' : 'Settings for animation of plot area.',
          'example': "<a href='"+Constants.DocExample.SnippetUrl+"8535' target='_blank'>"+Constants.DocExample.TryThisValue+"</a>"
        },
        'startColor' : {
          'name' : 'startColor',
          'supportedValueType' : 'String',
          'defaultValue' : "#C2E3A9",
          'description' : 'Set heatMap startColor.'
        },
      
        'endColor' : {
          'name' : 'endColor',
          'supportedValueType' : 'String',
          'defaultValue' : "#73C03C",
          'description' : 'Set heatMap endColor.'
        },
        
        'colorPalette' : {
          'name' : 'colorPalette',
          'supportedValueType' : 'StringArray',
          'defaultValue' : undefined,
          'description' : 'Set the color palette for sectors. For example, ["#748CB2","#9CC677","#EACF5E","#F9AD79","#D16A7C"].'
        },

        'tooltip' : {
          'name' : 'tooltip',
      'description' : 'Settings for tooltip.',
          'supportedValueType' : 'Object',
          'supportedValues' : {
              'visible': {
                    'name' : 'enabled',
                    'supportedValueType' : 'Boolean',
                    'defaultValue' : true,
                    'description' : 'Set enabled/disabled tooltip.'
              },
          },
        'isExported' : false
        }
      },
      'events' : {
        'initialized': Constants.Event.Initialized.desc,
        'selectData' : Constants.Event.SelectData.desc,
      'deselectData' : Constants.Event.DeSelectData.desc,
      'showTooltip' : Constants.Event.TooltipShow.desc,
      'hideTooltip' : Constants.Event.TooltipHide.desc

      },
      'feeds' :{
          id:"heatMap"
      },
      'css' : {},
      'configure' : null,
      fn : fn
    };

    Manifest.register(module);
});
define('sap/viz/manifests/HeatMapChart',['sap/viz/manifests/Viz','sap/viz/modules/Constants','sap/viz/manifests/BaseSingleChart',
'sap/viz/modules/manifests/RootContainer','sap/viz/modules/manifests/Axis','sap/viz/modules/manifests/Tooltip',
'sap/viz/modules/manifests/HeatMap','sap/viz/modules/manifests/legend/Common'],
function Setup(Manifest, Constants) {
  var chart = {
    id : 'viz/heatmap',
    name : 'IDS_HEATMAPCHART',
    base : 'riv/base/single',
    modules : {
      root : {
        configure : {
          properties : {
            layout : { adjustPolicy : Constants.LAYOUT_ADJUST_POLICY.RELAYOUT }
          }
        },
        modules : {
          legends : {
            id : 'sap.viz.modules.legend',
            configure : {
              properties : {
                layout : {
                  position : 'right',
                  priority : 1
                }
              }
            },
            modules : {
              legend : {
                id : 'sap.viz.modules.legend.common',
                configure : {
                  description : 'The measure based coloring legend is a bar containing segments with different colors and a value scale on side to indicate the relationship between the values and colors in the chart. ',
                  properties : { type : 'MeasureBasedColoringLegend' },
                  propertiesOverride : {
                    isHierarchical : { isExported : false },
                    isScrollable :  { isExported: false },
                    formatString: { isExported: true }
                  }
                }
              }
            }
          },
          
          tooltip : {
            id : 'sap.viz.modules.tooltip',
            configure : {
              propertyCategory : 'tooltip',
              properties : { chartType : 'heatmap', orientation : 'bottom' }
            }
          },

          interaction : {
            id : 'sap.viz.modules.controller.interaction',
            configure : {
              clientID : 'main',
              propertyCategory : 'interaction',
              properties : {
                supportedEventNames: ['mouseup', 'mouseover', 'mouseout', 'touchstart']
              }
            }
          },

          main : {
            modules : {
              dataLabel : {
                id : 'sap.viz.modules.datalabel',
                configure : {
                  propertyCategory : 'dataLabel',
                  properties : {
                    paintingMode : 'rectCoordinate',
                    visible : false,
                    orientation : 'vertical',
                    position : 'inside',
                    automaticInOutside : false,
                    showZero : true,
                    isStackMode : false,
                    isPercentMode : false,
                    outsideVisible : false
                  },
                  propertiesOverride:{
                    position : {
                      isExported : false
                    }
                  }
                }
              },
              
              xAxis : {
                id : 'sap.viz.modules.axis',
                data : { aa : [ 1 ] },
                configure : {
                  description : 'Settings for the x axis of a normal heatmap.',
                  propertyCategory : 'xAxis',
                  properties : {
                    type : 'category',
                    position : 'bottom',
                    gridline : { visible : false }
                  },
                  propertiesOverride : {
                    gridline : { isExported : false },
                    label : { isExported : false },
                    axisline : { isExported : false },
                    scale : { 
                      fixedRange : {isExported : false},
                      minValue : {isExported : false},
                      maxValue : {isExported : false},
                      isExported : false 
                    }
                  }
                }
              },
              
              yAxis : {
                id : 'sap.viz.modules.axis',
                data : { aa : [ 2 ] },
                configure : {
                  description : 'Settings for the y axis of a normal heatmap.',
                  propertyCategory : 'yAxis',
                  properties : {
                    type : 'category',
                    position : 'left',
                    gridline : {
                      visible : false
                    }
                  },
                  propertiesOverride : {
                    gridline : { isExported : false },
                    label : { isExported : false },
                    axisline : { isExported : false },
                    scale : { 
                      fixedRange : {isExported : false},
                      minValue : {isExported : false},
                      maxValue : {isExported : false},
                      isExported : false 
                    }
                  }
                }
              },          
            
              plot : {
                id : 'sap.viz.modules.heatmap',
                configure : {
                  description : 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory : 'plotArea'
                }
              }
            }
          }
        }
      }
    },
    
    dependencies : {
      attributes : [ {
        targetModule : 'root.main.xAxis',
        target : 'scale',
        sourceModule : 'root.main.plot',
        source : 'categoryScaleX'
      },{
        targetModule : 'root.main.xAxis',
        target : 'isDrawBody',
        sourceModule : 'root.main.plot',
        source : 'isDrawXaxisBody'
      }, {
        targetModule : 'root.main.yAxis',
        target : 'scale',
        sourceModule : 'root.main.plot',
        source : 'categoryScaleY'
      },
      {
        targetModule : 'root.legends.legend',
        target : 'mbcLegendInfo',
        sourceModule : 'root.main.plot',
        source : 'mbcLegendInfo'
      }, {
          targetModule : 'root.legends.legend',
          target : 'setSelectionMode',
          sourceModule : 'root.interaction',
          source : 'getSelectionMode'
      }],
    
      events : [ {
        targetModule : 'root.interaction',
        listener : 'registerEvent',
        sourceModule : 'root.main.plot',
        type : 'initialized.interaction'
      }, {
        targetModule : 'root.interaction',
        listener : 'highlightedByLegend',
        sourceModule : 'root.legends.legend',
        type : 'highlightedByLegend'
      }, {
        targetModule : 'root.legends.legend',
        listener : 'deselectLegend',
        sourceModule : 'root.interaction',
        type : 'deselectLegend'
      }, {
        targetModule : 'root.tooltip',
        listener : 'showTooltip',
        sourceModule : 'root.main.plot',
        type : 'showTooltip'
        }, {
        targetModule : 'root.tooltip',
        listener : 'hideTooltip',
        sourceModule : 'root.main.plot',
        type : 'hideTooltip'
        },  {
        targetModule : 'root.main.dataLabel',
        listener : 'showLabel',
        sourceModule : 'root.main.plot',
        type : 'initialized.datalabel'
      }, {
        targetModule : 'root.main.dataLabel',
        listener : 'removeLabel',
        sourceModule : 'root.main.plot',
        type : 'startToInit.datalabel'
      }, {
        targetModule : 'root.interaction',
        listener : 'defaultSelection',
        sourceModule : 'root.main.plot',
        type : 'initialized.defaultSelection'
      }]
    }
  };

  Manifest.register(chart);
});
define('sap/viz/modules/treemap',['sap/viz/modules/dispatch','sap/viz/util/ColorSeriesGenerator','sap/viz/modules/util/tooltipDataHandler',
'sap/viz/util/NumberUtils','sap/viz/base/utils/TypeUtils',
'sap/viz/util/TextUtils','sap/viz/util/MeasureBasedColoring','sap/viz/lang/langManager',
'sap/viz/base/utils/ObjectUtils','sap/viz/base/utils/Objects','sap/viz/modules/util/BoundUtil',
'sap/viz/modules/util/defaultSelectionUtil'],
function Setup(dispatch, ColorSeries, tooltipDataHandler, NumberUtils, 
               TypeUtils, TextUtils, MeasureBasedColoring, langManager, 
               ObjectUtils, Objects, boundUtil,defaultSelUtil) {
    //treemap has no MND
    var treeMap = function(manifest, ctx) {

//--------------------------start of internal vars-----------------------------
        var randomSuffix = ObjectUtils.guid();              //diff all the id
        var extendObj = function(target, source)
        {
            for(var prop in source)
            {
                if(typeof(source[prop]) === "object")
                {
                    if(target[prop])
                    {
                        target[prop] = extendObj(target[prop], source[prop]);
                    }
                    else
                    {
                        target[prop] = source[prop];
                    }
                }
                else
                {
                    target[prop] = source[prop];
                }
            }
            return target;
        };      

        var m_labelAreaMouseOverColor = "#cccccc";
        var m_labelAreaMouseDownColor = "#808080";

        var m_selectionList = [];

        var m_width, m_height;
        var m_props =
        {
            "emptycolor":"#e0e0e0",
            'animation': {
                dataLoading : true,
                dataUpdating : true,
                resizing : true
            },
            'colornumber': 5,
            'discretecolor' : false,
            'colorPalette': [],
            tooltip: {
                enabled: true
            }
        };
        
        m_props = extendObj(m_props, manifest.props(null));

        var m_propsOutput = manifest.props(null);

        var m_styleTooltipFont = "'Open Sans', Arial, Helvetica, sans-serif";

        var m_data;

        var m_HLElement;

        var m_redrawAll = true;

        //it has 3 states: dataLoading, dataUpdating, resizing
        var m_drawState = "dataLoading";

        var m_className = "v-treemap";
        var m_classNameItem = "v-treemapitem";

        var m_padding;

        var m_xScale = d3.scale.ordinal();
        var m_yScale = d3.scale.ordinal();

        var m_dispatch = new dispatch('selectData', 'deselectData', 'initialized', 'showTooltip', 'hideTooltip', 'startToInit');

        var m_styleLineColor = "#ffffff";
        
        var m_dataDimensions;
        var m_dataRectWeight;
        var m_dataRectColor;

        var m_dataRects;

        var m_selection = null;

        var m_tooltipElement = null;
        var m_guidline = null;

        var m_effectManager = ctx.effectManager;
        var m_maxDimensionLevel = 6;

        var m_colorScale = null;
        var hasDefaultSelection = false;
        
        var m_defaultString = langManager.get('IDS_ISNOVALUE');

        var m_styleLabel = {};
        m_styleLabel.fontSize = "12px";
        m_styleLabel.fontWeight = "normal";
        m_styleLabel.fontFamily = "'Open Sans', Arial, Helvetica, sans-serif";
        m_styleLabel.fill = "#ffffff";

//--------------------------end of internal vars-------------------------------
//--------------------------start of internal functions------------------------
        var fastMeasure = function(_text, _style)
        {
            return TextUtils.fastMeasure(_text, _style['font-size'],
                                                _style['font-weight'],
                                                _style['font-family']);
        };

        var stringNoValueHandler = function(str)
        {
            if(str === null || str === undefined)
            {
                str = langManager.get('IDS_ISNOVALUE');
            }
            return str;
        };

        var generateTooltipData = function(dataIndex){

            var tooltipData = {
                body:[],
                footer:[]
            };
            var dataItem = m_dataRects[dataIndex];
            var weightValue = {
                    'name': stringNoValueHandler(dataItem.weight.col),
                    val:[{
                        value: NumberUtils.isNoValue(dataItem.weight.row.val)?m_defaultString:dataItem.weight.row.val
                    }]
            };
            
            tooltipData.body.push(weightValue);

            if(m_dataRectColor)
            {
                var colorValue = {
                        'name': stringNoValueHandler(dataItem.color.col),
                        val:[{
                            value: NumberUtils.isNoValue(dataItem.color.row.val)?m_defaultString:dataItem.color.row.val
                        }]
                };
                
                tooltipData.body.push(colorValue);
            }

            if(TypeUtils.isExist(m_dataDimensions)){
                for(var tval = m_dataDimensions.values, len = tval.length, i = len -1; i  >= 0; i--){
                    var footer = {};
                    footer.label = tval[i].col;
                    footer.value = tval[i].rows[dataIndex%tval[i].rows.length];
                    tooltipData.footer.push(footer);
                }
            }
                        
            return tooltipData;
        };

        var HLCell = function(item)
        {
            if(!NumberUtils.isNoValue(item.datum().val))
            {
                m_HLElement.attr("visibility", "visible");

                var iLeft = item.datum().left+m_padding;
                var iRight = item.datum().left + item.datum().width-m_padding;
                var iTop = item.datum().top+m_padding;
                var iBottom = item.datum().top + item.datum().height-m_padding;

                m_HLElement.select(".HLLeft").attr("x1",iLeft).attr("y1",iTop).attr("x2",iLeft).attr("y2",iBottom);
                m_HLElement.select(".HLRight").attr("x1",iRight).attr("y1",iTop).attr("x2",iRight).attr("y2",iBottom);
                m_HLElement.select(".HLTop").attr("x1",iLeft).attr("y1",iTop).attr("x2",iRight).attr("y2",iTop);
                m_HLElement.select(".HLBottom").attr("x1",iLeft).attr("y1",iBottom).attr("x2",iRight).attr("y2",iBottom);
            }
        };

        var unHLCell = function(item)
        {
            m_HLElement.attr("visibility", "hidden");
        };

        var endAnimation = function(d, i)
        {   
        
            if(  (d && d.level === 0 && d.index === 0 )|| (m_dataRects && m_dataRects.length === 0) /*no data*/|| (d === undefined && i === undefined) //not in "each"
            )
            {
                //When the endAnimation is called, animation may not be end. 
                //(it looks like a bug of d3 or browsers) 
                //So the opacity is 0.9999 or something, and then it will be changed to 1
                //We have to use setTimeout here in case defaultselection changes opacity again. 
                //not use m_dispatch.initialized();            
                setTimeout(m_dispatch.initialized, 0);
               
            }
        };

        var drawTreeMapItems = function(treeLevelRoot, rectObjs, redrawAll, iLevel)
        {
        
            if(rectObjs.length <= 0)
            {
                return;
            }

            //rectObjs.length > 0
            var isLeafItem = (rectObjs[0].children.length === 0);
            
            //draw this level
            if(redrawAll)
            {
                treeLevelRoot = treeLevelRoot.append("g").attr("class", m_className + "level" + rectObjs[0].level);
            }
            else
            {
                treeLevelRoot = treeLevelRoot.select("." + m_className + "level" + rectObjs[0].level);
            }

            var rectObjArrayToDraw = [];
            for(var i = 0; i < rectObjs.length; i++)
            {
                if(rectObjs[i].level === iLevel)
                {
                    rectObjArrayToDraw.push(rectObjs[i]);
                }
            }

            var rootClassName = treeLevelRoot.attr("class");
            var items = treeLevelRoot.selectAll("." + rootClassName + " > ." + m_classNameItem);

            items = items.data(rectObjArrayToDraw,function(d){return d.index;});
                                 
            var toDrawItems = items.enter();
            var toDeleteItems = items.exit();

            var gItems;//items of this level

            //help functions
            var textLength = function(data)
            {
                var style = {};
                style['font-size'] = m_styleLabel.fontSize;
                style['font-weight'] = m_styleLabel.fontWeight;
                style['font-family'] = m_styleLabel.fontFamily;

                var textHeight = fastMeasure(data.label, style).height;
                var textLength = 0;
                if(textHeight > data.height)
                {
                    textLength = -1;//do not show text
                }
                else
                {
                    textLength = data.width - 6;
                }
                return textLength;
            };

            var xLocation = function(d)
            {
//                return d.left+d.width/2;
              return (isLeafItem)?(d.width/2):(d.left+d.width/2);
            };

            var yLocation = function(d)
            {
                var style = {};
                style['font-size'] = m_styleLabel.fontSize;
                style['font-weight'] = m_styleLabel.fontWeight;
                style['font-family'] = m_styleLabel.fontFamily;
                var labelHeight;
                if(d.labelHeight !== undefined) {
                  labelHeight = d.labelHeight;
                } else {
                  labelHeight = fastMeasure(d.label, style).height;
                }

                if(d.children.length === 0)
                {
//                    return d.top + d.height/2 + labelHeight/2 - labelHeight/10;
                  return (isLeafItem)?(d.height/2 + labelHeight/2 - labelHeight/10):(d.top + d.height/2 + labelHeight/2 - labelHeight/10);
                }
                else
                {
                    return d.top + labelHeight - labelHeight/10;
                }
            };

            var getText = function(d)
            {
                var styleStr = "font-size:" + m_styleLabel.fontSize;
                styleStr += "font-weight:" + m_styleLabel.fontWeight;
                styleStr += "font-family:" + m_styleLabel.fontFamily;

                var text = "";
                if(d.showLabel)
                {
                    if(!d.label)
                    {
                        d.label = "";
                    }
                    text = TextUtils.ellipsis(d.label, this, textLength(d), styleStr);
                }
                return text;
            };

            var textLocation = function(d)
            {
                return "middle";
            };

            var textColor = function(d)
            {
                var tColor;
                if(d.children.length === 0)
                {
                    tColor = "white";
                }
                else
                {
                    if(d.level === (d.levelNum -1))//leaf
                    {
                        tColor = "white";
                    }
                    else if((d.levelNum - d.level) === 6)
                    {
                        tColor = "white";
                    }
                    else if((d.levelNum - d.level) === 5)
                    {
                        tColor = "white";
                    }
                    else if((d.levelNum - d.level) === 4)
                    {
                        tColor = "white";
                    }
                    else if((d.levelNum - d.level) === 3)
                    {
                        tColor = "#595959";
                    }
                    else//((d.levelNum - d.level) === 2)
                    {
                        tColor = "#464646";
                    }
                }

                return tColor;
            };

            var drawLabelArea = function(labelArea)
            {
                var rectRes = labelArea.attr("x", function(d){return (d.left+m_padding);})
                .attr("class", "v-labelarea")
                .attr("y", function(d){return (d.top+m_padding);})
                .attr("width", function(d){return d.width-2*m_padding>0?d.width-2*m_padding:0;})
                .attr("height", function(d){return d.labelHeight;})
                .attr("opacity", 0)
                .attr("shape-rendering", "crispEdges");

                rectRes.each(function(d){this.labelContexts = d.ctx;});

                return rectRes;
            };

            var drawRect = function(rect)
            {
                var rectRes = rect.attr("x", function(d){return (isLeafItem)?(0):(d.left+m_padding);})
                .attr("class", function(d){return (isLeafItem)?("v-item v-datapoint v-morphable-datapoint"):("v-item");})
                .attr("y", function(d){return (isLeafItem)?(0):(d.top+m_padding);})
                .attr("width", function(d){return d.width-2*m_padding>0?d.width-2*m_padding:0;})
                .attr("height",function(d){return d.height-2*m_padding>0?d.height-2*m_padding:0;})
                .attr("fill",function(d){
                    var parameter = {
                        drawingEffect:'normal',
                        fillColor : d.color};
                    return m_effectManager.register(parameter);
                    })
                .attr("shape-rendering", "crispEdges");

                return rectRes;
            };

            var drawLabels = function(labels)
            {
              var labelsRes = null;
              
              if (isLeafItem) {
                labelsRes = labels.attr("x", xLocation)
                .attr("y", yLocation)
                .attr('class', 'v-treemapdatalabel')
                //ie does not support this property
                //.attr("dominant-baseline", "central")//"auto")//"hanging")//"central")
                .attr("text-anchor", textLocation) // text-align
                .attr("fill", textColor)
                .attr("font-size", m_styleLabel.fontSize)
                .attr("font-family", m_styleLabel.fontFamily)
                .attr('pointer-events', 'none');
               } else {
                 labelsRes = labels.attr("x", xLocation)
                 .attr("y", yLocation)       
                  //ie does not support this property
                  //.attr("dominant-baseline", "central")//"auto")//"hanging")//"central")
                 .attr("text-anchor", textLocation) // text-align
                 .attr("fill", textColor)
                 .attr("font-size", m_styleLabel.fontSize)
                 .attr("font-family", m_styleLabel.fontFamily)
                 .attr('pointer-events', 'none');
               } 
              
              labelsRes.text(getText);
              return labelsRes;
            };

            var labelArea, labels;
            if(redrawAll)
            {
              var className = m_classNameItem;
              if(isLeafItem) {
                className += ' v-datashape';
              }
              
              gItems = toDrawItems.append("g").attr('class', className);
              if (isLeafItem) {
                gItems.attr('transform', function(d) {return 'translate(' + (d.left+m_padding) + ',' + (d.top+m_padding) + ')';});
               }
                //add rect
                var rects = gItems.append("rect");
                drawRect(rects);

                if(isLeafItem)
                {
                    rects.attr('id', function(d, i){return ("HM" + d.index + randomSuffix);});
                }
				else
				{
                    labelArea = gItems.append("rect");
                    drawLabelArea(labelArea);
				}

                //add labels
                labels = gItems.append("text");
                drawLabels(labels);

            }
            else
            {
                gItems = items;

                //move rects and labels
                var rect = items.select(".v-item");
                labelArea = items.select(".v-labelarea");
                labels = items.select("text");

                var resizeTime = 0;
                if(m_drawState === "resizing" && m_props.animation.resizing)
                {
                    resizeTime = 500;
                }

                if(resizeTime > 0)
                {
                    rect = rect.transition();
                    labels = labels.transition();
                }
                
                if (isLeafItem) {
                    if(resizeTime > 0)
                    {
                        gItems = gItems.transition();

                        gItems = gItems.attr('transform', function(d) {
                            var transformStr = 'translate(' + (d.left+m_padding) + ',' + (d.top+m_padding) + ')';
                            return transformStr;
                        });

                        gItems = gItems.delay(0).duration(resizeTime);
                    }
                    else
                    {
                      gItems.attr('transform', function(d) {
                        var transformStr = 'translate(' + (d.left+m_padding) + ',' + (d.top+m_padding) + ')';
                        return transformStr;
                        });
                    }
                }
                
                rect = drawRect(rect);
                if(!isLeafItem)
                {
                    drawLabelArea(labelArea);
                }
                labels = drawLabels(labels);
                        
                if(resizeTime > 0)
                {
                    rect.delay(0).duration(resizeTime).each('end',endAnimation);
                    labels.delay(0).duration(resizeTime);
                }
                else
                {
                    endAnimation();
                }
            }
            
            //draw children recursively
            var eachSubFun = function(thisObj, d, i)
            {
                var thisItem = d3.select(thisObj);
                var da = thisItem.datum().children;

                drawTreeMapItems(thisItem, thisItem.datum().children, redrawAll, iLevel + 1);
            };

            gItems.each(function(d, i)
                {
                    eachSubFun(this, d, i);
                }
            );

            //animation
            gItems = treeLevelRoot.selectAll("." + m_classNameItem);
            
            if(redrawAll)
            {
            
                var fadeInTime = 0;
                if(m_drawState === "dataLoading" && m_props.animation.dataLoading)
                {
                    fadeInTime = 1000;
                }
                else if(m_drawState === "dataUpdating" && m_props.animation.dataUpdating)
                {
                    fadeInTime = 500;
                }
                
                if(fadeInTime > 0)
                {
                    gItems.attr('opacity', 0);
                    gItems.transition()
                        .delay(0)
                        .duration(fadeInTime).attr('opacity', 1).each('end',endAnimation);
                }
                else
                {
                    gItems.attr('opacity', 1).each(endAnimation);
                    
                }
            }
            else
            {
                gItems.attr('opacity', 1);
                endAnimation();
            }

            return gItems;
        };

        var drawTreeMap = function(selection, rectObjs)
        {
            m_drawState = "resizing";
            if(m_redrawAll)
            {
                if(selection.selectAll("*").empty())
                {
                    m_drawState = "dataLoading";
                }
                else
                {
                    m_drawState = "dataUpdating";
                }      
                selection.selectAll("*").remove();
            }

            boundUtil.drawBound(selection, m_width, m_height);

            var treeLevelRoot = selection;
            
            var datashapesgroup = selection.selectAll('g.v-datashapesgroup');
            if(!TypeUtils.isExist(datashapesgroup[0][0])){
              datashapesgroup = selection.append('g').attr('class', 'v-datashapesgroup');
            }
            drawTreeMapItems(datashapesgroup, rectObjs, m_redrawAll, 0);
        
            //the HLCell Rectange
            if(m_redrawAll)
            {
                m_HLElement = selection.append('g').attr('class', 'v-element').attr("visibility", "hidden");
                m_HLElement.append('line').attr("x1",0).attr("y1",0).attr("x2",0).attr("y2",0).attr("shape-rendering", "crispEdges").attr("stroke","#6c6c6c");
                m_HLElement.append('line').attr("x1",0).attr("y1",0).attr("x2",0).attr("y2",0).attr("shape-rendering", "crispEdges").attr("stroke","#6c6c6c");
                m_HLElement.append('line').attr("x1",0).attr("y1",0).attr("x2",0).attr("y2",0).attr("shape-rendering", "crispEdges").attr("stroke","#6c6c6c");
                m_HLElement.append('line').attr("x1",0).attr("y1",0).attr("x2",0).attr("y2",0).attr("shape-rendering", "crispEdges").attr("stroke","#6c6c6c");
            }
            else
            {
                if(m_HLElement)
                {
                    m_HLElement.attr("visibility", "hidden");
                }
            }

            m_redrawAll = false;
        };

        var buildColorScale = function()
        {
            var maxVal, minVal;
            var hasNullValue;
            //return a color scale like
            //var domainRg = [ [10,40], [40, 100] ];
            //var rangeRg = ['#ff0000', '#00ff00' ];
            //d3.scale.ordinal().domain(domainRg).range(rangeRg);
            if(m_dataRectColor)
            {
                var colorObjArray = [];
                var i;

                var hData = m_dataRectColor.values[0].rows[0];
                //add the data to heatObjArray. the number of rectanges is the number of rectanglecolor.valuies.
                for(i = 0; i < hData.length; i++)
                {
                    colorObjArray.push(hData[i]);
                }

                //count the max and min value of heatObjArray[i].val
                maxVal = -Number.MAX_VALUE;
                minVal = Number.MAX_VALUE;

                for(var iObj = 0; iObj < colorObjArray.length; iObj++)
                {
                    if(!NumberUtils.isNoValue(colorObjArray[iObj].val))
                    {
                        if(maxVal < colorObjArray[iObj].val)
                        {
                            maxVal = colorObjArray[iObj].val;
                        }

                        if(minVal > colorObjArray[iObj].val)
                        {
                            minVal = colorObjArray[iObj].val;
                        }
                    }
                }
                //has "novalue" or not
                hasNullValue = false;
                for(i = 0; i < colorObjArray.length; i++)
                {
                    if( NumberUtils.isNoValue(colorObjArray[i].val))
                    {
                        hasNullValue = true;
                    }
                }
            }
            
            var numS = m_props.colornumber;

            var fontColorScale;
            if(minVal === Number.MAX_VALUE && maxVal === -Number.MAX_VALUE || (!m_dataRectColor)    
            ){
                //do not show the scale if there is no color measure, or there are just "No values"
                fontColorScale = undefined;
            } else {
                var scaleInfo = {
                    numberOfTicks: numS, 
                    startColor: m_props.startColor, 
                    endColor: m_props.endColor
                };
                if(m_props.colorPalette){
                  scaleInfo.colorPalette = m_props.colorPalette;
                }
                fontColorScale = MeasureBasedColoring.getColorScale(minVal, maxVal, false, scaleInfo);
                if(hasNullValue){
                    var domains = fontColorScale.domain();
                    var ranges = fontColorScale.range();
                    domains.push([]);
                    ranges.push(m_props.emptycolor);
                }
            }

            return fontColorScale;
        };

        var adjustValues = function(rectObjArray)
        {
            var i;
            for(i = 0 ; i < rectObjArray.length; i++)
            {
                var valArray = [];
                valArray.push(rectObjArray[i].val);
                valArray.push(rectObjArray[i].colorVal);

                rectObjArray[i].val = valArray;

                if(rectObjArray[i].children.length > 0)
                {
                    adjustValues(rectObjArray[i].children);
                }
            }
        };

//----------------layout function: squarifiedTreeMapLayout-----------------------------------------------
        //please refer to http://www.win.tue.nl/~vanwijk/stm.pdf
        var squarifiedTreeMapLayout = function(rectObjs)
        {
            var squarifiedLayout = function (rectObjs, baseRect, isCurrentLevelShowLabel)
            {
                //the function will set 
                //item.left
                //item.top
                //item.height
                //item.width
                //item.labelHeight
                //item.labelWidth
                //item.showLabel
                //item.needMoreHeightToShowLabel
                //for all rectObjs items, and may change items order
                var allWeight = 0;
                var i;
                for( i= 0; i < rectObjs.length; i++)
                {
                    allWeight += rectObjs[i].val;
                }

                //to make the sort stable, we must use a stable sort. But Javascript sort may not stable in 
                //Chrome. So using bubble sort here (do not use rectObjs.sort)
                //sort it!
                var weightOrder = function(objA, objB)
                {
                    var compareObjs = 0; 
                    if(objB.val !== objA.val)
                    {
                        compareObjs = objA.val - objB.val;
                    }
                    return compareObjs;
                };
                var tmpObj;
                for (var time = 0; time < rectObjs.length - 1; time++)
                {
                    for (i = rectObjs.length - 1; i> time; i--)
                    {
                        if (weightOrder(rectObjs[i], rectObjs[i - 1]) > 0)
                        {
                            tmpObj = rectObjs[i - 1];
                            rectObjs[i - 1] = rectObjs[i];
                            rectObjs[i] = tmpObj;
                        }
                    }
                }

                //the current row rectangle
                var currentRowRect = {
                        left:0,
                        top:0,
                        width:0,
                        height:0,
                        weight:0,
                        items:[],//indexs of items
                        worstRadio:0
                    };

                //currentRow rect + space rect
                var currentLiveRect = {
                        left:0,
                        top:0,
                        width:0,
                        height:0,
                        weight:0,
                        vertical:false
                    };
                
                //layout this level
                for(i = 0; i < rectObjs.length; i++)
                {
                    squarify(rectObjs, i, allWeight, currentRowRect, currentLiveRect, baseRect);
                }

                var itemIndex;
                //Now some additional work.
                for(itemIndex = 0; itemIndex < rectObjs.length; itemIndex++)
                {
                    //make sure no "NaN"
                    if(!rectObjs[itemIndex].left)
                    {
                        rectObjs[itemIndex].left = 0;
                    }

                    if(!rectObjs[itemIndex].top)
                    {
                        rectObjs[itemIndex].top = 0;
                    }

                    if(!rectObjs[itemIndex].width || rectObjs[itemIndex].width < 0)
                    {
                        rectObjs[itemIndex].width = 0;
                    }

                    if(!rectObjs[itemIndex].height || rectObjs[itemIndex].height < 0)
                    {
                        rectObjs[itemIndex].height = 0;
                    }

                    //draw label or not
                    var miniLabel = "";
                    if(rectObjs[itemIndex].label && rectObjs[itemIndex].label.length && rectObjs[itemIndex].label.length > 0)
                    {
                        var strBegin = rectObjs[itemIndex].label[0];
                        miniLabel = strBegin.concat("...");
                    }

                    var style = {};
                    style['font-size'] = m_styleLabel.fontSize;
                    style['font-weight'] = m_styleLabel.fontWeight;
                    style['font-family'] = m_styleLabel.fontFamily;

                    rectObjs[itemIndex].labelHeight = fastMeasure(miniLabel, style).height;
                    rectObjs[itemIndex].labelWidth = fastMeasure(miniLabel, style).width;

                    rectObjs[itemIndex].needMoreHeightToShowLabel = false;

                    if((rectObjs[itemIndex].labelHeight < rectObjs[itemIndex].height) && (rectObjs[itemIndex].labelWidth < rectObjs[itemIndex].width))
                    {
                        rectObjs[itemIndex].showLabel = true;
                    }
                    else
                    {
                        rectObjs[itemIndex].showLabel = false;
                        if(rectObjs[itemIndex].labelHeight >= rectObjs[itemIndex].height && rectObjs[itemIndex].val > 0)
                        {
                            rectObjs[itemIndex].needMoreHeightToShowLabel = true;
                        }
                    }
                }
                
                var isLeafNodeNeedMoreHeight = true;
                //check each leaf
                for(itemIndex = 0; itemIndex < rectObjs.length; itemIndex++)
                {
                    if(rectObjs[itemIndex].level === (rectObjs[itemIndex].levelNum - 1))
                    {
                        if(!rectObjs[itemIndex].needMoreHeightToShowLabel)
                        {
                            isLeafNodeNeedMoreHeight = false;
                            break;
                        }
                    }
                    else
                    {
                        isLeafNodeNeedMoreHeight = false;
                    }
                }

                var hideLabelFun = function(i)
                {
                    if(rectObjs[i].level !== (rectObjs[i].levelNum - 1))
                    {
                        rectObjs[i].showLabel = false;
                    }

                    //adjust base rect for children
                    baseRectForChild.top = rectObjs[i].top + m_padding*2;
                    baseRectForChild.left = rectObjs[i].left + m_padding*2;
                    baseRectForChild.width = rectObjs[i].width - m_padding*2 - m_padding;
                    baseRectForChild.height = rectObjs[i].height - m_padding*2 - m_padding;
                };

                if(!isLeafNodeNeedMoreHeight)
                {
                    for(i = 0; i < rectObjs.length; i++)
                    {
                        if(rectObjs[i].children.length > 0)
                        {
                            var showLabelForChildren = true;
                            if(!isCurrentLevelShowLabel)
                            {
                                showLabelForChildren = false;
                            }

                            var labelHeight = rectObjs[i].labelHeight;

                            var baseRectForChild = {};
                            baseRectForChild.top = rectObjs[i].top + m_padding*2 + labelHeight;
                            baseRectForChild.left = rectObjs[i].left + m_padding*2;
                            baseRectForChild.width = rectObjs[i].width - m_padding*2 - m_padding;
                            baseRectForChild.height = rectObjs[i].height - m_padding*2 - m_padding - labelHeight;

                            if(!showLabelForChildren)
                            {
                                hideLabelFun(i);
                            }

                            isLeafNodeNeedMoreHeight = squarifiedLayout(rectObjs[i].children, baseRectForChild, showLabelForChildren);
                            if((isLeafNodeNeedMoreHeight || !rectObjs[i].showLabel) && showLabelForChildren)//relayout
                            {
                                hideLabelFun(i);
                                isLeafNodeNeedMoreHeight = squarifiedLayout(rectObjs[i].children, baseRectForChild, false);
                            }
                        }
                    }
                }
                
                return isLeafNodeNeedMoreHeight;
            };

            var rectAspectRatio = function(rect)
            {
                //radio >= 1
                var radio;
                if(rect.height > rect.width)
                {
                    radio = rect.height/rect.width;
                }
                else
                {
                    radio = rect.width/rect.height;
                }

                radio = Math.floor(radio*1000);
                return radio;
            };

            var worstAspectRatio = function(rectObjs, newItemWeight, isInCurrentRow, currentRowRect, currentLiveRect)
            {
                //return the worst AspectRatio in the (changed) currentRow and the new item. 
                var worstRadio = 0;

                var newItemRect = {};
                if(isInCurrentRow)
                {
                    //if currentLiveRect is vertical, 
                    //it means items in currentRow is horizontal.
                    if(currentLiveRect.vertical)
                    {
                        newItemRect.width = currentLiveRect.width * (newItemWeight / (currentRowRect.weight + newItemWeight));
                        newItemRect.height = currentLiveRect.height * ((currentRowRect.weight + newItemWeight) / currentLiveRect.weight);
                    }
                    else
                    {
                        newItemRect.height = currentLiveRect.height * (newItemWeight / (currentRowRect.weight + newItemWeight));
                        newItemRect.width = currentLiveRect.width * ((currentRowRect.weight + newItemWeight) / currentLiveRect.weight);
                    }

                    worstRadio = rectAspectRatio(newItemRect);

                    //adjust items in currentRowRect, count the worstRadio
                    for(var i = 0; i < currentRowRect.items.length; i++)
                    {
                        var objIndex = currentRowRect.items[i];
                        var currentItemRect = {};
                        if(currentLiveRect.vertical)
                        {
                            currentItemRect.width = currentRowRect.width * (rectObjs[objIndex].val / (currentRowRect.weight + newItemWeight));
                            currentItemRect.height = currentLiveRect.height * ((currentRowRect.weight + newItemWeight) / currentLiveRect.weight);
                        }
                        else
                        {
                            currentItemRect.height = currentRowRect.height * (rectObjs[objIndex].val / (currentRowRect.weight + newItemWeight));
                            currentItemRect.width = currentLiveRect.width * ((currentRowRect.weight + newItemWeight) / currentLiveRect.weight);
                        }

                        //current item radio
                        var currentItemRadio = rectAspectRatio(currentItemRect);

                        //update the worst
                        if(worstRadio < currentItemRadio)
                        {
                            worstRadio = currentItemRadio;
                        }
                    }
                }
                else
                {
                    worstRadio = currentRowRect.worstRadio;
                }

                return worstRadio;
            };

            var getCurrentSpaceRect = function(currentRowRect, currentLiveRect)
            {
                var currentSpaceRect = {};
                currentSpaceRect.weight = currentLiveRect.weight - currentRowRect.weight;

                if(currentLiveRect.width === currentRowRect.width)
                {
                    currentSpaceRect.left = currentLiveRect.left;
                    currentSpaceRect.top = currentRowRect.top + currentRowRect.height;
                    currentSpaceRect.width = currentLiveRect.width;
                    currentSpaceRect.height = currentLiveRect.height - currentRowRect.height;
                }
                else
                {
                    currentSpaceRect.left = currentRowRect.left + currentRowRect.width;
                    currentSpaceRect.top = currentLiveRect.top;
                    currentSpaceRect.width = currentLiveRect.width - currentRowRect.width;
                    currentSpaceRect.height = currentLiveRect.height;
                }

                return currentSpaceRect;
            };

            var squarify = function (rectObjs, itemIndex, allWeight, currentRowRect, currentLiveRect, baseRect)
            {
                //itemIndex : const
                //allWeight : const
                //currentRowRect : be changed
                //currentLiveRect : be changed
                if(itemIndex === 0)
                {
                    rectObjs[itemIndex].left = baseRect.left;
                    rectObjs[itemIndex].top = baseRect.top;

                    if(baseRect.width > baseRect.height)
                    {
                        //layout the item
                        rectObjs[itemIndex].height = baseRect.height;
                        rectObjs[itemIndex].width = baseRect.width * (rectObjs[itemIndex].val / allWeight);
                        currentLiveRect.vertical = false;
                    }
                    else
                    {
                        //layout the item
                        rectObjs[itemIndex].width = baseRect.width;
                        rectObjs[itemIndex].height = baseRect.height * (rectObjs[itemIndex].val / allWeight);
                        currentLiveRect.vertical = true;
                    }
                    
                    //adjust currentRowRect
                    currentRowRect.left = baseRect.left;
                    currentRowRect.top = baseRect.top;
                    currentRowRect.width = rectObjs[itemIndex].width;
                    currentRowRect.height = rectObjs[itemIndex].height;
                    currentRowRect.weight = rectObjs[itemIndex].val;
                    currentRowRect.items.push(itemIndex);
                    currentRowRect.worstRadio = rectAspectRatio(currentRowRect);

                    //adjust currentLiveRect
                    currentLiveRect.left = baseRect.left;
                    currentLiveRect.top = baseRect.top;
                    currentLiveRect.width = baseRect.width;
                    currentLiveRect.height = baseRect.height;
                    currentLiveRect.weight = allWeight;
                }
                else if(itemIndex === (rectObjs.length -1))
                {
                    //just put it into the space
                    var currentSpaceRect = getCurrentSpaceRect(currentRowRect, currentLiveRect);
                    rectObjs[itemIndex].left = currentSpaceRect.left;
                    rectObjs[itemIndex].top = currentSpaceRect.top;
                    rectObjs[itemIndex].width = currentSpaceRect.width;
                    rectObjs[itemIndex].height = currentSpaceRect.height;
                }
                else
                {                
                    var inRowWorstRadio = (worstAspectRatio(rectObjs, rectObjs[itemIndex].val, true, currentRowRect, currentLiveRect));
                    var newRowWorstRadio = (worstAspectRatio(rectObjs, rectObjs[itemIndex].val, false, currentRowRect, currentLiveRect));

                    if(inRowWorstRadio < newRowWorstRadio)
                    {
                        //update the worstRadio
                        currentRowRect.worstRadio = inRowWorstRadio;

                        //adjust currentRowRect
                        currentRowRect.items.push(itemIndex);
                        currentRowRect.weight += rectObjs[itemIndex].val;

                        if(currentLiveRect.vertical)
                        {
                            currentRowRect.height = currentLiveRect.height * (currentRowRect.weight / currentLiveRect.weight);
                        }
                        else
                        {
                            currentRowRect.width = currentLiveRect.width * (currentRowRect.weight / currentLiveRect.weight);
                        }

                        //adjust items in currentRowRect
                        for(var i = 0; i < currentRowRect.items.length; i++)
                        {
                            var objIndex = currentRowRect.items[i];
                            if(currentLiveRect.vertical)
                            {
                                rectObjs[objIndex].width = currentRowRect.width * (rectObjs[objIndex].val / currentRowRect.weight);
                                rectObjs[objIndex].height = currentLiveRect.height * (currentRowRect.weight / currentLiveRect.weight);

                                rectObjs[objIndex].top = currentRowRect.top;
                                
                                if(i === 0)//for the first item in the row
                                {
                                    rectObjs[objIndex].left = currentRowRect.left;
                                }
                                else
                                {
                                    rectObjs[objIndex].left = rectObjs[objIndex-1].left + rectObjs[objIndex-1].width;
                                }
                            }
                            else
                            {
                                rectObjs[objIndex].height = currentRowRect.height * (rectObjs[objIndex].val / currentRowRect.weight);
                                rectObjs[objIndex].width = currentLiveRect.width * (currentRowRect.weight / currentLiveRect.weight);

                                rectObjs[objIndex].left = currentRowRect.left;
                                
                                if(i === 0)//for the first item in the row
                                {
                                    rectObjs[objIndex].top = currentRowRect.top;
                                }
                                else
                                {
                                    rectObjs[objIndex].top = rectObjs[objIndex-1].top + rectObjs[objIndex-1].height;
                                }
                            }
                        }

                        //do not need to adjust currentLiveRect.
                    }
                    else
                    {
                        //make a new currentLiveRect
                        var newCurrentLiveRect = getCurrentSpaceRect(currentRowRect, currentLiveRect);
                        
                        currentLiveRect.left = newCurrentLiveRect.left;
                        currentLiveRect.top = newCurrentLiveRect.top;
                        currentLiveRect.width = newCurrentLiveRect.width;
                        currentLiveRect.height = newCurrentLiveRect.height;
                        currentLiveRect.weight = newCurrentLiveRect.weight;

                        if(currentLiveRect.width > currentLiveRect.height)
                        {
                            currentLiveRect.vertical = false;
                        }
                        else
                        {
                            currentLiveRect.vertical = true;
                        }

                        //make a new currentRowRect
                        currentRowRect.left = currentLiveRect.left;
                        currentRowRect.top = currentLiveRect.top;
                        currentRowRect.weight = rectObjs[itemIndex].val;
                        if(currentLiveRect.vertical) 
                        {
                            currentRowRect.width = currentLiveRect.width;
                            currentRowRect.height = currentLiveRect.height * (rectObjs[itemIndex].val / currentLiveRect.weight);
                        }
                        else
                        {
                            currentRowRect.height = currentLiveRect.height;
                            currentRowRect.width = currentLiveRect.width * (rectObjs[itemIndex].val / currentLiveRect.weight);
                        }

                        currentRowRect.worstRadio = rectAspectRatio(currentRowRect);        
                        currentRowRect.items = [];
                        currentRowRect.items.push(itemIndex);

                        //layout the item
                        rectObjs[itemIndex].width = currentRowRect.width;
                        rectObjs[itemIndex].height = currentRowRect.height;
                        rectObjs[itemIndex].top = currentRowRect.top;
                        rectObjs[itemIndex].left = currentRowRect.left;
                    }
                }
            };
            //the entry of squarifiedTreeMapLayout
            var baseRect = {};
            baseRect.top = 0;
            baseRect.left = 0;
            baseRect.width = m_width;
            baseRect.height = m_height;
            
            var isLeafNodeNeedMoreHeight = squarifiedLayout(rectObjs, baseRect, true);
            if(isLeafNodeNeedMoreHeight)//relayout
            {
                squarifiedLayout(rectObjs, baseRect, false);
            }
        };

//----------------end of layout function: squarifiedTreeMapLayout-----------------------------------------------
        var isLabelArea = function(target)
        {
            var labelArea = false;
            if(target)
            {
                var classname = target.getAttribute('class');
                if(classname && classname.indexOf('v-labelarea') >= 0)//find it
                {
                    labelArea = true;
                }
            }
            return labelArea;
        };

        var buildTreeData = function(m_dataRects, iLevel, levelNum, startIndex, endIndex)
        {
            if(iLevel >= levelNum)
            {
                return [];
            }

            var rectObjArray = [];

            //each item:
            //color:#333333
            //colorValue:2
            //ctx:(color m ctx)
            //label:
            //val:(the weight) (if it is a negative value, we set it to 0)
            //children: a rectObjArray or []
            //level: leaf is 0
            //levelNum
            //index (id)
            var lastDimensionName;
            
            var childrenStartIndex = startIndex;
            var childrenEndIndex = childrenStartIndex + 1;

            for(var i = startIndex; i < endIndex; i++)
            {
                var rectObjItem = {};
                var currentDimensionName = m_dataRects[i].dimensions[iLevel].row.val;
                if(currentDimensionName !== lastDimensionName || 
                    iLevel === levelNum - 1) //for leaf items, we do not merge
                {
                    //set rectObjItem.color and rectObjItem.colorValue
                    var color = setItemColor(i, iLevel, levelNum, rectObjItem);

                    rectObjItem.label = m_dataRects[i].dimensions[iLevel].row.val;
                    rectObjItem.level = iLevel;
                    rectObjItem.levelNum = levelNum;
                    rectObjItem.isTreeMap = true;
                    
                    if(iLevel === levelNum - 1)//leaf node
                    {
                        var ctxArray = [];
                        var infoArray = [];
                        ctxArray.push(m_dataRects[i].weight.row.ctx);
                        infoArray.push(m_dataRects[i].weight.row.info);
                        if(m_dataRects[i].color)
                        {
                            ctxArray.push(m_dataRects[i].color.row.ctx);
                            infoArray.push(m_dataRects[i].color.row.info);
                        }
                        rectObjItem.ctx = ctxArray;
                        rectObjItem.info = infoArray;
                    }
                    else
                    {
                        rectObjItem.ctx = [];
                    }
                    rectObjItem.index = i;
                    
                    var colorVal = null;
                    if(m_dataRects[i].color)
                    {
                        colorVal = m_dataRects[i].color.row.val;
                    }

                    var weightVal = 0;
                    //https://tipjira.pgdev.sap.corp/browse/BITVIZA-137 "Treat negative value as zero."
                    if(m_dataRects[i].weight.row.val >= 0)
                    {
                        //rectObjItem.val = m_dataRects[i].weight.row.val;
                        weightVal = m_dataRects[i].weight.row.val;
                    }

                    rectObjItem.val = (weightVal);
                    rectObjItem.colorVal = (colorVal);

                    //we should update the children of previous item
                    if(rectObjArray.length >0)
                    {
                        rectObjArray[rectObjArray.length -1].children = buildTreeData(m_dataRects,
                                       (iLevel + 1), levelNum, childrenStartIndex, childrenEndIndex);

                        childrenStartIndex = i;
                        childrenEndIndex = childrenStartIndex + 1;
                    }

                    //add new item and update childrenIndexs
                    rectObjArray.push(rectObjItem);
                }
                else
                {
                    //update the last item
                    if(m_dataRects[i].weight.row.val >= 0)
                    {
                        rectObjArray[rectObjArray.length -1].val += m_dataRects[i].weight.row.val;
                    }
                    
                    childrenEndIndex++;
                }
                lastDimensionName = currentDimensionName;

                if(i === endIndex - 1)
                {
                    //we should update the children of previous item
                    if(rectObjArray.length >0)
                    {
                        rectObjArray[rectObjArray.length -1].children = buildTreeData(m_dataRects,
                                       (iLevel + 1), levelNum, childrenStartIndex, childrenEndIndex);
                    }
                }
            }

            var k;
            var m;
            //update ctxs
            for(k = 0; k < rectObjArray.length; k++)
            {
                for(m = 0; m < rectObjArray[k].children.length; m++)
                {
                    rectObjArray[k].ctx = rectObjArray[k].ctx.concat(rectObjArray[k].children[m].ctx);
                }
            }

            return rectObjArray;
        };

        var setItemColor = function(index, iLevel, levelNum, rectObjItem)
        {
            if(iLevel !== (levelNum - 1))//not leaf
            {
                //set rectObjItem.color
                var level = (levelNum -1 - iLevel);
                if(level === 1)
                {
                    rectObjItem.color = "#f9f9f9";
                }
                else if(level === 2)
                {
                    rectObjItem.color = "#e3e3e3";
                }
                else if(level === 3)
                {
                    rectObjItem.color = "#bfbfbf";
                }
                else if(level === 4)
                {
                    rectObjItem.color = "#989898";
                }
                else if(level === 5)
                {
                    rectObjItem.color = "#717171";
                }
                //set rectObjItem.colorValue
                rectObjItem.colorValue = Number.MAX_VALUE;
            }
            else
            {
                if(m_dataRects[index].color)
                {
                    //set colorValue
                    rectObjItem.colorValue = m_dataRects[index].color.row.val;

                    //set rectObjItem.color. m_colorScale is set
                    if(m_colorScale)
                    {
                        var domainArray = m_colorScale.domain();

                        if(NumberUtils.isNoValue(rectObjItem.colorValue))
                        {
                            rectObjItem.color = m_props.emptycolor;
                        }
                        else
                        {
                            var domainValue;
                            for( var j = 0; j<domainArray.length; j++)
                            {
                                var tdv = domainArray[j];
                                if ((j === domainArray.length-1) || (domainArray[j+1].length === 0)) {
                                    domainValue = tdv;
                                    break;
                                }
                                if ((rectObjItem.colorValue >= tdv[0]) && (rectObjItem.colorValue < tdv[1])) {
                                    domainValue = tdv;
                                    break;
                                }
                            }
                            rectObjItem.color = m_colorScale(domainValue);
                        }
                    }
                    else
                    {
                        rectObjItem.color = m_props.emptycolor;
                    }
                }
                else
                {
                    rectObjItem.colorValue = Number.MAX_VALUE;

                    //set rectObjItem.color
                    var colorArray = ColorSeries.sap32().range();
                    rectObjItem.color = colorArray[0];
                }
            }
        };

//--------------------------end of internal functions--------------------------
//--------------------------external functions---------------------------------

        function chart(selection) {
            m_selection = selection;
            m_dispatch.startToInit();
            if(m_props.border && m_props.border.visible)
            {
                m_padding = 1;
            }
            else
            {
                m_padding = 0;
            }
            //build color scale
            m_colorScale = buildColorScale();

            //prepare tree data, and draw the treeMap level by level
            var levelNum = m_dataRects[0].dimensions.length;

            var rectObjArray = buildTreeData(m_dataRects, 0, levelNum, 0, m_dataRects.length);

            //existing data is read-only in layout and draw functions
            //layout it recursively
            squarifiedTreeMapLayout(rectObjArray);

            //adjust val
            adjustValues(rectObjArray);

            //draw the treemap recursively (update it, or redraw it)
            drawTreeMap(selection, rectObjArray);

            return chart;
        }

        chart.dataLabel = function(_){
          
        };
        
        chart.afterUIComponentAppear = function(){
          m_dispatch.initialized(); 
          // console.log('afterUIComponentAppear');
        };
        
        
        chart.mouseover = function(elem){
            if(isLabelArea(elem))
            {
                //high light the target
                elem.setAttribute("opacity", 1);
                elem.setAttribute("class", "v-labelarea v-hovershadow");
                elem.setAttribute("fill", m_labelAreaMouseOverColor);
            }

            var item = d3.select(elem);
            var clickedItemID = item.attr('id');
            if(clickedItemID && m_props.tooltip.enabled)
            {
              var tmpLength = clickedItemID.toString().length - randomSuffix.toString().length - 2;
                var dataIndex = clickedItemID.toString().substr(2 , tmpLength);
                
                var transform = m_selection.node().getTransformToElement(m_selection.node().ownerSVGElement);
                var svgBoundingBox = m_selection.node().ownerSVGElement.getBoundingClientRect();
                var rectBoundingBox =  elem.getBoundingClientRect();
                //showTooltip(dataIndex);
                var tooltipData = generateTooltipData(dataIndex);
                tooltipData.point = {
                        x : rectBoundingBox.left - svgBoundingBox.left + rectBoundingBox.width/2,
                        y : (rectBoundingBox.height > 16) ? rectBoundingBox.top - svgBoundingBox.top + 8 : rectBoundingBox.top - svgBoundingBox.top + rectBoundingBox.height/2
                };
                tooltipData.plotArea = {
                        x : transform.e,
                        y : transform.f,
                        width : m_width,
                        height : m_height
                };
                m_dispatch.showTooltip(tooltipDataHandler.formatTooltipData(tooltipData));
                HLCell(item);
            }

        };
        
        chart.mouseout = function(target){
            if(isLabelArea(target))
            {
                //un high light all the label areas
                target.setAttribute("class", "v-labelarea");
                target.setAttribute("opacity", 0);
            }
            if(m_props.tooltip.enabled)
            {
                m_dispatch.hideTooltip();
            }
            unHLCell(target);
        };   
        
        chart.cleanLabelAreas = function()
        {
            if(m_selection)
            {
                m_selection.selectAll(".v-labelarea")
                           .attr("class", "v-labelarea")
                           .attr("opacity", 0);
            }
        };

        chart.mouseup = function(target){
            if(isLabelArea(target))
            {
                //un high light the target
                target.setAttribute("opacity", 1);
                target.setAttribute("class", "v-labelarea v-hovershadow");            
                target.setAttribute("fill", m_labelAreaMouseOverColor);
            }
        };
        
        chart.mousedown = function(target){
            //high light the target
            target.setAttribute("opacity", 1); 
            target.setAttribute("class", "v-labelarea v-hovershadow-mousedown");
            target.setAttribute("fill", m_labelAreaMouseDownColor);
        };

        /*
         * Add mouse interaction functions.
         */
        chart.parent = function(){
            return m_selection;
        };

        chart.highlight = function(elems){
            if(elems instanceof Array){
                for(var i = 0, len = elems.length; i < len; i++){
                    elems[i].setAttribute('opacity', 1);
                }
            }else{
                elems.setAttribute('opacity', 1);
            }
            
            if(hasDefaultSelection){
              defaultSelUtil.clearSelectionInfo(m_selection, true, elems);
            }
        };
        
        chart.unhighlight = function(elems){
            if(elems instanceof Array){
                for(var i = 0, len = elems.length; i < len; i++){
                    elems[i].setAttribute('opacity', 0.4);
                }
            }else{
                elems.setAttribute('opacity', 0.4);
            }
            
            if(hasDefaultSelection){
              defaultSelUtil.clearSelectionInfo(m_selection, false, elems);
            }
        };
        
        chart.clear = function(gray){
          if( !gray ){
            var rects = m_selection.selectAll('.v-datapoint');
                rects.attr('opacity', 1);
            if(hasDefaultSelection){
              defaultSelUtil.clearSelectionInfo(m_selection, false, rects);
            }
          }else{
            m_selection.selectAll('.v-datapoint').attr('opacity', 0.4);
          }
      };
        
        chart.width = function(_width){
            if (!arguments.length){
              return m_width;
            }
            m_width = _width;
            return chart;
        };

        chart.height = function(_height){
            if (!arguments.length){
              return m_height;
            }
            m_height = _height;
            return chart;       
        };

        chart.data = function(value){
            if (!arguments.length){
                return m_data;
            }

            m_data = value;
            m_redrawAll = true;
            
            m_dataDimensions = m_data.getAnalysisAxisDataByIdx(0);
            m_dataRectWeight = m_data.getMeasureValuesGroupDataByIdx(0);
            m_dataRectColor = m_data.getMeasureValuesGroupDataByIdx(1);
            
            hasDefaultSelection = false;
            if(m_dataRectWeight.values[0].rows[0][0].info && m_dataRectWeight.values[0].rows[0][0].info.defaultSelection){
              hasDefaultSelection = true;
            }

            if(m_dataRectColor)
            {
                if(m_dataRectColor.values[0].rows[0][0].info && m_dataRectColor.values[0].rows[0][0].info.defaultSelection){
                  hasDefaultSelection = true;
                }
            }
            
            var dataDimensions = m_data.getAnalysisAxisDataByIdx(0);
            var dataRectWeight = m_data.getMeasureValuesGroupDataByIdx(0);
            var dataRectColor = m_data.getMeasureValuesGroupDataByIdx(1);

            //make the rect array which has all datas(not a tree)
            m_dataRects = [];

            //add weight
            var vArray = dataRectWeight.values[0].rows[0];
            var i, dataRectItem;
            for(i = 0; i < vArray.length; i++)
            {
                dataRectItem = {};

                var weightObj = {};
                weightObj.col = dataRectWeight.values[0].col;
                weightObj.row = vArray[i];

                dataRectItem.weight = weightObj;

                m_dataRects.push(dataRectItem);
            }

            //add color
            if(dataRectColor)
            {
                vArray = dataRectColor.values[0].rows[0];
                for(i = 0; i < m_dataRects.length; i++)
                {
                    dataRectItem = m_dataRects[i];

                    var colorObj = {};
                    colorObj.col = dataRectColor.values[0].col;
                    colorObj.row = vArray[i];

                    dataRectItem.color = colorObj;
                }
            }

            //add dimensions (6 levels at most)
            vArray = dataDimensions.values;
            for(i = 0; i < m_dataRects.length; i++)
            {
                dataRectItem = m_dataRects[i];

                var dimensionArray = [];
                var levels = vArray.length;
                if(levels > m_maxDimensionLevel)
                {
                    levels = m_maxDimensionLevel;
                }
                for(var j = 0; j < levels; j++)
                {
                    var dimensionItem = {};
                    dimensionItem.col = dataDimensions.values[j].col;
                    dimensionItem.row = dataDimensions.values[j].rows[i];

                    dimensionArray.push(dimensionItem);
                }

                dataRectItem.dimensions = dimensionArray;
            }
            
            return chart;
        };

        chart.properties = function(props){
            if (!arguments.length){
                return m_propsOutput;
            }           
            Objects.extend(true, m_props, props);
            Objects.extend(true, m_propsOutput, props);
            m_redrawAll = true;
            return chart;           
        };

        /**
         * interfaces for MBC legend selection
         * @param {Object} selectedData 
         * <pre>
         * {
         * ctx: {
         *   ranges: {
         *    endValue:100
         *    isLeftOpen:false
         *    isRightOpen:true
         *    startValue:84
         *   }
         * },
         * val: 84   
         * }
         * @returns {Array} d3 selections in the given range  
         */
        chart.getDatapointsByRange = function(selectedData){
          var datapoints = m_selection.selectAll('.v-datapoint')[0], ctxDatapoints = [], ranges = selectedData.ctx.ranges, data;
          for(var i = 0, len = datapoints.length; i < len; i++){
            data = datapoints[i].__data__.colorValue;
            if(NumberUtils.isNoValue(selectedData.val)){
              if(NumberUtils.isNoValue(data)){
                ctxDatapoints.push(datapoints[i]);
              }
            }else{
              if(data < ranges.endValue && data > ranges.startValue){
                ctxDatapoints.push(datapoints[i]);
              }else{
                if(!ranges.isLeftOpen && data === ranges.startValue) {
                  ctxDatapoints.push(datapoints[i]);
                }else if(!ranges.isRightOpen && data === ranges.endValue){
                  ctxDatapoints.push(datapoints[i]);
                }
              }
            }
          }
          return ctxDatapoints;
        };
         
        /**
         * for MBC legend
         */
        chart.mbcLegendInfo = function(){
            var hColor = buildColorScale();
            var title = "";
            if(m_dataRectColor)
            {
                title = m_dataRectColor.values[0].col;
            }
            return {
                'colorScale' : hColor,
                'title': title
            };
        };

        /**
         * required by the layout
         */
        chart.getPreferredSize = function(){  
          
        };

        /**
         * get/set your event dispatch if you support event
         */
        chart.dispatch = function(_){
            if(!arguments.length){
                return m_dispatch;
            }
            m_dispatch = _;
            return chart;
        };
        
        chart.destroy = function(){
            if(m_xScale){
              m_xScale.domain([0,1]).range([0,1]);
            }
            if(m_yScale){
              m_yScale.domain([0,1]).range([0,1]);
            }
            m_yScale = null;
            m_xScale = null;
            m_dataDimensions = null;
            m_dataRectWeight = null;
            m_dataRectColor = null;
            m_dataRects = null;
            m_selection = null;
            m_tooltipElement = null;
            m_guidline = null;
            m_colorScale = null;
            m_styleLabel = null;
            m_selectionList = null;
            m_HLElement = null;
            
            //destroy ctx
           if(ctx){
             ctx.destroy();
             ctx = null;
           }
        };
        return chart;
    };

    return treeMap;
});

define('sap/viz/feeds/TreeMap',['sap/viz/feeds/Manifest','sap/viz/data/feed/Constants'],
function Setup(Manifest, constants) {
  var rectangleTitleFeed = {
    'id' : 'rectangleTitle',
    'name' : 'IDS_RECTANGLETITLE',
    'type' : constants.Type.Dimension,
    'min' : 1,
    'max' : 1,
    'aaIndex' : 1,
    'acceptMND': -1,
    'maxStackedDims' : 6
  };

  var rectangleWeightFeed = {
    'id' : 'rectangleWeight',
    'name' : 'IDS_RECTANGLEWEIGHT',
    'type' : constants.Type.Measure,
    'min' : 1,
    'max' : 1,
    'mgIndex' : 1
  };

  var rectangleColorFeed = {
    'id' : 'rectangleColor',
    'name' : 'IDS_RECTANGLECOLOR',
    'type' : constants.Type.Measure,
    'min' : 0,
    'max' : 1,
    'mgIndex' : 2
  };
  var feeds = {
    id : "treeMap",
    feeds : [ rectangleTitleFeed, rectangleColorFeed, rectangleWeightFeed ]
  };
  Manifest.register(feeds);
});
define('sap/viz/modules/manifests/TreeMap',['sap/viz/modules/manifests/Module','sap/viz/modules/Constants','sap/viz/modules/treemap','sap/viz/feeds/TreeMap'],
function Setup(Manifest, Constants, fn)
{
    var module =
    {
      'id' : 'sap.viz.modules.treemap',
      'type' : Constants.Type.Chart,
      'name' : 'treemap',
      'properties' : {
        'border' : {
          'name' : 'border',
          'description' : 'Settings for border.',
          'supportedValueType' : 'Object',
          'supportedValues' : {
            'visible' : {
                'name' : 'visible',
                'supportedValueType' : 'Boolean',
                'defaultValue' : true,
                'description' : 'Set visibility of zone edge.'
            },
          },
        },

        'animation' : {
          'name' : 'animation',
          'supportedValueType' : 'Object',
          'supportedValues' : {
            'dataLoading' : {
              'name' : 'dataLoading',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enable/disable data loading animation of plot area.'
            },
            'dataUpdating' : {
              'name' : 'dataUpdating',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enable/disable data updating animation of plot area.'
            },
            'resizing' : {
              'name' : 'resizing',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enable/disable resizing animation of plot area.'
            }
          },
          'description' : 'Settings for animation of plot area.',
          'example': "<a href='"+Constants.DocExample.SnippetUrl+"8535' target='_blank'>"+Constants.DocExample.TryThisValue+"</a>"
        },
        'startColor' : {
          'name' : 'startColor',
          'supportedValueType' : 'String',
          'defaultValue' : "#C2E3A9",
          'description' : 'Set treeMap startColor.'
        },
      
        'endColor' : {
          'name' : 'endColor',
          'supportedValueType' : 'String',
          'defaultValue' : "#73C03C",
          'description' : 'Set treeMap endColor.'
        },
        
        'colorPalette' : {
          'name' : 'colorPalette',
          'supportedValueType' : 'StringArray',
          'defaultValue' : undefined,
          'description' : 'Set the color palette for sectors. For example, ["#748CB2","#9CC677","#EACF5E","#F9AD79","#D16A7C"].'
        },

        'tooltip' : {
          'name' : 'tooltip',
          'description' : 'Settings for tooltip.',
          'supportedValueType' : 'Object',
          'supportedValues' : {
              'visible': {
                    'name' : 'enabled',
                    'supportedValueType' : 'Boolean',
                    'defaultValue' : true,
                    'description' : 'Set enabled/disabled tooltip.'
              },
          },
          'isExported': false
        }
      },
      'events' :
      {
        'initialized': Constants.Event.Initialized.desc,
        'selectData' : Constants.Event.SelectData.desc,
        'deselectData' : Constants.Event.DeSelectData.desc,
        'showTooltip' : Constants.Event.TooltipShow.desc,
        'hideTooltip' : Constants.Event.TooltipHide.desc
      },
      'feeds' :{
          id:"treeMap"
      },
      'css' : {},
      'configure' : null,
      fn : fn
    };

    Manifest.register(module);
});
define('sap/viz/manifests/TreeMapChart',['sap/viz/manifests/Viz','sap/viz/modules/Constants','sap/viz/modules/manifests/RootContainer',
'sap/viz/manifests/BaseSingleChart','sap/viz/modules/manifests/Tooltip','sap/viz/modules/manifests/TreeMap'],
function Setup ( Manifest, Constants ) {
  var chart = {
    id : 'viz/treemap',
    name : 'IDS_TREEMAPCHART',
    base : 'riv/base/single',
    modules : {
      root : {
        configure : {
          properties : {
            layout : { adjustPolicy : Constants.LAYOUT_ADJUST_POLICY.RELAYOUT }
          }
        },
        modules : {
          legends : {
            modules : {
              legend : {
                id : 'sap.viz.modules.legend.common',
                configure : {
                  'description': 'The measure based coloring legend is a bar containing segments with different colors and a value scale on side to indicate the relationship between the values and colors in the chart. ',
                  properties : { type : 'MeasureBasedColoringLegend' },
                  propertiesOverride : {
                    isHierarchical : { isExported : false },
                    isScrollable :  { isExported: false },
                    formatString: { isExported: true }
                  }
                }
              }
            }
          },
          tooltip : {
            id : 'sap.viz.modules.tooltip',
            configure : {
              propertyCategory : 'tooltip',
              properties : {
                chartType : 'treemap',
                orientation : 'bottom'
              }
            }
          },
          
          interaction : {
            id : 'sap.viz.modules.controller.interaction',
            configure : {
              clientID : "main",
              propertyCategory : 'interaction',
              properties : {
                supportedEventNames: ['mouseup', 'mouseover', 'mouseout', 'touchstart']
              }
            }
          },
    
          main : {
            modules : {
              dataLabel : {
                id : 'sap.viz.modules.datalabel',
                configure : {
                  propertyCategory : 'dataLabel',
                  properties : {
                    paintingMode : 'rectCoordinate',
                    visible : false,
                    orientation : 'vertical',
                    position : 'inside',
                    automaticInOutside : false,
                    showZero : true,
                    isStackMode : false,
                    isPercentMode : false,
                    isTreeMap : true,
                    outsideVisible : false
                  },
                  propertiesOverride:{
                    position : {
                      isExported : false
                    }
                  }
                }
              },
              plot : {
                id : 'sap.viz.modules.treemap',
                configure : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory : 'plotArea'
                }
              }
            }
          }
        }
      }
    },
    dependencies : {
      attributes : [ 
      {
        targetModule : 'root.legends.legend',
        target : 'mbcLegendInfo',
        sourceModule : 'root.main.plot',
        source : 'mbcLegendInfo'
      }, {
          targetModule : 'root.legends.legend',
          target : 'setSelectionMode',
          sourceModule : 'root.interaction',
          source : 'getSelectionMode'
      }],
    
          events : [ {
              targetModule : 'root.interaction',
              listener : 'registerEvent',
              sourceModule : 'root.main.plot',
              type : 'initialized.interaction'
          }, {
          targetModule : 'root.interaction',
          listener : 'highlightedByLegend',
          sourceModule : 'root.legends.legend',
          type : 'highlightedByLegend'
      }, {
              targetModule : 'root.legends.legend',
            listener : 'deselectLegend',
            sourceModule : 'root.interaction',
            type : 'deselectLegend'
      }, {
          targetModule : 'root.tooltip',
          listener : 'showTooltip',
          sourceModule : 'root.main.plot',
          type : 'showTooltip'
        }, {
          targetModule : 'root.tooltip',
          listener : 'hideTooltip',
          sourceModule : 'root.main.plot',
          type : 'hideTooltip'
        }, {
          targetModule : 'root.main.dataLabel',
          listener : 'showLabel',
          sourceModule : 'root.main.plot',
          type : 'initialized.datalabel'
        }, {
          targetModule : 'root.main.dataLabel',
          listener : 'removeLabel',
          sourceModule : 'root.main.plot',
          type : 'startToInit.datalabel'
        }, {
          targetModule : 'root.interaction',
          listener : 'defaultSelection',
          sourceModule : 'root.main.plot',
          type : 'initialized.defaultSelection'
        }]
    }
  };

  Manifest.register(chart);
});
define('sap/viz/manifests/SimpleChart',['sap/viz/manifests/Viz','sap/viz/modules/manifests/RootContainer','sap/viz/modules/manifests/Title',
'sap/viz/modules/manifests/DataLabel',
'sap/viz/modules/manifests/layout/Dock',
'sap/viz/modules/manifests/layout/Stack'],
function Setup(Manifest) {
  var chart = {
    id : 'riv/simple',
    name : 'IDS_SIMPLECHART',
    'abstract' : true,
    modules : {
      root : {
        id : 'sap.viz.modules.rootContainer',
        configure : {
          propertyCategory : 'general'
        },
        modules : {
          title : {
            id : 'sap.viz.modules.title',
            configure : {
              propertyCategory : 'title',
              properties : {
                layout : {
                  position : 'top',
                  priority : 0
                }
              }
            }
          },
          main : {
            id : 'sap.viz.modules.xycontainer',
            configure : {
              propertyCategory : 'xyContainer',
              properties : {
                layout : {
                  position : 'center',
                  priority : 10
                }
              }
            }
          },
          layout : {
            id : 'sap.viz.modules.layout.dock'
          }
        }
      }
      
    },
    dependencies : {}
  };

  Manifest.register(chart);
});
define('sap/viz/modules/tree/treeData',[],
function Setup(){

  var treeData = {
     
    collapseOrExtend : function(treeNode, forceCollapse, forceExtend)
    {
        var isDataChanged = false;
        if(treeNode.children && treeNode.children.length > 0 && !forceExtend)
        {
            treeNode.collapsedChildren = treeNode.children;
            treeNode.children = [];
            isDataChanged = true;
        }
        else if(treeNode.collapsedChildren && treeNode.collapsedChildren.length > 0 && !forceCollapse)
        {
            treeNode.children = treeNode.collapsedChildren;
            treeNode.collapsedChildren = [];
            isDataChanged = true;
        }

        return isDataChanged;
    },

    initTreeData : function(treeNode, showLevels)
    {
        var collapseAllNodes = function(node)
        {
            var i;
            if(node.children && node.children.length > 0)
            {
                for(i = 0; i < node.children.length; i++)
                {
                    collapseAllNodes(node.children[i]);
                }
            }
            else if(node.collapsedChildren && node.collapsedChildren.length > 0)
            {
                for(i = 0; i < node.collapsedChildren.length; i++)
                {
                    collapseAllNodes(node.collapsedChildren[i]);
                }
            }

            treeData.collapseOrExtend(node, true, undefined);
        };
        
        var extendNodes = function(node)
        {
            if(node.depth < (showLevels - 1))
            {
                if( node.collapsedChildren && 
                    node.collapsedChildren.length > 0 )
                {
                    var i;
                    for(i = 0; i < node.collapsedChildren.length; i++)
                    {
                        extendNodes(node.collapsedChildren[i]);
                    }
                }
                treeData.collapseOrExtend(node, undefined, true);
            }
        };

        //collapseAll, and then extend showLevels
        collapseAllNodes(treeNode);
        extendNodes(treeNode);
    },

    treeBuilder : function(data)
    {
        //use the original data to build the tree Structure
        //the returned data should be like
        //Object
        //children: Array[2]
        //    0: Object
        //    children: Array[0]
        //    name: "2011"
        //    1: Object
        //    children: Array[0]
        //    name: "2010"
        //name: "China"

        var buildNameArray = function(diData)
        {
            var reArray = [];
            var values = diData[0].values;

            var i;
            for(i = 0; i < values[0].rows.length; i++)
            {
                var item = {};
                item.source = values[0].rows[i].val;
                item.target = values[1].rows[i].val;
                
                if(item.source && item.target){
                  reArray.push(item);
                }
            }

            return reArray;
        };

        var buildRoot = function(treeD, nodeArray, nameTreeNodeMap)
        {
            nameTreeNodeMap = {};
            var allSource = [];
            var i;
            for(i = 0; i < nodeArray.length; i++)
            {
                allSource.push(nodeArray[i].source);
            }

            for(i = 0; i < nodeArray.length; i++)
            {
                var findIndex = allSource.indexOf(nodeArray[i].target);
                if(findIndex >= 0)
                {
                    allSource.splice(findIndex,1);
                }
            }
            
            if(allSource.length > 0){
              treeD.name = allSource[0];
              treeD.children = [];

              nameTreeNodeMap[treeD.name] = treeD;
            }
           
            return nameTreeNodeMap;
        };

        var findSourceNode = function(nameTreeNodeMap, sourceName)
        {
            var reNode = null;
            if(nameTreeNodeMap[sourceName])
            {
                reNode = nameTreeNodeMap[sourceName];
            }
            return reNode;
        };

        var addNodePairs = function(treeD, nodeArray)
        {
            if(nodeArray.length === 0)
            {
                return;
            }

            //add one pair, and then others
            var i;
            var isAddedOneNode = false;
            for(i = 0; i < nodeArray.length; i++)
            {
                var eNode = findSourceNode(nameTreeNodeMap, nodeArray[i].source);
                if(eNode)
                {
                    //add newNode to the tree
                    var newNode = {};
                    newNode.name = nodeArray[i].target;
                    newNode.children = [];

                    eNode.children.push(newNode);

                    //add to nameTreeNodeMap
                    nameTreeNodeMap[newNode.name] = newNode;

                    isAddedOneNode = true;
                    //remove it from nodeArray
                    nodeArray.splice(i, 1);
                    break;
                }
            }

            if(isAddedOneNode)
            {
                addNodePairs(treeD, nodeArray);
            }
        };

        var addNodeId = function(treeD, parentId, index, depth)
        {
          if(treeD.name){
            treeD.depth = depth;
            treeD.id = parentId + "-" + index;
            if(treeD.children && treeD.children.length > 0)
            {
                var i;
                for(i = 0; i < treeD.children.length; i++)
                {
                    addNodeId(treeD.children[i], treeD.id, i, depth + 1);
                }
            }
          }
        };

        var nameTreeNodeMap = {};

        var diData = data.getAnalysisAxisDataByIdx();
        var nodeArray = buildNameArray(diData);
        
        //build the root node, but do not change nodeArray
        var treeD = {};
        nameTreeNodeMap = buildRoot(treeD, nodeArray, nameTreeNodeMap);

        //add nodeArray to treeD
        addNodePairs(treeD, nodeArray, nameTreeNodeMap);

        //now we have a tree. Add id, depth for each node.
        addNodeId(treeD, 0, 0, 0);

        return treeD;
    }
  };
  
  return treeData;

});

define('sap/viz/modules/tree/treeLayout',[],
function Setup(){

  var treeLayout = {
    reLayout : function(treeDataStructure, allWidth, allHeight, props)
    {
        var doLayoutTree = function(_treeData, _width,_height, paddingOffset)
        {
            //the core layout algorithm is from 
            //http://billmill.org/pymag-trees/
            //and
            //http://dirk.jivas.de/papers/buchheim02improving.pdf
            //the implementation refers to d3.layout.tree
            var separation = function(a, b) {
                return a.parent === b.parent ? 1 : 2;
            };

            var treeVisitAfter = function (node, callback)
            {
                function visit(node, previousSibling) {
                    var children = node.children;
                    var n;
                    if (children && (n = children.length)) {
                        var child, previousChild = null,
                            i = -1;
                        while (++i < n) {
                            child = children[i];
                            visit(child, previousChild);
                            previousChild = child;
                        }
                    }
                    callback(node, previousSibling);
                }
                visit(node, null);
            };

            var treeLeft = function(node)
            {
                var children = node.children;
                return children && children.length ? children[0] : node._tree.thread;
            };

            var treeMove = function(ancestor, node, shift)
            {
                ancestor = ancestor._tree;
                node = node._tree;
                var change = shift / (node.number - ancestor.number);
                ancestor.change += change;
                node.change -= change;
                node.shift += shift;
                node.prelim += shift;
                node.mod += shift;
            };

            var treeRight = function(node)
            {
                var children = node.children,
                    n;
                return children && (n = children.length) ? children[n - 1] : node._tree.thread;
            };

            var treeSearch = function(node, compare)
            {
                var children = node.children;
                var n;
                if (children && (n = children.length)) {
                    var child, i = -1;
                    while (++i < n) {
                        if (compare(child = treeSearch(children[i], compare), node) > 0) {
                            node = child;
                        }
                    }
                }
                return node;
            };

            var treeShift = function(node)
            {
                var shift = 0,
                    change = 0,
                    children = node.children,
                    i = children.length,
                    child;
                while (--i >= 0) {
                    child = children[i]._tree;
                    child.prelim += shift;
                    child.mod += shift;
                    shift += child.shift + (change += child.change);
                }
            };

            var layoutTree = function ()
            {
                var size = [1, 1];
                var treeLayout = function(d, i)
                {
                    var root = d;
                    function firstWalk(node, previousSibling) {
                        var children = node.children,
                            layout = node._tree;

                        var n;
                        if (children && (n = children.length)) {
                                var firstChild = children[0],
                                previousChild, ancestor = firstChild,
                                child, i = -1;
                            while (++i < n) {
                                child = children[i];
                                firstWalk(child, previousChild);
                                ancestor = apportion(child, previousChild, ancestor);
                                previousChild = child;
                            }
                            treeShift(node);
                            var midpoint = 0.5 * (firstChild._tree.prelim + child._tree.prelim);
                            if (previousSibling) {
                                layout.prelim = previousSibling._tree.prelim + separation(node, previousSibling);
                                layout.mod = layout.prelim - midpoint;
                            } else {
                                layout.prelim = midpoint;
                            }
                        } else {
                            if (previousSibling) {
                                layout.prelim = previousSibling._tree.prelim + separation(node, previousSibling);
                            }
                        }
                    }

                    function secondWalk(node, x) {
                        node.x = node._tree.prelim + x;
                        var children = node.children;
                        var n;
                        if (children && (n = children.length)) {
                            var i = -1;
                            x += node._tree.mod;
                            while (++i < n) {
                                secondWalk(children[i], x);
                            }
                        }
                    }

                    function apportion(node, previousSibling, ancestor) {
                        if (previousSibling) {
                            var vip = node,
                                vop = node,
                                vim = previousSibling,
                                vom = node.parent.children[0],
                                sip = vip._tree.mod,
                                sop = vop._tree.mod,
                                sim = vim._tree.mod,
                                som = vom._tree.mod,
                                shift;
                            
                            vim = treeRight(vim);
                            vip = treeLeft(vip);
                            while ( vim  && vip ) {
                                vom = treeLeft(vom);
                                vop = treeRight(vop);
                                vop._tree.ancestor = node;
                                shift = vim._tree.prelim + sim - vip._tree.prelim - sip + separation(vim, vip);
                                if (shift > 0) {
                                    var treeAncestor;
                                    if(vim._tree.ancestor.parent === node.parent)
                                    {
                                        treeAncestor = vim._tree.ancestor;
                                    }
                                    else
                                    {
                                        treeAncestor = ancestor;
                                    }
                                    treeMove(treeAncestor, node, shift);
                                    sip += shift;
                                    sop += shift;
                                }
                                sim += vim._tree.mod;
                                sip += vip._tree.mod;
                                som += vom._tree.mod;
                                sop += vop._tree.mod;

                                vim = treeRight(vim);
                                vip = treeLeft(vip);
                            }
                            if (vim && !treeRight(vop)) {
                                vop._tree.thread = vim;
                                vop._tree.mod += sim - sop;
                            }
                            if (vip && !treeLeft(vom)) {
                                vom._tree.thread = vip;
                                vom._tree.mod += sip - som;
                                ancestor = node;
                            }
                        }
                        return ancestor;
                    }
                    var addtionalInfo = function (node, previousSibling)
                    {
                        node._tree = {
                            ancestor: node,
                            prelim: 0,
                            mod: 0,
                            change: 0,
                            shift: 0,
                            number: previousSibling ? previousSibling._tree.number + 1 : 0
                        };
                    };
                    treeVisitAfter(root, addtionalInfo);
                    firstWalk(root);
                    secondWalk(root, - root._tree.prelim);

                    var treeRightmost = function(a, b)
                    {
                        return a.x - b.x;
                    };

                    var treeLeftmost = function(a, b)
                    {
                        return b.x - a.x;
                    };

                    var treeDeepest = function(a, b)
                    {
                        return a.depth - b.depth;
                    };

                    var left = treeSearch(root, treeLeftmost),
                        right = treeSearch(root, treeRightmost),
                        deep = treeSearch(root, treeDeepest),
                        x0 = left.x - separation(left, right) / 2,
                        x1 = right.x + separation(right, left) / 2,
                        y1 = deep.depth || 1;

                    var extandLayout = function (node)
                    {
                        if(props.orientation === "top")
                        {
                            node.x = (node.x - x0) / (x1 - x0) * size[0];
                            node.y = node.depth / y1 * size[1];
                        }
                        else if(props.orientation === "left")
                        {
                            //1. we need one more depth to show the text
                            //2. each node should have x offset (5+1) and y offset (-(5+1))
                            var allDepth = deep.depth + 1;

                            node.y = (node.x - x0) / (x1 - x0) * size[1];
                            node.x = node.depth / allDepth * size[0];

                            node.y += paddingOffset;
                            node.x += paddingOffset;
                            
                            node.levelDistance = 1 / allDepth * size[0];
                        }
                        delete node._tree;
                    };
                    treeVisitAfter(root, extandLayout);
                    return root;
                };

                treeLayout.size = function (x) {
                    if (!arguments.length)
                    {
                        return size;
                    }
                    size = x;
                    return treeLayout;
                };

                return treeLayout;
            };

            //start of doLayoutTree
            // Create a tree "canvas"
            var tree = layoutTree().size([_width,_height]);
            var treeLayoutData = tree(_treeData);
            return treeLayoutData;
        };

        //build parents for treeDataStructure
        var buildParent = function(treeDataStructure, parent, depth)
        {
            if(parent)
            {
                treeDataStructure.parent = parent;
            }

            if(maxVisibleDepth < treeDataStructure.depth)
            {
                maxVisibleDepth = treeDataStructure.depth;
            }

            if(treeDataStructure.children && treeDataStructure.children.length > 0)
            {
                var i;
                for(i = 0; i < treeDataStructure.children.length; i++)
                {
                    buildParent(treeDataStructure.children[i], treeDataStructure, depth + 1);
                }
            }
        };

        var updateMaxVisibleDepth = function(treeDataStructure, maxVisibleDepth)
        {
            treeDataStructure.maxVisibleDepth = maxVisibleDepth;
            if(treeDataStructure.children && treeDataStructure.children.length > 0)
            {
                var i;
                for(i = 0; i < treeDataStructure.children.length; i++)
                {
                    updateMaxVisibleDepth(treeDataStructure.children[i], maxVisibleDepth);
                }
            }
        };
        //add parent
        var maxVisibleDepth = 0;//do not care collapsed children
        buildParent(treeDataStructure, null, 0);

        //update maxVisibleDepth
        updateMaxVisibleDepth(treeDataStructure, maxVisibleDepth);

        var treeLayoutData;
        var paddingOffset = props.pointRadius + props.pointBorderWidth;
        var realWidth = allWidth - 2*paddingOffset;
        var realHeight = allHeight - 2*paddingOffset;
        treeLayoutData = doLayoutTree(treeDataStructure, realWidth, realHeight, paddingOffset);

        //console.log(treeLayoutData);
        return treeLayoutData;
    }
  };

  return treeLayout;

});

define('sap/viz/modules/tree/treeRender',['sap/viz/util/TextUtils'],
function Setup(TextUtils){

  var treeRender = {
    reRender : function(selection, treeLayoutData, props, treeUICallbackFuns,effectManager)
    {
        var idTreeDOMMap = treeUICallbackFuns.idTreeDOMMap;
        var treeContext = this;
        var hideAllLabels = false;
        var hideLimit = 30;
        
	function getEffectColor(color){
		if (!effectManager){
			return color;
		}
		var parameter = {
			fillColor : color
		};
		return effectManager.register(parameter);
	}
        var fastMeasure = function(_text, _fontSize, _fontWeight, _fontFamily)
        {
            return TextUtils.superFastMeasure(_text, _fontSize,
                                                _fontWeight,
                                                _fontFamily);
        };

        var getTextMaxLength = function(treeNode)
        {
            var tLength;
            if(treeNode.depth === treeNode.maxVisibleDepth)
            {
                //leaves in last level
                tLength = treeNode.levelDistance - 2*props.labelOffset;
            }
            else
            {
                tLength = treeNode.levelDistance - 2*props.pointRadius - 2*props.labelOffset;
            }
            return tLength;
        };

        var updateNodeDrawState= function(treeLayoutData, idTreeDOMMap)
        {
            var updateNodes = function(treeNode, forceCollapse)
            {
                //do not need to check collapsed nodes
                if(!forceCollapse)
                {
                    var labelLength;
                    if(hideAllLabels)
                    {
                        labelLength = 0;
                    }
                    else
                    {
                        var fontSize = props.labelRealStyle["font-size"] + "px";
                        var fontWeight = props.labelRealStyle["font-weight"];
                        var fontFamily = props.labelRealStyle["font-family"];
                        
                        labelLength = fastMeasure(treeNode.name, fontSize, fontWeight, fontFamily).width;
                    }

                    //check hideAllLabels
                    if(!hideAllLabels)
                    {
                        var maxLabelSpace = getTextMaxLength(treeNode);
                        if(maxLabelSpace < hideLimit && labelLength > maxLabelSpace)
                        {
                            hideAllLabels = true;
                        }
                        else
                        {
                            //if one text is empty string, hide all
                            var textToDraw = getTruncatedText(treeNode.name, maxLabelSpace);
                            if(treeNode.name.length > 0 && textToDraw.length === 0)
                            {
                                hideAllLabels = true;
                            }
                        }
                    }
                }

                //drawState
                if(forceCollapse)
                {
                    treeNode.drawState = "delete";
                }
                else
                {
                    if(idTreeDOMMap[treeNode.id])
                    {
                        //exist. Delete or update
                        if( (treeNode.parent &&
                            treeNode.parent.collapsedChildren &&
                            treeNode.parent.collapsedChildren.length > 0)
                          )
                        {
                            treeNode.drawState = "delete";
                        }
                        else
                        {
                            treeNode.drawState = "update";
                        }
                    }
                    else
                    {
                        treeNode.drawState = "new";
                    }
                }

                var i;
                //update collapsedChildren
                if(treeNode.collapsedChildren && treeNode.collapsedChildren.length > 0)
                {
                    for(i = 0; i < treeNode.collapsedChildren.length; i++)
                    {
                        updateNodes(treeNode.collapsedChildren[i], true);
                    }
                }

                //update children
                if(treeNode.children && treeNode.children.length > 0)
                {
                    for(i = 0; i < treeNode.children.length; i++)
                    {
                        updateNodes(treeNode.children[i], forceCollapse);
                    }
                }
            };
            updateNodes(treeLayoutData);
        };


        var reRenderTree = function(parentSelection, treeNode, level, idTreeDOMMap)
        {
            var i;
            var selection = parentSelection;

            //draw children
            if(treeNode.children && treeNode.children.length > 0)
            {
                for(i = 0; i < treeNode.children.length; i++)
                {
                    reRenderTree(selection, treeNode.children[i], level + 1, idTreeDOMMap);
                }
            }

            //draw collapsedChildren
            if(treeNode.collapsedChildren && treeNode.collapsedChildren.length > 0)
            {
                for(i = 0; i < treeNode.collapsedChildren.length; i++)
                {
                    reRenderTree(selection, treeNode.collapsedChildren[i], level + 1, idTreeDOMMap);
                }
            }

            //draw one note.
            //it contains one point, one text and one line
            drawOneNode(treeNode, selection, idTreeDOMMap);
        };

        var clickNodeHandler = function()
        {
            var context = treeUICallbackFuns.context;

            var treeNode = this.__data__;

            //use call the change context to "this"
            treeUICallbackFuns.collapseOrExtend.call(context, treeNode, treeLayoutData);
        };

        var liveAncestorNode = function(treeNode)
        {
            var aNode = treeNode;
            if(treeNode.parent)
            {
                if(treeNode.parent.drawState === "update")
                {
                    aNode = treeNode.parent;
                }
                else
                {
                    aNode = liveAncestorNode(treeNode.parent);
                }
            }

            return aNode;
        };

        var drawLinesInPoint = function(pointS, treeNode)
        {
            var lineWidth = props.pointRadius*2/7;//2
            var xyOffset = props.pointRadius*4/7;//4

            var line1_S = pointS.select(".v-line1");
            var line2_S = pointS.select(".v-line2");

            if( (treeNode.children && treeNode.children.length > 0) ||
                (treeNode.collapsedChildren && treeNode.collapsedChildren.length > 0) )
            {
                if(line1_S.empty())
                {
                    line1_S = pointS.append("line")
                     .attr("class", "v-line1");
                }
                line1_S.attr("stroke", getEffectColor(props.pointBorderColor))
                .attr("stroke-width", lineWidth)
                .attr("x1", -xyOffset)
                .attr("x2", xyOffset)
                .attr("y1", 0)
                .attr("y2", 0);

                if(treeNode.collapsedChildren && treeNode.collapsedChildren.length > 0)
                {
                    if(line2_S.empty())
                    {
                        line2_S = pointS.append("line")
                         .attr("class", "v-line2");
                    }
                    line2_S.attr("stroke", getEffectColor(props.pointBorderColor))
                    .attr("stroke-width", lineWidth)
                    .attr("display", null)
                    .attr("x1", 0)
                    .attr("x2", 0)
                    .attr("y1", -xyOffset)
                    .attr("y2", xyOffset);
                }
                else
                {
                    line2_S.attr("display", "none");
                }
            }
        };

        var getTruncatedText = function(text, limit) {
            var style = 'font-weight:' +
                        props.labelRealStyle["font-weight"] + '; font-family: ' + 
                        props.labelRealStyle["font-family"] + '; font-size: ' + 
                        props.labelRealStyle["font-size"] + "px" + ';';
            return TextUtils.ellipsis(text, undefined, limit, style);
        };

        var getTextToDraw = function(treeNode)
        {
            var textToDraw = null;
            if(!hideAllLabels)
            {
                var lengthOfLabel = getTextMaxLength(treeNode);
                textToDraw = getTruncatedText(treeNode.name, lengthOfLabel);
            }

            //return null means no text(text has to be removed)
            return textToDraw;
        };

        var drawOneNode = function(treeNode, selection, idTreeDOMMap)
        {
            var nodeSelection;
            var pointS;
            var textS;
            var textX;
            var textY;
            var liveNode;
            var lineS;
            var animationTime = 500;
            if(treeNode.drawState === "delete")
            {
                if(idTreeDOMMap[treeNode.id])
                {
                    //remove it(callback)
                    var removeNode = function()
                    {
                        //remove transform attr
                        idTreeDOMMap[treeNode.id].attr("transform",null);
                        
                        //delete DOM
                        var child = idTreeDOMMap[treeNode.id].node();
                        if(child)
                        {
                            child.parentNode.removeChild(child);
                        }
                        
                        delete idTreeDOMMap[treeNode.id];
                    };

                    nodeSelection = idTreeDOMMap[treeNode.id];
                    //add animation
                    liveNode = liveAncestorNode(treeNode);

                    nodeSelection.transition().duration(animationTime)
                        .attr("transform", "translate(" + liveNode.x + ", " + liveNode.y + ") scale(0)")
                        .each("end", removeNode);
                }
            }
            else
            {
                var isNewNode = false;
                if(treeNode.drawState === "new")
                {
                    isNewNode = true;
                }
                //draw it or update it
                if(isNewNode)
                {
                    nodeSelection = selection.append("g").attr("class", "v-nodeLevel" + treeNode.depth);
                }
                else
                {
                    nodeSelection = idTreeDOMMap[treeNode.id];
                }
                nodeSelection.data([treeNode]);
                //draw one line
                if(treeNode.parent)
                {
                    if(props.lineShape === "line")
                    {
                        if(isNewNode)
                        {
                            lineS = nodeSelection.append("line").attr("class", "v-link");
                        }
                        else
                        {
                            lineS = nodeSelection.select(".v-link");
                            lineS = lineS.transition().duration(animationTime);
                        }
                        lineS.attr("stroke", getEffectColor(props.lineColor))
                        .attr("stroke-width", 1)
                        .attr("x1", treeNode.x)
                        .attr("y1", treeNode.y)
                        .attr("x2", treeNode.parent.x)
                        .attr("y2", treeNode.parent.y);
                    }
                    else if(props.lineShape === "curve")
                    {
                        var diagonal = d3.svg.diagonal();
                        var dString;
                        // change x and y (for the left to right tree)
                        if(props.orientation === "left")
                        {
                            diagonal.projection(function(d) { return [d.y, d.x]; });
                            dString = diagonal({
                                                source:{x:treeNode.parent.y,y:treeNode.parent.x}, 
                                                target:{x:treeNode.y, y:treeNode.x}  
                                              });
                        }
                        else if(props.orientation === "top")
                        {
                            dString = diagonal({
                                                source:{x:treeNode.parent.x,y:treeNode.parent.y}, 
                                                target:{x:treeNode.x, y:treeNode.y}  
                                              });
                        }
                        
                        if(isNewNode)
                        {
                            lineS = nodeSelection.append("path").attr("class", "v-link");
                        }
                        else
                        {
                            lineS = nodeSelection.select(".v-link");
                            lineS = lineS.transition().duration(animationTime);
                        }
                        lineS.attr("fill","none")
                        .attr("stroke", getEffectColor(props.lineColor))
                        .attr("stroke-width", 1)
                        .attr("d", dString);
                    }
                }
                
                //point
                if(isNewNode)
                {
                    pointS = nodeSelection.append("g").attr("class", "v-point");
                    
                    if(props.clickAble)
                    {
                        pointS.on("click", clickNodeHandler);
                    }

                    if( (treeNode.children && treeNode.children.length > 0) ||
                        (treeNode.collapsedChildren && treeNode.collapsedChildren.length > 0) )
                    {
                        if(props.clickAble)
                        {
                            pointS.attr("cursor", "pointer");
                        }
                    }

                    pointS.append("circle")
                         .attr("class", "v-pointItem")
                         .attr("fill", getEffectColor(props.pointColor))
                         .attr("stroke-width", props.pointBorderWidth)
                         .attr("stroke", getEffectColor(props.pointBorderColor))
                         .attr("r", props.pointRadius);

                    drawLinesInPoint(pointS, treeNode);
                }
                else
                {
                    pointS = nodeSelection.select(".v-point");
                         
                    pointS.select(".v-pointItem").attr("fill", getEffectColor(props.pointColor))
                          .attr("stroke-width", props.pointBorderWidth)
                          .attr("stroke", getEffectColor(props.pointBorderColor))
                          .attr("r", props.pointRadius);
                    
                    drawLinesInPoint(pointS, treeNode);

                    pointS = pointS.transition().duration(animationTime);
                }
                pointS.attr("transform", "translate(" + treeNode.x + ", " + treeNode.y + ")");

                //text
              if(props.label.visible){
                var textToDraw = getTextToDraw(treeNode);
                if(textToDraw !== null)
                {
                    textX = treeNode.x + props.pointRadius + props.pointBorderWidth + props.labelOffset;
                    textY = treeNode.y + props.labelRealStyle["font-size"]/2.6;

                    if(isNewNode)
                    {
                        textS = nodeSelection.append("text").attr("class", "v-text");
                    }
                    else
                    {
                        textS = nodeSelection.select(".v-text");
                        if(textS.empty())//has been deleted
                        {
                            textS = nodeSelection.append("text").attr("class", "v-text");
                            
                            textS.text(textToDraw)
                                 .attr("fill", props.labelDefaultStyle.fill)
                                 .attr("font-weight", props.labelDefaultStyle["font-weight"])
                                 .attr("font-size", props.labelDefaultStyle["font-size"] + "px")
                                 .attr("font-family", props.labelDefaultStyle["font-family"])
                                 .attr("x", textX)
                                 .attr("y", textY)
                                 .attr("opacity", 0);
                        }
                        textS = textS.transition().duration(animationTime);
                    }
                    textS.text(textToDraw)
                         .attr("fill", props.labelDefaultStyle.fill)
                         .attr("font-weight", props.labelDefaultStyle["font-weight"])
                         .attr("font-size", props.labelDefaultStyle["font-size"] + "px")
                         .attr("font-family", props.labelDefaultStyle["font-family"])
                         .attr("x", textX)
                         .attr("y", textY)
                         .attr('pointer-events', 'none')
                         .attr("opacity", 1);
                }
                else
                {
                    var removeText = function()
                    {
                        if(this)
                        {
                            d3.select(this).remove();
                        }
                    };
                    //remove text for "update"
                    if(!isNewNode)
                    {
                        textS = nodeSelection.select(".v-text").attr("opacity", 1);
                        textS = textS.transition().duration(animationTime);
                        textS.attr("opacity", 0).each("end", removeText);
                    }
                }
              }


                //add animation for new node
                if(isNewNode)
                {
                    //remove transform
                    var removeTransform = function()
                    {
                        //remove transform attr
                        nodeSelection.attr("transform",null);
                    };
                    liveNode = liveAncestorNode(treeNode);

                    //use the old x, y of liveNote 
                    //(we draw children first. So liveNote has nor been updated yet)
                    //if the liveNode does not exist in DOM, do not make animation(it is init)
                    if(idTreeDOMMap[liveNode.id])
                    {
                        var oldLocation = idTreeDOMMap[liveNode.id].select(".v-point").attr("transform");

                        nodeSelection.attr("transform", oldLocation + " scale(0)");

                        nodeSelection.transition().duration(animationTime)
                            .attr("transform", "translate(0,0) scale(1)")
                            .each("end", removeTransform);
                    }
                }

                //if current node is not new,
                //we have to make sure it is added after all children,
                //or the line of children will cover the point
                if(!isNewNode)
                {
                    var DOME = nodeSelection.node();
                    DOME.parentNode.appendChild(DOME);
                }

                //update idTreeDOMMap
                if(isNewNode)
                {
                    idTreeDOMMap[treeNode.id] = nodeSelection;
                }
            }
        };


        var rootSelection;
        if(Object.keys(idTreeDOMMap).length <= 0)
        {
            rootSelection = selection.append("g")
            .attr("class", "v-tree");
        }
        else
        {
            rootSelection = selection.select(".v-tree");
        }
        //update treeNode state accodring to idTreeDOMMap
        //do not change idTreeDOMMap
        updateNodeDrawState(treeLayoutData, idTreeDOMMap);

        //draw
        reRenderTree(rootSelection, treeLayoutData, 0, idTreeDOMMap);       
    },

    removeTreeDOM : function(thisContext)
    {
        if(thisContext._rdr_treeAllData)
        {
            var rootID = thisContext._rdr_treeAllData.id;
            //delete Tree DOM
            var rootNodeDOM = thisContext._rdr_UICallbackFuns.idTreeDOMMap[rootID].node();
            var treeRootDOM = rootNodeDOM.parentNode;
            treeRootDOM.parentNode.removeChild(treeRootDOM);
        }
        thisContext._rdr_UICallbackFuns.idTreeDOMMap = [];
    }
  };
  
  return treeRender;

});

define('sap/viz/modules/tree',['sap/viz/base/utils/oo',
'sap/viz/modules/Base', 
'sap/viz/modules/dispatch',
'sap/viz/base/utils/Objects',
'sap/viz/modules/tree/treeData',
'sap/viz/modules/tree/treeLayout',
'sap/viz/modules/tree/treeRender',
"sap/viz/modules/util/BoundUtil"],
function Setup(oo, Base, dispatch, Objects, treeData, treeLayout, treeRender, BoundUtil) {

    var Tree = function(manifest, ctx) {
        Tree.superclass.constructor.apply(this,arguments);

        var treeClassNames = 
        {
            label:"v-text"
        };

        this._rdr_selection = null;
        this._rdr_data = null;
        this._rdr_propsOutput = null;
        this._rdr_width = 0;
        this._rdr_height = 0;
        this._rdr_dispatch = new dispatch('initialized', 'startToInit');
        this._rdr_defaultProps = manifest.props(null);
        this._rdr_effectManager = ctx.effectManager;
        this._rdr_propsInternal = 
        {
            "orientation":"left",//top, left, right, bottom
            "lineShape":"curve",//line, curve, arc, polyline
            "showLevels":3,
            "lineColor":'#bfbfbf',
            
            "pointColor":'#297cbe',//ColorSeriesGenerator.sap32().range()[0],//one color for each point
            "pointRadius":7,
            "pointBorderWidth":1,
            "pointBorderColor":"#ffffff",

            "labelDefaultStyle":
            {
                "fill":"#333333",
                "font-size":12,
                "font-weight":"normal",
                "font-family":"Arial, Helvetica, sans-serif, 'Open Sans'"
            },
            "labelRealStyle":{},

            "labelOffset":6
        };
        Objects.extend(true, this._rdr_propsInternal, this._rdr_defaultProps);

        //update style
        this._rdr_propsInternal.labelRealStyle = Objects.extend(true, this._rdr_propsInternal.labelRealStyle, this._rdr_propsInternal.labelDefaultStyle);
        //query from styleManager
        this._rdr_propsInternal.labelDefaultStyle = Objects.extend(true, this._rdr_propsInternal.labelDefaultStyle, 
                                                    ctx.styleManager.queryDefault(treeClassNames.label));

        this._rdr_propsInternal.labelRealStyle = Objects.extend(true, this._rdr_propsInternal.labelRealStyle, 
                                                 ctx.styleManager.query(treeClassNames.label));

        this._rdr_UICallbackFuns = {};
        this._rdr_UICallbackFuns.context = this;
        this._rdr_UICallbackFuns.idTreeDOMMap = [];
        this._rdr_UICallbackFuns.collapseOrExtend = Tree.prototype.collapseOrExtend;

        this._rdr_treeAllData = null;
    };
    
    //the start point of tree chart
    oo.extend(Tree,Base);
    Tree.prototype.collapseOrExtend = function(treeNode, allTree){
        //the tree must have been drawed.

        //1. update tree data for children
        //2. relayout
        //3. reRender (uodate) the tree in GUI
        var isDataChanged = treeData.collapseOrExtend(treeNode);

        if(isDataChanged)
        {

            var treeLayoutData;
            treeLayoutData = treeLayout.reLayout(allTree, 
                             this._rdr_width, this._rdr_height, this._rdr_propsInternal);

            treeRender.reRender(this._rdr_selection, treeLayoutData, 
                                this._rdr_propsInternal, this._rdr_UICallbackFuns,this._rdr_effectManager);
        }
    };

    Tree.prototype.render = function(selection){
        var width = this._rdr_width,
          height = this._rdr_height;
        BoundUtil.drawBound(selection, width, height);
        this._rdr_selection = selection;
        
        //before draw it
        this._rdr_dispatch.startToInit();

        //to draw a chart, we need
        //1. build internal data structure from this._rdr_data
        //2. layout the tree
        //3. draw it

        //if there is no Tree DOM, we have to create it from the data
        var idTreeDOMMap = this._rdr_UICallbackFuns.idTreeDOMMap;
        if(Object.keys(idTreeDOMMap).length <= 0)
        {
            if(!this._rdr_treeAllData)
            {
                this._rdr_treeAllData = treeData.treeBuilder(this._rdr_data);
            }
            //keep showLevels
            treeData.initTreeData(this._rdr_treeAllData, this._rdr_propsInternal.showLevels);
        }

        var treeLayoutData;
        treeLayoutData = treeLayout.reLayout(this._rdr_treeAllData, 
                         this._rdr_width, this._rdr_height, this._rdr_propsInternal);


        if(treeLayoutData.children){
          treeRender.reRender(this._rdr_selection, treeLayoutData, 
                            this._rdr_propsInternal, this._rdr_UICallbackFuns,this._rdr_effectManager);
        }

        
        
        //after draw it
        //no init animation
        this._rdr_dispatch.initialized();
        return this;
    };

    Tree.prototype.parent = function(){
        return this._rdr_selection;
    };

    Tree.prototype.data = function(_data){
        if (!arguments.length){
            return this._rdr_data;
        }
        this._rdr_data = _data;

        //all tree data, layout data, render data have to be recreated.
        this._rdr_treeAllData = null;

        //redraw the tree
        treeRender.removeTreeDOM(this);

        return this;
    };
    
    Tree.prototype.properties = function(_props){
        if (!arguments.length){
            return this._rdr_propsOutput;
        }
        this._rdr_propsOutput = _props;

        //check input
        var rInput = parseFloat(this._rdr_propsOutput.pointRadius);
        this._rdr_propsOutput.pointRadius = rInput;
        if(!rInput || rInput <= 0)
        {
            this._rdr_propsOutput.pointRadius = this._rdr_defaultProps.pointRadius;
        }

        var levelInput = Math.round(parseFloat(this._rdr_propsOutput.showLevels));
        this._rdr_propsOutput.showLevels = levelInput;
        if(!levelInput || levelInput < 1)
        {
            this._rdr_propsOutput.showLevels = this._rdr_defaultProps.showLevels;
        }

        //update this._rdr_propsInternal 
        Objects.extend(true, this._rdr_propsInternal, this._rdr_propsOutput);

        //we do not need to change this._rdr_treeAllData, but we should
        //remove the Tree DOM.
        treeRender.removeTreeDOM(this);

        //and redraw the tree
        //(Tree.prototype.render will be called. So do nothing here)
        return this;           
    };

    Tree.prototype.width = function(_width){
        if (!arguments.length){
          return this._rdr_width;
        }
        this._rdr_width = _width;
        return this;
    };

    Tree.prototype.height = function(_height){
        if (!arguments.length){
          return this._rdr_height;
        }
        this._rdr_height = _height;
        return this;       
    };

    Tree.prototype.dispatch = function(_){
        if(!arguments.length){
            return this._rdr_dispatch;
        }
        this._rdr_dispatch = _;
        return this;
    };

    Tree.prototype.destroy = function() {
        //1. remove DOM events
        this._rdr_selection
            .selectAll(".v-point")
            .on("click", null);

        //2. remove DOM refers
        this._rdr_UICallbackFuns.idTreeDOMMap = [];
    };

    return Tree;
});

define('sap/viz/feeds/Tree',['sap/viz/feeds/Manifest','sap/viz/data/feed/Constants'],
function Setup(Manifest, constants) {
  var treeNodeFeed = {
    'id' : 'treeNode',
    'name' : 'IDS_TREENODE',
    'type' : constants.Type.Dimension,
    'min' : 1,
    'max' : 1,
    'aaIndex' : 1,
    'acceptMND': -1,
    'minStackedDims': 2,
    'maxStackedDims' : 2,
    'description': 'The first dimension is for parent node and the second dimension is for child node. If there is undefined or null, it will ignore this pair of values.'
  };

  var feeds = {
    id : "tree",
    feeds : [ treeNodeFeed ]
  };
  Manifest.register(feeds);
});
define('sap/viz/modules/manifests/Tree',['sap/viz/modules/manifests/Module','sap/viz/modules/Constants','sap/viz/modules/tree','sap/viz/feeds/Tree'],
function Setup(Manifest, Constants, fn)
{
    var module =
    {
      'id' : 'sap.viz.modules.tree',
      'type' : Constants.Type.Chart,
      'name' : 'tree',
      'properties' : {
        'lineShape' : {
            'name' : 'lineShape',
            'supportedValueType' : 'String',
            'supportedValues' : [ 'line', 'curve'],//line, curve, arc, polyline
            'defaultValue' : 'curve',
            'description' : 'Set line type.',
            'isExported' : true,
        },
        'pointRadius' : {
            'name' : 'pointRadius',
            'supportedValueType' : 'Number',
            'defaultValue' : 7,
            'description' : 'Set point radius.',
            'isExported' : false,
        },
        'clickAble' : {
            'name' : 'clickAble',
            'supportedValueType' : 'Boolean',
            'defaultValue' : true,
            'description' : 'Set clickAble.',
            'isExported' : false,
        },
        'showLevels' : {
            'name' : 'showLevels',
            'supportedValueType' : 'Number',
            'defaultValue' : 3,
            'description' : 'Set initial levels.',
            'isExported' : true,
        },
        'label':{
            'name': 'label',
            'supportedValueType': 'Object',
            'supportedValues': {
              'visible' : {
                'name' : 'visible',
                'supportedValueType' : 'Boolean',
                'defaultValue' : true,
                'description' : 'Set the visibility of label'
              },
            },
            'description':'tree chart label',
            'isExported' : false
          },
      },
      'events' :
      {
        'initialized': Constants.Event.Initialized.desc
      },
      'feeds' :{
          id:"tree"
      },
      'css' :
      {
        '.v-text' :
        {
            'description' : 'Define style for the label text.',
            'value' : {
            'fill' : '#333333'
            }
        },
        '.v-link' :
        {
            'description' : 'Define style for the link line.',
            'value' : {
            'stroke' : '#bfbfbf'
            }
        },
        '.v-pointItem' :
        {
            'description' : 'Define style for the point item.',
            'value' : {
            'fill' : '#297cbe'
            }
        }
      },
      'configure' : null,
      fn : fn
    };

    Manifest.register(module);
});
define('sap/viz/manifests/TreeChart',['sap/viz/manifests/Viz','sap/viz/modules/Constants','sap/viz/modules/manifests/RootContainer',
'sap/viz/manifests/SimpleChart','sap/viz/modules/manifests/Tooltip','sap/viz/modules/manifests/Tree'],
function Setup ( Manifest, Constants ) {
  var chart = {
    id : 'viz/tree',
    name : 'IDS_TREECHART',
    base : 'riv/simple',
    modules : {
      root : {
        configure : {
          properties : {
            layout : { adjustPolicy : Constants.LAYOUT_ADJUST_POLICY.RELAYOUT }
          }
        },
        modules : {
          main : {
            modules : {
              plot : {
                id : 'sap.viz.modules.tree',
                configure : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory : 'plotArea'
                }
              }
            }
          }
        }
      }
    },
    dependencies : {
      attributes : [ ],
      events : [ ]
    }
  };

  Manifest.register(chart);
});
define('sap/viz/manifests/scatter/BaseBubbleChart',['sap/viz/manifests/Viz','sap/viz/modules/manifests/RootContainer','sap/viz/manifests/BaseSingleChart',
'sap/viz/modules/manifests/Tooltip','sap/viz/modules/manifests/Axis'],
function Setup(Manifest) {
  var chart = {
    id : 'viz/scatter/single/base',
    name : 'IDS_BASEBUBBLECHART',
    'abstract' : true,
    base : 'riv/base/single',
    modules : {
      root : {
        modules : {
          legends : {
            configure : {
              properties : {
                layout : {
                  position : 'right',
                  priority : 1,
                  alignment : 'right'
                }
              }
            },
            modules : {
              legend : {
                data : { aa : [ 1, 2 ] },
                configure : {
                  properties : {
                    type : 'BubbleColorLegend',
                    layout : { order : 1 }
                  },
                  propertiesOverride : {
                    isHierarchical : { isExported: false },
                    isScrollable :  { isExported: false }
                  }
                }
              }
            }
          },
          
          tooltip : {
            id : 'sap.viz.modules.tooltip',
            configure : {
              propertyCategory : 'tooltip',
              properties : { orientation : 'left' }
            }
          },
          
          interaction : { 
            id : 'sap.viz.modules.controller.interaction',
            configure : {
              clientID : 'main', 
              propertyCategory :'interaction'
            }
          },
          
          main : {
            modules : {
              dataLabel : {
                id : 'sap.viz.modules.datalabel',
                configure : {
                  propertyCategory : 'dataLabel',
                  properties : {
                    paintingMode : 'rectCoordinate',
                    orientation : 'vertical',
                    visible : false,
                    position : 'outside',
                    outsideVisible : true,
                    positionPreference : true
                  }
                }
              },
              xAxis : {
                id : 'sap.viz.modules.axis',
                data : {
                  mg : [ 1 ]
                },
                configure : {
                  'description': 'Settings for the x axis of a normal bubble or scatter plot.',
                  propertyCategory : 'xAxis',
                  properties : {
                    type : 'value',
                    position : 'bottom',
                    gridline : {
                      visible : false
                    }
                  }
                }
              },
              yAxis : {
                id : 'sap.viz.modules.axis',
                data : { mg : [ 2 ] },
                configure : {
                  description : 'Settings for the y axis of a normal bubble or scatter plot.',
                  propertyCategory : 'yAxis',
                  properties : {
                    type : 'value',
                    position : 'left',
                    gridline : {
                      visible : true
                    }
                  }
                }
              },
            
            background : {
            id: 'sap.viz.modules.background',
            configure : {
              propertyCategory : 'background',
              properties : {
                direction : 'vertical'
              }
            }
            }
            }
          }
        }
      }
    },
    dependencies : {
      attributes : [ 
      {
        targetModule : 'root.main.plot',
        target : 'valueAxis1DataRange',
        sourceModule : 'root.main.xAxis',
        source : 'range'
      }, {
        targetModule : 'root.main.plot',
        target : 'valueAxis2DataRange',
        sourceModule : 'root.main.yAxis',
        source : 'range'
      }, {
        targetModule : 'root.main.xAxis',
        target : 'scale',
        sourceModule : 'root.main.plot',
        source : 'valueAxis1Scale'
      }, {
        targetModule : 'root.main.yAxis',
        target : 'scale',
        sourceModule : 'root.main.plot',
        source : 'valueAxis2Scale'
      }, {
        targetModule : 'root.main.xAxis',
        target : 'title',
        sourceModule : 'root.main.plot',
        source : 'valueAxis1Title'
      }, {
        targetModule : 'root.main.yAxis',
        target : 'title',
        sourceModule : 'root.main.plot',
        source : 'valueAxis2Title'
      }, {
        targetModule : 'root.legends.legend',
        target : 'colorPalette',
        sourceModule : 'root.main.plot',
        source : 'colorPalette'
      }, {
        targetModule : 'root.legends.legend',
        target : 'shapes',
        sourceModule : 'root.main.plot',
        source : 'shapes'
      }, {
        targetModule : 'root.legends.legend',
        target : 'setSelectionMode',
        sourceModule : 'root.interaction',
        source : 'getSelectionMode'
      }],
      events : [{
        targetModule : 'root.tooltip',
        listener : 'showTooltip',
        sourceModule : 'root.main.plot',
        type : 'showTooltip'
      }, {
        targetModule : 'root.tooltip',
        listener : 'hideTooltip',
        sourceModule : 'root.main.plot',
        type : 'hideTooltip'
      },{
          targetModule : 'root.interaction',
          listener : 'registerEvent',
          sourceModule : 'root.main.plot',
          type : 'initialized.interaction'
        }, {
        targetModule : 'root.interaction',
        listener : 'highlightedByLegend',
        sourceModule : 'root.legends.legend',
        type : 'highlightedByLegend'
        }, {
        targetModule : 'root.legends.legend',
        listener : 'deselectLegend',
        sourceModule : 'root.interaction',
        type : 'deselectLegend'
        }, {
          targetModule : 'root.main.dataLabel',
          listener : 'showLabel',
          sourceModule : 'root.main.plot',
          type : 'initialized.datalabel'
        }, {
          targetModule : 'root.main.dataLabel',
          listener : 'removeLabel',
          sourceModule : 'root.main.plot',
          type : 'startToInit.datalabel'
        },  {
          targetModule : 'root.interaction',
          listener : 'defaultSelection',
          sourceModule : 'root.main.plot',
          type : 'initialized.defaultSelection'
        }]
    }
  };

  Manifest.register(chart);
});
define('sap/viz/modules/util/lassoSelection',['jquery'],
function Setup($) 
{
  return function(){
    var layerPos = {},//point on svg xy-coordinate
      clientPos = {},  //point on client position
      svgBoundingBox = null; //to improve performance, save all the bound of selected shape
    var lassoHelper, //div holder 
      lassoStart, lassoMove, lassoFinish, //lasso handler 
      start = false, 
      gWrapper = null, 
      gSelection = null, hitTestRect = {}, elementFilter, selectees,
      decorativeRect = null;
    //selection should be a svg element, as some function as svg native function. 
    var lassoSelection = function(selection, options){
      
      lassoHelper = $('<div id="lasso-selection-help" style="position:absolute;pointer-events:none;background:#cccccc;"></div>');
      elementFilter = options && options.filter ? options.filter:'.v-datapoint';
      gSelection = d3.select(selection).select('.main').length > 0  ? d3.select(selection).select('.main')[0][0] :  selection;
      gWrapper = d3.select(gSelection);
      var bbox = gSelection.getBBox();
      //as SVG limitation, you can not get the event info if you click where there is no shape.
      decorativeRect = gWrapper.insert('rect', 'g').attr('width', bbox.width).attr('height', bbox.height).attr('x', 0).attr('y', 0).attr('fill-opacity', 0);
      lassoStart = options.lassoStart ?options.lassoStart: function(){}, 
      lassoMove = options.lassoMove ? options.lassoMove: function(){}, 
      lassoEnd = options.lassoEnd ? options.lassoEnd: function(){};
      //register event on svg element
      gWrapper.on('mousedown', lassoSelection.start);
      gWrapper.on('mousemove', lassoSelection.move);
      gWrapper.on('mouseup', lassoSelection.end);
      return lassoSelection;
    };
    //intersect two rectangle
    function intersect(a, b) {
        return (a.x <= (b.x + b.width) &&
                b.x <= (a.x + a.width) &&
                a.y <= (b.y + b.height) &&
                b.y <= (a.y + a.height));
    };
    
    //filter the selectees to see whether the shape intersect with hitTestRect. 
    var filter = function(point, size){
      
      hitTestRect.x = point.x;
      hitTestRect.y = point.y;
      hitTestRect.height = size.height;
      hitTestRect.width = size.width;
      
      var res = [];
      //to reduce the time to get the bounding value, restore them into variable.
      if(selectees == null){
        selectees = gWrapper.selectAll(elementFilter);;
      }
      
      selectees.filter(function(d, m){
        var bounding = this.getBoundingClientRect();
        var rect = {
          x : bounding.left,
          y : bounding.top,
          width : bounding.width,
          height : bounding.height
        };
        if(intersect(rect , hitTestRect)){
          res.push(this);
        }
      });

      return res;
    };
    
    lassoSelection.start = function(){
      //as the layerX's issue in IE, so use the other way to calculate the x/y point on svg element.
      //layerX = pageX - svgBounding.left
      //layerY = pageY - svgBounding.top
      svgBoundingBox = gSelection.ownerSVGElement.getBoundingClientRect();
      clientPos.x = d3.event.clientX, clientPos.y = d3.event.clientY;
      layerPos.x = clientPos.x - svgBoundingBox.left, layerPos.y = clientPos.y - svgBoundingBox.top;
      
      lassoHelper.css({
        "left": layerPos.x,
        "top": layerPos.y,
        "width": 0,
        "height": 0
      });
      
      //insert the background before the svg element in order to draw the background the behind svg
      lassoHelper.insertBefore(gSelection.ownerSVGElement.parentNode);
      
      var candidates = filter({x:clientPos.x, y:clientPos.y}, {width:0, height:0});
      
      lassoStart(candidates);
      
      start = true;
    };
    
    /**
     * when mouse move, only show the background
     */
    lassoSelection.move = function(){
      if(start){
        svgBoundingBox = gSelection.ownerSVGElement.getBoundingClientRect();
        var x1 = layerPos.x, y1 = layerPos.y, x2 = d3.event.clientX - svgBoundingBox.left, y2 = d3.event.clientY - svgBoundingBox.top;
        if (x1 > x2) { var tmp = x2; x2 = x1; x1 = tmp; }
        if (y1 > y2) { var tmp = y2; y2 = y1; y1 = tmp; }
        lassoHelper.css({left: x1, top: y1, width: x2-x1, height: y2-y1});
      }
    };
    
    lassoSelection.end = function(){
      lassoHelper.css({
        width:0,
        height:0
      });
      lassoHelper.remove();
      svgBoundingBox = gSelection.ownerSVGElement.getBoundingClientRect();
      var x1 = layerPos.x, y1 = layerPos.y, x2 = d3.event.clientX - svgBoundingBox.left, y2 = d3.event.clientY - svgBoundingBox.top;
      var cx1 = clientPos.x, cy1 = clientPos.y , cx2 = d3.event.clientX, cy2 = d3.event.clientY;
      if (x1 > x2) { var tmp = x2; x2 = x1; x1 = tmp; tmp = cx2; cx2 = cx1; cx1 = tmp;}
      if (y1 > y2) { var tmp = y2; y2 = y1; y1 = tmp; tmp = cy2; cy2 = cy1; cy1 = tmp; }
      //lassoHelper.css({left: x1, top: y1, width: x2-x1, height: y2-y1});
      
      if(x1 === x2 && y1 === y2){
        start = false;
      }else{
        var candidates = filter({x:cx1, y:cy1}, {width: x2-x1, height: y2-y1});
        lassoEnd(candidates);
        start = false;
      }
    };
    
    return lassoSelection;
  };
});
define('sap/viz/modules/util/dataUtil',['sap/viz/base/utils/TypeUtils'],
function Setup(TypeUtils) {
  var dataUtil = function (){
    var hasSameSchema = function (dataA, dataB){
       if (!dataA || !dataB || TypeUtils.isEmptyObject(dataA) || TypeUtils.isEmptyObject(dataB) ){
        return false;
      } else {
        return hasSameAASchema(dataA, dataB) && hasSameMGSchema(dataA, dataB);        
      }
    };
    
    var addMetaInfo2Data = function (module, elementName, obj) {
      var mvgData = module[elementName].data.getMeasureValuesGroupDataByIdx();
      if (TypeUtils.isArray(mvgData)) {
        for (var index1 = 0, ilen = mvgData.length; index1 < ilen; index1++) {
          if (TypeUtils.isArray(mvgData[index1].values)) {
            for (var index2 = 0, jlen = mvgData[index1].values.length; index2 < jlen; index2++) {
              if (TypeUtils.isArray(mvgData[index1].values[index2].rows)) {
                for (var index3 = 0, mlen = mvgData[index1].values[index2].rows.length; index3 < mlen; index3++) {
                  var tmp = mvgData[index1].values[index2].rows[index3];
                  if (TypeUtils.isArray(tmp)) {
                    for (var index4 = 0, nlen = tmp.length; index4 < nlen; index4++) {
                      tmp[index4].metaInfo = obj;
                    }
                  }
                }
              }
            }
          }
        }
      }
    };
    
    var updateAxisFormatString = function (module, axisName, properties, dataContext) {
      if (properties.hasOwnProperty(axisName) && TypeUtils.isExist(properties[axisName].label) && TypeUtils.isExist(properties[axisName].label.formatString)) {
        if (module.hasOwnProperty(axisName)) {
          var axisProps = module[axisName].properties();
          if (axisProps.type === 'value') {
            var axisMeasure =  dataContext.data().getMeasureValuesGroupDataByIdx(0);
            if (axisMeasure.values && TypeUtils.isArray(axisMeasure.values) && TypeUtils.isArray(axisMeasure.values[0].rows)) {
              var formatString = null, props = {label:{}};
              if (TypeUtils.isArray(properties[axisName].label.formatString)) {
                var iFormatString = properties[axisName].label.formatString[axisMeasure.values[0].rows[0][0].ctx.path.mg];
                if (iFormatString) {
                  var indexOfiFSX = axisMeasure.values[0].rows[0][0].ctx.path.mi >= iFormatString.length ? iFormatString.length -1 : axisMeasure.values[0].rows[0][0].ctx.path.mi;
                  formatString = iFormatString[indexOfiFSX];
                }
              } else if (TypeUtils.isString(properties[axisName].label.formatString)) {
                formatString = properties[axisName].label.formatString;
              }
              
              if(formatString) {
                props.label.formatString = formatString;
                module[axisName].properties(props);
              }
            }
          }
        }
      } 
    };
    
    function hasSameAASchema(dataA, dataB){
      var dataA_aa = [], dataB_aa = [];
      var i = 0;
      var temp = dataA.getAnalysisAxisDataByIdx(i);
      while (temp) {
        dataA_aa.push(temp);
        ++i;
        temp = dataA.getAnalysisAxisDataByIdx(i);
      } 
      i = 0;
      temp = dataB.getAnalysisAxisDataByIdx(i);
      while (temp) {
        dataB_aa.push(temp);
        ++i;
        temp = dataB.getAnalysisAxisDataByIdx(i);
      } 
      if (dataA_aa.length !== dataB_aa.length){
        return false;
      }
      var aaLength = dataA_aa.length;
      for (i = 0; i < aaLength; ++i){
        if (dataA_aa[i].index !== dataB_aa[i].index){
          return false;
        }
        if (! equalAAArray(dataA_aa[i].values, dataB_aa[i].values)){
          return false;
        }
      }
      return true;
    }
    
    function hasSameMGSchema(dataA, dataB){
      var dataA_mg = [], dataB_mg = [];
      var i = 0;
      var temp = dataA.getMeasureValuesGroupDataByIdx(i);
      while (temp) {
        dataA_mg.push(temp);
        ++i;
        temp = dataA.getMeasureValuesGroupDataByIdx(i);
      }
      i = 0;
      temp = dataB.getMeasureValuesGroupDataByIdx(i);
      while (temp) {
        dataB_mg.push(temp);
        ++i;
        temp = dataB.getMeasureValuesGroupDataByIdx(i);
      } 
      if (dataA_mg.length !== dataB_mg.length){
        return false;
      }
      var aaLength = dataA_mg.length;
      for (i = 0; i < aaLength; ++i){
        if (dataA_mg[i].index !== dataB_mg[i].index){
          return false;
        }
        if (! equalMGArray(dataA_mg[i].values, dataB_mg[i].values)){
          return false;
        }
      }
      return true;
      
    }
    
    function equalAAArray(arrayA, arrayB){
      if (arrayA.length !== arrayB.length){
        return false;
      }
      var length = arrayA.length;
      for (var i = 0; i < length; ++i){
        if (arrayA[i].type !== arrayB[i].type){
          return false;
        }
        if (arrayA[i].col.val !== arrayB[i].col.val){
          return false;
        }
        if (arrayA[i].rows.length !== arrayB[i].rows.length){
          return false;
        }
      }
      return true;
    }
    
    function equalMGArray(arrayA, arrayB){
      if (arrayA.length !== arrayB.length){
        return false;
      }
      var length = arrayA.length;
      for (var i = 0; i < length; ++i){
        if (arrayA[i].col !== arrayB[i].col){
          return false;
        }
        if (arrayA[i].rows.length !== arrayB[i].rows.length){
          return false;
        }
      }
      return true;
    }
    
    return {hasSameSchema:hasSameSchema, addMetaInfo2Data:addMetaInfo2Data, updateAxisFormatString:updateAxisFormatString};
  };
  return dataUtil;
});
define('sap/viz/modules/bubble',['sap/viz/base/utils/oo','sap/viz/modules/Base','sap/viz/modules/dispatch','sap/viz/util/ColorSeriesGenerator','sap/viz/util/ShapeSeriesGenerator',
'sap/viz/base/utils/TypeUtils','sap/viz/base/utils/ObjectUtils','sap/viz/util/TextUtils',
'sap/viz/modules/util/lassoSelection','sap/viz/util/Scaler','sap/viz/util/NumberUtils',
'sap/viz/util/DrawUtil','sap/viz/modules/util/tooltipDataHandler',
'sap/viz/base/utils/Objects','sap/viz/format/FormatManager','sap/viz/lang/langManager',
'sap/viz/modules/util/BoundUtil','sap/viz/modules/util/dataUtil',
'sap/viz/modules/util/defaultSelectionUtil','sap/viz/modules/Constants', 'sap/viz/base/UADetector'],
function Setup(oo, Base, dispatch, ColorSeries, ShapeSeries, TypeUtils, ObjectUtils, TextUtils,
    lassoSelection, Scaler, NumberUtils, DrawUtil, tooltipDataHandler, 
    Objects,formatManager, langManager, BoundUtil, dataUtil, defaultSelUtil, Constants, UADetector) 
{
  
  //////////////// shared functions, invisible from outside //////////////////////
  var updateFormerSize = function(width, height) {
    this._ble_formerWidth = width;
    this._ble_formerHeight = height;
  };
  ///////////////////////////////

  //////////////// CLASS VARS///////////////////////
  var CLASSMARKERSELECTED = Constants.CSS.CLASS.DATAPOINTSELECTED,
        CLASSMARKERHOVER = Constants.CSS.CLASS.DATAPOINTHOVER,
        CLASSMARKERDEFAULT = Constants.CSS.CLASS.DATAPOINTDEFAULT,
        CLASSDATAPOINT = Constants.CSS.CLASS.DATAPOINT,
        CLASSMORPHABLEDATAPOINT = Constants.CSS.CLASS.MORPHABLEDATAPOINT,
        CLASSTOOLTIP = 'v-m-tooltip',
        OPACITY1 = '0.4',
        OPACITY2 = '0.8',
        BUBBLESCALE = 1/6,
        DEFAULTMARKERSTYLE = {
          'stroke' : '#ffffff',
          'stroke-width' : 1
        },
        HOVERMARKERSTYLE = {
          'stroke' : '#ffffff',
          'stroke-width' : 1
        },
        SELECTEDMARKERSTYLE = {
          'stroke' : '#333333',
          'stroke-width' : 1
        },
        ANIMATETIME = 1000;
  var CLASSDATAPOINTCOMBINED = CLASSDATAPOINT + ' ' + CLASSMORPHABLEDATAPOINT;
  /////////////////////////////////////
  
  var Bubble = function(manifest, ctx){
    Bubble.superclass.constructor.apply(this, arguments);
    
    this._ble_width = 500;
    this._ble_height = 300;
    this._ble_padding = 0;
    this._ble_data = null;
    this._ble_props = {};
    this._ble_xManualRange = false;
    this._ble_yManualRange = false;
    this._ble_xScale = d3.scale.linear();
    this._ble_yScale = d3.scale.linear();
    this._ble_wScale = undefined;
    this._ble_hScale = undefined;
    this._ble_wMax = undefined;
    this._ble_wMin = undefined;
    this._ble_hMax = undefined;
    this._ble_hMin = undefined;
    this._ble_xMax = undefined;
    this._ble_xMin = undefined;
    this._ble_yMax = undefined;
    this._ble_yMin = undefined;
    this._ble_randomSuffix = ObjectUtils.guid();
    this._ble_distinctValuesObj = undefined;
    this._ble_color = ColorSeries.sap32().range();
    this._ble_shape = ShapeSeries.sapShapes().range();
    this._ble_g = undefined;
    this._ble_defs = undefined;
    this._ble_tooltipX = undefined;
    this._ble_tooltipY = undefined;
    this._ble_crossX = undefined;
    this._ble_crossY = undefined;
    this._ble_tooltipVisible = true;
    this._ble_hoverlineVisible = true;
    this._ble_bFirstCreation = true;
    this._ble_eDispatch = new dispatch('selectData', 'deselectData', 'showTooltip', 'hideTooltip', 'initialized', 'startToInit');
    this._ble_selection = undefined;
    this._ble_drawingEffect = 'normal';
    this._ble_effectManager = ctx.effectManager;
    this._ble_styleManager = ctx.styleManager;
    this._ble_markerSize = 10;
    this._ble_animationComplete = false;
    this._ble_hasDefaultSelection = false;
    this._ble_formatString = undefined;
    this._ble_isDataSchemaChanged = false;
    this._ble_isSizeChanged = false;
    this._ble_isDatasetChanged = false;
    this._ble_formerWidth = undefined;
    this._ble_formerHeight = undefined;
    
    this._blefn_resetBoundaryValues();
    this._ble_props = manifest.props(null);
  };

  oo.extend(Bubble, Base);
  
  Bubble.prototype.render = function(selection) {
    if (this._ble_formerWidth !== undefined && this._ble_formerHeight !== undefined){
      if (!this._ble_isSizeChanged){
        this._ble_isSizeChanged = this._ble_formerWidth !== this._ble_width || this._ble_formerHeight !== this._ble_height;
      }
    }
    updateFormerSize.call(this, this._ble_width, this._ble_height);
    BoundUtil.drawBound(selection, this._ble_width, this._ble_height);
    this._ble_selection = selection;
    this._blefn_renderChart(selection);
    this._ble_bFirstCreation = false;
    this._ble_isDataSchemaChanged = false, this._ble_isSizeChanged = false, this._ble_isDatasetChanged = false;
    return this;
  };
      
  Bubble.prototype.width = function(value) {
      if (!arguments.length){
          return this._ble_width;
      }
      this._ble_width = value;
      if(TypeUtils.isExist(this._ble_width) && TypeUtils.isExist(this._ble_height)&& TypeUtils.isExist(this._ble_data)){
         this._blefn_computeScales();
      }
      return this;
  };

  Bubble.prototype.height = function(value) {
      if (!arguments.length){
          return this._ble_height;
      }
      this._ble_height = value;
      if(TypeUtils.isExist(this._ble_width) && TypeUtils.isExist(this._ble_height)&& TypeUtils.isExist(this._ble_data)){
        this._blefn_computeScales();
      }
      return this;
  };
  
  Bubble.prototype.size = function(value) {
      if (!arguments.length){
          return {
            width: this._ble_width,
            height: this._ble_height
          };
      }
      this._ble_width = value.width;
      this._ble_height = value.height;
      if(TypeUtils.isExist(this._ble_width) && TypeUtils.isExist(this._ble_height)&& TypeUtils.isExist(this._ble_data)){
        this._blefn_computeScales();
      }
      return this;
  };
    
  Bubble.prototype.padding = function(value){
      if(!arguments.length){
          return this._ble_padding;
      }
      this._ble_padding = value;
      if(TypeUtils.isExist(this._ble_width) && TypeUtils.isExist(this._ble_height)&& TypeUtils.isExist(this._ble_data)){
        this._blefn_computeScales();
      }
      return this;
  };
  
  Bubble.prototype.valueAxis1Scale = function(value){
    if(!arguments.length){
          return this._ble_xScale;
    }
    this._ble_xScale = value;
    return this;
  };
  
  Bubble.prototype.valueAxis2Scale = function(value){
    if(!arguments.length){
      return this._ble_yScale;
    }
    this._ble_yScale = value;
    return this;
  };
  
  Bubble.prototype.valueAxis1DataRange = function(range){
    if (!arguments.length){
      return {
        min: this._ble_xMin,
        max: this._ble_xMax
      };
    }
    var tempMax, tempMin;
    if (range !== null) {
      if (!isNaN(range.max)) {
        tempMax = range.max;
      } else {
        tempMax = this._ble_xScale.perfectDomainEnd;
      }
      if (!isNaN(range.min)) {
        tempMin = range.min;
      } else {
        tempMin = this._ble_xScale.perfectDomainBegin;
      }
      if (tempMax > tempMin) {
        this._ble_xMax = tempMax;
        this._ble_xMin = tempMin;
        if (range.from === 'axis') {
          this._ble_xManualRange = true;
        }
        if(TypeUtils.isExist(this._ble_width) && TypeUtils.isExist(this._ble_height)){
          this._blefn_computeScales();
        }
      }
    } else {
      if (this._ble_xManualRange === true) {
        this._ble_xMax = this._ble_xScale.perfectDomainEnd;
        this._ble_xMin = this._ble_xScale.perfectDomainBegin;
        this._ble_xManualRange = false;
        if(TypeUtils.isExist(this._ble_width) && TypeUtils.isExist(this._ble_height)){
          this._blefn_computeScales();
        }
      }
    }
    return this;
  };
  
  Bubble.prototype.valueAxis2DataRange = function(range){
    if (!arguments.length){
      return {
        min: this._ble_yMin,
        max: this._ble_yMax
      };
    }
    var tempMax, tempMin;
    if (range !== null) {
      if (!isNaN(range.max)) {
        tempMax = range.max;
      } else {
        tempMax = this._ble_yScale.perfectDomainEnd;
      }
      if (!isNaN(range.min)) {
        tempMin = range.min;
      } else {
        tempMin = this._ble_yScale.perfectDomainBegin;
      }
      if (tempMax > tempMin) {
        this._ble_yMax = tempMax;
        this._ble_yMin = tempMin;
        if (range.from === 'axis') {
          this._ble_yManualRange = true;
        }
        if(TypeUtils.isExist(this._ble_width) && TypeUtils.isExist(this._ble_height)){
          this._blefn_computeScales();
        }
      }
    } else {
      if (this._ble_yManualRange === true) {
        this._ble_yMax = this._ble_yScale.perfectDomainEnd;
        this._ble_yMin = this._ble_yScale.perfectDomainBegin;
        this._ble_yManualRange = false;
        if(TypeUtils.isExist(this._ble_width) && TypeUtils.isExist(this._ble_height)){
          this._blefn_computeScales();
        }
      }
    }
    return this;
  };
  
  Bubble.prototype.bubbleWidthDataRange = function(range){
    if (!arguments.length){
      return {
        distinctValuesObj : this._ble_distinctValuesObj,
        min: this._ble_wMin,
        max: this._ble_wMax
      };
    }
    this._ble_wMax = range.max;
    this._ble_wMin = range.min;
    this._ble_distinctValuesObj = range.distinctValuesObj;
    if(TypeUtils.isExist(this._ble_width) && TypeUtils.isExist(this._ble_height)){
      this._blefn_computeScales();
    }
    return this;
  };
  
  Bubble.prototype.bubbleHeightDataRange = function(range){
    if (!arguments.length){
      return {
        min: this._ble_hMin,
        max: this._ble_hMax
      };
    }
    this._ble_hMax = range.max;
    this._ble_hMin = range.min;
    if(TypeUtils.isExist(this._ble_width) && TypeUtils.isExist(this._ble_height)){
      this._blefn_computeScales();
    }
    return this;
  };
  
  Bubble.prototype.colorPalette = function(value){
    if(!arguments.length){
      return this._ble_color;
    }
    this._ble_color = value;
    return this;
  };
  
  Bubble.prototype.shapes = function(value){
    if(!arguments.length){
      return this._ble_shape;
    }
    this._ble_shape = value;
    return this;
  };
  
  Bubble.prototype.sizeLegend = function() {
    var heightFeed = this._ble_data.getMeasureValuesGroupDataByIdx(3);
    var hasHeightFeed = (TypeUtils.isExist(heightFeed) && heightFeed.values.length > 0);
    var widthFeed = this._ble_data.getMeasureValuesGroupDataByIdx(2);
    var sizeLegendTitle;
    if (widthFeed && widthFeed.values.length){
      sizeLegendTitle = widthFeed.values[0].col;
    }
    return {      
        bubbleScale : BUBBLESCALE,
        space : this._ble_padding,
        scale : this._ble_wScale,
        data : this._blefn_sizeData(),
        title : sizeLegendTitle,
        hasHeightFeed : hasHeightFeed
    };
  };
  
  Bubble.prototype.dispatch = function(_){
      if(!arguments.length){
          return this._ble_eDispatch;
      }
      this._ble_eDispatch = _;
      return this;
  };
  
  Bubble.prototype.dataLabel = function(_){
    
  };
  
  Bubble.prototype.data = function(value){
      if (!arguments.length){
          return this._ble_data;
      }
      this._ble_isDatasetChanged = true;
      this._ble_isDataSchemaChanged = false;
      if (! dataUtil().hasSameSchema(this._ble_data, value)){
        this._ble_isDataSchemaChanged = true;
      }
      this._ble_data = value;
      
      var info = this._ble_data.getMeasureValuesGroupDataByIdx(0).values[0].rows[0][0].info;
      if(info && info.defaultSelection){
        this._ble_hasDefaultSelection = true;
      }else{
        this._ble_hasDefaultSelection = false;
      }
      
      if(TypeUtils.isExist(this._ble_width) && TypeUtils.isExist(this._ble_height)&& TypeUtils.isExist(this._ble_data)){
        this._blefn_calculateBoundaryValues();
        this._blefn_computeScales();
      }
      return this;            
  };

  Bubble.prototype.valueAxis1Title = function(_){
    if(!arguments.length){
    var titles =  this._ble_data.getMeasureValuesGroupDataByIdx(0), title = [];
    if(titles){
      for(var i=0, len =titles.values.length; i< len;i++ ){
        if (titles.values[i].col !== null && titles.values[i].col !== undefined)
        {
            title.push(titles.values[i].col);
        }
        else
        {
            title.push(langManager.get('IDS_ISNOVALUE'));
        }
      }
    }
    return title.join(' & ');
  }
  return this;
  };
  
  Bubble.prototype.valueAxis2Title = function(_){
    if(!arguments.length){
    var titles =  this._ble_data.getMeasureValuesGroupDataByIdx(1), title = [];
    if(titles){
      for(var i=0, len =titles.values.length; i< len;i++ ){
        if (titles.values[i].col !== null && titles.values[i].col !== undefined)
        {
            title.push(titles.values[i].col);
        }
        else
        {
            title.push(langManager.get('IDS_ISNOVALUE'));
        }
      }
    }
    return title.join(' & ');
  }
  return this;
  };

  Bubble.prototype.properties = function(_){
      if (!arguments.length){
          return this._ble_props;
      }
      Objects.extend(true, this._ble_props, _);
      this._blefn_parseOptions();
      return this;            
  };
  
  Bubble.prototype.parent = function() {
      return this._ble_selection;
  };

  Bubble.prototype.mouseover = function(target) {
      var item = d3.select(target);
      if(item === undefined || item.node() === null || !this._ble_animationComplete){
        return;
      }
      if (item.attr('id') !== null && (item.attr('id') === ('event-rect' + this._ble_randomSuffix) ||
          item.attr('id').indexOf('cross-x-') >= 0 ||
          item.attr('id').indexOf('cross-y-') >= 0)) {
          return;
      }
      var val = item.datum();
      item.attr('opacity', '1');
      if(!item.classed(CLASSMARKERSELECTED))
      {   
          item.classed(CLASSMARKERDEFAULT, false).classed(CLASSMARKERHOVER, true)
              .attr('stroke',  HOVERMARKERSTYLE.stroke)
              .attr('stroke-width',  HOVERMARKERSTYLE['stroke-width']);
      }
      
      if (this._ble_hoverlineVisible) {
          this._ble_crossX.attr('visibility', 'visible')
              .attr('x1', 0)
              .attr('y1', this._ble_yScale(val.y))
              .attr('x2', this._ble_width)
              .attr('y2', this._ble_yScale(val.y));
          this._ble_crossY.attr('visibility', 'visible')
              .attr('x1', this._ble_xScale(val.x))
              .attr('y1', 0)
              .attr('x2', this._ble_xScale(val.x))
              .attr('y2', this._ble_height);
      }
      
      this._blefn_showTooltip(val, this._ble_selection[0][0].getTransformToElement(this._ble_selection[0][0].ownerSVGElement));
      this._blefn_reDrawTooltip();
  };
  
  Bubble.prototype.mouseout = function(target, isHighlighted) {
      var item = d3.select(target);
      if(item === undefined || item.node() === null || !this._ble_animationComplete) {return;}
      if (item.attr('id') === ('event-rect' + this._ble_randomSuffix)) {
          return;
      }
      this._ble_selection.selectAll("." + CLASSMARKERHOVER).classed(CLASSMARKERHOVER, false)
             .classed(CLASSMARKERDEFAULT, true).attr('stroke',  DEFAULTMARKERSTYLE.stroke)
             .attr('stroke-width', DEFAULTMARKERSTYLE["stroke-width"]);
      if (isHighlighted) {
          item.attr('opacity', OPACITY2);
      } else {
          item.attr('opacity', OPACITY1);
      }
      
      this._ble_crossX.attr('visibility', 'hidden');
      this._ble_crossY.attr('visibility', 'hidden');
      
      this._blefn_hideTooltip();
  };
  
  Bubble.prototype.highlight = function(elems) {
      if (TypeUtils.isArray(elems)) {
          for (var i = 0, len = elems.length; i < len; i++) {
            if (d3.select(elems[i]).attr('class').indexOf(CLASSMARKERHOVER) > -1){
              d3.select(elems[i]).attr('class', CLASSMARKERSELECTED+' '+CLASSDATAPOINTCOMBINED).attr('opacity', 1).attr('stroke', SELECTEDMARKERSTYLE['stroke']).attr('stroke-width', SELECTEDMARKERSTYLE['stroke-width']);
            } else {
              d3.select(elems[i]).attr('class', CLASSMARKERSELECTED+' '+CLASSDATAPOINTCOMBINED).attr('opacity', OPACITY2).attr('stroke', SELECTEDMARKERSTYLE['stroke']).attr('stroke-width', SELECTEDMARKERSTYLE['stroke-width']);
            }
          }
      } else { // select only one bubble
        if(UADetector.isMobile()){//if mobile, set opacity of all the other elements to 0.8
          d3.selectAll(".v-datapoint-selected").attr('opacity',0.8);
        }
        if (d3.select(elems).attr('class').indexOf(CLASSMARKERHOVER) > -1){
          d3.select(elems).attr('class', CLASSMARKERSELECTED+' '+CLASSDATAPOINTCOMBINED).attr('opacity', 1).attr('stroke', SELECTEDMARKERSTYLE['stroke']).attr('stroke-width', SELECTEDMARKERSTYLE['stroke-width']);
        } else {
          d3.select(elems).attr('class', CLASSMARKERSELECTED+' '+CLASSDATAPOINTCOMBINED).attr('opacity', OPACITY2).attr('stroke', SELECTEDMARKERSTYLE['stroke']).attr('stroke-width', SELECTEDMARKERSTYLE['stroke-width']);
        }
      }
      if(this._ble_hasDefaultSelection){
        defaultSelUtil.clearSelectionInfo(this._ble_selection, true, elems);
      }
  };
  
  Bubble.prototype.unhighlight = function(elems, onMarker) {
      var sel = TypeUtils.isArray(elems) ? d3.selectAll(elems) : d3.select(elems);
      sel.classed(CLASSMARKERSELECTED,false);
      if( !UADetector.isMobile() ){
        if( onMarker !== false){
          sel.classed(CLASSMARKERHOVER, true)
               .attr('stroke', HOVERMARKERSTYLE.stroke)
               .attr('stroke-width', HOVERMARKERSTYLE['stroke-width']);
        } else {
          sel.classed(CLASSMARKERDEFAULT, true).attr('opacity',OPACITY1)
             .attr('stroke', DEFAULTMARKERSTYLE['stroke']).attr('stroke-width', DEFAULTMARKERSTYLE['stroke-width']);
        }
      } else {
        sel.classed(CLASSMARKERDEFAULT, true).attr('opacity',OPACITY1)
        .attr('stroke', DEFAULTMARKERSTYLE['stroke']).attr('stroke-width', DEFAULTMARKERSTYLE['stroke-width']);
      }
      
      if(this._ble_hasDefaultSelection){
        defaultSelUtil.clearSelectionInfo(this._ble_selection, false, elems);
      }
  };
  
  Bubble.prototype.clear = function(gray) {
      this._ble_selection.selectAll("." + CLASSMARKERSELECTED).classed(CLASSMARKERSELECTED, false).classed(CLASSMARKERDEFAULT, true)
          .attr('stroke', DEFAULTMARKERSTYLE['stroke']).attr('stroke-width', DEFAULTMARKERSTYLE['stroke-width']);
      var allMarks = this._ble_selection.selectAll('.'+CLASSDATAPOINT);
      if (gray) {
          allMarks.attr('opacity', OPACITY1);
      } else {
          if(this._ble_hasDefaultSelection){
            defaultSelUtil.clearSelectionInfo(this._ble_selection, false, allMarks);
          }
          allMarks.attr('opacity', OPACITY2);
      }
      this._ble_selection.selectAll("." + CLASSMARKERHOVER).attr('opacity', '1');
  };
  
  Bubble.prototype.destroy = function(){
    if(this._ble_xScale){
      this._ble_xScale.domain([0,1]).range([0,1]);
    }
    if(this._ble_yScale){
      this._ble_yScale.domain([0,1]).range([0,1]);
    }
	this._ble_xScale = null;
	this._ble_yScale = null;
    this._ble_wScale = undefined;
    this._ble_hScale = undefined;
    this._ble_g = undefined;
    this._ble_selection = undefined;
    if(this._ble_effectManager && this._ble_effectManager.destroy){
        this._ble_effectManager.destroy();
    }
    if(this._ble_styleManager && this._ble_styleManager.destroy){
        this._ble_styleManager.destroy();
    }
  };
  
  /////////////////////////previous internal functions////////////
  Bubble.prototype._blefn_isAnimationEnabled = function() {
    var hasAnmation = false;
    if(this._ble_bFirstCreation){
      hasAnmation = this._ble_props.animation.dataLoading;
    }else if(this._ble_isDatasetChanged){
      hasAnmation = this._ble_props.animation.dataUpdating;
    }else if(this._ble_isSizeChanged){
      hasAnmation = this._ble_props.animation.resizing;
    }
    return hasAnmation;
  };
  
  Bubble.prototype._blefn_resetBoundaryValues = function() {
    this._ble_wMax = 0; this._ble_wMin = Number.MAX_VALUE;
    this._ble_hMax = 0; this._ble_hMin = Number.MAX_VALUE;
    this._ble_xMax = 0; // max value for xAxis
    this._ble_xMin = 0; // min value for xAxis
    this._ble_yMax = 0; // max value for yAxis
    this._ble_yMin = 0; // max value for yAxis  
  };
  
  Bubble.prototype._blefn_parseOptions = function() {
    this._ble_color = this._ble_props.colorPalette;
    this._ble_shape = this._ble_props.shapePalette;
    this._ble_tooltipVisible = this._ble_props.axisTooltip.visible;
    this._ble_hoverlineVisible = this._ble_props.hoverline.visible;
    this._ble_drawingEffect = this._ble_props.drawingEffect;
    this._ble_formatString = this._ble_props.axisTooltip.formatString;
    // necessary to check, since markerSize is N/A for bubble chart and only applicable for scatter chart
    var _markerSize = this._ble_props.markerSize;
    this._ble_markerSize = TypeUtils.isExist(_markerSize) && _markerSize <= 32 && _markerSize >= 4 ? _markerSize : this._ble_markerSize;
    if(this._ble_props.xScaleType && this._ble_props.xScaleType === "log") {
      this._ble_xScale = d3.scale.log();
    }
  };
        
  Bubble.prototype._blefn_calculateBoundaryValues = function() {
    this._blefn_resetBoundaryValues();
    var measureFeed1 = this._ble_data.getMeasureValuesGroupDataByIdx(0);
    var measureFeed2 = this._ble_data.getMeasureValuesGroupDataByIdx(1);
    var bubbleWidthFeed = this._ble_data.getMeasureValuesGroupDataByIdx(2);
    var bubbleHeightFeed = this._ble_data.getMeasureValuesGroupDataByIdx(3);
    this._ble_distinctValuesObj = {};
    
    for (var i = 0; i < measureFeed1.values[0].rows.length; i++) {
      for (var j = 0; j < measureFeed1.values[0].rows[i].length; j++) {
        var x = measureFeed1.values[0].rows[i][j].val;
        var y = measureFeed2.values[0].rows[i][j].val;
        
        if (NumberUtils.isNoValue(x) || NumberUtils.isNoValue(y)) {
            continue;
        }
        
        var w = bubbleWidthFeed && bubbleWidthFeed.values.length && TypeUtils.isExist(bubbleWidthFeed.values[0].rows[i][j].val) ? Math.abs(bubbleWidthFeed.values[0].rows[i][j].val) : null;
        var h;
        if (bubbleHeightFeed && bubbleHeightFeed.values.length) {
            if (TypeUtils.isExist(bubbleHeightFeed.values[0].rows[i][j].val)) {
                h = Math.abs(bubbleHeightFeed.values[0].rows[i][j].val);
            } else {
                h = null;
            }
        } else {
            h = w;
        }

        if (!NumberUtils.isNoValue(w)) {
            this._ble_distinctValuesObj[w] = '';
        } 
        this._ble_xMax = x > this._ble_xMax ? x : this._ble_xMax;
        this._ble_xMin = x < this._ble_xMin ? x : this._ble_xMin;
        this._ble_yMax = y > this._ble_yMax ? y : this._ble_yMax;
        this._ble_yMin = y < this._ble_yMin ? y : this._ble_yMin;
        this._ble_wMax = w > this._ble_wMax ? w : this._ble_wMax;
        this._ble_wMin = w < this._ble_wMin ? w : this._ble_wMin;
        this._ble_hMax = h > this._ble_hMax ? h : this._ble_hMax;
        this._ble_hMin = h < this._ble_hMin ? h : this._ble_hMin;
      }
    } 
  };
  
  Bubble.prototype._blefn_computeXScale = function() {
    //when xmax and xmin are 0, we make the xscale.domain(0,1)
    if( this._ble_xMax === 0 && this._ble_xMin === 0 ){
      this._ble_xScale.domain([0, 1]).range([this._ble_padding, this._ble_width - this._ble_padding]);
    }else{
      if (this._ble_xManualRange) {
        this._ble_xScale.domain([this._ble_xMin, this._ble_xMax]).range([this._ble_padding, this._ble_width - this._ble_padding]);
      } else {
        this._ble_xScale.domain([this._ble_xMin * (1 + BUBBLESCALE), this._ble_xMax * (1 + BUBBLESCALE)]).range([this._ble_padding, this._ble_width - this._ble_padding]);
      }
    }
  };
  
  Bubble.prototype._blefn_computeYScale = function() {
    //when ymin and ymax are 0 ,we make the yscale.domain(0,1)
    if( this._ble_yMax === 0 && this._ble_yMin === 0){
      this._ble_yScale.domain([0,1]).range([this._ble_height - this._ble_padding, this._ble_padding]);  
    }else{
      if (this._ble_yManualRange) {
        this._ble_yScale.domain([this._ble_yMin, this._ble_yMax]).range([this._ble_height - this._ble_padding, this._ble_padding]);
      } else {
        this._ble_yScale.domain([this._ble_yMin * (1 + BUBBLESCALE), this._ble_yMax * (1 + BUBBLESCALE)]).range([this._ble_height - this._ble_padding, this._ble_padding]);
      }
    }
  };
  
  Bubble.prototype._blefn_computeWScale = function() {
    var that = this;
    var bubbleWidthFeed = this._ble_data.getMeasureValuesGroupDataByIdx(2);
    var bubbleHeightFeed = this._ble_data.getMeasureValuesGroupDataByIdx(3);
    //[Jimmi/8/17/2012]here we means if you don't feed data for width and height, we won't change the scale even if the data range
    //has been passed by  bubbleWidthDataRange and bubbleHeightDataRange
    if (bubbleWidthFeed && bubbleWidthFeed.values.length && this._ble_wMax !== this._ble_wMin) {
        this._ble_wScale = this._blefn_bubbleSizeScale(this._ble_wMax, true, bubbleHeightFeed);
    } else {
        this._ble_wScale = function(value) {
            return that._ble_markerSize;
        };
    }
  };
  
  Bubble.prototype._blefn_computeHScale = function() {
    var that = this;
    var bubbleHeightFeed = this._ble_data.getMeasureValuesGroupDataByIdx(3);
    if (bubbleHeightFeed && bubbleHeightFeed.values.length && this._ble_hMax !== this._ble_hMin) {
        this._ble_hScale = this._blefn_bubbleSizeScale(this._ble_hMax, false);
    } else {
      if(this._ble_wScale && this._ble_hMax > this._ble_hMin){
        this._ble_hScale = this._ble_wScale;
      }else{
        this._ble_hScale = function(value) {
            return that._ble_markerSize;
        };
      }
    }
  };
    
  Bubble.prototype._blefn_computeScales = function() {
    this._blefn_computeXScale();
    if (!this._ble_xManualRange) {
      Scaler.perfect(this._ble_xScale);
    } else {
      Scaler.getRoughTickNum(this._ble_xScale);
    }
    this._blefn_computeYScale();
    if (!this._ble_yManualRange) {
      Scaler.perfect(this._ble_yScale);
    } else {
      Scaler.getRoughTickNum(this._ble_yScale);
    }

    this._blefn_computeWScale();
    this._blefn_computeHScale();
  };

  Bubble.prototype._blefn_renderChart = function(selection) {
      // TODO: avoid repeat drawing data when re-draw
      if (this._ble_g) {
          this._ble_g.remove();
      }
      if (this._ble_defs) {
          this._ble_defs.remove();
      }
      
      this._ble_eDispatch.startToInit();
      
      var i;//for iteration
      
      //we will share tooltip-x and tooltip-y between modules in a same chart
      var parent = d3.select(selection.node().ownerSVGElement.parentNode);
      if (this._ble_tooltipVisible && parent.select('svg.sc-tooltip-x').node() === null) {
        parent.append('svg').style('position', 'absolute').style('direction','ltr').attr('class', 'sc-tooltip-x ' + CLASSTOOLTIP).attr('pointer-events', 'none').attr('width', '0').attr('height', 0);
      }
      this._ble_tooltipX = parent.select('svg.sc-tooltip-x');
      if (this._ble_tooltipVisible && parent.select('svg.sc-tooltip-y').node() === null) {
        parent.append('svg').style('position', 'absolute').style('direction','ltr').attr('class', 'sc-tooltip-y ' + CLASSTOOLTIP).attr('pointer-events', 'none').attr('width', '0').attr('height', 0);
      }
      this._ble_tooltipY = parent.select('svg.sc-tooltip-y');
      
  //    getThemeStyleDef();
      
      var measureFeed1 = this._ble_data.getMeasureValuesGroupDataByIdx(0);
      var measureFeed2 = this._ble_data.getMeasureValuesGroupDataByIdx(1);
      var bubbleWidthFeed = this._ble_data.getMeasureValuesGroupDataByIdx(2);
      var bubbleHeightFeed = this._ble_data.getMeasureValuesGroupDataByIdx(3);
      var colorFeed = this._ble_data.getAnalysisAxisDataByIdx(0);
      var shapeFeed = this._ble_data.getAnalysisAxisDataByIdx(1);
      
     
      var clipPathId = 'edge-clip-' + this._ble_randomSuffix;
      var defs = this._ble_defs = selection.append('defs');
      defs.append('clipPath').attr('id', clipPathId).append('rect').attr('width', this._ble_width).attr('height', this._ble_height);
      
      var g = this._ble_g = selection.append('g').attr('class','v-datashapesgroup');  
      g.attr('clip-path', 'url(#' + clipPathId + ')');  
      
      g.append('rect')
              .attr('x', 0)
              .attr('y', 0)
              .attr('width', this._ble_width)
              .attr('height', this._ble_height)
              .attr('fill-opacity', 0)
              .attr('id', 'event-rect' + this._ble_randomSuffix);
      var hoverlineStyle = this._ble_styleManager.queryDefault('v-hoverline');
      this._ble_crossX = g.append('line').attr('id', 'cross-x-' + this._ble_randomSuffix).attr('class', 'v-hoverline').attr('stroke-width', 1).attr('stroke', hoverlineStyle['stroke']).attr('shape-rendering','crispEdges').attr('visibility', 'hidden');
      this._ble_crossY = g.append('line').attr('id', 'cross-y-' + this._ble_randomSuffix).attr('class', 'v-hoverline').attr('stroke-width', 1).attr('stroke', hoverlineStyle['stroke']).attr('shape-rendering','crispEdges').attr('visibility', 'hidden');
      
      var colorIndex = 0;
      var colorContainer = {};
      
      function renderByShape(i, renderShape, renderArray) {
          for (var j = 0; j < measureFeed1.values[0].rows[i].length; j++) {
              // Currently just group by the first dimension in hierarchy
              var colorFeedVal = (colorFeed && colorFeed.values.length  > 0) ? colorFeed.values[0].rows[j].val : 0;
              var colorValue;
              if (colorContainer[colorFeedVal]) {
                  colorValue = colorContainer[colorFeedVal];
              } else {
                  colorValue = this._ble_color[colorIndex % this._ble_color.length];
                  colorContainer[colorFeedVal] = colorValue;
                  colorIndex++;
              }
              var x = measureFeed1.values[0].rows[i][j].val;
              var y = measureFeed2.values[0].rows[i][j].val;
              var w = bubbleWidthFeed && bubbleWidthFeed.values.length ? bubbleWidthFeed.values[0].rows[i][j].val : null;
              var h = bubbleHeightFeed && bubbleHeightFeed.values.length ? bubbleHeightFeed.values[0].rows[i][j].val : null;
              
              var renderData = {
                  x : x,
                  y : y,
                  w : w, 
                  h : h,
                  colorIndex : j,
                  shapeIndex : i,
                  colorValue : colorValue,
                  shapeValue : renderShape,
                  val : [x, y, w, h],
                  ctx : [
                      measureFeed1.values[0].rows[i][j].ctx, 
                      measureFeed2.values[0].rows[i][j].ctx,
                      bubbleWidthFeed && bubbleWidthFeed.values.length ? bubbleWidthFeed.values[0].rows[i][j].ctx : null,
                      bubbleHeightFeed && bubbleHeightFeed.values.length ? bubbleHeightFeed.values[0].rows[i][j].ctx : null
                  ],
                  info : [
                           measureFeed1.values[0].rows[i][j].info, 
                           measureFeed2.values[0].rows[i][j].info,
                           bubbleWidthFeed && bubbleWidthFeed.values.length ? bubbleWidthFeed.values[0].rows[i][j].info : null,
                           bubbleHeightFeed && bubbleHeightFeed.values.length ? bubbleHeightFeed.values[0].rows[i][j].info : null
                  ]
              };
              
              if (!NumberUtils.isNoValue(x) && !NumberUtils.isNoValue(y)) {
                  renderArray.push(renderData);
              }
          }
      }
      
      
      
      
      var renderArray = [];
      var renderShape;
      if (shapeFeed && shapeFeed.values.length > 0) {
          i = 0;
          for (var shapeIndex = 0, shapeContainer = {}; i < shapeFeed.values[0].rows.length; i++) {
              // Currently just group by the first dimension in hierarchy
              var shapeFeedVal = shapeFeed.values[0].rows[i].val;
              if (shapeContainer[shapeFeedVal]) {
                  renderShape = shapeContainer[shapeFeedVal];
              } else {
                  renderShape = this._ble_shape[shapeIndex % this._ble_shape.length];
                  shapeContainer[shapeFeedVal] = renderShape;
                  shapeIndex++;
              }
              renderByShape.call(this, i, renderShape, renderArray);
          }
      } else {
          renderByShape.call(this, 0, this._ble_shape[0], renderArray);
      }

      // sort to draw big shape first
            renderArray.sort(function(a, b) {
                var ah = a.h === null ? a.w : a.h;
                var bh = b.h === null ? b.w : b.h;
                return Math.abs(b.w * bh) - Math.abs(a.w * ah);
            });
            
            var completedArray = 0;
            this._ble_animationComplete = false;
            this._blefn_hideTooltip();
            var that = this;
            function checkAnimationCompleted(d, m) {
                completedArray++;
                if (completedArray === renderArray.length) {
                  that._ble_animationComplete = true;
                    that._ble_eDispatch.initialized();
                }
            }
 
            var enableAnimation = this._blefn_isAnimationEnabled();
            for (i = 0; i < renderArray.length; i++) {
                var x = renderArray[i].x, 
                    y = renderArray[i].y, 
                    w = renderArray[i].w, 
                    h = bubbleHeightFeed && bubbleHeightFeed.values.length ? renderArray[i].h : w, 
                    colorValue = renderArray[i].colorValue; 
                renderShape = renderArray[i].shapeValue;
                    
                    
                var markerShape;
                
                var rx = this._ble_wScale(w) / 2,
                  ry = this._ble_hScale(h) / 2;
                var aniTime = 0;
                if (enableAnimation){
                  aniTime = ANIMATETIME;
                }
                var newG = g.append('g').attr('class', 'v-datashape').attr('transform', 'translate(' + this._ble_xScale(x) + ',' + this._ble_yScale(y) + ')');
                var element = DrawUtil.createElements(newG, {shape: renderShape, className: CLASSMARKERDEFAULT + " " + CLASSDATAPOINTCOMBINED} );
                var parameter = {
                  drawingEffect: this._ble_drawingEffect,
                  fillColor: colorValue,
                  graphType: renderShape,
                  direction: 'vertical',
                  rx: rx,
                  ry: ry,
                  borderWidth:  DEFAULTMARKERSTYLE['stroke-width'],
                  borderColor: DEFAULTMARKERSTYLE['stroke'],
                  node:element,
                  visibility: "visible",
                  animateTime: aniTime,
                  endFunc: checkAnimationCompleted
                };

                DrawUtil.drawGraph(parameter, this._ble_effectManager).attr('opacity', OPACITY2);
            }
            
      selection.selectAll('.' + CLASSDATAPOINT).data(renderArray);
      
      if (!enableAnimation) {
        this._ble_animationComplete = true;
          this._ble_eDispatch.initialized();
      }
  };
        
  Bubble.prototype._blefn_bubbleSizeScale = function(vMax, forWidth, hasHeightFeed) {
      var that = this;
      // even 0 value for bubble size, still render a small size shape
      return function(value) {
          if (NumberUtils.isNoValue(value)) {
              return 4;
          }
          var range;
          if (forWidth) {
              range = (!hasHeightFeed && (that._ble_height < that._ble_width)) ? that._ble_height : that._ble_width;
          } else {
              range = that._ble_height;
          }
          var r = Math.pow(Math.abs(value) / vMax, 0.5) * (range - that._ble_padding) * BUBBLESCALE;
          return r > 4 ? r : 4;
      };
  };
        
  Bubble.prototype._blefn_sizeData = function() {
      var wDistinctValues = 0;
      for (var i in this._ble_distinctValuesObj) {
        if(this._ble_distinctValuesObj.hasOwnProperty(i)){
          wDistinctValues++;
        }
      }
      if (wDistinctValues === 0) {
          return [];
      } else if (wDistinctValues === 1) {
          return [this._ble_wMax];
      } else if (wDistinctValues === 2) {
          return [this._ble_wMax, this._ble_wMin];
      } else {
          return [this._ble_wMax, (this._ble_wMax + this._ble_wMin) / 2, this._ble_wMin];
      }
  };
     
  Bubble.prototype._blefn_showTooltip = function(val, transform) {
      var measureFeed1 = this._ble_data.getMeasureValuesGroupDataByIdx(0);
      var measureFeed2 = this._ble_data.getMeasureValuesGroupDataByIdx(1);
      var bubbleWidthFeed = this._ble_data.getMeasureValuesGroupDataByIdx(2);
      var bubbleHeightFeed = this._ble_data.getMeasureValuesGroupDataByIdx(3);
      var colorFeed = this._ble_data.getAnalysisAxisDataByIdx(0);
      var shapeFeed = this._ble_data.getAnalysisAxisDataByIdx(1);
      
      var tooltipData = {
          body: [],
          footer: []
      };
      var footer;//for iteration
      //push color footer to tooltipData
      for (var i = 0, len = (colorFeed ? colorFeed.values.length : 0); i < len; i++) {
        footer = {};
        footer.label = colorFeed.values[i].col.val;
        footer.value = colorFeed.values[i].rows[val.colorIndex].val;
        tooltipData.footer.push(footer);
      }
      //push shape footer to tooltipData
      for (var j = 0, jlen = (shapeFeed ? shapeFeed.values.length : 0); j < jlen; j++) {
        footer = {};
        footer.label = shapeFeed.values[j].col.val;
        footer.value = shapeFeed.values[j].rows[val.shapeIndex].val;
        tooltipData.footer.push(footer);
      }
      
      var xObj = {path:{}}, yObj = {path:{}}, hObj = {path:{}}, wObj = {path:{}};
      xObj.path.mg = val.ctx[0].path.mg;
      xObj.path.mi = val.ctx[0].path.mi;
      tooltipData.body.push({
        name : !TypeUtils.isExist(measureFeed1.values[0].col) ? langManager.get('IDS_ISNOVALUE') : measureFeed1.values[0].col,
        val : [{
          color : val.colorValue,
          shape : val.shapeValue,
          value : val.x
        }],
        ctx : xObj
      });
      
      yObj.path.mg = val.ctx[1].path.mg;
      yObj.path.mi = val.ctx[1].path.mi;
      tooltipData.body.push({
        name : !TypeUtils.isExist(measureFeed2.values[0].col) ? langManager.get('IDS_ISNOVALUE') : measureFeed2.values[0].col,
        val :[{
          color : val.colorValue,
          shape : val.shapeValue,
          value : val.y
        }],
        ctx : yObj
      });
      
      if (bubbleWidthFeed && bubbleWidthFeed.values.length > 0) {
        wObj.path.mg = val.ctx[2].path.mg;
        wObj.path.mi = val.ctx[2].path.mi;
        tooltipData.body.push({
            name : !TypeUtils.isExist(bubbleWidthFeed.values[0].col) ? langManager.get('IDS_ISNOVALUE') : bubbleWidthFeed.values[0].col,
            val : [{
              color : val.colorValue,
              shape : val.shapeValue,
              value : NumberUtils.isNoValue(val.w) ? langManager.get('IDS_ISNOVALUE') : val.w
            }],
            ctx : wObj
          });
      }
      if (bubbleHeightFeed && bubbleHeightFeed.values.length > 0) {
        hObj.path.mg = val.ctx[3].path.mg;
        hObj.path.mi = val.ctx[3].path.mi;
        tooltipData.body.push({
            name : !TypeUtils.isExist(bubbleHeightFeed.values[0].col) ? langManager.get('IDS_ISNOVALUE') : bubbleHeightFeed.values[0].col,
            val : [{
              color : val.colorValue,
              shape : val.shapeValue,
              value : NumberUtils.isNoValue(val.h) ? langManager.get('IDS_ISNOVALUE') : val.h
            }],
            ctx : hObj
          });
      }

      tooltipData.point = {
         x : this._ble_xScale(val.x),
         y : this._ble_yScale(val.y) + transform.f
      };
      tooltipData.plotArea = {
         x : transform.e,
         y : transform.f,
         width : this._ble_width,
         height : this._ble_height
      };
      
      this._ble_eDispatch.showTooltip(tooltipDataHandler.formatTooltipData(tooltipData));
      
      if (this._ble_tooltipVisible) {
          var xAxisValue, yAxisValue;
          if (TypeUtils.isExist(this._ble_formatString)) {
              xAxisValue = formatManager.format(val.x, this._ble_formatString[0]);
              yAxisValue = formatManager.format(val.y, this._ble_formatString[1]);
          } else {
              xAxisValue = val.x;
              yAxisValue = val.y;
          }
          this._blefn_drawXYTooltip(xAxisValue, this._ble_tooltipX, {
              x : this._ble_xScale(val.x),
              y : this._ble_yScale(val.y)
          }, transform, 'x');
          this._blefn_drawXYTooltip(yAxisValue, this._ble_tooltipY, {
              x : this._ble_xScale(val.x),
              y : this._ble_yScale(val.y)
          }, transform, 'y');
      }

  };
  
  // This function's purpose is re-draw the tooltip(position&width&height) so that the bubble&scatter chart's tooltip be showed correctly on Android browser
  // Although we fixed tooltip bugs in this way, we still do not know the reasons,maybe it due to Android browser's compatibility or sth else
  // Edited by Joe&Ian, feel free to contact us if any questions
  Bubble.prototype._blefn_reDrawTooltip = function() {
    if (this._ble_tooltipVisible) {
      var parent = d3.select(this._ble_selection.node().ownerSVGElement.parentNode);
      var tooltip_x = parent.select('.sc-tooltip-x.v-m-tooltip').remove();
      var tooltip_y = parent.select('.sc-tooltip-y.v-m-tooltip').remove();
      parent.node().appendChild(tooltip_x.node());
      parent.node().appendChild(tooltip_y.node());
    }
  };
        
  Bubble.prototype._blefn_hideTooltip = function() {
      this._ble_eDispatch.hideTooltip();
      if (this._ble_tooltipVisible) {
          this._ble_tooltipX.selectAll('g').remove();
          this._ble_tooltipY.selectAll('g').remove();
      }
  };
  
  Bubble.prototype._blefn_drawXYTooltip = function(value, container, point, transform, axis) {
      var font = {
          size : '12px',
          weight : 'bold',
          family : '"Open Sans", Arial, Helvetica, sans-serif'
      };
      var valueSize = TextUtils.fastMeasure(value, font.size, font.weight, font.family);
      container.attr('width', valueSize.width + 20).attr('height', valueSize.height + 10);
      container.wrapper = container.append('g');
      container.wrapper.append('rect')
              .attr('x', 1)
              .attr('y', 1)
              .attr('rx', 4)
              .attr('ry', 4)
              .attr('width', valueSize.width + 18)
              .attr('height', valueSize.height + 8)
              .attr('fill', '#ffffff')
              .attr('stroke', '#000000')
              .attr('stroke-width', 1)
              .attr('class', 'v-background');
      container.wrapper.append('text')
              .attr('x', 10)
              .attr('y', valueSize.height + 3)
              .attr('fill', '#000000')
              .style('font', font.weight + ' ' + font.size + ' ' + font.family)
              .attr('class', 'v-body-value')
              .text(value);
      if ('y' === axis) {
          var left = transform.e - container.attr('width') + 1;
          container.style('left', (left < 0 ? 0 : left) + 'px').style('top',( point.y + transform.f - container.attr('height') / 2 ) + 'px');
      } else if ('x' === axis) {
          container.style('left', point.x + transform.e -  container.attr('width') / 2 + 'px').style('top', transform.f + this._ble_height - 1 + 'px');
      }
  };
  ////////////////////////////////
  
  return Bubble;
});

define('sap/viz/feeds/Scatter',['sap/viz/feeds/Manifest','sap/viz/data/feed/Constants'],
function Setup(Manifest, constants) {
  var feeds = {
    id : "scatter",
    feeds : [ {
      'id' : 'regionColor',
      'name' : 'IDS_REGIONCOLOR',
      'type' : constants.Type.Dimension,
      'min' : 0,
      'max' : 1,
      'aaIndex' : 1,
      'acceptMND': -1
    }, {
      'id' : 'regionShape',
      'name' : 'IDS_REGIONSHAPE',
      'type' : constants.Type.Dimension,
      'min' : 0,
      'max' : 1,
      'aaIndex' : 2,
      'acceptMND': -1
    }, {
      'id' : 'primaryValues',
      'name' : 'IDS_PRIMARYVALUES',
      'type' : constants.Type.Measure,
      'min' : 1,
      'max' : 1,
      'mgIndex' : 1
    }, {
      'id' : 'secondaryValues',
      'name' : 'IDS_SECONDARYVALUES',
      'type' : constants.Type.Measure,
      'min' : 1,
      'max' : 1,
      'mgIndex' : 2
    }, {
      'id' : 'bubbleWidth',
      'name' : 'IDS_BUBBLEWIDTH',
      'type' : constants.Type.Measure,
      'min' : 0,
      'max' : 1,
      'mgIndex' : 3
    }, {
      'id' : 'bubbleHeight',
      'name' : 'IDS_BUBBLEHEIGHT',
      'type' : constants.Type.Measure,
      'min' : 0,
      'max' : 1,
      'mgIndex' : 4
    } ]
  };
  Manifest.register(feeds);
});
define('sap/viz/modules/manifests/Bubble',['sap/viz/modules/manifests/Module','sap/viz/modules/Constants','sap/viz/modules/bubble','sap/viz/feeds/Scatter'],
function Setup(Manifest, Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.bubble',
    'type' : Constants.Type.Chart,
    'name' : 'bubble',
    'data' : 'DATA STRUCTURE DOC',
    'properties' : {
      'colorPalette' : {
        'name' : 'colorPalette',
        'supportedValueType' : 'StringArray',
        'defaultValue' : Constants.COLOR.SAPColorSingleAxis,
        'description' : 'Set marker color of bubble.',
        'example': "<a href='"+Constants.DocExample.SnippetUrl+"4449' target='_blank'>"+Constants.DocExample.TryThisValue+"</a>"
      },
      'shapePalette' : {
        'name' : 'shapePalette',
        'supportedValueType' : 'StringArray',
        'defaultValue' : [ 'circle', 'square', 'diamond', 'triangleUp',
            'triangleDown', 'triangleLeft', 'triangleRight', 'cross', 'intersection' ],
        'supportedValues' : [ 'circle', 'square', 'diamond', 'triangleUp',
              'triangleDown', 'triangleLeft', 'triangleRight', 'cross', 'intersection' ],
        'description' : 'Set marker shape of bubble.'
      },
      'axisTooltip' : {
        'name' : 'axisTooltip',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'visible' : {
            'name' : 'visible',
            'supportedValueType' : 'Boolean',
            'defaultValue' : true,
            'description' : 'enabled/disabled tooltip.'
          },
          'formatString': {
      		'name' : 'formatString',
      		'supportedValueType': 'StringArray',
      		'defaultValue' : null,
      		'description' : 'Set format string for small tooltip.The first one is applied to xAxis and the second one is applied to yAxis.Any character in "MDYHSAmdyhsa#?%0@" is reserved as a token for format code.'
          }
        },
        'description' : 'Set tooltip related properties.'
      },
      'hoverline' : {
        'name' : 'hoverline',
        'supportedValueType' : 'Object',
        'description' : 'Settings for hoverline properties.',
        'supportedValues' : {
          'visible' : {
            'name' : 'visible',
            'supportedValueType' : 'Boolean',
            'defaultValue' : true,
            'description' : 'Set to enabled/disabled hoverline or not.'
          }
        }
      },
      'animation' : {
          'name' : 'animation',
          'supportedValueType' : 'Object',
          'supportedValues' : {
            'dataLoading' : {
              'name' : 'dataLoading',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enable/disable data loading animation of plot area.'
            },
            'dataUpdating' : {
              'name' : 'dataUpdating',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enable/disable data updating animation of plot area.'
            },
            'resizing' : {
              'name' : 'resizing',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enable/disable resizing animation of plot area.'
            }
          },
          'description' : 'Set animation of bubble/scatter.',
          'example': "<a href='"+Constants.DocExample.SnippetUrl+"8535' target='_blank'>"+Constants.DocExample.TryThisValue+"</a>"
        },
        'drawingEffect':{
          'name' : 'drawingEffect',
           'supportedValueType' : 'String',
            'supportedValues' : [ 'normal', 'glossy' ],
            'defaultValue' : 'normal',
            'description' : 'Drawing effect of bubble marker.',
            'isExported' : true
        }
    },
    'css' : {
        '.v-hoverline' : {
            'description' : 'Define style for hover line color.',
            'value' : {
                'stroke' : '#cccccc'
            }
        }
    },
    'events' : {
      'initialized': Constants.Event.Initialized.desc,
        'selectData' : Constants.Event.SelectData.desc,
        'deselectData' : Constants.Event.DeSelectData.desc,
        'showTooltip' : Constants.Event.TooltipShow.desc,
        'hideTooltip' : Constants.Event.TooltipHide.desc
    },
    'feeds' : {
      id : "scatter",
      configure : {
        bubbleWidth:
        {
          min:1
        }
      }
    },
  
    'configure' : null,
    fn : fn
  };
  Manifest.register(module);
});
define('sap/viz/manifests/scatter/BubbleChart',['sap/viz/manifests/Viz','sap/viz/modules/Constants','sap/viz/modules/manifests/RootContainer',
'sap/viz/manifests/scatter/BaseBubbleChart','sap/viz/modules/manifests/Bubble'],
function Setup ( Manifest, Constants ) {
  var chart = {
    id : 'viz/bubble',
    name : 'IDS_BUBBLECHART',
    base : "viz/scatter/single/base",
    modules : {
      root : {
        configure : {
          properties : {
            layout : { adjustPolicy : Constants.LAYOUT_ADJUST_POLICY.APPROXIMATE }
          }
        },
        modules : {
          legends : {
            modules : {
              sizeLegend : {
                id : 'sap.viz.modules.legend.common',
                configure : {
                  description : 'The size legend is a box mapping the charts data shapes\' size to the value by some typical symbols and associated indication values.',
                  propertyCategory : 'sizeLegend',
                  properties : {
                    type : 'SizeLegend',
                    layout : { order : 0 }
                  },
                  propertiesOverride  : {
                    isHierarchical : { isExported : false },
                    isScrollable :  { isExported: false },
                    formatString: { isExported: true }
                  }
                }
              }
            }
          },

          tooltip : {
            configure : {
              properties : { chartType : 'bubble' }
            }
          },
          
          main : {
            modules : {
              dataLabel : {
                id : 'sap.viz.modules.datalabel',
                configure : {
                  properties : {
                    automaticInOutside : true,
                    position : 'inside'
                  }
                }
              },
              plot : {
                id : 'sap.viz.modules.bubble',
                configure : {
                  description : 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory : 'plotArea'
                }
              }
            }
          }
        }
      }
    },
    dependencies : {
      attributes : [  
        undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined,
     {
        targetModule : 'root.legends.sizeLegend',
        target : 'sizeLegendInfo',
        sourceModule : 'root.main.plot',
        source : 'sizeLegend'
      } ],
      events : [ {
        targetModule : 'root.tooltip',
        listener : 'showTooltip',
        sourceModule : 'root.main.plot',
        type : 'showTooltip'
      }, {
        targetModule : 'root.tooltip',
        listener : 'hideTooltip',
        sourceModule : 'root.main.plot',
        type : 'hideTooltip'
      }, {
        targetModule : 'root',
        listener : 'relayout',
        sourceModule : 'root.legends',
        type : 'relayout'
      },{
          targetModule : 'root.interaction',
          listener : 'registerEvent',
          sourceModule : 'root.main.plot',
          type : 'initialized.interaction'
        }, {
        targetModule : 'root.interaction',
        listener : 'highlightedByLegend',
        sourceModule : 'root.legends.legend',
        type : 'highlightedByLegend'
        }, {
        targetModule : 'root.legends.legend',
        listener : 'deselectLegend',
        sourceModule : 'root.interaction',
        type : 'deselectLegend'
        }, {
          targetModule : 'root.main.dataLabel',
          listener : 'showLabel',
          sourceModule : 'root.main.plot',
          type : 'initialized.datalabel'
        }, {
          targetModule : 'root.main.dataLabel',
          listener : 'removeLabel',
          sourceModule : 'root.main.plot',
          type : 'startToInit.datalabel'
        },  {
          targetModule : 'root.interaction',
          listener : 'defaultSelection',
          sourceModule : 'root.main.plot',
          type : 'initialized.defaultSelection'
        }]
    }
  };

  Manifest.register(chart);
});
define('sap/viz/modules/manifests/Scatter',['sap/viz/modules/manifests/Module','sap/viz/modules/manifests/Bubble'],
function Setup(Manifest) {
  var module = {
    'id' : 'sap.viz.modules.scatter',
    base : 'sap.viz.modules.bubble',
    'name' : 'scatter',
    'properties' : {
        'markerSize' : {
            'name' : 'markerSize',
              'supportedValueType' : 'PositiveInt',
              'defaultValue' : "10",
              'description' : 'Set marker size of data point. The available range is from 4 to 32.'
        }
    },
    'feeds' : {
      configure : {
        bubbleWidth : null,
        bubbleHeight : null
      }
    }
  };
  Manifest.register(module);
});
define('sap/viz/modules/datatransform',['sap/viz/base/utils/TypeUtils','sap/viz/manifest','sap/viz/base/utils/Objects','sap/viz/util/NumberUtils',
'sap/viz/modules/dispatch'],
function Setup(TypeUtils, Manifest, Objects, NumberUtils, dispatch) {
  var datatransform = function(manifest) {
    var _props = manifest.props(null);
    var _data;
    var _autoBinning = {
          displayString : 'Others'
        },
        _dataSampling = {}; 
    var wMax,wMin,hMax,hMin,xMax,xMin,yMax,yMin;
    
    //currently we don't need initialized for this module
    //var d = dispatch('initialized');
	
    function transformation (){
    }
    
    transformation.data = function(data) {
      if (!arguments.length){
        return _data;
      }
      _data = data;
      return transformation;
    };
    
    transformation.properties = function(properties){
      if (!arguments.length){
        return _props;
      }
      Objects.extend(true, _props, properties);
      parseOptions();
      if (_data) {
        dataTransformer(_data);
      }
      return transformation;
    };
    
    transformation.parent = function(){};
    
    function resetBoundaryValues() {
      wMax = 0; wMin = Number.MAX_VALUE;
      hMax = 0; hMin = Number.MAX_VALUE;
      xMax = 0; // max value for xAxis
      xMin = 0; // min value for xAxis
      yMax = 0; // max value for yAxis
      yMin = 0; // max value for yAxis  
    }

    function calculateBoundaryValues(data) {
      resetBoundaryValues();
      var measureFeed1 = data.getMeasureValuesGroupDataByIdx(0);
      var measureFeed2 = data.getMeasureValuesGroupDataByIdx(1);
      var bubbleWidthFeed = data.getMeasureValuesGroupDataByIdx(2);
      var bubbleHeightFeed = data.getMeasureValuesGroupDataByIdx(3);
      var distinctValuesObj = {};
      
      for (var i = 0; i < measureFeed1.values[0].rows.length; i++) {
        for (var j = 0; j < measureFeed1.values[0].rows[i].length; j++) {
            var x = measureFeed1.values[0].rows[i][j].val;
            var y = measureFeed2.values[0].rows[i][j].val;
            
            if (NumberUtils.isNoValue(x) || NumberUtils.isNoValue(y)) {
                continue;
            }
            
            var w = bubbleWidthFeed && bubbleWidthFeed.values.length && TypeUtils.isExist(bubbleWidthFeed.values[0].rows[i][j].val) ? Math.abs(bubbleWidthFeed.values[0].rows[i][j].val) : null;
            var h;
            if (bubbleHeightFeed && bubbleHeightFeed.values.length) {
                if (TypeUtils.isExist(bubbleHeightFeed.values[0].rows[i][j].val)) {
                    h = Math.abs(bubbleHeightFeed.values[0].rows[i][j].val);
                } else {
                    h = null;
                }
            } else {
                h = w;
            }

            if (!NumberUtils.isNoValue(w)) {
                distinctValuesObj[w] = '';
            } 
            xMax = x > xMax ? x : xMax;
            xMin = x < xMin ? x : xMin;
            yMax = y > yMax ? y : yMax;
            yMin = y < yMin ? y : yMin;
            wMax = w > wMax ? w : wMax;
            wMin = w < wMin ? w : wMin;
            hMax = h > hMax ? h : hMax;
            hMin = h < hMin ? h : hMin;
        }
      }
    }
 
    function fillGridBox (gridBoxArray, obj) {
      var isFind = false;
      for (var i = 0; i < _dataSampling.grid.column; i++) {
        var pos = 0;
        if (isFind) {
          break;
        }
        pos = i*_dataSampling.grid.row;
        if (obj.x >= gridBoxArray[pos].xRange.x1 && obj.x < gridBoxArray[pos].xRange.x2 || obj.x === xMax) {
          for (var j = 0; j < _dataSampling.grid.row; j++) {
            if (obj.y >= gridBoxArray[pos + j].yRange.y1 && obj.y < gridBoxArray[pos + j].yRange.y2 || obj.y === yMax) {
              gridBoxArray[pos + j].indexArray.push(obj.index);
              gridBoxArray[pos + j].refArray.push(obj.ref);
              isFind = true;
              break;
            }
          }
        }
      }
    }
    
    function scatterDataSampling (data) {
      var measureFeed1 = data.getMeasureValuesGroupDataByIdx(0);
      var measureFeed2 = data.getMeasureValuesGroupDataByIdx(1);
      var dataPointNum = measureFeed1.values[0].rows.length * measureFeed1.values[0].rows[0].length;
      if (_dataSampling.sizeFactor > 0 && 
          _dataSampling.sizeFactor < 1 && 
          _dataSampling.numberPrecondition > 0 && 
          _dataSampling.grid.row > 0 && 
          _dataSampling.grid.column > 0)
        {
          if (dataPointNum && dataPointNum > _dataSampling.numberPrecondition) {
            calculateBoundaryValues(data);
            var gridBoxArray = [];
            var xStep = (xMax - xMin) / _dataSampling.grid.column, yStep = (yMax - yMin) / _dataSampling.grid.row, xStart = xMin, yStart = yMin;
            var i, j;
            for (i = 0; i < _dataSampling.grid.column; i++) {
              var xRange = {};
              xRange.x1 = xStart;
              xRange.x2 = xStart + xStep;
              for (j = 0; j < _dataSampling.grid.row; j++) {
                var yRange = {}, gridBox = {};
                yRange.y1 = yStart;
                yRange.y2 = yStart + yStep;
                gridBox.xRange = xRange;
                gridBox.yRange = yRange;
                gridBox.indexArray = [];
                gridBox.refArray = [];
                gridBoxArray.push(gridBox);
                yStart += yStep;
              }
              xStart += xStep;
              yStart = yMin;
            }
            
            for (i = 0; i < measureFeed1.values[0].rows.length; i++) {
              for (j = 0; j < measureFeed1.values[0].rows[i].length; j++) {
                var obj = {};
                obj.x = measureFeed1.values[0].rows[i][j].val;
                obj.y = measureFeed2.values[0].rows[i][j].val;
                obj.index = j;
                obj.ref = {
                    x : measureFeed1.values[0].rows,
                    y :  measureFeed2.values[0].rows,
                    xIndex : i,
                    yIndex : j
                };
                fillGridBox(gridBoxArray, obj);
              }
            }
            
            for (var m = 0; m < gridBoxArray.length; m++) {
              var refLen = gridBoxArray[m].refArray.length;
              if (refLen > 0) {
                var deletePos = Math.round(refLen * _dataSampling.sizeFactor);
                /*jshint bitwise:false */
                if ((refLen & 1) !== 0) {
                  deletePos++;
                }
                for (; deletePos < refLen; deletePos++) {
                  var xIndex = gridBoxArray[m].refArray[deletePos].xIndex, yIndex =  gridBoxArray[m].refArray[deletePos].yIndex;
                  gridBoxArray[m].refArray[deletePos].x[xIndex][yIndex].val = null;
                  gridBoxArray[m].refArray[deletePos].y[xIndex][yIndex].val = null;
                }
              }
            }
          }
        }
    }
    
    function parseOptions() {
      if (_props.autoBinning.enable) {
        _autoBinning.enable = _props.autoBinning.enable;
        _autoBinning.binNumber = _props.autoBinning.binNumber;
      } else if (_props.dataSampling.enable) {
        _dataSampling.enable = _props.dataSampling.enable;
        _dataSampling.grid = _props.dataSampling.grid;
        _dataSampling.sizeFactor = _props.dataSampling.sizeFactor;
        _dataSampling.numberPrecondition = _props.dataSampling.numberPrecondition;        
      }
    }
    
    function dataTransformer(data) {
      if (_props && _data) {
        if (_autoBinning.enable) {
          pieAutoBinning(data); 
        }
        
        if (_dataSampling.enable) {
          scatterDataSampling(data);
        }
      }
    }
 
    function objCompare(a, b) {
      return b.val - a.val;
    }
    
    function pieDataSort(data) {
      var measure = data.getMeasureValuesGroupDataByIdx(0).values[0];
      for (var i = 0; i < measure.rows[0].length; i++) {
        measure.rows[0][i].index = i;
      }
      
      measure.rows[0].sort(objCompare);
      var dimensions = data.getAnalysisAxisDataByIdx(0).values;
      for (var m = 0; m < dimensions.length; m++) {
        var tmpArray = [];
        for (var n = 0; n < dimensions[m].rows.length; n++) {
          var measurePos = measure.rows[0][n].index;
          if (measurePos !== n) {
            tmpArray.push(dimensions[m].rows[measurePos]);
          } else {
            tmpArray.push(dimensions[m].rows[n]);
          }
        }
        dimensions[m].rows = tmpArray;
      }
    }
    
    function pieAutoBinning(data) {
      var measure = data.getMeasureValuesGroupDataByIdx(0).values[0];
      var binNumber = _props.autoBinning.binNumber;
      var measuresNum = measure.rows[0].length;
      if (binNumber > 0 && binNumber <  measuresNum) {
        var filteredMeasuresNum = measuresNum;
        for (var i = 0; i < measure.rows[0].length; i++) {
          measure.rows[0][i].index = i;
          if (measure.rows[0][i].val < 0) {
            filteredMeasuresNum--;
          }
        }
        
        //[Christy | 2013/5/2] Validation
        if(filteredMeasuresNum === 0 || filteredMeasuresNum <= binNumber){
          //All measure values are negative. Or validatedMeasures is less than binNumber. Don't do auto binning
          return;
        }
        
        
        measure.rows[0].sort(objCompare);
        var dimensions = data.getAnalysisAxisDataByIdx(0).values;
        for (var m = 0; m < dimensions.length; m++) {
          var tmpArray = [];
          for (var n = 0; n < dimensions[m].rows.length; n++) {
            var measurePos = measure.rows[0][n].index;
            if (measurePos !== n) {
              tmpArray.push(dimensions[m].rows[measurePos]);
            } else {
              tmpArray.push(dimensions[m].rows[n]);
            }
          }
          dimensions[m].rows = tmpArray;
        }
        
        var deletedNum = 0;
        var j;
        for (j = measure.rows[0].length - 1; j >= 0; j--) {
          if (measure.rows[0][j].val < 0) {
            measure.rows[0].pop();
            deletedNum++;
          }
        }
        measuresNum = measure.rows[0].length;
        
        for (var x = 0; x < dimensions.length; x ++) {
          var dimensionLen = dimensions[x].rows.length;
          for (var y = dimensions[x].rows.length - 1; y > dimensionLen - deletedNum - 1; y--) {
            dimensions[x].rows.pop();
          }
        }
        
        var othersPos = binNumber - 1;
        for (var k = othersPos + 1; k < measuresNum; k++) {
          measure.rows[0][othersPos].val += measure.rows[0][k].val;
        }
        for (j = measuresNum - 1; j > othersPos; j--) {
          measure.rows[0].pop();
        }
        
        for (var q = 0; q < dimensions.length; q++) {
          if (q === 0) {
            var othersNum = measuresNum - binNumber + 1;
            dimensions[q].rows[othersPos].val = _autoBinning.displayString;
            dimensions[q].rows[othersPos].dataTransformInfo = {autoBinning : {'othersNum' : othersNum}};
          } else {
            dimensions[q].rows[othersPos].val = '';
          }
          for (var r = dimensions[q].rows.length - 1; r > othersPos; r--) {
            dimensions[q].rows.pop();
          }
        }
      }
    }
    
    transformation.destroy = function(){
      _data = null;
    };

    return transformation;
  };
  return datatransform;
});
define('sap/viz/modules/manifests/DataTransform',['sap/viz/modules/manifests/Module','sap/viz/modules/Constants','sap/viz/modules/datatransform'],
function Setup(Manifest,Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.datatransform',
    'type' : Constants.Type.Controller,
    'name' : 'dataTransform',
    'renderto' : Constants.RenderTo.NONE,
    'properties' : {
       'autoBinning' : {
         'name' : 'autoBinning',
         'supportedValueType' : 'Object',
         'supportedValues' : {
           'enable': {
             'name' : 'enable',
             'supportedValueType' : 'Boolean',
             'defaultValue' : false,
             'description' : 'Set whether to enable data auto binning.'
            },
            'binNumber': {
              'name' : 'binNumber',
              'supportedValueType' : 'PositiveInt',
              'defaultValue' : 10,
              'description' : 'Set bin number.'
             }
        },
        'isExported' : true,
        'description' : 'Settings for auto-binning algorithm'
       },
       'dataSampling' : {
         'name' : 'dataSampling',
         'supportedValueType' : 'Object',
         'supportedValues' : {       
           'enable': {
             'name' : 'enable',
             'supportedValueType' : 'Boolean',
             'defaultValue' : false,
             'description' : 'Set whether to enable data sampling.'
            },
            'sizeFactor': {
              'name' : 'sizeFactor',
              'supportedValueType' : 'PositiveInt',
              'defaultValue' : 1,
              'description' : 'Set data point percentage in original dataset'
             },
             'numberPrecondition': {
               'name' : 'numberPrecondition',
               'supportedValueType' : 'PositiveInt',
               'defaultValue' : 3000,
               'description' : 'if data point is larger than this value, data sampling will be triggered.'
              },
             'grid' : {
               'name' : 'grid',
               'supportedValueType' : 'Object',
               'supportedValues' : {
                 'row' : {
                   'name' : 'row',
                   'supportedValueType' : 'PositiveInt',
                   'defaultValue' : 3,
                   'description' : 'The row number of grid'
                 },
                 'column' : {
                   'name' : 'column',
                   'supportedValueType' : 'PositiveInt',
                   'defaultValue' : 3,
                   'description' : 'The column number of grid',
                  } 
               }
             }
       },
       'isExported' : true,
       'description' : 'Settings for data sampling algorithm'
       }
     },
    configure: null,
    fn : fn
  };

  Manifest.register(module);
});
define('sap/viz/manifests/scatter/ScatterChart',['sap/viz/manifests/Viz','sap/viz/modules/manifests/RootContainer','sap/viz/manifests/scatter/BaseBubbleChart',
'sap/viz/modules/manifests/Scatter','sap/viz/modules/manifests/DataTransform'],
function Setup(Manifest) {
  var chart = {
    id : 'viz/scatter',
    name : 'IDS_SCATTERCHART',
    base : "viz/scatter/single/base",
    modules : {
      dataTransform : {
        id : 'sap.viz.modules.datatransform',
        configure : {
          propertyCategory : 'dataTransform',
          properties : {
            dataSampling : {
              enable : false,
              sizeFactor : 0.5     
            },
            autoBinning : {
              enable: null
            }
          },
          propertiesOverride : {
            autoBinning : {
              isExported : false
            }
          }
        }
      },
      root : {
        modules : {
          tooltip : {
            configure : {
              properties : {
                chartType : 'scatter'
              }
            }
          },
          main : {
            modules : {
              plot : {
                id : 'sap.viz.modules.scatter',
                configure : {
                  description : 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory : 'plotArea'
                }
              },
              dataLabel : {
                id : 'sap.viz.modules.datalabel',
                configure : {
                  properties : {
                    automaticInOutside : false
                  }
                }
              }
            }
          }
        }
      }
    }
  };

  Manifest.register(chart);
});
define('sap/viz/modules/util/DimensionalInfoHandler',['sap/viz/lang/langManager'],
function Setup(langManager) {
  //fake dataset
  return function(props, multiplier) {
    var data_ = multiplier;
    var props_ = props;
    var dimInCol_;
    var dimInRow_;
    var rowDimension_ = {
      'values' : []
    };

    var colDimension_ = {
      'values' : []  
    };
    var ctx_ = [];
    var rowCount_;
    var colCount_;
    var mndDefaultString = langManager.get('IDS_DEFAULTMND');
    var my = function() {

    };


    my.setData = function(data)
    {
      data_ = data;
      return my;
    };

    my.setProperties = function(props)
    {
      props_ = props;
      return my;
    };

    my.getColumnDimensionData = function()
    {
      return  colDimension_;
    };

    my.getRowDimensionData = function()
    {
      return rowDimension_;
    };

    my.getContexts = function()
    {
      return ctx_;
    };

    function buildIndexMeasuresOnly()
    {
      var i = 0;
      if(dimInCol_ > 0)
      {
        rowCount_ = 1;
        colCount_ = data_.values[0].rows.length;
        ctx_.push([]);
        var colDimVals = colDimension_.values;
        colDimVals[0] = { 
            'col':{
          'val': mndDefaultString
        },
        'rows':[]
        };

        for(i = 0; i < data_.values[0].rows.length; ++i)
        {
          colDimVals[0].rows.push({ 
            'val': data_.values[0].rows[i].val,
            'info': data_.values[0].rows[i].info
          });
          ctx_[0].push(data_.values[0].rows[i].ctx);
        }
      }
      else
      {
        rowCount_ = data_.values[0].rows.length;
        colCount_ = 1;
        var rowDimVals = rowDimension_.values;
        rowDimVals[0] = { 
            'col':{
        'val': mndDefaultString
        },
        'rows':[]
        };
        for(i = 0; i < data_.values[0].rows.length; ++i)
        {
          rowDimVals[0].rows.push({
            'val': data_.values[0].rows[i].val,
            'info': data_.values[0].rows[i].info
          });
          ctx_.push([data_.values[0].rows[i].ctx]);
        }
      }
    }

    function initilize()
    {
      rowDimension_.values = [];
      colDimension_.values = [];
      rowCount_ = 0;
      colCount_ = 0;
      ctx_ = [];
    }
    // compare tow title is the same
    function compare(index, preIndex, startDim, dimNum)
    {
      for(var i = startDim; i < startDim + dimNum; ++i)
      {
        if(data_.values[i].rows[index].val !== data_.values[i].rows[preIndex].val){
          return false;
        }
      }
      return true;
    }

    //  
    function buildUniqueIndexes(uniqueIndex, index, startDim, dimNum)
    {
      var start = 0;
      var end = uniqueIndex.length;
      var isFound = true;
      for ( var level = 0; isFound && level < dimNum; ++level) {
        var nextStart = end;
        var nextEnd = start;
        isFound = false;
        for ( var pos = start; pos < end; ++pos) {
          if (data_.values[startDim + level].rows[uniqueIndex[pos]].val=== data_.values[startDim + level].rows[index].val) {
            isFound = true;
            if (pos < nextStart){
              nextStart = pos;
            }
            if (pos >= nextEnd){
              nextEnd = pos + 1;
            }
          }
        }

        if (isFound) {
          start = nextStart;
          end = nextEnd;
        }
      }

      if (!isFound)
      {
        if (end < uniqueIndex.length){
          uniqueIndex.splice(end, 0, index);
        } else {
          uniqueIndex.push(index);}
      }       
    }

    // use one array to stroe one column header title
    function buildOneHeader(index, startDim, dimNum)
    {
      var result = [];
      for(var i = startDim; i < startDim + dimNum; ++i)
      {
        result.push(data_.values[i].rows[index].val);
      }
      return result;
    }

    // generate hashmap map from name to col index
    function generateIndexMap(allUniqueColIndex, startDim, dimNum)
    {
      var map = {};
      for(var i = 0; i < allUniqueColIndex.length; ++i)
      {
        map[buildOneHeader(allUniqueColIndex[i], startDim, dimNum)] = i;
      }
      return map;
    }

    function processColHeader(startDim, dimNum)
    {
      var colIndex = [];
      var allUniqueColIndex = [];
      allUniqueColIndex.push(0);
      var i;
      var element = {};
      for(i = 1; i < data_.values[startDim].rows.length; ++i)
      {
        buildUniqueIndexes(allUniqueColIndex, i, startDim, dimNum);
      }

      //build column dimension data set
      var colDimVals = colDimension_.values;
      for(i = 0; i < dimNum; ++i)
      {
        element = {};
        element.col = data_.values[startDim + i].col;
        element.rows = [];
        element.rows[0] = {
          'val': data_.values[startDim + i].rows[0].val,
          'info': data_.values[startDim + i].rows[0].info
        };
        colDimVals.push(element);
      }
      for(i = 0; i < allUniqueColIndex.length; ++i)
      {
        for(var j = 0; j < dimNum; j++)
        {
          colDimVals[j].rows[i] = {
            'val': data_.values[startDim + j].rows[allUniqueColIndex[i]].val,
            'info': data_.values[startDim + j].rows[allUniqueColIndex[i]].info
          };
        }

      }
      // to solve performance issue
      var hashMap = generateIndexMap(allUniqueColIndex, startDim, dimNum);
      for(i = 0; i < data_.values[startDim].rows.length; ++i)
      {
        element = buildOneHeader(i, startDim, dimNum);
        colIndex[i] = hashMap[element];
      }
      colCount_ = allUniqueColIndex.length;
      return colIndex;
    }
    
    
    function cloneOneContext(ctx)
    {
      if(!ctx) {return null;}
      return {
        'type': ctx.type,
        'path':{
          'aa': ctx.path.aa,
          'di': ctx.path.di,
          'dii': ctx.path.dii
        }
      };
    }
    
    function cloneOneRowContext(row)
    {
      var clones = [];
      for(var i = 0; i < row.length; ++i)
      {
        clones.push(cloneOneContext(row[i]));
      }
      return clones;
    }

    function addMeasureContext(row, ctx)
    {
      
      for(var i = 0; i < row.length; ++i)
      {
        if(!row[i]) {continue;}
        else if(!row[i].path)
        {
           row[i].path = {};
        }
        row[i].path.mg = ctx.path.mg;
        row[i].path.mi = ctx.path.mi;
      }
    }

    function expendContexts(num)
    {
      var totalRow = ctx_.length;
      for(var i = 0; i < num; ++i)
      {
        for(var j = 0; j < totalRow; ++j)
        {
          ctx_.push(cloneOneRowContext(ctx_[j]));
        }
      }
    }

    function addMND(bMNDInner, bMNDInRow, dimInRow, dimInCol)
    {
      var indexMND = bMNDInner ? data_.values.length - 1 : 0;
      var measures = data_.values[indexMND].rows;
      //new dimension to add row or column
      var row = {};
         row.col = data_.values[indexMND].col;
         row.rows = []; 
      var dimVals = bMNDInRow ? rowDimension_.values :colDimension_.values;
      var dimNums = bMNDInRow ? dimInRow : dimInCol;
      var i, j, k;
      var element;
      
      //1 MND in row and no dimension in row
      if(bMNDInRow && dimInRow === 0)
      {
        dimVals[0] = { 
            'col':{
            'val': mndDefaultString
          },
          'rows':[]
        };
        addMeasureContext(ctx_[0], measures[0].ctx);
        //Jimmy,12/27/2012 we don't have additional info for MND for now
        dimVals[0].rows.push({ 'val': measures[0].val});
        for(i = 1; i < measures.length; ++i)
        {
          dimVals[0].rows.push({ 'val': measures[i].val});
          ctx_.push(cloneOneRowContext(ctx_[0]));
          addMeasureContext(ctx_[i], measures[i].ctx);
        }
        rowCount_ = measures.length;
        return;
      }
      
      //2 MND in column and no dimension in column
      if(!bMNDInRow && dimInCol === 0)
      {
        //create column dimension and set value
        dimVals[0] = { 
            'col':{
            'val': mndDefaultString
            },
            'rows':[]
        };
        for(i = 0; i < measures.length; ++i)
        {
          dimVals[0].rows.push({'val' : measures[i].val});
        }
        
        // expand context  
        for(i = 0; i < ctx_.length; ++i)
        {
          ctx_[i][0].path.mg = measures[0].ctx.path.mg;
          ctx_[i][0].path.mi = measures[0].ctx.path.mi;
          for(j = 1; j < measures.length; ++j)
          {
            ctx_[i].push(cloneOneContext(ctx_[i][0]));
            ctx_[i][j].path.mg = measures[j].ctx.path.mg;
            ctx_[i][j].path.mi = measures[j].ctx.path.mi;
          }
        }
        return;
      }
      var count = bMNDInRow ? rowCount_ : colCount_;
      // 3 have dimensions in column and have dimensions in row
      if( bMNDInner)
      {
        // add measure data
        for(i = 0; i < count; ++i)
        {
          for(j = 0; j < dimVals.length; ++j)
          {
            for(k = 1; k < measures.length; ++k)
            {
              element =  {
                'val': dimVals[j].rows[i * measures.length + k - 1].val,
                'info': dimVals[j].rows[i * measures.length + k - 1].info
              };
              dimVals[j].rows.splice(i * measures.length + k, 0, element);
            }
          }
        }

        //add MND dimension to row/column
        for(i = 0; i < count; ++i)
        {
          for(j = 0; j < measures.length; ++j)
          {
            element =  {'val': measures[j].val};
            row.rows.push(element);
          }
        }
        dimVals.push(row);

        if(bMNDInRow)
        {
          rowCount_ *= measures.length;
          for(i = 0; i < rowCount_; i += measures.length)
          {
            addMeasureContext(ctx_[i], measures[0].ctx);
            for(j = 1; j < measures.length; ++j)
            {
              var oneRow = cloneOneRowContext(ctx_[i]);
              ctx_.splice(i + j, 0, oneRow);
              addMeasureContext(ctx_[i + j],  measures[j].ctx);
            }
          }

        }else{      
          colCount_ *= measures.length;
          for(i = 0; i < ctx_.length; ++i)
          {
            for(j = 0; j < colCount_; j+= measures.length)
            {
              ctx_[i][j].path.mg = measures[0].ctx.path.mg;
              ctx_[i][j].path.mi = measures[0].ctx.path.mi;    
              for(k = 1; k < measures.length; ++k)
              {
                ctx_[i].splice(j + k, 0, cloneOneContext(ctx_[i][j]));
                ctx_[i][j + k].path.mg = measures[k].ctx.path.mg;
                ctx_[i][j + k].path.mi = measures[k].ctx.path.mi;
              }
            }
          }
        }
        return;
      }
      else {

        //expand value first; 
        for(i = 1; i < measures.length; ++i)
        {
          for(j = 0; j < dimNums; ++j)
          {
            for(k = 0; k < count; ++k)
            {
              element = {
                'val': dimVals[j].rows[k].val,
                'info': dimVals[j].rows[k].info
              };
              dimVals[j].rows.push(element);
            }
          }
        }

        //add 
        for(j = 0; j < measures.length; ++j)
        {
          for(i = 0; i < count; ++i)
          {
            element =  {'val': measures[j].val};
            row.rows.push(element);
          }
        }
        dimVals.splice(0, 0, row);
        if(bMNDInRow)
        {
          rowCount_ *= measures.length;
          expendContexts(measures.length - 1);
          for(i = 0; i < rowCount_; ++i)
          {
            var measureIndex = Math.floor((i * measures.length) / rowCount_);
            addMeasureContext(ctx_[i], measures[measureIndex].ctx);
          }
        }else{
          colCount_ *= measures.length;

          for(i = 0; i < ctx_.length; ++i)
          {
            var rows = [];
            addMeasureContext(ctx_[i], measures[0].ctx);
            for(j = 1; j < measures.length; ++j)
            {
              var addedRow = cloneOneRowContext(i);
              addMeasureContext(addedRow, measures[0].ctx);
              rows = rows.concat(cloneOneRowContext(i));
            }
            ctx_[i] = ctx_[i].concat(rows);
          }
        }
      }
    }
    
    function buildRowDimension(dimInRow, startIndex, rowIndexs){

      var rowDimVals = rowDimension_.values;
      var i = 0;
      for(i = 0; i < dimInRow; ++i)
      {
        var element = {};
        element.col = data_.values[startIndex + i].col;
        element.rows = [];
        element.rows[0] = {
          'val': data_.values[startIndex + i].rows[0].val,
          'info': data_.values[startIndex + i].rows[0].info
        };
        rowDimVals.push(element);
      }
      for (i = 1; i < data_.values[startIndex].rows.length; ++i)
      {
        if (compare(i, i - 1, startIndex, dimInRow)){
          rowIndexs[i] = rowCount_;
        }else {  
          ++rowCount_;
          for(var j = 0; j < dimInRow; j++)
          {
            rowDimVals[j].rows[rowCount_] = {
              'val': data_.values[startIndex + j].rows[i].val,
              'info': data_.values[startIndex + j].rows[i].info
            };
          }
          rowIndexs[i] = rowCount_;
        }
      }
      ++rowCount_;
    }
    
    // Mix MND and dimension case
    function processDimsWithMeasure()
    {
      var startIndex = 0,
        endIndex = data_.values.length;
      var dimInRow = dimInRow_,
        dimInCol = dimInCol_;
      var bMNDInner = false,
        bMNDInRow = true;
      var i;
      if(data_.values[0].type === "MND")
      {
        ++startIndex;
        if(dimInRow > 0){ 
          --dimInRow;
        } else {
          --dimInCol;
          bMNDInRow = false;
        }
      }

      if(data_.values[endIndex - 1].type === "MND")
      {
        bMNDInner = true;
        --endIndex;
        if(dimInCol > 0)
        {
          --dimInCol;
          bMNDInRow = false;
        }else{
          bMNDInRow = true;
          --dimInRow;
        }
      }

      //process no MND cases first
      if(startIndex < endIndex)
      {
        //some dimension in row and some in column 
        var rowIndexs = [];
        if(dimInCol > 0 || dimInRow > 0)
        {
          //process row dimension first
          rowIndexs[0] = 0;
          rowCount_ = 0;
          if(dimInRow > 0)
          {
            buildRowDimension(dimInRow, startIndex, rowIndexs);
          }else{
            rowCount_ = 1;
            for(i = 1; i < data_.values[startIndex].rows.length; ++i){
              rowIndexs[i] = 0;
            }
          }
          
          //build column dimensions and indexes
          var colIndexs = [];
          if(dimInCol > 0)
          {
            colIndexs = processColHeader(startIndex + dimInRow, dimInCol);
          }else{
            colCount_ = 1;
            for(i = 0; i < data_.values[startIndex].rows.length; ++i){
              colIndexs[i] = 0;
            }
          }
          
          //generate data context for each sub chart
          ctx_ = new Array(rowCount_);
          for(i = 0; i < rowCount_; ++i)
          {
            ctx_[i] = [];
            for(var j = 0; j < colCount_; ++j){
              ctx_[i][j] = null;
            }
          }

          for(i = 0 ; i < data_.values[startIndex].rows.length; ++i)
          {
            ctx_[rowIndexs[i]][colIndexs[i]] = data_.values[startIndex + dimInRow + dimInCol - 1].rows[i].ctx;
          }
        }
        
        //process measure names at last
        if(dimInRow < dimInRow_ || dimInCol < dimInCol_)
        {
          addMND(bMNDInner, bMNDInRow, dimInRow, dimInCol);
        }
      }
    }

    my.process = function()
    {
      initilize();
      if(!data_ || !data_.values || data_.values.length === 0) {return;}
      dimInCol_ =  props_ && props_["numberOfDimensionsInColumn"] !== undefined ?  props_["numberOfDimensionsInColumn"] : 1;
      if(!dimInCol_ || dimInCol_ < 0) { dimInCol_ = 0;}
      if(dimInCol_ > data_.values.length) {dimInCol_ = data_.values.length;}
      dimInRow_ = data_.values.length - dimInCol_;
      if(dimInRow_ < 0){ dimInRow_ = 0;}

      if(data_.values.length === 1 && data_.values[0].type === "MND")
      {
        buildIndexMeasuresOnly();
      }else{
        processDimsWithMeasure();
      }
    };

    return my;

  };
});
define('sap/viz/data/handler/MultiChartDataHandler',['sap/viz/base/utils/FunctionUtils','sap/viz/data/MultiAxesDataAdapter','sap/viz/data/handler/MeasureDataHandler', 'sap/viz/lang/langManager'],
 function Setup(FunctionUtils, MultiAxesDataAdapter, MeasureDataHandler, langManager){
    
   function initSubChartAxes(axes){
     
       var sub = axes.slice(0);
       sub.sort(function(a,b){return a.index -b.index;});
       sub.shift();  
       
       return sub;
   }
   
   function initMeasureValueAxisIndexForMeasure(bindingInfo){
     if(bindingInfo[0] === true){
       if(bindingInfo[1] === true){
          return [1,2];
       }else{
         return [1];
       }
      
     }else if(bindingInfo[1] === true){
       return [2];
     }else{
       return [1]; 
     }
     
   }
   
   function initMeasureValueAxisIndex(bindingInfo){
     
      //axis 1 has been feeded with crosstable
      if(bindingInfo[0] === true){
         if(bindingInfo[1] === true){
            return [1];
         }else if(bindingInfo[2] === true){
            if(bindingInfo.length > 3){
               return [1];//Multi Radar,pass crosstable to radar as single chart handler
            }else{
               return [2];
            }
         }else if(bindingInfo[3] === true){// Multi Radar, aa 4 could not be feeded
            FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_NOT_SUPPORTED'));
         }else{
            return [1];
         }
      }else if(bindingInfo[1] === true){
         if(bindingInfo[2] === true){
            return [1, 2];
         }else if(bindingInfo[3] === true){
            FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_NOT_SUPPORTED'));
         }else{
            return [1];
         }
      }else if(bindingInfo[2] === true){
        if(bindingInfo[3] === true){
           FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_NOT_SUPPORTED'));
        }
        else{
          if(bindingInfo.length > 3){
             return [1];//Multi Radar,pass crosstable to radar as single chart handler
          }else{
             return [2];
          }
        }
      }else{
        for(var i = 0; i< bindingInfo.length;i++){
          if(bindingInfo[i] === true){
             FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_NOT_DETERMINE_AXIS_INDEX'));
          }
        }
        //all false
        return [1];
      }
      
      FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_NOT_DETERMINE_AXIS_INDEX'));
     
     } 
   
   function MultiChartDataHandler(dataAdapter, type){
        this._dataAdapter =  dataAdapter;
        this._aa = this._dataAdapter.getAnalysisAxisDataByIdx();
        this._mg = this._dataAdapter.getMeasureValuesGroupDataByIdx();
        this._subAxes = initSubChartAxes(this._aa);
        this._type = type;
        
        if(this._type === undefined){
           this._measureValueAxisIndex = initMeasureValueAxisIndex(this._dataAdapter.getBindingInfo());
           this._maxMeasureAxis = 2;
        }else if(this._type === "measures"){
           this._measureValueAxisIndex = initMeasureValueAxisIndexForMeasure(this._dataAdapter.getBindingInfo());
           this._maxMeasureAxis = this._dataAdapter.getBindingInfo().length ;
        }
      
   }
   
   MultiChartDataHandler.prototype.getSubDataAdapter = function(ctx){
       if(this._type === undefined){
          return this.getSubDataAdapterByContext(ctx);
       }else if(this._type === "measures"){
          return this.getSubDataAdapterByMeasures(ctx);
       }
       
       return null;
     
   };
   
   MultiChartDataHandler.prototype.getSubDataAdapterByContext = function(ctx){
     var dataAdapter, subAxis, i, mvg;
     if(ctx){
        //Multiplier with MND
        if(ctx.path.mg !== undefined && ctx.path.mi !== undefined){
          if(ctx.path.di !== undefined && ctx.path.dii !== undefined){ // Mulitplier with Dimension and MND
             dataAdapter = new MultiAxesDataAdapter();
            
            for(i = 0; i < this._subAxes.length; i++){
              subAxis = this._subAxes[i];
              dataAdapter.addAnalysisAxis({index: subAxis.index - 1, values: subAxis.values});
            }
            
            mvg = this._mg[ctx.path.mg];
            dataAdapter.addMeasureValuesGroup({index: 0, values: MeasureDataHandler.makeMeasureValues(ctx, mvg, this._measureValueAxisIndex, this._maxMeasureAxis, true)});
            
            
            return dataAdapter;

          }else{//Multiplier with MND only
           dataAdapter = new MultiAxesDataAdapter();
           
           for(i = 0; i < this._subAxes.length; i++){
             subAxis = this._subAxes[i];
             dataAdapter.addAnalysisAxis({index: subAxis.index - 1, values: subAxis.values});
           }
           
           mvg = this._mg[ctx.path.mg];
           //MeasureDataHandler.makeMeasureValues(ctx, mvg, this._measureValueAxisIndex, this._maxAxisCount
           dataAdapter.addMeasureValuesGroup({index: 0, values:MeasureDataHandler.makeMeasureValues(null, {"values":[mvg.values[ctx.path.mi]]}, this._measureValueAxisIndex, this._maxMeasureAxis, false)});
           
           return dataAdapter;
          }
          
        }else{ //Multiplier without MND
          dataAdapter = new MultiAxesDataAdapter();
        
          for(i = 0; i < this._subAxes.length; i++){
            subAxis = this._subAxes[i];
            dataAdapter.addAnalysisAxis({index: subAxis.index - 1, values: subAxis.values});
          }
          
          for(i = 0; i < this._mg.length; i++){
            mvg = this._mg[i];
            dataAdapter.addMeasureValuesGroup({index: mvg.index, values:  MeasureDataHandler.makeMeasureValues(ctx, mvg, this._measureValueAxisIndex, this._maxMeasureAxis, false)});
          }
          
          return dataAdapter;
          }
       }
     
     return null;
   };
   
   MultiChartDataHandler.prototype.getSubDataAdapterByMeasures = function(ctx){
     var dataAdapter = new MultiAxesDataAdapter();
      
     for(var i = 0; i < this._aa.length; i++){
        dataAdapter.addAnalysisAxis(this._aa[i]);
     }
      
     var mg = this._mg[0];
     
     dataAdapter.addMeasureValuesGroup({index : 0, values : MeasureDataHandler.makeMeasureValues(null, {"values":[mg.values[ctx.row]]}, this._measureValueAxisIndex, this._maxMeasureAxis, false)});
     dataAdapter.addMeasureValuesGroup({index : 1, values : MeasureDataHandler.makeMeasureValues(null, {"values":[mg.values[ctx.col]]}, this._measureValueAxisIndex, this._maxMeasureAxis, false)});
     
     return dataAdapter;
   };
   
   
   return MultiChartDataHandler;
   
 });
define('sap/viz/modules/tablecontainer',['sap/viz/base/utils/TypeUtils','sap/viz/base/utils/Objects','sap/viz/base/utils/FunctionUtils',
'sap/viz/modules/layout','sap/viz/modules/util/DimensionalInfoHandler','sap/viz/data/handler/MultiChartDataHandler',
'sap/viz/modules/manifests/Module','sap/viz/data/MultiAxesDataAdapter',
'sap/viz/modules/dispatch','sap/viz/modules/util/BoundUtil','sap/viz/util/ignite',
'sap/viz/util/fn/createContext','sap/viz/modules/util/dataUtil'],
function Setup ( TypeUtils, Objects, Functions, layout, DIHandler, MCHandler, 
  Manifest, MultiAxesDataAdapter,dispatch, boundUtil, ignite, createContext, dataUtil ) {
  
  var retfn =  function (manifest, ctx) {
    var width = 0, 
        height = 0,
        centerWidth = 0, //size for the real table area without table headers
        centerHeight = 0, 
        properties = {},
        //for containers we use properties to hold any properties we have to pass to sub
        //then we use this internalProps to hold properties for container itself
        internalProps = manifest.props(null),
        internalRange = {}, //used for data range merge
        multiData = {
          
        },//used to save raw data process result
        subModuleNames = [], //used to update sub modules while data updating
        subControllerNames = [], //used to update controllers while data updating  
        data = null,
        config = {},
        modules = {},
        selections = {},
        parent = null, // a d3 selection
        rows = 3,
        columns = 2,
        xCategoryScale = d3.scale.ordinal(),
        yCategoryScale = d3.scale.ordinal(),
        eDispatch = new dispatch('initialized', 'showTooltip', 'hideTooltip'), avaPlotCount = 0, avaModulesCount = 0,
        plotManifest, plotContext;
    
    //for container, we won't extract properties exactly for it. so we have to
    //get property by ourselves. the property category should be consistent with
    //module definition
    var PROPERTYCATEGORY = 'multiLayout';
    var initializedPlots = 0;

    //Alex Su: we need to hold a copy of animation flag settings to control animation flow.
    var plotAnimation = {
      dataLoading: true,
      dataUpdating:true,
      resizing:true
    };
    var bFirstCreation = true, bDataChanged = false;
    
    var PLOTAREAPROPCATE = 'plotArea';
    
    function setAnimationFlag(back){
      //Alex Su: FIXME hard coded here, need to be resolved in the future.
      var props = {};
      var propcate = (props[PLOTAREAPROPCATE] = {});
      var animation = (propcate.animation = {});
      Objects.extend(animation, plotAnimation);
      if (!back && bDataChanged){
        animation.dataLoading = plotAnimation.dataUpdating;
      }
      var plots = modules.plot;
      for(var i = 0, len = plots.length; i < len; i++){
        plots[i].properties(props);
      }      
    }
    
    function clearInternalRange(){
      for(var i in internalRange){
        if(internalRange.hasOwnProperty(i)){
          delete internalRange[i];
        }
      }
    }
    
    function initialize() {
      if ( TypeUtils.isEmptyObject(config) ) {
        Functions.error('Container configuration missing');
      }
      
      processRawData();
      avaPlotCount = 0, avaModulesCount = 0;
      //Jimmy/9/13/2012 we only support yAxis and xAxis2 for now, the other two won't be initialized
      initAxis(config, 'xAxis', multiData.columnData);
      initAxis(config, 'yAxis', multiData.rowData);
      initAxis(config, 'xAxis2', multiData.columnData);
      initAxis(config, 'yAxis2', multiData.rowData);
      
      initializePlots();
      updateProperties("plot");
      updateProperties("xAxis2");
      updateProperties("yAxis");
      updatePlotData();
      initializePlotElements();
      
      avaModulesCount = avaModulesCount + avaPlotCount;
    }
    
    function processRawData() {
      delete multiData.contexts;
      delete multiData.columnData;
      delete multiData.rowData;
      delete multiData.dataHandler;
      //get dimensional info
      //FIXME jimmy/8/8/2012, we assume to use dimensional layout by default
      //we may need support other layouts
      //FIXME jimmy/8/8/2012, how to know which feed is for multiplier?
      var dih = DIHandler({
        'numberOfDimensionsInColumn' : internalProps.numberOfDimensionsInColumn
      }, data.getAnalysisAxisDataByIdx(0));//data['sap.viz.multiplier']);
      
      dih.process();
      
      var rowD = dih.getRowDimensionData();
      var columnD = dih.getColumnDimensionData();
      var contexts = dih.getContexts();
      rows = contexts.length;
      columns = rows > 0 ? contexts[0].length : columns;
      
      var columnData = new MultiAxesDataAdapter();
      columnData.addAnalysisAxis({key:columnData.key, index : 0, values: columnD.values});
      var rowData = new MultiAxesDataAdapter();
      rowData.addAnalysisAxis({key:rowD.key, index : 0, values: rowD.values});

      //row data has no contexts. we have to add ctx to rowData and columnData
      var rowAAData;
      var colAAData;
      if(rowData.getAnalysisAxisDataByIdx)
      {
        rowAAData = rowData.getAnalysisAxisDataByIdx(0);
      }
      if(columnData.getAnalysisAxisDataByIdx)
      {
        colAAData = columnData.getAnalysisAxisDataByIdx(0);
      }

      var i;
      var j;

      var colNum = 0;
      var rowNum = contexts.length;
      if(rowNum > 0)
      {
          colNum = contexts[0].length;
      }

      var initContexts = function(aaDataValues, index)
      {
          var i;
          for(i = 0; i < aaDataValues.length; i++)
          {
              aaDataValues[i].rows[index].contexts = [];
          }
      };

      var pushContexts = function(aaDataValues, index, ctx)
      {
          var i;
          for(i = 0; i < aaDataValues.length; i++)
          {
              aaDataValues[i].rows[index].contexts.push(ctx);
          }
      };

      //for rowData
      for(i = 0; i < rowNum; i++)
      {
        initContexts(rowAAData.values, i);
        for(j = 0; j < colNum; j++)
        {
            pushContexts(rowAAData.values, i, contexts[i][j]);
        }
      }

      //for colData
      for(i = 0; i < colNum; i++)
      {
          if(colAAData.values.length > 0)
          {
            initContexts(colAAData.values, i);
            for(j = 0; j < rowNum; j++)
            {
                pushContexts(colAAData.values, i, contexts[j][i]);
            }
          }
      }
      
      multiData.contexts = contexts;
      multiData.columnData = columnData;
      multiData.rowData = rowData;
      multiData.dataHandler = new MCHandler(data);
    }
    
    function initAxis( config, id , axisData) {
      if ( !config.modules[id] ) {
        return;
      }
      
      var axisConfig = config.modules[id],
          axis = modules[id] = ignite(axisConfig.id, ctx, 'v-m-' + id); // Saves references to axis function.
      
      updateAxisData(id, axisData);
          
      var props = {}, usrProps, sysProps;
      if ( axisConfig.configure ) {
        usrProps = properties[axisConfig.configure.propertyCategory] || {};
        sysProps = axisConfig.configure.properties || {};
        Objects.extend( true, props, sysProps, usrProps );
        axis.properties(props);
      }
      
      if(axis.dispatch && axis.dispatch()['initialized']){
        avaModulesCount++;
        axis.dispatch().on('initialized.tablecontainer', initialized);
      }
      
      selections[id] = parent.append('g').attr('class', 'v-m-' + id);
    }
    
    function updateAxisData (id, axisData) {
      if(modules[id]){
        modules[id].data(axisData);
      }
    }
    
    function initializePlots() {
      var plotConfig = config.modules.plot;
      if ( !plotConfig ) {
        return;
      }      
      
      cleanSubControllers();
      cleanSubModules();

      //we will create multi plot here
      var contexts = multiData.contexts;
      var plots = modules.plot = [], i = 0;
      for(var colI = 0; colI < columns; colI++){
        for(var rowI = 0; rowI < rows; rowI++){
          //contexts returned from dimensionalInfoHandler is rows*column
          var ctxI = contexts[rowI][colI];
          //[Jimmy/8/28/2012]we won't create sub plots when ctxI is undefined. but do we need
          //filter them out of the array? currently we will still have the full-size array with
          //some of them undefined. other parts who need read them should pay attention to (like
          //dependency resolving, and controller etc.)
          if(ctxI){
            
            
            if ( !plotManifest || !plotContext ) {
              plotManifest = Manifest.get(plotConfig.id);
              plotContext = createContext(plotManifest, ctx, "v-m-plot");
            }
            
            var plotI = plots[i] = ignite(plotManifest, plotContext);
            plotI.config(plotConfig);

            if(plotI.dispatch){
              avaPlotCount++;
              var dis =  plotI.dispatch();
                 if(dis.initialized) {
                   dis.on('initialized.tablecontainer', initialized);
                 }
                 if(dis.showTooltip) {
                   dis.on('showTooltip.tablecontainer', showTooltip);
                 }
                 if(dis.hideTooltip) {
                   dis.on('hideTooltip.tablecontainer', hideTooltip);
                 }
            }
            ++i;
          }
        }
      }
    }
    
    function updatePlotProperties() {
      var plots = modules.plot;
      if(plots){
        var plotConfig = config.modules.plot;
        if ( !plotConfig ) {
          return;
        }
        //Jimmy/8/23/2012 pay attention to the property structure, for container we will pass
        //all properties instead of properties under propsCat only.
        //FIXME currently it's hard coded here we assume the plot is container, actually we should
        //check the plot type
        var props = null, usrProps, sysProps;
        var nodeConfig = plotConfig.configure;
        if ( nodeConfig ) {
          sysProps = {};
          if ( nodeConfig.propertyCategory ) {
            sysProps[nodeConfig.propertyCategory]  = nodeConfig.properties;
          }
          usrProps = properties;
          props = {};
          Objects.extend( true, props, sysProps, usrProps ); 
        }else{
          props = properties;
        }
        
        for(var i = 0, len = plots.length; i < len; i++){
          if(props && plots[i]){
            plots[i].properties(props);
          }
        }
      }
    }
    //TO FIX: remove this work around.
    function updateProperties(moduleId){
      if (moduleId === 'plot'){
        updatePlotProperties();
      }
      else{
        var module = modules[moduleId];
        if(module){
          var moduleConfig = config.modules[moduleId];
          if ( !moduleConfig ) {
            return;
          }
          var props;
          var nodeConfig = moduleConfig.configure;
          if ( nodeConfig ) {
            props = Objects.extend(true, {}, properties[ nodeConfig.propertyCategory ]);
          }else{
            props = properties;
          }
         module.properties(props); 
        }
      }
    }
    
    function updatePlotData() {
      var dataHandler = multiData.dataHandler;
      var contexts = multiData.contexts;
      var plots = modules.plot, i = 0;
      for(var colI = 0; colI < columns; colI++){
        for(var rowI = 0; rowI < rows; rowI++){
          //contexts returned from dimensionalInfoHandler is rows*column
          var ctxI = contexts[rowI][colI];
          if(ctxI){
            var dataI = dataHandler.getSubDataAdapter(ctxI);
            if(plots[i]){
              plots[i].data(dataI);
              ++i;
            }  
          }
        }
      }
    }
    
    function initializePlotElements() {
      var plotConfig = config.modules.plot;
      if ( !plotConfig ) {
        return;
      }
           
      var plots = modules.plot;
      var splots = selections.plot = [];
      var contexts = multiData.contexts;

      if(selections.plotRoot){
        selections.plotRoot.remove();
      }
      var plotRoot = selections.plotRoot = parent.append('g').attr('class', 'v-m-plot');
      var i = 0;
      for(var colI = 0; colI < columns; colI++){
        for(var rowI = 0; rowI < rows; rowI++){
          var ctxI = contexts[rowI][colI];
          if(ctxI){
            var plotI = plots[i];
            
            //create svg elements
            splots[i] = plotRoot.append('g').attr('class', 'v-m-plot' + i);
            plotI.parent(splots[i]);
            
            if(plotI.modules){
              var subModules = plotI.modules();
              dataUtil().updateAxisFormatString(subModules, 'xAxis', properties, plotI);
              dataUtil().updateAxisFormatString(subModules, 'yAxis', properties, plotI);
              
              var sname;
              for ( var m in subModules ){
                if ( subModules.hasOwnProperty(m) ){
                  sname = 'plot[' + i + ']' + '.' + m;
                  subModuleNames.push(sname);
                  modules['plot[' + i + ']' + '.' + m] = subModules[m];
                }
              }
              //for multiple xycontainers here add rotate  
              if(plotConfig.modules.rotate){
                var target = ignite( 'sap.viz.modules.controller.rotate', ctx);
                  modules['plot[' + i + ']' + '.' + 'rotate'] = target;
                  modules['plot[' + i + ']' + '.' + 'rotate']().module(plotI);
              }
            }
            ++i;
          }
        }
      }
    }
    
    function cleanSubControllers() {
      //clean all current submodules
      for(var i = 0, len = subControllerNames.length; i < len; i++){
        delete modules[subControllerNames[i]];
      }
      subControllerNames = [];
    }
    
    function cleanSubModules () {
      //clean all current submodules
      for(var i = 0, len = subModuleNames.length; i < len; i++){
        delete modules[subModuleNames[i]];
      }
      subModuleNames = [];
      
      if ( plotContext ) {
        plotContext.styleManager.cleanChildren();
      }
    }

    function relayout() {
      if ( TypeUtils.isEmptyObject(modules) || !width || !height ) {
        return;
      }
      
      var prefs = {};
      if ( modules.xAxis ) {
          modules.xAxis.drawable(true);
          prefs.south = { size : modules.xAxis.getPreferredSize() };
      }
      if ( modules.yAxis ) {
          modules.yAxis.drawable(true);
          prefs.west = { size : modules.yAxis.getPreferredSize() };
      }
      if ( modules.xAxis2 ) {
          modules.xAxis2.drawable(true);
          prefs.north = { size : modules.xAxis2.getPreferredSize() };
      }
      if ( modules.yAxis2 ) {
          modules.yAxis2.drawable(true);
          prefs.east = { size : modules.yAxis2.getPreferredSize() };
      }
      if ( modules.plot ) {
        prefs.center = {};
      }
      
      var solution = layout({
        type : 'border',
        bias : 'none',
        size : { width : width, height : height },
        prefs : prefs
      });
      
      centerWidth = solution.center.bounds.width;
      centerHeight = solution.center.bounds.height;
      
      //JIMMY/8/8/2012, WHY WE NEED DO THIS HERE?
      //the first time layout, we haven't set scale to axis (as dependency resolve happens after
       // the first layout), so the preferred size we get from axis is 0. then during dependency
       //resolving, we return scale to axis based on this inaccurate preferred size.
       
       //then during rendering, we will do layout again, this time we get a new preferred size from
       //axis as axis has scale now. but with this new preferred size, the scale has also to be updated,
       //but we won't do dependency resolving anymore. so we have to update the scale here. as axis
       //has the same reference of the scale, it can also get the new scale value.
       
       //so the preferred size returned by axis is actually based on the old scale and thus inaccurate. why
       //it doesn't affect the rendering result? for horizontal axis, the scale only matters the width of the axis
       //which we don't care, we only care height for horizontal axis. for vertical axis, the scale only matters
       //the height of the axis while we only care the width of it during layout.
       
       //so that's why we need layout again before rendering. we want to get the preferredsize from axis
       //even with a wrong scale. if axis can return preferredsize without scale (it's only possible for one
       //direction which is exactly we care during layout), we don't need do this.  
      xCategoryScale.rangeBands([0, centerWidth]);
      yCategoryScale.rangeBands([0, centerHeight]);
      
      if ( solution.north ) {
        // Modifies xAxis width and coordinate to handle horizontal offset
        // to ensure joints with yAxis.
        var xAxis2Width = solution.north.bounds.width, xAxis2X = 0;
        if ( solution.west ) {
          xAxis2Width -= solution.west.bounds.width;
          xAxis2X = solution.north.bounds.x + solution.west.bounds.width;
        }
        if ( solution.east ) {
          xAxis2Width -= solution.east.bounds.width;
        }
        
        selections.xAxis2.attr('transform', 
          'translate(' + xAxis2X + ',' + solution.north.bounds.y + ')');
        
        modules.xAxis2
          .width(xAxis2Width)
          .height(solution.north.bounds.height);
      
        modules.xAxis2.gridlineLength(solution.center.bounds.height);  
      } else if (modules.xAxis2) {
          modules.xAxis2.drawable(false);
      }
      
      if ( solution.east ) {
        selections.yAxis2.attr('transform', 
          'translate(' + solution.east.bounds.x + 
          ',' + solution.east.bounds.y + ')');
        modules.yAxis2
          .width(solution.east.bounds.width)
          .height(solution.east.bounds.height);
          
        modules.yAxis2.gridlineLength(solution.center.bounds.width);    
      } else if (modules.yAxis2) {
          modules.yAxis2.drawable(false);
      }
      
      if ( solution.south ) {
        // Modifies xAxis width and coordinate to handle horizontal offset
        // to ensure joints with yAxis.
        var xAxisWidth = solution.south.bounds.width, xAxisX = 0;
        if ( solution.west ) {
          xAxisWidth = solution.south.bounds.width - solution.west.bounds.width;
          xAxisX = solution.south.bounds.x + solution.west.bounds.width;
        }
        if ( solution.east ){
          xAxisWidth = solution.south.bounds.width - solution.east.bounds.width;
        }
        
        selections.xAxis.attr('transform', 
          'translate(' + xAxisX + ',' + solution.south.bounds.y + ')');
        
        modules.xAxis
          .width(xAxisWidth)
          .height(solution.south.bounds.height);

        modules.xAxis.gridlineLength(solution.center.bounds.height);
      } else if (modules.xAxis) {
          modules.xAxis.drawable(false);
      }
      
      if ( solution.west ) {
        selections.yAxis.attr('transform', 
          'translate(' + solution.west.bounds.x + 
          ',' + solution.west.bounds.y + ')');
        modules.yAxis
          .width(solution.west.bounds.width)
          .height(solution.west.bounds.height);
      
        modules.yAxis.gridlineLength(solution.center.bounds.width);       
      } else if (modules.yAxis) {
          modules.yAxis.drawable(false);
      }
      
      if ( solution.center ) {
        selections.plotRoot.attr('transform', 
          'translate(' + solution.center.bounds.x + 
          ',' + solution.center.bounds.y + ')');
          
        var centersolution = layout({
          type : 'table',
          bias : 'none',
          size : { width : solution.center.bounds.width, height : solution.center.bounds.height },
          columns : columns,
          rows : rows,
          cellpadding : internalProps.cellPadding,
          paddingThreshold : internalProps.paddingThreshold
        });
        var i = 0;
        var contexts = multiData.contexts;
        for(var colI = 0; colI < columns; colI++){
          for(var rowI = 0; rowI < rows; rowI++){
            var ctxI = contexts[rowI][colI];
            if(ctxI){
              var plotI = modules.plot[i];
              var csi = centersolution[colI][rowI];
              var splotI = selections.plot[i];
              plotI.width(csi.bounds.width).height(csi.bounds.height);
              splotI.attr('transform',  'translate(' + csi.bounds.x +  ',' + csi.bounds.y + ')');
              ++i;
            }
          }
        }
      }
    }
    
    
    function dataRange(type) {
        return function(range) {
            if (!arguments.length) {
                return internalRange[type];
            } else {
                if (!internalRange[type]) {
                    internalRange[type] = range;
                } else {
                    var currentRange = internalRange[type];
                    if (range.distinctValuesObj) {
                        for (var i in range.distinctValuesObj) {
                            if (range.distinctValuesObj.hasOwnProperty(i)){
                              currentRange.distinctValuesObj[i] = range.distinctValuesObj[i];
                            }
                        }
                    }
                    
                    if (range.min < currentRange.min) {
                        currentRange.min = range.min;
                    }
                    if (range.max > currentRange.max) {
                        currentRange.max = range.max;
                    }
                    
                    if (range.hasNoValue) {
                      currentRange.hasNoValue = true;
                    }

                }
            }
        };
    }

    
    function resolveMergeDataRange (types){
      //for each type we will generate a function to set/get data range
      for(var i = 0, len = types.length; i < len; i++){
        container[types[i] + 'DataRange'] = dataRange(types[i]);
      }
    }
    
    function parseProperties (props){
      properties = props;
      if (properties[PLOTAREAPROPCATE]){
        Objects.extend(plotAnimation, properties[PLOTAREAPROPCATE].animation);
      }
      if(props[PROPERTYCATEGORY]){
        if(props[PROPERTYCATEGORY].mergeDataRange){
          internalProps.mergeDataRange = props[PROPERTYCATEGORY].mergeDataRange;
          resolveMergeDataRange(internalProps.mergeDataRange);
        }
        var formerDimsInCol = internalProps.numberOfDimensionsInColumn;
        Objects.extend(true, internalProps, props[PROPERTYCATEGORY]);
        if (modules.plot && formerDimsInCol !== internalProps.numberOfDimensionsInColumn){
          processRawData();
          clearInternalRange();
          updateAxisData('xAxis', multiData.columnData);
          updateAxisData('yAxis', multiData.rowData);
          updateAxisData('xAxis2', multiData.columnData);
          updateAxisData('yAxis2', multiData.rowData);
          updatePlotData();
        }
      }
    }
    
    function buildXCateScale(){
      var domain = [];
      for (var i = 0; i < columns; i++){
         domain.push(i);
      }
      var xAxis = modules.xAxis ? modules.xAxis : modules.xAxis2;
      xCategoryScale.domain(domain).rangeBands([0, centerWidth]);
    }
    
    function buildYCateScale(){
      var domain = [];
      for (var i = 0; i < rows; i++){
         domain.push(i);
      }
      var yAxis = modules.yAxis ? modules.yAxis : modules.yAxis2;
      yCategoryScale.domain(domain).rangeBands([0, centerHeight]);
    }

    function container( selection ) {
      relayout();
      selection.each(function ( data ) {
        //Alex Su: if detected data changing, we set sub plot's dataLoading with container's dataUpdating to control its animation
        if (!bFirstCreation && bDataChanged){
          setAnimationFlag();
        }
        initializedPlots = 0;
        parent = selection;
        boundUtil.drawBound(selection, width, height);
        if(selections.plotRoot){
          boundUtil.drawBound(selections.plotRoot, centerWidth, centerHeight);
        }
        if ( TypeUtils.isEmptyObject(modules) ){ 
          initialize();
        }
        render();
        //Alex Su: and set animation flags back after rendering.
        if (!bFirstCreation && bDataChanged){
          setAnimationFlag(true);
        }
      });
      bFirstCreation = false, bDataChanged = false;
      return container;
    }
    
    container.width = function (_) {
      if ( !arguments.length ) {
        return width;
      }
      width = _;
      clearInternalRange();//Alex Su: internal data range needs reset, too.
      //Jimmy,8/20/2012, as a container, you don't know whether your
      //sub elements need relayout even if the container size remains
      //the same. so here we just give a chance to sub elements to relayout
      relayout();
      return container;
    };
    
    container.height = function (_) {
      if ( !arguments.length ) {
        return height;
      }
      height = _;
      //see @width
      clearInternalRange();
      relayout();
      return container;
    };
    
    container.size = function(_) {
      if ( !arguments.length ) {
        return {
          'width' : width,
          'height' : height
        };
      }
      height = _.height;
      width = _.width;
      //see @width
      clearInternalRange();
      relayout();
      return container;
    };
    
    container.data = function (_) {
      if ( !arguments.length ) {
        return data;
      }
      bDataChanged = true;
      var bDataSchmaChanged = false;
      if (! dataUtil().hasSameSchema(data, _)){
        bDataSchmaChanged = true;
      }
       data = _;
      
      //clean internal data range
       clearInternalRange();      
       
      if(!TypeUtils.isEmptyObject(modules)){
        processRawData();

        if (bDataSchmaChanged){
          avaModulesCount = avaModulesCount - avaPlotCount;
          updateAxisData('xAxis', multiData.columnData);
          updateAxisData('yAxis', multiData.rowData);
          updateAxisData('xAxis2', multiData.columnData);
          updateAxisData('yAxis2', multiData.rowData);
          
          avaPlotCount = 0;
          //Jimmy/9/13/2012 we may have chance to split data update and data
          //schema update in the future
          //done by Alex Su
          initializePlots();
          updateProperties("plot");
          updateProperties("xAxis2");
          updateProperties("yAxis");        
          updatePlotData();
          initializePlotElements();
          
          avaModulesCount = avaModulesCount + avaPlotCount;
          
        } else {
          updateAxisData('xAxis', multiData.columnData);
          updateAxisData('yAxis', multiData.rowData);
          updateAxisData('xAxis2', multiData.columnData);
          updateAxisData('yAxis2', multiData.rowData);
          updatePlotData();
        }
          
      }
      return container;
    };
    
    container.properties = function (_) {
      if ( !arguments.length ) {
        //Alex Su: for a container, it accept a full list properties including its submodules' but return its private ones.
        return internalProps;
      }
      //FIXME JIMMY/8/8/2012, columns/rows may be different with different properties
      if(!TypeUtils.isEmptyObject(_)){
        parseProperties(_);
      }
      
      //update properties of sub plots
      if(!TypeUtils.isEmptyObject(modules)){
        ///*Jimmy/9/19/2012, we may need deal with internalProps.numberOfDimensionsInColumn update
        //we don't need recreate plots but we need rearrange plots and change data*/
        //^^ fixed by Alex Su
        updateProperties("plot");
        updateProperties("xAxis2");
        updateProperties("yAxis");        
      }
      return container;
    };
    
    container.config = function (_) {
      if ( !arguments.length ) {
        return config;
      }
      config = _;
      return container;
    };
    
    container.xCategoryScale = function (_) {
      if ( !arguments.length ) {
        buildXCateScale();
        return xCategoryScale;
      }
      xCategoryScale = _;
      return container;
    };
    
    container.yCategoryScale = function (_) {
      if ( !arguments.length ) {
        buildYCateScale();
        return yCategoryScale;
      }
      yCategoryScale = _;
      return container;
    };
    
    container.modules = function (_) {
      if ( !arguments.length ) {
        if ( TypeUtils.isEmptyObject(modules) ) {
          initialize();
        } 
        return modules;
      }
      modules = _;
      return container;
    };
    
    container.parent = function (_) {
      if ( !arguments.length ) {
        return parent;
      }
      parent = _;
      return container;
    };
    
    container.dispatch = function(_){
      if( !arguments.length){
        return eDispatch;
      }
      eDispatch = _;
      return container;
    };

    container.infoForSizeLegend = function() {
      var plot;
      for ( var i = -1, j = modules.plot.length; ++i < j;) {
        plot = modules.plot[i];
        if (plot){
          break;
        }
      }
      return {
        space : plot ? (width - centerWidth + plot.infoForSizeLegend().space * columns) : 0,
        number : columns,
        plotHeight : plot ? plot.height() : 0
      };
    };
    
    container.plotRegion = function () {
      return {
        selection: selections.plotRoot,
        width: centerWidth,
        height: centerHeight
      };
    };
    
    container.destroy = function(){
        
        if(xCategoryScale){
          xCategoryScale.domain([0,1]).range([0,1]);
        }
        if(yCategoryScale){
          yCategoryScale.domain([0,1]).range([0,1]);
        }
        
        xCategoryScale = null;
        yCategoryScale = null;
        
        modules = null;
        data = null;
      //destroy ctx
      if(ctx){
        ctx.destroy();
        ctx = null;
      }
    };
    
    function renderAxis ( id ) {
      if(selections[id]){
        parent.select('.v-m-' + id).datum(modules[id].data()).call(modules[id]);
      }
    }
    
    function render() {
      renderAxis('xAxis');
      renderAxis('xAxis2');
      renderAxis('yAxis');
      renderAxis('yAxis2');
      
      if(selections.plot){
        for(var i = 0, len = selections.plot.length; i < len; i++){
          if(selections.plot[i]){
            selections.plot[i].datum(modules.plot[i].data()).call(modules.plot[i]);
          }
        }
      }
    }
    
    function initialized(){
      if(++initializedPlots === avaModulesCount){
        initializedPlots = 0;
        eDispatch.initialized();
      }
    }
    
    function showTooltip(evt){
      eDispatch.showTooltip(evt);
    }
    
    function hideTooltip(evt){
      eDispatch.hideTooltip(evt);
    }
    
    return container;
  };
  
  return retfn;
  
});
define('sap/viz/modules/manifests/TableContainer',['sap/viz/modules/manifests/Module','sap/viz/modules/Constants','sap/viz/modules/tablecontainer',
'sap/viz/data/feed/Constants'],
function Setup(Manifest, moduleConstants, fn, feedConstants) {
    var multiplierFeed = {
    'id' : 'multiplier',
    'name' : 'Chart Multiplier',
    'type' : feedConstants.Type.Dimension,
    'min' : 1,
    'max' : 1,
    'aaIndex' : 1,
    'acceptMND' : 0
  };

  var module = {
    'id' : 'sap.viz.modules.tablecontainer',
    'type' : moduleConstants.Type.Container,
    'name' : 'table container',
    'description': 'Settings for the subcharts layout of multiple charts.',
    //TODO support different layout: row/column/dimensional
    'properties' : {
      'mergeDataRange' : {
        'name' : 'mergeDataRange',
        'supportedValueType' : 'String',
        'supportedValues' : ['ANY DATA RANGE NAME'],
        'defaultValue' : null,
        'description' : 'Set mergeDataRange. Specify names of data range you want to merge, we will generate corresponding functions in this module to do the real merge. for example, if \'primary\' and \'second\' are specified here, two functions will be generated: \'primaryDataRange\' and \'secondDataRange\'. the function name is the range name plus \'DataRange\'. these generated functions support both getter and setter, for setter, you can pass any number of ranges {min:NUM, max:NUM} to it to merge, then you can get the merged result through the getter.',
        'isExported' : false
      },
      'numberOfDimensionsInColumn' : {
        'name' : 'numberOfDimensionsInColumn',
        'supportedValueType' : 'PositiveInt',
        'defaultValue' : 1,
        'description' : 'Set the specified number of dimensions, retrieved from the end of the dimension list in multiplier, will be put in column when doing multiple layout.'
      },
      'cellPadding' : {
        'name' : 'cellPadding',
        'supportedValueType' : 'PositiveInt',
        'defaultValue' : 15,
        'description' : 'Set padding between cells of sub plots. If cellPadding value exceeds containerSize * threshold, we set it to 0.'
      },
      'paddingThreshold' : {
        'name' : 'paddingThreshold',
        'supportedValueType' : 'Number',
        'defaultValue' : 0.2,
        'description' : 'Set paddingThreshold, if cellPadding value exceeds the containerSize * threshold, we set it to 0.',
        'isExported' : false
      }
    },
  'events' : {
      'showTooltip' : moduleConstants.Event.TooltipShow.desc,
      'hideTooltip' : moduleConstants.Event.TooltipHide.desc
   },
    //TODO
    'css' : null,
    'feeds' : [multiplierFeed],
    'fn' : fn
  };
  Manifest.register(module);
});
define('sap/viz/manifests/BaseMultipleChart',['sap/viz/manifests/Viz','sap/viz/manifests/BaseChart','sap/viz/modules/manifests/RootContainer',
'sap/viz/modules/manifests/XYContainer','sap/viz/modules/manifests/TableContainer',
'sap/viz/modules/manifests/Axis','sap/viz/modules/manifests/Background'],
function Setup(Manifest) {
  var multiChart = {
    id : 'riv/base/multiple',
    name : 'IDS_BASEMULTIPLECHART',
    base : 'riv/base',
    'abstract' : true,
    modules : {
      root : {
        id : 'sap.viz.modules.rootContainer',
        configure : { propertyCategory : 'general' },
        modules : {
          interaction : {
            id : 'sap.viz.modules.controller.interaction',
            configure : {
              clientID : 'main',
              propertyCategory : 'interaction',
              properties : {
                supportedEventNames: ['mouseup', 'mousedown', 'mousemove', 'mouseover', 'mouseout', 'touchstart']
              }
            }
          },        
          main : {
            id : 'sap.viz.modules.tablecontainer',
            configure : {
              propertyCategory : 'multiLayout',
              properties : {
                layout : {
                  position : 'center',
                  priority : 10
                }
              }
            },
            modules: {
              xAxis2 : {
                id : 'sap.viz.modules.axis',
                configure : {
                'description': 'Settings for the column axis of multiple charts.',
                  propertyCategory : 'columnAxis',
                  properties : {
                    title : { visible : false },
                    gridline : { visible : true },
                    color : '#d8d8d8',
                    type : 'category',
                    position : 'top'
                  },
                  propertiesOverride : {    
                    label : { isExported : false },
                    axisline : { isExported : false },
                    gridline:{ 
                      isExported : false,
                      color: { isExported : false },
                      size: { isExported:false }
                    },
                    scale : { 
                      fixedRange : {isExported : false},
                      minValue : {isExported : false},
                      maxValue : {isExported : false},
                      isExported : false 
                    }
                  }
                }
              },
              yAxis : {
                id : 'sap.viz.modules.axis',
                configure : {
                  description : 'Settings for the row axis of multiple charts.',
                  propertyCategory : 'rowAxis',
                  properties : {
                    type : 'category',
                    position : 'left',
                    title : { visible : false },
                    color : '#d8d8d8',
                    gridline : { visible : true }
                  },
                  propertiesOverride : {          
                    label : { isExported : false },
                    axisline : { isExported : false },
                    gridline:{
                      isExported : false,
                      color: { isExported : false },
                      size: { isExported:false }
                    },
                    scale : { 
                      fixedRange : {isExported : false},
                      minValue : {isExported : false},
                      maxValue : {isExported : false},
                      isExported : false 
                    }
                  }
                }
              },
              plot : { id : 'sap.viz.modules.xycontainer' }
            }
          }
        }
      }
    }
  };

  Manifest.register(multiChart);
});
define('sap/viz/manifests/BaseMultipleXYChart',['sap/viz/manifests/Viz','sap/viz/manifests/BaseChart','sap/viz/modules/manifests/RootContainer',
'sap/viz/modules/manifests/XYContainer','sap/viz/modules/manifests/TableContainer',
'sap/viz/modules/manifests/Axis','sap/viz/manifests/BaseMultipleChart','sap/viz/modules/manifests/Tooltip'],
function Setup(Manifest) {
  var multiXYChart = {
    id : 'riv/base/multiple/xy',
    name : 'IDS_BASEMULTIPLEXYCHART',
    base : 'riv/base/multiple',
    'abstract' : true,
    modules : {
      root : {
        id : 'sap.viz.modules.rootContainer',
        configure : { propertyCategory : 'general' },
        modules : {
          tooltip : {
            id : 'sap.viz.modules.tooltip',
            configure : { propertyCategory : 'tooltip' }
          },
          main : {
            modules: {
              plot : {
                id : 'sap.viz.modules.xycontainer',
                modules : {
                  plot: {
                    configure: {
                      propertiesOverride:{
                        primaryValuesColorPalette:{ isExported: false },
                        secondaryValuesColorPalette: { isExported: false }
                      }
                    }
                  },
                  background : {
                    id : 'sap.viz.modules.background',
                    configure : {
                      propertyCategory : 'background',
                      properties : { direction : 'vertical' }
                    }
                  },
                  dataLabel : {
                    id : 'sap.viz.modules.datalabel',
                    configure : {
                      propertyCategory : 'dataLabel',
                      properties : {
                        paintingMode : 'rectCoordinate',
                        visible : false,
                        position : 'inside',
                        automaticInOutside : true,
                        showZero : true,
                        isStackMode : false,
                        isPercentMode : false,
                        outsideVisible : true
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  };

  Manifest.register(multiXYChart);
});
define('sap/viz/manifests/MultiScatterChart',['sap/viz/manifests/Viz','sap/viz/manifests/BaseChart','sap/viz/modules/manifests/RootContainer',
'sap/viz/modules/manifests/XYContainer','sap/viz/modules/manifests/TableContainer',
'sap/viz/modules/manifests/Axis','sap/viz/modules/manifests/Scatter','sap/viz/manifests/BaseMultipleChart',
'sap/viz/manifests/BaseMultipleXYChart'],
function Setup(Manifest) {
  var multiBarChart = {
    id : 'viz/multi_scatter',
    name : 'IDS_MULTISCATTERCHART',
    base : 'riv/base/multiple/xy',
   
    modules : {
      root : {
        modules : {
          legends : {
            modules : {
              legend : {
                data : { aa : [ 2,3 ] },
                configure : {
                  properties : { type : 'BubbleColorLegend' },
                  propertiesOverride : {
                      isHierarchical : { isExported: false },
                      isScrollable :  { isExported: false }
                  }
                } 
              }
            }
          },
          tooltip : {
            configure : {
              properties : {
                chartType : 'scatter',
                orientation : 'left'
              }
            }
          },
          
          interaction : { 
            id : 'sap.viz.modules.controller.interaction',
            configure : { 
              clientID : "main",
              propertyCategory : 'interaction'
            }
          },
          
          main : {              
            configure : {
              properties : {
                'mergeDataRange' : ['valueAxis1', 'valueAxis2']
              }
            },
            modules: {
              plot : {
                id : 'sap.viz.modules.xycontainer',
                modules : {
                  xAxis : {
                    id : 'sap.viz.modules.axis',
                    configure : {
                    'description': 'Settings for the x axis of a normal bubble or scatter plot.',
                     propertyCategory : 'xAxis',
                      properties : {
                        title : {
                          visible : false
                        },
                        type : 'value',
                        position : 'bottom'
                      },
                      propertiesOverride : {
                        title : {
                          isExported : false
                        }                    
                      }
                    }
                  },
                  dataLabel : {
                    id : 'sap.viz.modules.datalabel',
                    configure : {
                      propertyCategory : 'dataLabel',
                      properties : {
                        automaticInOutside : false,
                        orientation : 'vertical',
                        position : 'outside',
                        outsideVisible : true
                      }
                    }
                  },
                  /**
                   * 'xAxis2' : { },
                   */
        
                  yAxis : {
                    id : 'sap.viz.modules.axis',
                    configure : {
                    'description': 'Settings for the y axis of a normal bubble or scatter plot.',
                      propertyCategory : 'yAxis',
                      properties : {
                        title : {
                          visible : false
                        },
                        type : 'value',
                        position : 'left'
                      },
                      propertiesOverride : {
                        title : {
                          isExported : false
                        }                    
                      }
                    }
                  },
                  
                  plot : {
                    id : 'sap.viz.modules.scatter',
                    configure : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                      propertyCategory : 'plotArea'
                    }
                  }
                }
              }
            }
          }
        }
      }
      
    },
    feeds:{
      multiplier:{
        acceptMND:-1
       }
   },
    dependencies : {
      attributes : [
      {
        targetModule : 'root.main.plot.plot',
        target : 'valueAxis1DataRange',
        sourceModule : 'root.main.plot.xAxis',
        source : 'range'
      }, 
      {
        targetModule : 'root.main.plot.plot',
        target : 'valueAxis2DataRange',
        sourceModule : 'root.main.plot.yAxis',
        source : 'range'
      },
      {
        targetModule : 'root.main.xAxis2',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'xCategoryScale'
      }, 
      {
        targetModule : 'root.main.yAxis',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'yCategoryScale'
      },
      {
        targetModule : 'root.main',
        target : 'valueAxis1DataRange',
        sourceModule : 'root.main.plot.plot',
        source : 'valueAxis1DataRange'
      },
      {
        targetModule : 'root.main.plot.plot',
        target : 'valueAxis1DataRange',
        sourceModule : 'root.main',
        source : 'valueAxis1DataRange'
      },
      {
        targetModule : 'root.main',
        target : 'valueAxis2DataRange',
        sourceModule : 'root.main.plot.plot',
        source : 'valueAxis2DataRange'
      },
      {
        targetModule : 'root.main.plot.plot',
        target : 'valueAxis2DataRange',
        sourceModule : 'root.main',
        source : 'valueAxis2DataRange'
      },
      {
        targetModule : 'root.main.plot.xAxis',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'valueAxis1Scale'
      }, {
        targetModule : 'root.main.plot.xAxis',
        target : 'title',
        sourceModule : 'root.main.plot.plot',
        source : 'valueAxis1Title'
      }, {
        targetModule : 'root.main.plot.yAxis',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'valueAxis2Scale'
      }, {
        targetModule : 'root.main.plot.yAxis',
        target : 'title',
        sourceModule : 'root.main.plot.plot',
        source : 'valueAxis2Title'
      }, {
        targetModule : 'root.legends.legend',
        target : 'colorPalette',
        sourceModule : 'root.main.plot.plot',
        source : 'colorPalette'
      }, {
        targetModule : 'root.legends.legend',
        target : 'shapes',
        sourceModule : 'root.main.plot.plot',
        source : 'shapes'
      }, {
        targetModule : 'root.legends.legend',
        target : 'setSelectionMode',
        sourceModule : 'root.interaction',
        source : 'getSelectionMode'
    }
      ],
      events : [  {
          targetModule : 'root.interaction',
          listener : 'registerEvent',
          sourceModule : 'root.main',
          type : 'initialized.interaction'
        }, {
            targetModule : 'root.tooltip',
            listener : 'showTooltip',
            sourceModule : 'root.main',
            type : 'showTooltip'
        }, {
            targetModule : 'root.tooltip',
            listener : 'hideTooltip',
            sourceModule : 'root.main',
            type : 'hideTooltip'
        },{
        targetModule : 'root.interaction',
        listener : 'highlightedByLegend',
        sourceModule : 'root.legends.legend',
        type : 'highlightedByLegend'
        }, {
          targetModule : 'root.legends.legend',
        listener : 'deselectLegend',
        sourceModule : 'root.interaction',
        type : 'deselectLegend'
        }, {
          targetModule : 'root.main.plot.dataLabel',
          listener : 'showLabel',
          sourceModule : 'root.main.plot.plot',
          type : 'initialized.datalabel'
        }, {
          targetModule : 'root.main.plot.dataLabel',
          listener : 'removeLabel',
          sourceModule : 'root.main.plot.plot',
          type : 'startToInit.datalabel'
        }]
    }
  };

  Manifest.register(multiBarChart);
});
define('sap/viz/manifests/MultiBubbleChart',['sap/viz/manifests/Viz','sap/viz/manifests/BaseChart','sap/viz/modules/manifests/RootContainer',
'sap/viz/modules/manifests/XYContainer','sap/viz/modules/manifests/TableContainer',
'sap/viz/modules/manifests/Axis','sap/viz/modules/manifests/Scatter','sap/viz/manifests/MultiScatterChart'],
function Setup(Manifest) {
  var multiBarChart = {
    id : 'viz/multi_bubble',
    name : 'IDS_MULTIBUBBLECHART',
    base : 'viz/multi_scatter',
    modules : {
      root : {
        modules : {
          legends : {
            modules : {
              legend : {
                data : { aa : [ 2, 3 ] },
                configure : {properties : {layout :{order : 1}},propertiesOverride :{isHierarchical : { isExported : false }}}
              },
              sizeLegend : {
                id : 'sap.viz.modules.legend.common',
                configure : {
                  description: "The size legend is a box mapping the charts data shapes's size to the value by some typical symbols and associated indication values.",
                  propertyCategory : 'sizeLegend',
                  properties : { type : 'SizeLegend',layout : { order : 0 } },
                  propertiesOverride : {
                      isHierarchical : { isExported: false },
                      isScrollable :  { isExported: false }
                  }
                }
              }
            }
          },
          
          tooltip : {
            configure : {
              properties : { chartType : 'bubble', orientation : 'left' }
            }
          },
          
          main : {
            configure : {
              properties : {
                'mergeDataRange' : ['valueAxis1', 'valueAxis2', 'bubbleWidth', 'bubbleHeight']
              }
            },
            
            modules: {
              plot : {
                id : 'sap.viz.modules.xycontainer',
                modules : {
                  dataLabel : {
                    id : 'sap.viz.modules.datalabel',
                    configure : {
                      propertyCategory : 'dataLabel',
                      properties : { 
                        automaticInOutside : true,
                        position : 'inside'
                      }
                    }
                  },
                  
                  plot : {
                    id : 'sap.viz.modules.bubble',
                    configure : {
                    description : 'Settings regarding the chart area and plot area as well as general chart options.',
                      propertyCategory : 'plotArea'
                    }
                  }
                }
              }
            }
          }
        }
      }
      
    },
    feeds:{
      multiplier : { acceptMND : -1 },
      secondaryValues: { max: 1 } // or null
    },
    
    dependencies : {
      attributes : [
        {
          targetModule : 'root.main.plot.plot',
          target : 'valueAxis1DataRange',
          sourceModule : 'root.main.plot.xAxis',
          source : 'range'
        }, 
        {
          targetModule : 'root.main.plot.plot',
          target : 'valueAxis2DataRange',
          sourceModule : 'root.main.plot.yAxis',
          source : 'range'
        }, 
        {
          targetModule : 'root.main.xAxis2',
          target : 'scale',
          sourceModule : 'root.main',
          source : 'xCategoryScale'
        }, 
        {
          targetModule : 'root.main.yAxis',
          target : 'scale',
          sourceModule : 'root.main',
          source : 'yCategoryScale'
        },
        {
          targetModule : 'root.main',
          target : 'valueAxis1DataRange',
          sourceModule : 'root.main.plot.plot',
          source : 'valueAxis1DataRange'
        },
        {
          targetModule : 'root.main.plot.plot',
          target : 'valueAxis1DataRange',
          sourceModule : 'root.main',
          source : 'valueAxis1DataRange'
        },
        {
          targetModule : 'root.main',
          target : 'valueAxis2DataRange',
          sourceModule : 'root.main.plot.plot',
          source : 'valueAxis2DataRange'
        },
        {
          targetModule : 'root.main.plot.plot',
          target : 'valueAxis2DataRange',
          sourceModule : 'root.main',
          source : 'valueAxis2DataRange'
        },
        {
          targetModule : 'root.main',
          target : 'bubbleWidthDataRange',
          sourceModule : 'root.main.plot.plot',
          source : 'bubbleWidthDataRange'
        },
        {
          targetModule : 'root.main.plot.plot',
          target : 'bubbleWidthDataRange',
          sourceModule : 'root.main',
          source : 'bubbleWidthDataRange'
        },
        {
          targetModule : 'root.main',
          target : 'bubbleHeightDataRange',
          sourceModule : 'root.main.plot.plot',
          source : 'bubbleHeightDataRange'
        },
        {
          targetModule : 'root.main.plot.plot',
          target : 'bubbleHeightDataRange',
          sourceModule : 'root.main',
          source : 'bubbleHeightDataRange'
        },
        {
          targetModule : 'root.main.plot.xAxis',
          target : 'scale',
          sourceModule : 'root.main.plot.plot',
          source : 'valueAxis1Scale'
        },
        {
          targetModule : 'root.main.plot.yAxis',
          target : 'scale',
          sourceModule : 'root.main.plot.plot',
          source : 'valueAxis2Scale'
        }, 
        {
          targetModule : 'root.main.plot.xAxis',
          target : 'title',
          sourceModule : 'root.main.plot.plot',
          source : 'valueAxis1Title'
        }, 
        {
          targetModule : 'root.main.plot.yAxis',
          target : 'title',
          sourceModule : 'root.main.plot.plot',
          source : 'valueAxis2Title'
        }, 
        {
          targetModule : 'root.legends.legend',
          target : 'colorPalette',
          sourceModule : 'root.main.plot.plot',
          source : 'colorPalette'
        }, 
        {
          targetModule : 'root.legends.legend',
          target : 'shapes',
          sourceModule : 'root.main.plot.plot',
          source : 'shapes'
        }, 
        {
            targetModule : 'root.legends.sizeLegend',
            target : 'sizeLegendInfo',
            sourceModule : 'root.main.plot.plot',
            source : 'sizeLegend'
        }
      ]
    }
  };

  Manifest.register(multiBarChart);
});
define('sap/viz/modules/scattermatrixcontainer',['jquery', 'sap/viz/base/utils/TypeUtils','sap/viz/base/utils/ObjectUtils','sap/viz/base/utils/FunctionUtils',
'sap/viz/modules/layout','sap/viz/data/handler/MultiChartDataHandler','sap/viz/modules/manifests/Module',
'sap/viz/util/TextUtils','sap/viz/modules/dispatch',
'sap/viz/lang/langManager','sap/viz/modules/util/BoundUtil','sap/viz/util/ignite',
'sap/viz/util/fn/createContext','sap/viz/modules/util/dataUtil', 'sap/viz/base/UADetector'],
function Setup($, TypeUtils, Objects, Functions, layout, MultiChartDataHandler, Manifest, TextUtils, dispatch, langManager, boundUtil, ignite, createContext, dataUtil, UADetector) {

    return function(manifest, ctx) {
        var CSSCLASS_SUBTITLE = 'v-subtitle';

        var width = 0, height = 0, subWidth = 0, subHeight = 0,
        properties = {}, data = {}, config = {}, modules = {}, selections = {}, parent = null, // a d3 selection
        dataHandler = null, plotLabels = [];
        var plotTitleVisible = true;
        var isTitleHidden = false;
        var eDispatch = new dispatch('initialized', 'showTooltip', 'hideTooltip'), avaPlotCount = 0;
        var font = {};
        var defaultTitleStyle;
        var innerProperties = manifest.props(null);
        var initializedPlots = 0;
        var plotManifest, plotContext;

        var handleNull = function(_) {
          if (_ === null || _ === undefined) {
            return langManager.get('IDS_ISNOVALUE');
          } else {
            return _;
          }
        };
    
        //Alex Su: we need to hold a copy of animation flag settings to control animation flow.
        var plotAnimation = {
          dataLoading: true,
          dataUpdating:true,
          resizing:true
        };
        var bFirstCreation = true, bDataChanged = false;
        
        var PLOTAREAPROPCATE = 'plotArea';
        
        function setAnimationFlag(back){
          //Alex Su: FIXME hard coded here, need to be resolved in the future.
          var props = {};
          var propcate = (props[PLOTAREAPROPCATE] = {});
          var animation = (propcate.animation = {});
          Objects.extend(animation, plotAnimation);
          if (!back && bDataChanged){
            animation.dataLoading = plotAnimation.dataUpdating;
          }
          var plots = modules.plot;
          for(var i = 0, len = plots.length; i < len; i++){
            plots[i].properties(props);
          }      
        }
        function getThemeStyleDef() {
            var titleStyle = ctx.styleManager.query(CSSCLASS_SUBTITLE);
            if(titleStyle) {
                if(titleStyle['fill']){
                    font.fill = titleStyle['fill'];
                }
                if(titleStyle['font-family']){
                    font.family = titleStyle['font-family'];
                }
                if(titleStyle['font-size']){
                    font.size = titleStyle['font-size'];
                }
                if(titleStyle['font-weight']){
                    font.weight = titleStyle['font-weight'];
                }
            }
            defaultTitleStyle = ctx.styleManager.queryDefault(CSSCLASS_SUBTITLE);
        };
        
        function initializePlot() {
          var plotConfig = config.modules.plot;
          if (!plotConfig)
              return;
          delete modules.plot;
          modules.plot = [];
          
          if ( plotContext ) {
            plotContext.styleManager.cleanChildren();
          }
          
          var measureNum = data.getMeasureValuesGroupDataByIdx()[0].values.length;
          for (var colI = 0; colI < measureNum; colI++) {
              for (var rowI = 0; rowI < measureNum; rowI++) {
                  var i = rowI * measureNum + colI;
                  
                  if ( !plotManifest || !plotContext ) {
                    plotManifest = Manifest.get(plotConfig.id);
                    plotContext = createContext(plotManifest, ctx, "v-m-plot");
                  }
                  
                  var plotI = modules.plot[i] = ignite(plotManifest, plotContext);
                  plotI.config(plotConfig);
                  avaPlotCount++;
                  if(plotI.dispatch){
                      var dis =  plotI.dispatch();
                        if(dis.initialized) dis.on('initialized.scattermatrixcontainer', initialized);
                        if(dis.showTooltip) dis.on('showTooltip.scattermatrixcontainer', showTooltip);
                        if(dis.hideTooltip) dis.on('hideTooltip.scattermatrixcontainer', hideTooltip);
                   }
              }
          }
        }
        
        function updatePlotProperties() {
          if (TypeUtils.isExist(properties.multiLayout) && TypeUtils.isExist(properties.multiLayout.plotTitle) && TypeUtils.isExist(properties.multiLayout.plotTitle.visible)) {
            plotTitleVisible = properties.multiLayout.plotTitle.visible;
            innerProperties.plotTitle.visible = properties.multiLayout.plotTitle.visible;              
          }
          
          var plots = modules.plot;
          if(plots){
            var plotConfig = config.modules.plot;
            if (!plotConfig)
                return;
            var props;
            if (plotConfig.configure) {
                if (plotConfig.configure.propertyCategory) {
                  props = Objects.extend(true, {}, properties[ plotConfig.configure.propertyCategory ]);
               }
            } else {
                props = properties;
            }

            for(var i = 0, len = plots.length; i < len; i++){
              if (props) {
                plots[i].properties(props);
              }
            }
          }
          getThemeStyleDef();
        }
        
        function updatePlotData() {
          //Alex Su: delete Dom for matrix labels
          if (plotLabels){
            for (var i = 0; i < plotLabels.length; ++i){
              var shape = plotLabels[i].shape;
              if (shape){
                shape.remove();
              }
            }
          }
          plotLabels = [];//can we split data label updating outside?
          dataHandler = new MultiChartDataHandler(data, "measures");
          var measureNum = data.getMeasureValuesGroupDataByIdx()[0].values.length;
          for (var colI = 0; colI < measureNum; colI++) {
              for (var rowI = 0; rowI < measureNum; rowI++) {
                  var dataI = dataHandler.getSubDataAdapterByMeasures({
                      row : rowI,
                      col : colI
                  });
                  var plotI = modules.plot[rowI * measureNum + colI];
                  plotI.data(dataI);
                  
                  var plotLabel = plotLabels[rowI * measureNum + colI];
                  if(!plotLabel) plotLabel = plotLabels[rowI * measureNum + colI] = {};
                  //we may already have other members here in plotLabel, do not remove them while updating
                  plotLabel.empty = (colI == rowI);
                  plotLabel.label = (colI == rowI 
                          ? handleNull(dataI.getMeasureValuesGroupDataByIdx(0).values[0].col) 
                          : handleNull(dataI.getMeasureValuesGroupDataByIdx(0).values[0].col) + ' - ' + handleNull(dataI.getMeasureValuesGroupDataByIdx(1).values[0].col));
              }
          }
        }
        
        function initializePlotElements() {
          delete selections.plot;
          parent.select('.v-m-plot').remove();
          if (modules.plot && !selections.plot) {
            var splots = selections.plot = [];
            var plotRoot = selections.plotRoot = parent.append('g').attr('class', 'v-m-plot');
            for (var i = 0, len = modules.plot.length; i < len; i++) {
                splots[i] = plotRoot.append('g').attr('class', 'v-m-plot' + i);

                var plotI = modules.plot[i];
                var subModules = plotI.parent(splots[i]).modules();

                var formatString = null, xAxisProps = {label:{}}, yAxisProps = {label:{}};
                var plotIData = null;
                
                if (properties.hasOwnProperty('xAxis') && subModules.hasOwnProperty('xAxis')) 
                {
                  plotIData = plotI.data();
                  var measureXAxis = plotIData.getMeasureValuesGroupDataByIdx()[0].values;
                  if (TypeUtils.isArray(measureXAxis)) {
                    if (TypeUtils.isExist(measureXAxis[0].rows[0][0].ctx.path) && TypeUtils.isExist(properties['xAxis'].label) && TypeUtils.isExist(properties['xAxis'].label.formatString)) {
                      if (TypeUtils.isArray(properties['xAxis'].label.formatString)) {
                        formatString = properties['xAxis'].label.formatString[0][measureXAxis[0].rows[0][0].ctx.path.mi];
                      } else if (TypeUtils.isString(properties['xAxis'].label.formatString)) {
                        formatString = properties['xAxis'].label.formatString
                      }
                      if(formatString) {
                        xAxisProps.label.formatString = formatString;
                        subModules['xAxis'].properties(xAxisProps);
                      }
                    }
                  }
                }
                
                if (properties.hasOwnProperty('yAxis') && subModules.hasOwnProperty('yAxis'))
                {
                  if (!plotIData) {
                    plotIData = plotI.data();
                  }
                  var measureYAxis = plotIData.getMeasureValuesGroupDataByIdx()[1].values;
                  if (TypeUtils.isArray(measureYAxis)) {
                    if (TypeUtils.isExist(measureYAxis[0].rows[0][0].ctx.path) && TypeUtils.isExist(properties['yAxis'].label) && TypeUtils.isExist(properties['yAxis'].label.formatString)) {
                      if (TypeUtils.isArray(properties['yAxis'].label.formatString)) {
                        formatString = properties['yAxis'].label.formatString[0][measureYAxis[0].rows[0][0].ctx.path.mi];
                      } else if (TypeUtils.isString(properties['yAxis'].label.formatString)) {
                        formatString = properties['yAxis'].label.formatString
                      }
                      if(formatString) {
                        yAxisProps.label.formatString = formatString;
                        subModules['yAxis'].properties(yAxisProps);
                      }
                    }
                  }
                }
                
                for (var m in subModules )
                if (subModules.hasOwnProperty(m))
                    modules['plot[' + i + ']' + '.' + m] = subModules[m];
            }
          }
        }

        function initialize() {
            if (TypeUtils.isEmptyObject(config))
                Functions.error('Container configuration missing');

            avaPlotCount = 0;
            initializePlot();
            updatePlotProperties();
            updatePlotData();
            initializePlotElements();
        };
        
        function relayout() {
            if (TypeUtils.isEmptyObject(modules) || !width || !height)
                return;
            
            getThemeStyleDef();
            var measureNum = data.getMeasureValuesGroupDataByIdx()[0].values.length;
            subWidth = width / measureNum;
            subHeight = height / measureNum;
            var labelSize = getMaxLabelSize();
            var labelHeight = labelSize.height;
            if (!plotTitleVisible || labelSize.width > subWidth || labelSize.height > subHeight / 3) {
                labelHeight = 0;
                isTitleHidden = true;
            }
            for (var colI = 0; colI < measureNum; colI++) {
                for (var rowI = 0; rowI < measureNum; rowI++) {
                    
                    var plotI = modules.plot[rowI * measureNum + colI];
                    var splotI = selections.plot[rowI * measureNum + colI];
                    plotI.width(subWidth).height(subHeight - labelHeight);
                    splotI.attr('transform', 'translate(' + (subWidth * colI) + ',' + (subHeight * rowI) + ')');
                }
            }
        };

        function container(selection) {
            selection.each(function(data) {
              //Alex Su: if detected data changing, we set sub plot's dataLoading with container's dataUpdating to control its animation
              if (!bFirstCreation && bDataChanged){
                setAnimationFlag();
              }

              initializedPlots = 0;
              parent = selection;
              boundUtil.drawBound(selection, width, height);
              if (TypeUtils.isEmptyObject(modules)){
                  initialize();
              }
              relayout();
              render();
              //Alex Su: and set animation flags back after rendering.
              if (!bFirstCreation && bDataChanged){
                setAnimationFlag(true);
              }

            });
            bFirstCreation = false, bDataChanged = false;
            return container;
        }


        container.width = function(_) {
            if (!arguments.length)
                return width;
            if (width !== _) {
                width = _;
                relayout();
            }
            return container;
        };

        container.height = function(_) {
            if (!arguments.length)
                return height;
            if (height !== _) {
                height = _;
                relayout();
            }
            return container;
        };

        container.size = function(_) {
            if (!arguments.length)
                return {
                    'width' : width,
                    'height' : height
                };
            if (height !== _.height || width !== _.width) {
                height = _.height;
                width = _.width;
                relayout();
            }
            return container;
        };

        container.data = function(_) {
            if (!arguments.length)
                return data;
            bDataChanged = true;
            var bDataSchmaChanged = false;
            if (! dataUtil().hasSameSchema(data, _)){
              bDataSchmaChanged = true;
            }
            data = _;
            if(!TypeUtils.isEmptyObject(modules)){
              //TODO Jimmy/9/11/2012 currently we can't know
              //whether it's a data change only (without schema change)
              //but we do have chance in new data model. for now, we just
              //update everything

              if (bDataSchmaChanged){
                avaPlotCount = 0;
                initializePlot();
                updatePlotProperties();
                updatePlotData();
                initializePlotElements();
              } else {
                updatePlotData();
              }
            }
            return container;
        };

        container.properties = function(_) {
            if (!arguments.length)
                return innerProperties;
            properties = $.extend(true, {}, properties, _);
            Objects.extend(true, innerProperties, properties["multiLayout"]);
            
            if (properties[PLOTAREAPROPCATE]){
              Objects.extend(plotAnimation, properties[PLOTAREAPROPCATE].animation);
            }
            if(!TypeUtils.isEmptyObject(modules)){
              updatePlotProperties();
            }
            return container;
        };

        container.config = function(_) {
            if (!arguments.length)
                return config;
            config = _;
            return container;
        };

        container.modules = function(_) {
            if (!arguments.length) {
                if (TypeUtils.isEmptyObject(modules)) {
                    initialize();
                }
                return modules;
            }
            modules = _;
            return container;
        };

        container.parent = function(_) {
            if (!arguments.length)
                return parent;
            parent = _;
            return container;
        };

        container.dispatch = function(_){
          if( !arguments.length){
            return eDispatch;
          }
          eDispatch = _;
          return container;
        };
        
        function render() {

            if (selections.plot) {
                for (var i = 0, len = selections.plot.length; i < len; i++) {
                    if (plotLabels[i].empty) {
                        renderLabel(selections.plot[i], plotLabels[i], subHeight / 2);
                        initialized();
                    } else {
                        modules.plot[i].width(subWidth);
                        selections.plot[i].datum(modules.plot[i].data()).call(modules.plot[i]);
                        renderLabel(selections.plot[i], plotLabels[i], subHeight);
                    }
                    
                }
            }
            isTitleHidden = false;
        };
        
        function renderLabel(plot, labelObj, ybaseline) {
            if (labelObj.shape) {
                labelObj.shape.remove();
            }
            
            if (isTitleHidden) {
                return;
            }
            
            var labelSize = TextUtils.fastMeasure(labelObj.label, font.size, font.weight, font.family);
            
            labelObj.shape = plot.append('text').attr('class', CSSCLASS_SUBTITLE + ' ' + 'viz-matrix-sub-title')
                    .attr('text-anchor', 'middle')
                    .attr('x', subWidth / 2)
                    .attr('y', UADetector.isIE() ? ybaseline : ybaseline - labelSize.height / 2)
                    .attr('dominant-baseline', 'middle')
                    .style('cursor', 'default');
            defaultTitleStyle.toAttrs(labelObj.shape);
            TextUtils.ellipsis(labelObj.label, labelObj.shape.node(), subWidth - 5 /* leave some padding */, "font:" + font.weight + ' ' + font.size + ' ' + font.family);
        };
        
        function getMaxLabelSize() {
            var maxWidth = 0, maxHeight = 0;
            for (var i = 0, len = plotLabels.length; i < len; i++) {
                var size = TextUtils.fastMeasure(plotLabels[i].label, font.size, font.weight, font.family);
                maxHeight = size.height > maxHeight ? size.height : maxHeight;
                maxWidth = size.width > maxWidth ? size.width : maxWidth;
            }
            return {
                width : maxWidth,
                height : maxHeight
            };
        }
        
        function initialized(){
          if(++initializedPlots == avaPlotCount){
            initializedPlots = 0;
            eDispatch.initialized();
          }
        }
        
        function showTooltip(evt){
          eDispatch.showTooltip(evt);
        };
        
        function hideTooltip(evt){
          eDispatch.hideTooltip(evt);
        };
        
        return container;
    };

});

define('sap/viz/feeds/ScatterMatrix',['sap/viz/feeds/Manifest','sap/viz/data/feed/Constants'],
function Setup(Manifest, constants) {
    var feeds = {
      id : "scattermatrix",
      feeds : [ {
        'id' : 'regionColor',
        'name' : 'IDS_REGIONCOLOR',
        'type' : constants.Type.Dimension,
        'min' : 0,
        'max' : 1,
        'aaIndex' : 1,
        'acceptMND': -1
      }, {
        'id' : 'regionShape',
        'name' : 'IDS_REGIONSHAPE',
        'type' : constants.Type.Dimension,
        'min' : 0,
        'max' : 1,
        'aaIndex' : 2,
        'acceptMND': -1
      }, {
        'id' : 'primaryValues',
        'name' : 'IDS_PRIMARYVALUES',
        'type' : constants.Type.Measure,
        'min' : 2,
        'max' : constants.Constraints.INF,
        'mgIndex' : 1
      }]
    };
    Manifest.register(feeds);
});
define('sap/viz/modules/manifests/ScatterMatrixContainer',['sap/viz/modules/manifests/Module','sap/viz/modules/Constants','sap/viz/modules/scattermatrixcontainer',
'sap/viz/feeds/ScatterMatrix'],
function Setup(Manifest, Constants, fn) {
    
    var module = {
      'id' : 'sap.viz.modules.scattermatrixcontainer',
        'type' : Constants.Type.Container,
        'name' : 'Scatter Matrix Container',
        'description': 'Settings for the subcharts layout of Scatter Matrix chart.',
        'properties' : {
            'plotTitle' : {
              'name' : 'plotTitle',
        'description': 'Settings for plot title.',
              'supportedValueType' : 'Object',
              'supportedValues' : {
                'visible' : {
                  'name' : 'visible',
                  'supportedValueType' : 'Boolean',
                  'defaultValue' : true,
                  'description' : 'Set visibility of sub plot title.'
                }
              }
            }
        },
        'css' : {
            '.viz-matrix-sub-title.v-subtitle' : {
                'description' : 'Define style for the sub plot title.',
                'value' : {
                    'fill' : '#000000',
                    'font-family' : "'Open Sans', Arial, Helvetica, sans-serif",
                    'font-size' : '12px',
                    'font-weight' : 'bold'
                }
            }
        },
        'feeds' : { 
            id : 'scattermatrix'
        },
    'events' : {
      'showTooltip' : Constants.Event.TooltipShow.desc,
      'hideTooltip' : Constants.Event.TooltipHide.desc
    },
        'fn' : fn
    };
    Manifest.register(module);
});
define('sap/viz/modules/manifests/ScatterInMatrix',['sap/viz/modules/manifests/Module','sap/viz/modules/manifests/Scatter'],
function Setup(Manifest) {
    var module = {
      'id' : 'sap.viz.modules.scatterInMatrix',
      base : 'sap.viz.modules.scatter',
      'name' : 'scatterInMatrix',
      'feeds' : null
    };
    Manifest.register(module);
});
define('sap/viz/manifests/ScatterMatrixChart',['sap/viz/manifests/Viz','sap/viz/modules/manifests/RootContainer','sap/viz/modules/manifests/Title',
'sap/viz/modules/manifests/ScatterMatrixContainer','sap/viz/modules/manifests/Legend',
'sap/viz/modules/manifests/XYContainer','sap/viz/modules/manifests/Tooltip',
'sap/viz/modules/manifests/Axis','sap/viz/modules/manifests/ScatterInMatrix'],
function Setup(Manifest) {
    var scatterMatrix = {
        id : 'viz/scatter_matrix',
        name : 'IDS_SCATTERMATRIXCHART',
        base : 'riv/base',
        modules : {
          root : {
            modules : {
              legends : {
                modules : {
                  legend : {
                    data : { aa : [1, 2] }, 
                    configure : { 
                      properties : { type :'BubbleColorLegend' },
                      propertiesOverride : {
                          isHierarchical : { isExported: false },
                          isScrollable :  { isExported: false }
                      }
                    }
                  }
                }
              },
  
              tooltip : { 
                id : 'sap.viz.modules.tooltip',
                configure : { 
                  propertyCategory : 'tooltip',
                  properties : { 
                    chartType: 'scattermatrix',
                    orientation :'left'
                  }
                }
              },
  
              interaction : { 
                id : 'sap.viz.modules.controller.interaction',
                configure : { 
                  clientID : 'main',
                  propertyCategory :'interaction'
                }
              },
  
              main : {
                id : 'sap.viz.modules.scattermatrixcontainer',
                configure : {
                  propertyCategory : 'multiLayout',
                  properties : {
                    layout : {
                      position : 'center',
                      priority : 10
                    }
                  }
                },
                
                modules : {
                  plot : {
                    id : 'sap.viz.modules.xycontainer',
                    modules : {
                      xAxis : {
                        id : 'sap.viz.modules.axis',
                        data : { mg : [1] },
                        configure : {
                          description : 'Settings for the x axis of a normal bubble or scatter plot.',
                          propertyCategory : 'xAxis',
                          properties : {
                            type : 'value',
                            position : 'bottom',
                            gridline : { visible : false }
                          }
                        }
                      },

                      yAxis : {
                        id : 'sap.viz.modules.axis',
                        data : { mg : [2] },
                        configure : {
                          description : 'Settings for the y axis of a normal bubble or scatter plot.',
                          propertyCategory : 'yAxis',
                            properties : {
                              type : 'value',
                              position : 'left',
                              gridline : { visible : false }
                            }
                        }
                      },
                
                      background : {
                        id: 'sap.viz.modules.background',
                        configure : {
                          propertyCategory : 'background',
                          properties : {
                            direction : 'vertical'
                          }
                        }
                      },
                      
                      dataLabel : {
                        id : 'sap.viz.modules.datalabel',
                        configure : {
                          propertyCategory : 'dataLabel',
                          properties : {
                            paintingMode : 'rectCoordinate',
                            visible : false,
                            position : 'outside',
                            automaticInOutside : false
                          }
                        }
                      },
                
                      plot : {
                        id : 'sap.viz.modules.scatterInMatrix',
                        configure : {
                          description : 'Settings regarding the chart area and plot area as well as general chart options.',
                          propertyCategory : 'plotArea'
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        
        dependencies : {
            attributes : [ {
              targetModule : 'root.main.plot.plot',
              target : 'valueAxis1DataRange',
              sourceModule : 'root.main.plot.xAxis',
              source : 'range'
            }, {
              targetModule : 'root.main.plot.plot',
              target : 'valueAxis2DataRange',
              sourceModule : 'root.main.plot.yAxis',
              source : 'range'
            }, {
                targetModule : 'root.main.plot.yAxis',
                target : 'scale',
                sourceModule : 'root.main.plot.plot',
                source : 'valueAxis2Scale'
            }, {
                targetModule : 'root.main.plot.xAxis',
                target : 'scale',
                sourceModule : 'root.main.plot.plot',
                source : 'valueAxis1Scale'
            }, {
                targetModule : 'root.main.plot.xAxis',
                target : 'title',
                sourceModule : 'root.main.plot.plot',
                source : 'valueAxis1Title'
            }, {
                targetModule : 'root.main.plot.yAxis',
                target : 'title',
                sourceModule : 'root.main.plot.plot',
                source : 'valueAxis2Title'
            }, {
                targetModule : 'root.legends.legend',
                target : 'colorPalette',
                sourceModule : 'root.main.plot.plot',
                source : 'colorPalette'
            }, {
                targetModule : 'root.legends.legend',
                target : 'shapes',
                sourceModule : 'root.main.plot.plot',
                source : 'shapes'
            }, {
              targetModule : 'root.legends.legend',
              target : 'setSelectionMode',
              sourceModule : 'root.interaction',
              source : 'getSelectionMode'
            }],

            events :[{
                targetModule : 'root.tooltip',
                listener : 'showTooltip',
                sourceModule : 'root.main',
                type : 'showTooltip'
            }, {
                targetModule : 'root.tooltip',
                listener : 'hideTooltip',
                sourceModule : 'root.main',
                type : 'hideTooltip'
            }, {
                targetModule : 'root.interaction',
                listener : 'registerEvent',
                sourceModule : 'root.main',
                type : 'initialized.interaction'
            }, {
              targetModule : 'root.interaction',
              listener : 'highlightedByLegend',
              sourceModule : 'root.legends.legend',
              type : 'highlightedByLegend'
            }, {
                    targetModule : 'root.legends.legend',
                  listener : 'deselectLegend',
                  sourceModule : 'root.interaction',
                  type : 'deselectLegend'
            }, {
              targetModule : 'root.main.plot.dataLabel',
              listener : 'showLabel',
              sourceModule : 'root.main.plot.plot',
              type : 'initialized.datalabel'
            }, {
              targetModule : 'root.main.plot.dataLabel',
              listener : 'removeLabel',
              sourceModule : 'root.main.plot.plot',
              type : 'startToInit.datalabel'
            }, {
              targetModule : 'root.interaction',
              listener : 'defaultSelection',
              sourceModule : 'root.main',
              type : 'initialized.defaultSelection'
            } ]
        }
    };

    Manifest.register(scatterMatrix);
});
define('sap/viz/modules/util/MNDHandler',[],
function Setup() 
{

  return function(data) 
  {
    var dataset1;
    var dataset2;
    var hasMND = false;
    var bMNDOnColor = true;
    var bMNDInner = false; 
    var bDualAxis = false;
    var measureFeed2 = data.getMeasureValuesGroupDataByIdx(1);
    var measureFeed1 = data.getMeasureValuesGroupDataByIdx(0);
    var regionColorFeed = data.getAnalysisAxisDataByIdx(1);
    var categoryFeed = data.getAnalysisAxisDataByIdx(0);

    if((measureFeed2 && measureFeed2.values && measureFeed2.values.length > 0))
    {
      bDualAxis = true;
    }
    if(categoryFeed && categoryFeed.values && categoryFeed.values.length > 0)
    {
      if (categoryFeed.values[0].type === 'MND')
      {
        hasMND = true;
        bMNDOnColor = false;
        bMNDInner = false;
      }else if(categoryFeed.values[categoryFeed.values.length - 1].type === 'MND')
      {
        hasMND = true;
        bMNDOnColor = false;
        bMNDInner = true;
      }
    }

    if(regionColorFeed && regionColorFeed.values && regionColorFeed.values.length > 0)
    {
      if(regionColorFeed.values[0].type === 'MND')
      {
        hasMND = true;
        bMNDInner = false;
      }else if(regionColorFeed.values[regionColorFeed.values.length - 1].type === 'MND')
      {
        hasMND = true;
        bMNDInner = true;
      }
    }

    // MND on axis label
    function processOneAxisValue(feed)
    {
      var dataset = [];
      var i, j, k;
      var measureData;
      if (feed.values.length <= 0){
        return dataset;
      }
      if (hasMND && !bMNDOnColor)
      {
        for(j = 0; j < feed.values[0].rows.length; ++j)
        {    
          measureData = new Array(feed.values.length * feed.values[0].rows[0].length);
          for(k = 0; k < feed.values[0].rows[0].length; ++k)
          {
            for(i = 0 ; i < feed.values.length; ++i)
            {
              var dataPoint = {};
              dataPoint.val = feed.values[i].rows[j][k].val;
              dataPoint.ctx = feed.values[i].rows[j][k].ctx;
              dataPoint.info = feed.values[i].rows[j][k].info;
              if(bMNDInner){
                measureData[k * feed.values.length + i] = dataPoint;
              } else {
                measureData[i * feed.values[0].rows[0].length + k] = dataPoint; 
              }
            }
          }
          dataset.push(measureData);
        }  
      }
      else // MND on Region color or no MND
      {
        dataset = new Array(feed.values.length * feed.values[0].rows.length);

        for(i = 0 ; i < feed.values.length; ++i)
        {
          for(j = 0; j < feed.values[0].rows.length; ++j)
          {    
            measureData = feed.values[i].rows[j];
            if(!hasMND || !bMNDInner){
              dataset[i * feed.values[0].rows.length + j] = measureData;
            } else {
              dataset[j * feed.values.length + i] = measureData;
            }
          }
        }
      }

      return dataset;
    }

    function addOneMeasure(dataset, measure)
    {
      for(var i = 0; i < measure.length; ++i)
      {
        dataset[i] = dataset[i].concat(measure[i]);
      }
    }

    function mergeTwoAxis(result)
    {
      var colors = [];
      var measure1Num = measureFeed1.values.length;
      var measure2Num = measureFeed2.values.length;
      var columnNum  = measureFeed1.values[0].rows[0].length;
      var dataset = new Array(measureFeed1.values[0].rows.length); 
      var curColumn = 0;
      var i,j,k;
      for(i = 0; i < dataset.length; ++i){
        dataset[i] = [];
      }
      if(bMNDInner){
        var rowNum = measureFeed1.values[0].rows.length;
        for(i = 0; i < columnNum; ++i)
        {

          for(j = 0; j < measure1Num; ++j)
          {
            for(k = 0; k < rowNum; ++k){
              dataset[k][curColumn] = measureFeed1.values[j].rows[k][i];
            }
            colors[curColumn] = 0;
            ++curColumn;
          }
          for(j = 0; j < measure2Num; ++j)
          {
            for(k = 0; k < rowNum; ++k){
              dataset[k][curColumn] = measureFeed2.values[j].rows[k][i];
            }
            colors[curColumn] = 1;
            ++curColumn;
          }
        }
      }else{
        for(i = 0; i < measure1Num; ++i)
        {
          for(j = 0; j < columnNum; ++j)
          {
            colors[curColumn++] = 0; 
          }
          addOneMeasure(dataset, measureFeed1.values[i].rows);
        }
        for(i = 0; i < measure2Num; ++i)
        {
          for(j = 0; j < columnNum; ++j)
          {
            colors[curColumn++] = 1; 
          }
          addOneMeasure(dataset, measureFeed2.values[i].rows);
        }
      }
      result['MG1'] = dataset;
      result["MG1Number"] = measureFeed1.values.length;
      result['color'] = colors;
    }

    var result = {};

    if(bDualAxis && !bMNDOnColor)
    {
      mergeTwoAxis(result);
    }else{
      dataset1 = processOneAxisValue(measureFeed1);
      result["MG1Number"] = measureFeed1.values.length;
      if(bDualAxis){
        dataset2 = processOneAxisValue(measureFeed2);
        result["MG2Number"] = measureFeed2.values.length;
      }
      result["MG1"] = dataset1;
      result["MG2"] = dataset2;
    }
    result["hasMND"] = hasMND;
    result["MNDOnColor"] = bMNDOnColor;
    result['MNDInner'] = bMNDInner;
    return result;

  };
});
define('sap/viz/util/BoundingBox',[],

function Setup() {
  var boundingbox = {};
  boundingbox.getBBox = function (node, rootNode) {
    var matrix;
    if (arguments.length === 1) {
      matrix = node.getCTM();
    } else {
      matrix = node.getTransformToElement(rootNode);
    }
    return boundingbox.getBBoxHelp(node, matrix);
  };

  boundingbox.getBBoxHelp = function (node, matrix) {
    var box = node.getBBox();
    var corners = [];
    var point = d3.select('svg')[0][0].createSVGPoint();
    point.x = box.x;
    point.y = box.y;
    corners.push(point.matrixTransform(matrix));
    point.x = box.x + box.width;
    point.y = box.y;
    corners.push(point.matrixTransform(matrix));
    point.x = box.x + box.width;
    point.y = box.y + box.height;
    corners.push(point.matrixTransform(matrix));
    point.x = box.x;
    point.y = box.y + box.height;
    corners.push(point.matrixTransform(matrix));
    var minX = corners[0].x;
    var maxX = corners[0].x;
    var minY = corners[0].y;
    var maxY = corners[0].y;
    for (var i = 1; i < corners.length; i++) {
      var x = corners[i].x;
      var y = corners[i].y;
      if (x < minX) {
        minX = x;
      } else if (x > maxX) {
        maxX = x;
      }
      if (y < minY) {
        minY = y;
      } else if (y > maxY) {
        maxY = y;
      }
    }

    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  };

  // return true if the two boxes intersect
  boundingbox.intersects = function(a, b) {
    return (a.x <= (b.x + b.width) &&
        b.x <= (a.x + a.width) &&
        a.y <= (b.y + b.height) &&
        b.y <= (a.y + a.height));
  };

  // returns a box representing the intersection of box1 and box2 if it exists, otherwise null
  boundingbox.intersection = function(box1, box2) {
    if (boundingbox.intersects(box1, box2)) {
      var x1 = Math.max(box1.x, box2.x),
          x2 = Math.min(box1.x + box1.width, box2.x + box2.width),
          y1 = Math.max(box1.y, box2.y),
          y2 = Math.min(box1.y + box1.height, box2.y + box2.height);

      return {
        x: x1,
        y: y1,
        width: x2 - x1,
        height: y2 - y1
      };
    }

    return null;
  };

  return boundingbox;
});
define('sap/viz/modules/line',['sap/viz/modules/util/dataUtil','sap/viz/modules/dispatch','sap/viz/modules/util/MNDHandler',
'sap/viz/base/utils/TypeUtils','sap/viz/util/Scaler','sap/viz/util/ColorSeriesGenerator',
'sap/viz/util/BoundingBox','sap/viz/util/NumberUtils','sap/viz/lang/langManager',
'sap/viz/util/DrawUtil','sap/viz/modules/util/tooltipDataHandler','sap/viz/modules/manifests/Module',
'sap/viz/base/utils/ObjectUtils','sap/viz/base/utils/Objects','sap/viz/base/UADetector',
'sap/viz/modules/util/BoundUtil','sap/viz/modules/util/defaultSelectionUtil','sap/viz/modules/Constants'],
function Setup(dataUtil, dispatch, MNDHandler, TypeUtils, Scaler, ColorSeries, BoundingBox, NumberUtils, langManager, DrawUtil, TooltipDataHandler, Manifest, ObjectUtils, Objects,UADetector,BoundUtil, defaultSelUtil, Constants) 
{
  var ret = function(manifest, ctx)
  {
    var CLASSMARKERSELECTED = Constants.CSS.CLASS.DATAPOINTSELECTED,
        CLASSMARKERHOVER = Constants.CSS.CLASS.DATAPOINTHOVER,
        CLASSMARKERDEFAULT = Constants.CSS.CLASS.DATAPOINTDEFAULT,
        CLASSDATAPOINT = Constants.CSS.CLASS.DATAPOINT,
        CLASSMORPHABLEDATAPOINT = Constants.CSS.CLASS.MORPHABLEDATAPOINT,
        CLASSMORPHABLELINE = Constants.CSS.CLASS.MORPHABLELINE;
    var CLASSLINES = "v-lines",
    SEL_CLASSLINES = "." + CLASSLINES;
    var CLASSLIGHTLINE = "v-lightLine",
    SEL_CLASSLIGHTLINE = "." + CLASSLIGHTLINE;
    
    var CLASSDATAPOINTCOMBINED = CLASSDATAPOINT + ' ' + CLASSMORPHABLEDATAPOINT;
    var CLASSLINESCOMBINED = CLASSLINES + ' ' + CLASSMORPHABLELINE;
    var CLASSLIGHTLINECOMBINED = CLASSLIGHTLINE + ' ' + CLASSMORPHABLELINE;
    
    var width, height;
    var data_ = null, props;
    //alistar zhu
    var randomSuffix = ObjectUtils.guid();
    //alex su
    var tooltipData = null;
    var _tooltipDataHandler;

    var bgColor = "#FFFFFF";
    var hoverColor = "#cccccc";
    var selectedColor = "#333333";

    var xScale = d3.scale.ordinal();
    var mouseMoveLine;
    var preHighLightIndex;
    var g;
    var svgMarkersGroup, svgLinesGroup, svgLightLinesGroup;
    var eDispatch = new dispatch('showTooltip', 'hideTooltip', 'initialized','startToInit');
    var hasMND;
    var bMNDOnColor;
    var bMNDInner;
    var effectManager = ctx.effectManager;
    var valueAxis1Data = {
        data: [],
        scale: d3.scale.linear(),
        colorPalette:null,
        selectedMarkers: null,
        markers:[],
        bottomValue: null,
        topValue:null,
        highLines:[]
    };

    var valueAxis2Data = {
        data: [],
        scale: d3.scale.linear(),
        colorPalette:null,
        selectedMarkers: null,
        markers:[],
        bottomValue: null,
        topValue:null,
        highLines:[]
    };
    var colorPalette = [];
    var PREFIXAXIS1 = 'v-axis1';
    var PREFIXAXIS2 = 'v-axis2';

    var bAnimationComplete = false;
    var hasDefaultSelection = false;
    var isDataSchemaChanged = false, isDataLoading = true, isSizeChanged = false, isDatasetChanged = false;

    var selectedMarkerNum = 0;
    var gSelection = null;

    // clip defs for enimation

    var clipRect;
    var OPACITY = 0.4;

    //@Alex Su, judge whether we should enable animation
    
    function enableAnimation(){
      var hasAnmation = false;
      if(isDataLoading){
        hasAnmation = props.animation.dataLoading;
      }else if(isDatasetChanged){
        hasAnmation = props.animation.dataUpdating;
      }else if(isSizeChanged){
        hasAnmation = props.animation.resizing;
      }
      return hasAnmation;
    }

    function line(selection) {
      BoundUtil.drawBound(selection, width, height);
      //selection.each(generate);
      
      //alex su
      _tooltipDataHandler = TooltipDataHandler();
      
      renderChart(selection);
      isDataSchemaChanged = false, isDataLoading = false, isSizeChanged = false, isDatasetChanged = false;
      return line;
    }

  
    


    function calculateMinMax(axisValue)
    {
      var minMax = {
          min:null,
          max:null
      };
      if(!axisValue.data || axisValue.data.length === 0){
        return null;
      }
      minMax.max = Number(d3.max(axisValue.data, function(d){
        return d3.max(d, function(_){ return _.val;});
      }));
      minMax.min = Number(d3.min(axisValue.data, function(d){
        return d3.min(d, function(_){ return _.val;});
      }));
      
      if(NumberUtils.isNoValue(minMax.max )) { 
          return null;
        }
      
      if(minMax.min >= 0)
      {
        minMax.min = 0;
        minMax.max += minMax.max * 5 / height ;
      }
      else if(minMax.max <= 0){
        minMax.max = 0;
        minMax.min +=  minMax.min * 5/ height;
      }else{
        var temp = (minMax.max - minMax.min) * 5 / height;
        minMax.min -= temp;
        minMax.max += temp;
      }
      
      return minMax;
    }

    function createColorPalette()
    {
      colorPalette = [];
      var i = 0, j = 0;
      if(valueAxis2Data.data && valueAxis2Data.data.length > 0){
        valueAxis1Data.colorPalette = props.primaryValuesColorPalette;
      } else {
        valueAxis1Data.colorPalette = props.colorPalette;
      }

      valueAxis2Data.colorPalette = props.secondaryValuesColorPalette;
      
      if (hasMND && bMNDOnColor && bMNDInner) {
        var dva1 = data_.getMeasureValuesGroupDataByIdx(0);
        var dva2 = data_.getMeasureValuesGroupDataByIdx(1);
        var mg1mNum=0, mg2mNum=0, mNum=0, colorAxisDataNum=0;
        if (dva1 && dva1.values.length>0) { 
          mg1mNum = dva1.values.length;
          colorAxisDataNum = dva1.values[0].rows.length;
        }
        if (dva2 && dva2.values.length>0) {
          mg2mNum = dva2.values.length;
          colorAxisDataNum = dva2.values[0].rows.length;
        }

        for (i=0; i<colorAxisDataNum; i++) {
          for (j=0; j<mg1mNum; j++) {
            colorPalette.push(valueAxis1Data.colorPalette[i*mg1mNum+j % valueAxis1Data.colorPalette.length]);
          }
          for (j=0; j<mg2mNum; j++){
            colorPalette.push(valueAxis2Data.colorPalette[i*mg2mNum+j % valueAxis2Data.colorPalette.length]);
          }
        }
      } else {
        for(i = 0; i < valueAxis1Data.data.length; ++i){
          colorPalette.push(valueAxis1Data.colorPalette[i % valueAxis1Data.colorPalette.length]);
        }
        if(valueAxis2Data.data && valueAxis2Data.data.length > 0)
        {
          for(i = 0; i < valueAxis2Data.data.length; ++i){
            colorPalette.push(valueAxis2Data.colorPalette[i % valueAxis2Data.colorPalette.length]);
          }
        }
      }
    }

    function calculateScale(axisValue)
    {
      if(axisValue.data && axisValue.data.length > 0)
      {
        if(axisValue.topValue === null || axisValue.topValue === undefined)
        {
          var minMax = calculateMinMax(axisValue);
          //when all data is 0 or null ,we make axisValue.scale.domain(0,1)
          if(!minMax || (minMax.min === 0 && minMax.max === 0)) {
            axisValue.scale.domain([]).range ([]);
            axisValue.bottomValue = null;
            axisValue.topValue = null;
          }
          else  {
            axisValue.scale.domain([minMax.min, minMax.max]).range ([height, 0]);
            axisValue.bottomValue = minMax.min;
            axisValue.topValue = minMax.max;
          }
        }
        else{
          axisValue.scale.domain([axisValue.bottomValue, axisValue.topValue]).range ([height, 0]);
        }

      }
      else{
        axisValue.scale.domain([0,0]).range([0,0]);
      }
      return axisValue.scale;
    }

    function computeScales()
    {
      var domain = [];
      var categoryNum = 0;
      if (valueAxis1Data.data.length !== 0) {
        categoryNum = valueAxis1Data.data[0].length;
      } else {
        categoryNum = valueAxis2Data.data[0].length;
      }
      for (var i=0; i < categoryNum; i++){
        domain.push(i);
      }
      xScale.domain(domain).rangeBands([0, width]);
      calculateScale(valueAxis1Data);
      calculateScale(valueAxis2Data);

      if (valueAxis1Data.data && valueAxis1Data.data.length > 0 &&
            valueAxis2Data.data && valueAxis2Data.data.length > 0 ) {
        if(valueAxis1Data.scale.domain().length === 0 && valueAxis2Data.scale.domain().length === 0){
          valueAxis1Data.scale.domain([0, 1]).range ([height, 0]); 
          valueAxis2Data.scale.domain([0, 1]).range ([height, 0]); 
        } else if(valueAxis1Data.scale.domain().length === 0 && valueAxis2Data.scale.domain().length !== 0){
          valueAxis1Data.scale.domain(valueAxis2Data.scale.domain()).range(valueAxis2Data.scale.range());
        } else if(valueAxis1Data.scale.domain().length !== 0 && valueAxis2Data.scale.domain().length === 0){
          valueAxis2Data.scale.domain(valueAxis1Data.scale.domain()).range(valueAxis1Data.scale.range());
        }
        
        if (!valueAxis1Data.manualRange && !valueAxis2Data.manualRange) {
            Scaler.perfectDual(valueAxis1Data.scale, valueAxis2Data.scale);
        } else if (!valueAxis1Data.manualRange) {
            Scaler.perfect(valueAxis1Data.scale);
            Scaler.getRoughTickNum(valueAxis2Data.scale);
        } else if (!valueAxis2Data.manualRange) {
            Scaler.perfect(valueAxis2Data.scale);
            Scaler.getRoughTickNum(valueAxis1Data.scale);
        } else {
            Scaler.getRoughTickNum(valueAxis1Data.scale);
            Scaler.getRoughTickNum(valueAxis2Data.scale);
        }
      } else if (valueAxis1Data.data && valueAxis1Data.data.length > 0) {
        if(valueAxis1Data.scale.domain().length === 0){
          valueAxis1Data.scale.domain([0, 1]).range ([height, 0]);
        }
        if (!valueAxis1Data.manualRange) {
            Scaler.perfect(valueAxis1Data.scale);
        } else {
            Scaler.getRoughTickNum(valueAxis1Data.scale);
        }
      } else if (valueAxis2Data.data && valueAxis2Data.data.length > 0) {
        if(valueAxis2Data.scale.domain().length === 0){
          valueAxis2Data.scale.domain([0, 1]).range ([height, 0]);
        }
        if (!valueAxis2Data.manualRange) {
            Scaler.perfect(valueAxis2Data.scale);
        } else {
            Scaler.getRoughTickNum(valueAxis2Data.scale);
        }
      }
    }

    function changeGroupMarker(groupIndex, visible, className)
    {
      if(groupIndex === undefined || groupIndex === null){
        return;
      }
      
      var seriesIndex = 0;
      for(seriesIndex = 0; seriesIndex < valueAxis1Data.data.length; ++seriesIndex)
      {   
        if(!valueAxis1Data.selectedMarkers[seriesIndex][groupIndex])
        {
          changeOneMarker(seriesIndex, groupIndex, className, valueAxis1Data);
        }
      }  

      if(!valueAxis2Data.data) {return;}

      for(seriesIndex = 0; seriesIndex < valueAxis2Data.data.length; ++seriesIndex)
      {
        if(!valueAxis2Data.selectedMarkers[seriesIndex][groupIndex])
        {
          changeOneMarker(seriesIndex, groupIndex, className, valueAxis2Data);
        }
      }
    }
   
    function lightLine(seriesIndex, xIndex, visible, valueAxis)
    {
      if(!valueAxis.highLines[seriesIndex])
      {
        valueAxis.highLines[seriesIndex] = [];
      }
      if(!valueAxis.highLines[seriesIndex][xIndex] && visible === "visible")
      {
        var d1 = valueAxis.data[seriesIndex][xIndex].val;
        var d2 = valueAxis.data[seriesIndex][xIndex + 1].val;
        valueAxis.highLines[seriesIndex][xIndex] = svgLightLinesGroup.append("svg:line");
        valueAxis.highLines[seriesIndex][xIndex].each(function(){
          this.setAttribute("class", CLASSLIGHTLINECOMBINED);
          this.setAttribute("x1",  xScale(xIndex) + xScale.rangeBand() / 2);
          this.setAttribute("y1",valueAxis.scale(d1));
          this.setAttribute("x2",xScale(xIndex + 1) + xScale.rangeBand() / 2);
          this.setAttribute("y2", valueAxis.scale(d2));
          this.setAttribute("stroke-width", props.width);
          this.setAttribute("stroke",valueAxis.colorPalette[seriesIndex %  valueAxis.colorPalette.length]);
          this.setAttribute("visibility", "hidden");
        });
        
       }
       if(valueAxis.highLines[seriesIndex][xIndex])
       {
         valueAxis.highLines[seriesIndex][xIndex].attr("visibility", visible);
       }
    }

    function changeOneMarker(seriesIndex, xIndex, className, valueAxis)
    {
      var stroke, tempOpacity;

      if (className === CLASSMARKERSELECTED) {
        stroke = selectedColor;
        tempOpacity = 1;
        if(xIndex > 0 && valueAxis.selectedMarkers[seriesIndex][xIndex - 1]){
           lightLine(seriesIndex, xIndex - 1, "visible", valueAxis);
        }
        if(xIndex < valueAxis.markers[0].length - 1 && valueAxis.selectedMarkers[seriesIndex][xIndex + 1]) {
           lightLine(seriesIndex, xIndex, "visible", valueAxis);
        }
        valueAxis.selectedMarkers[seriesIndex][xIndex] = true;
      } else {
        if(xIndex > 0 && valueAxis.selectedMarkers[seriesIndex][xIndex - 1]) {
           lightLine(seriesIndex, xIndex - 1, "hidden", valueAxis);
        }
        if(xIndex < valueAxis.markers[0].length - 1 && valueAxis.selectedMarkers[seriesIndex][xIndex + 1]){
           lightLine(seriesIndex, xIndex, "hidden", valueAxis);
        }
        valueAxis.selectedMarkers[seriesIndex][xIndex] = false;
        if(selectedMarkerNum > 0) {
            tempOpacity = OPACITY;
        } else {
            tempOpacity = 1;
        }
        
        if (className === CLASSMARKERHOVER) {
            stroke = bgColor;
        } else {
            stroke = "transparent";
            if (props.marker.visible === false) {
                tempOpacity = 0;
            }
        }
      }
  
      d3.select(valueAxis.markers[seriesIndex][xIndex])
        .attr("class", CLASSDATAPOINTCOMBINED + ' ' + className).attr("stroke", stroke).attr("opacity", tempOpacity);
    }

    function getCategoryIndex(val)
    {
      var index = val / xScale.rangeBand();
      index = Math.floor(index);
      var categoryNum = 0;
      if (valueAxis1Data.data.length !== 0) {
        categoryNum = valueAxis1Data.data[0].length;
      } else {
        categoryNum = valueAxis2Data.data[0].length;
      }
      if(index > categoryNum - 1) {index = categoryNum - 1;}
      if(index < 0) { index = 0;}
      return index;
    }

    function processOneAxisSelect(valueAxis, marker) {
      var findFlag = false, yi, xi;
      for(var i = 0; i < valueAxis.markers.length && !findFlag; i++)
      {
        var xMarks = valueAxis.markers[i];
        for (var j = 0; j<xMarks.length && !findFlag ; j++)
        {
          if(xMarks[j] === marker) {
            findFlag = true;
            yi = i;
            xi = j;
          }
        } //for j
      }//for i

      if (!findFlag) {
        return false;
      }

      if (valueAxis.selectedMarkers[yi][xi]) {
        return true;
      }
      ++selectedMarkerNum;
      changeOneMarker(yi, xi, CLASSMARKERSELECTED, valueAxis);
    }

    function processOneAxisDeselect (valueAxis, marker) {
      var xi = preHighLightIndex;

      var findFlag = false, yi;
      for(var i = 0; i < valueAxis.markers.length && !findFlag; i++)
      {
        var xMarks = valueAxis.markers[i];
        for (var j = 0; j<xMarks.length && !findFlag ; j++)
        {
          if(xMarks[j] === marker) {
            findFlag = true;
            yi = i;
            xi = j;
          }
        } 
      }

      if (!findFlag) {
        return false;
      }

      if (!valueAxis.selectedMarkers[yi][xi]){
        return true;
      }

      if(xi === preHighLightIndex){
        changeOneMarker(yi, xi, CLASSMARKERHOVER, valueAxis);
      }
      else{
        changeOneMarker(yi, xi, CLASSMARKERDEFAULT, valueAxis);
      }

    }

    
    function processNullValue(axisValue)
    {
      var result = {
          data:[],
          color:[]
      };
      var arr = [], obj, k;

      for(var i = 0; i < axisValue.length; ++i)
      {
        var preIndex = 0;
        for(var j = 0; j < axisValue[i].length; ++j)
        {
          if(NumberUtils.isNoValue(axisValue[i][j].val))
          {
            if(j > preIndex)
            {
              arr = [];
              for(k = preIndex; k < j; k++)
              {
                obj = axisValue[i][k];
                obj.x = k;  
                arr.push(obj);
              }
              result.data.push(arr);
              result.color.push(i);
            }
            preIndex = j + 1;
          }
        }
        
        if(preIndex < axisValue[i].length)
        {
          arr = [];
          for(k = preIndex; k <  axisValue[i].length; k++)
          {
            obj = axisValue[i][k];
            obj.x = k;
            arr.push(obj);
          }
          result.data.push(arr);
          result.color.push(i);
        }
      }
      return result;
    }
    
    function processOneAxis(axisValue, prefix)
    {
      if(!axisValue.data || axisValue.data.length === 0){
        return;
      }
      var axisGroup = svgLinesGroup.select("g." + prefix);
      if(axisGroup.empty())
      {
        axisGroup = svgLinesGroup.append("svg:g").attr("class", prefix);
      }
      axisValue.selectedMarkers = new Array(axisValue.data.length);
      axisValue.markers = [];
      var result = processNullValue(axisValue.data);
      
      var lines = axisGroup.selectAll(SEL_CLASSLINES).data(result.data);
      
      lines.enter().append("path");
      lines.each(function(){
        this.setAttribute('class', CLASSLINESCOMBINED);
        this.setAttribute("stroke-width", props.width);
        this.setAttribute("stroke-linejoin", "round");
      });

      lines.exit().remove();
      lines.attr("stroke-width", props.width);//@Alex: add this line to update attributes. 
      var line = d3.svg.line().x(function(d,i) { return xScale(d.x) + xScale.rangeBand() / 2; }).
      y(function(d) {  return NumberUtils.isNoValue(axisValue.scale(d.val)) ? null : axisValue.scale(d.val); });
      
      
      lines.each(function(d, i) {
        var para = { graphType:"line", 
            fillColor:axisValue.colorPalette[result.color[i] %  axisValue.colorPalette.length]};
        var strokeEffect = effectManager.register(para);
        this.setAttribute("d", line(d));
        this.setAttribute("stroke",strokeEffect);
      });
      
      
      // draw markers
      for(var seriesIndex = 0; seriesIndex < axisValue.data.length; ++seriesIndex)
      {
        axisValue.selectedMarkers[seriesIndex] = [];
        for(var dataIndex = 0; dataIndex < axisValue.data[0].length; ++dataIndex)
        {
          axisValue.selectedMarkers[seriesIndex][dataIndex] = false;
        }
      }
      var markerGroup = svgMarkersGroup.select("g." + prefix);
      if(markerGroup.empty()){
        markerGroup = svgMarkersGroup.append("svg:g").attr("class", prefix);
      }
      var groups = markerGroup.selectAll("g.v-marker").data(axisValue.data);
      groups.enter().append("svg:g").attr("class", "v-marker");
      groups.exit().remove();
      
      var visible = "hidden";
      if(props && props.marker && props.marker.visible){
        visible  = "visible";
      }
      groups.each(function(d, i) {
        
        var seriesMarkers = d3.select(this).selectAll(".v-datashape").data(d);
        var datashape = seriesMarkers.enter().append('g').attr('class','v-datashape').append("path");
        datashape.attr("class", CLASSDATAPOINTCOMBINED + " " + CLASSMARKERDEFAULT);
        seriesMarkers.exit().remove();
        var markerArr = [];
        var parameter = {
            drawingEffect:props.drawingEffect,
            graphType: props.marker.shape,
            fillColor : axisValue.colorPalette[i % axisValue.colorPalette.length],
            direction : 'vertical',
            rx: props.marker.size / 2,
            ry: props.marker.size / 2,
            borderWidth: 2,
            borderColor: props.style.marker.stroke,
            node:null,
            visibility: visible
        };
        seriesMarkers.attr("transform",function(point, index)
            {   
            if(NumberUtils.isNoValue(point.val))
            { 
                d3.select(this).remove();
                markerArr.push(null);
                return;
            }
            markerArr.push(d3.select(this).selectAll('path').node());
            parameter.node = d3.select(this).select('path');

            DrawUtil.drawGraph(parameter, effectManager);
            return  "translate(" + (xScale(index) + xScale.rangeBand() / 2) + "," + axisValue.scale(point.val) + ")";  
          });

        axisValue.markers.push(markerArr); 
      });
    }

    function processOneAxisDeselectAll(valueAxis, xIndex)
    {
      if(!valueAxis.selectedMarkers || valueAxis.selectedMarkers.length === 0){
        return;
      }

      for(var seriesIndex = 0; seriesIndex < valueAxis.selectedMarkers.length; ++seriesIndex)
      {
        for(var groupIndex = 0; groupIndex < valueAxis.selectedMarkers[0].length; ++groupIndex)
        {
          if(!valueAxis.selectedMarkers[seriesIndex][groupIndex]) {continue;}
          
          if(groupIndex === xIndex)
          {
            changeOneMarker(seriesIndex, groupIndex, CLASSMARKERHOVER, valueAxis);
          }
          else
          {
            changeOneMarker(seriesIndex, groupIndex, CLASSMARKERDEFAULT, valueAxis);
          }
        }
      }
    }
    function getCurrentEvent() {
        if (d3.event) {
            return d3.event;
        } else {
            return window.event;
        }
    }
    function deselectedAllHandler()
    {
      var event = getCurrentEvent();
      var xpoint = (event ? event.clientX : 0) - g.node().getBoundingClientRect().left;
      var xIndex = getCategoryIndex(xpoint);
      selectedMarkerNum = 0;
      processOneAxisDeselectAll(valueAxis1Data, xIndex);
      processOneAxisDeselectAll(valueAxis2Data, xIndex);
 
    }

    
    function renderChart(selection)
    {
      gSelection = selection;
      getCSSStyle();
      eDispatch.startToInit();
      if(!g) {
        g = selection.append("svg:g");
      }
      if(!clipRect){
        clipRect = g.append("svg:defs").append("svg:clipPath").attr("id", "clip1_" + randomSuffix).append("rect");
      }
      
      clipRect.each(function() {
        this.setAttribute("x", 0);
        this.setAttribute("y", 0);
        this.setAttribute("height", height);
        this.setAttribute("width", 0);
      });

      if(!mouseMoveLine){
        mouseMoveLine = g.append("svg:line");
        mouseMoveLine.each(function(){
          this.setAttribute("stroke", hoverColor);
          this.setAttribute("class", "v-hoverline viz-plot-hoverline");
        });
      }

      mouseMoveLine.each(function(){
        this.setAttribute("x1", 0);
        this.setAttribute("y1", 0);
        this.setAttribute("x2", 0);
        this.setAttribute("y2", height);
        this.setAttribute("stroke-width", 1);
        this.setAttribute("visibility", "hidden");
        this.setAttribute("shape-rendering", "crispEdges");
      });


      if(!svgLinesGroup)
      {
        svgLinesGroup = g.append("svg:g").attr("class", "v-datalines");
        svgLightLinesGroup = g.append("svg:g").attr("class", "v-lightLines");
        svgMarkersGroup = g.append("svg:g").attr("class", "v-markers v-datashapesgroup");
      }
      selectedMarkerNum = 0;
      lightAll();
      
      svgMarkersGroup.each(function(){
        this.setAttribute("clip-path", "url(#clip1_" + randomSuffix + ")");
        this.setAttribute("fill", "none");
      });
      svgLinesGroup.each(function(){
        this.setAttribute("clip-path", "url(#clip1_" + randomSuffix + ")");
        this.setAttribute("fill", "none");
      });
      svgLightLinesGroup.each(function(){
        this.setAttribute("clip-path", "url(#clip1_" + randomSuffix + ")");
        this.setAttribute("fill", "none");
      });
      svgLightLinesGroup.selectAll(SEL_CLASSLIGHTLINE).remove();
      //[21-Jan-2013 Nick] FIX BUG. Draw chart before 'initialized' event is fired out.
      processOneAxis(valueAxis1Data, PREFIXAXIS1);
      processOneAxis(valueAxis2Data, PREFIXAXIS2);
      if(enableAnimation()){
        clipRect
          .attr("x", 0).attr("y", 0).attr("height", height).attr("width", 0).transition().duration(1000)
          .attr("width", function(){return width;}).each("end", function(){
          eDispatch.initialized();});
         
        }else{
          clipRect.each(function() {
              this.setAttribute("x", 0);
              this.setAttribute("y", 0);
              this.setAttribute("height", height);
              this.setAttribute("width", width);
          });
          eDispatch.initialized();
         }


    }

    function lightAll() {
      svgLightLinesGroup.selectAll(SEL_CLASSLIGHTLINE).attr("visibility", "hidden");
      svgLinesGroup.attr("opacity", 1);
      if(UADetector.isIE()){
        svgLinesGroup.selectAll(SEL_CLASSLINES).attr("visibility", "visible");
      }
      
      var tempopacity;
      if (props.marker.visible === true) {
        tempopacity = 1;
      } else {
        tempopacity = 0;
      }
      svgMarkersGroup.selectAll("g." +  PREFIXAXIS1).selectAll("g.v-marker").selectAll("."+ CLASSMARKERSELECTED)
      .attr("opacity", tempopacity).attr("class",  CLASSDATAPOINTCOMBINED + " " + CLASSMARKERDEFAULT);
      svgMarkersGroup.selectAll("g." +  PREFIXAXIS2).selectAll("g.v-marker").selectAll("."+ CLASSMARKERSELECTED)
      .attr("opacity", tempopacity).attr("class", CLASSDATAPOINTCOMBINED + " " + CLASSMARKERDEFAULT);
    }

    function grayAll() {
      svgLightLinesGroup.selectAll(SEL_CLASSLIGHTLINE).attr("visibility", "hidden");
      svgLinesGroup.attr("opacity", OPACITY);
      if(UADetector.isIE()) {
        svgLinesGroup.selectAll(SEL_CLASSLINES).attr("visibility", "visible");
      }
      var tempopacity;
      if (props.marker.visible === true) {
        tempopacity = OPACITY;
      } else {
        tempopacity = 0;
      }      
      svgMarkersGroup.selectAll("g." +  PREFIXAXIS1).selectAll("g.v-marker").selectAll("."+ CLASSMARKERSELECTED)
      .attr("opacity", tempopacity).attr("class",  CLASSDATAPOINTCOMBINED + " " + CLASSMARKERDEFAULT);
      svgMarkersGroup.selectAll("g." +  PREFIXAXIS2).selectAll("g.v-marker").selectAll("."+ CLASSMARKERSELECTED)
      .attr("opacity", tempopacity).attr("class", CLASSDATAPOINTCOMBINED + " " + CLASSMARKERDEFAULT);
    }
    
    function getCSSStyle() {
      if (!props.style){
        props.style = {};
      } 
      var cssDef;
      if (!props.style.marker){
        props.style.marker = {};
      }
      props.style.marker.stroke = "transparent";
      cssDef = ctx.styleManager.queryDefault('v-hoverline');
      if(cssDef)
      {
        if (cssDef['stroke']){
          hoverColor = cssDef['stroke'];
        }
      }
    }
    
    function resetDataRange(){
      valueAxis1Data.topValue = null;
      valueAxis1Data.bottomValue = null;
      valueAxis2Data.topValue = null;
      valueAxis2Data.bottomValue = null;
    }
    
    line.afterUIComponentAppear = function(){
      eDispatch.initialized(); 
    };
    
    line.width = function(value) {
      if (!arguments.length){
        return width;
      }
      isSizeChanged = (!isSizeChanged && (value === width)) ? false : true;
      width = value;
      if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(data_)){
        computeScales();
      }
      return line;
    };

    line.height = function(value) {
      if (!arguments.length){
        return height;
      }
      isSizeChanged = (!isSizeChanged && (value === height)) ? false : true;
      height = value;
      if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(data_)){
        computeScales();
      }
      return line;
    };
    

    /*;
     * get/set properties
     */
    line.properties = function(_) {
      if (!arguments.length){
        return props;
      }
        
      Objects.extend(true, props, _);
      if(props.marker.size < 4 || props.marker.size > 32) { props.marker.size = 6;}
      if(props.width < 1 || props.width > 7) { props.width = 2; }

      createColorPalette();
      return line;
    };
    
     line.primaryAxisColor = function(){
        if(valueAxis2Data.data && valueAxis2Data.data.length > 0){
          return effectManager.register({graphType:"line", fillColor: valueAxis1Data.colorPalette[0]});
        }else{
          return null;
        }
      };
        
      line.secondAxisColor = function(){
        return effectManager.register({graphType:"line", fillColor:  valueAxis2Data.colorPalette[0]});
      };     
        
    /**
     * get/set your event dispatch if you support event
     */
    line.dispatch = function(_){
      if(!arguments.length){
        return eDispatch;
      }
      eDispatch = _;
      return line;
    };
    /**
     * set/get data, for some modules like Title, it doesn't need data
     */
    line.data = function(value){
      if (!arguments.length){
        return data_;
      }
      isDatasetChanged = true;
      isDataSchemaChanged = false;
      if (! dataUtil().hasSameSchema(data_, value)){
        isDataSchemaChanged = true;
      }
      data_ = value;
      var obj = MNDHandler(data_);
      valueAxis1Data.data = obj["MG1"];
      valueAxis2Data.data = obj["MG2"];
      resetDataRange();
      
      var dataInfo = (valueAxis1Data.data.length === 0 ? valueAxis2Data.data[0][0] : valueAxis1Data.data[0][0]);
      if(dataInfo.info &&  dataInfo.info.defaultSelection){
        hasDefaultSelection = true;
      }else{
        hasDefaultSelection = false;
      }
      
      hasMND = obj["hasMND"];
      bMNDOnColor = obj["MNDOnColor"];
      bMNDInner = obj["MNDInner"];
      //alex su
      tooltipData = TooltipDataHandler.dataTransform(obj);
      if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(data_)){
        computeScales();
      }
      createColorPalette();
      return line;        
    };
    
    line.dataLabel = function(_){};
      
      line.primaryAxisTitle = function(_){
        if(!arguments.length){
          var titles =  data_.getMeasureValuesGroupDataByIdx(0), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join(' & ');
        }
        return this;
      };
      
      line.secondAxisTitle = function(_){
        if(!arguments.length){
          var titles =  data_.getMeasureValuesGroupDataByIdx(1), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join(' & ');
        }
        return this;
      };
     
    /**
     * get color palette
     */
    line.getColorPalette = function() {
      if(colorPalette.length === 0)
      {
        createColorPalette();
      }
      return colorPalette;
    };

    line.shapePalette = function(){
      if(!arguments.length){
        return [props.marker.shape];
      }
      return line;
    };

    line.primaryScale = function(scale)
    {
      if(!arguments.length)
      {
        return valueAxis1Data.scale;
      }
      valueAxis1Data.scale = scale;
      return line;
    };

    line.secondaryScale = function(scale)
    {
      if(!arguments.length)
      {
        return valueAxis2Data.scale;
      }
      valueAxis2Data.scale = scale;
      return line;
    };

    line.categoryScale = function(scale)
    {
      if(!arguments.length)
      {
        return xScale;
      }
      xScale = scale;
      return line;

    };

    line.primaryDataRange = function(range){
      if (!arguments.length) {
        return {
          min : valueAxis1Data.bottomValue,
          max : valueAxis1Data.topValue
        };
      }
      var tempMax, tempMin;
      if (range !== null) {
          if (!isNaN(range.max)) {
            tempMax = range.max;
          } else {
            tempMax = valueAxis1Data.scale.perfectDomainEnd;
          }
          if (!isNaN(range.min)) {
            tempMin = range.min;
          } else {
            tempMin = valueAxis1Data.scale.perfectDomainBegin;
          }
          if (tempMax > tempMin) {
            valueAxis1Data.topValue = tempMax;
            valueAxis1Data.bottomValue = tempMin;
            if (range.from === 'axis') {
              valueAxis1Data.manualRange = true;
            }
            if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
              calculateScale(valueAxis1Data);
            }
          }
      } else {
        if (valueAxis1Data.manualRange === true) {
          valueAxis1Data.topValue = valueAxis1Data.scale.perfectDomainEnd;
          valueAxis1Data.bottomValue = valueAxis1Data.scale.perfectDomainBegin;
          valueAxis1Data.manualRange = false;
          if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
            calculateScale(valueAxis1Data);
          }
        }
      }
      return line;
    };

    line.secondDataRange = function(range){
      if (!arguments.length) {
        return {
          min : valueAxis2Data.bottomValue,
          max : valueAxis2Data.topValue
        };
      }
      var tempMax, tempMin;
      if (range !== null) {
          if (!isNaN(range.max)) {
            tempMax = range.max;
          } else {
            tempMax = valueAxis2Data.scale.perfectDomainEnd;
          }
          if (!isNaN(range.min)) {
            tempMin = range.min;
          } else {
            tempMin = valueAxis2Data.scale.perfectDomainBegin;
          }
          if (tempMax > tempMin) {
            valueAxis2Data.topValue = tempMax;
            valueAxis2Data.bottomValue = tempMin;
            if (range.from === 'axis') {
              valueAxis2Data.manualRange = true;
            }
            if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
              calculateScale(valueAxis2Data);
            }
          }
      } else {
        if (valueAxis2Data.manualRange === true) {
          valueAxis2Data.topValue = valueAxis2Data.scale.perfectDomainEnd;
          valueAxis2Data.bottomValue = valueAxis2Data.scale.perfectDomainBegin;
          valueAxis2Data.manualRange = false;
          if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
            calculateScale(valueAxis2Data);
          }
        }
      }
      return line;
    };
    line.parent = function() { 
      return gSelection;
    };

    /**
     * get/set size
     */
    line.size = function(_) {
      if (arguments.length === 0){
        return {
          width : line.width(),
          height : line.height()
        };
      }
      isSizeChanged = (!isSizeChanged && (_.height === height) &&(_.width === width)) ? false : true;
      width = _.width;
      height = _.height;
      if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(data_)){
        computeScales();
      }
      return line;
    };
    
    line.clear = function (gray) {
      deselectedAllHandler();
      var markers = [];
      if (gray === null || gray === undefined || gray === false){
        lightAll();
        markers.push(svgMarkersGroup.selectAll("g." +  PREFIXAXIS1).selectAll("g.v-marker").selectAll("."+CLASSDATAPOINT));
        markers.push(svgMarkersGroup.selectAll("g." +  PREFIXAXIS2).selectAll("g.v-marker").selectAll("."+CLASSDATAPOINT));
        if(hasDefaultSelection){
          defaultSelUtil.clearSelectionInfo(gSelection, false, markers);
        }
      } else {
        grayAll();
      }
    };

    line.highlight = function (elements) {
      var elementArray;
      if (elements instanceof Array) {
        elementArray = elements;
      } else {
        elementArray = [];
        elementArray.push(elements);
      }

      for (var i=0; i<elementArray.length; i++)
      {
        var marker = elementArray[i];
        if(!processOneAxisSelect(valueAxis1Data, marker )){
          processOneAxisSelect(valueAxis2Data, marker );
        }
      }
      svgMarkersGroup.selectAll("g." +  PREFIXAXIS1).selectAll("g.v-marker")
      .selectAll("."+ CLASSMARKERHOVER).attr("opacity", OPACITY);
      svgMarkersGroup.selectAll("g." +  PREFIXAXIS2).selectAll("g.v-marker")
      .selectAll("."+ CLASSMARKERHOVER).attr("opacity", OPACITY);
      if (props.marker.visible){
        svgMarkersGroup.selectAll("g." +  PREFIXAXIS1).selectAll("g.v-marker")
        .selectAll("."+ CLASSMARKERDEFAULT).attr("opacity", OPACITY);
        svgMarkersGroup.selectAll("g." +  PREFIXAXIS2).selectAll("g.v-marker")
        .selectAll("."+ CLASSMARKERDEFAULT).attr("opacity", OPACITY);
      }
      if(hasDefaultSelection){
        defaultSelUtil.clearSelectionInfo(gSelection, true, elementArray);
      }
    };

    line.unhighlight = function (elements) {
      var elementArray;
      if (elements instanceof Array) {
        elementArray = elements;
      } else {
        elementArray = [];
        elementArray.push(elements);
      }
      
      selectedMarkerNum -= elementArray.length;
      for (var i=0; i<elementArray.length; i++)
      {
        var marker = elementArray[i];

        if(!processOneAxisDeselect(valueAxis1Data, marker)){
          processOneAxisDeselect(valueAxis2Data, marker);
        }
      }
      if(selectedMarkerNum === 0)
      {
        svgMarkersGroup.selectAll("g." +  PREFIXAXIS1).selectAll("g.v-marker")
        .selectAll("."+ CLASSMARKERHOVER).attr("opacity", 1);
        svgMarkersGroup.selectAll("g." +  PREFIXAXIS2).selectAll("g.v-marker")
        .selectAll("."+ CLASSMARKERHOVER).attr("opacity", 1);
        if (props.marker.visible){
          svgMarkersGroup.selectAll("g." +  PREFIXAXIS1).selectAll("g.v-marker")
          .selectAll("."+ CLASSMARKERDEFAULT).attr("opacity", 1);
          svgMarkersGroup.selectAll("g." +  PREFIXAXIS2).selectAll("g.v-marker")
          .selectAll("."+ CLASSMARKERDEFAULT).attr("opacity", 1);
        }
      }
      if(hasDefaultSelection){
        defaultSelUtil.clearSelectionInfo(gSelection, false, elementArray);
      }
    };
    
    line.hoverOnPoint = function(point)
    {  
      var point0 = point.x, point1 = point.y;
      if(point0 < 0 || point0 > width){
        return;
      }

      var xIndex = getCategoryIndex(point0);
      if(preHighLightIndex === xIndex) { return; }
      var xCoord = xScale(xIndex) + xScale.rangeBand() / 2;
      changeGroupMarker(preHighLightIndex, "hidden", CLASSMARKERDEFAULT);
      changeGroupMarker(xIndex, "visible", CLASSMARKERHOVER);  

      preHighLightIndex = xIndex;


      if (props.hoverline.visible) {
        mouseMoveLine.attr("x1", xCoord).attr("x2", xCoord);
        mouseMoveLine.attr("visibility", "visible");
      } else {
        mouseMoveLine.attr("visibility", "hidden");
      }

      if (props.tooltip.enabled) {
        var pt = {};
        var matrix = g.node().getTransformToElement(g.node().ownerSVGElement);
        pt.x = xScale(xIndex) + xScale.rangeBand() / 2 + matrix.e;
        pt.y = height / 4 + matrix.f;
        //var globalPoint = pt.matrixTransform(g.node().parentNode.parentNode.getScreenCTM().inverse());
        //var tData = generateTooltipData(xIndex);
        //alex su
        var tData = _tooltipDataHandler.generateTooltipData(data_, 
               tooltipData, 
               xIndex, 
               colorPalette, 
               [props.marker.shape]);
        tData.point = pt;
        tData.plotArea = {
          x : matrix.e,
          y : matrix.f,
          width : width,
          height : height
        };
        eDispatch.showTooltip(TooltipDataHandler.formatTooltipData(tData));
      }

    };

    line.blurOut = function()
    {  
      mouseMoveLine.attr("visibility", "hidden");
      changeGroupMarker(preHighLightIndex, "hidden", CLASSMARKERDEFAULT);
      preHighLightIndex = null;
      if (props.tooltip.enabled) { 
        eDispatch.hideTooltip();
      }
    };
    
    line.destroy = function() {
      //don't simply set m_scale to null
      //we need clear the internal cached index and range
      if(valueAxis1Data.scale){
        valueAxis1Data.scale.domain([0,1]).range([0,1]);
      }
      if(valueAxis2Data.scale){
        valueAxis2Data.scale.domain([0,1]).range([0,1]);
      }
      if(xScale){
        xScale.domain([0,1]).range([0,1]);
      }
      valueAxis1Data.markers = null;
      valueAxis2Data.markers = null;
      valueAxis1Data.data = null;
      valueAxis2Data.data = null;
      
      //set null
      valueAxis1Data = null;
      valueAxis2Data = null;
      clipRect = null;
      data_ = null;
      xScale = null;
      tooltipData = null;
      g = null;
      gSelection = null;
      mouseMoveLine = null;
      svgLinesGroup = null;
      svgLightLinesGroup = null;
      svgMarkersGroup = null;
      
      //destroy ctx
      if(ctx){
        ctx.destroy();
        ctx = null;
      }
    };
    
    props = manifest.props(null);
    return line;
  };
  return ret;
});

define('sap/viz/feeds/XY',['sap/viz/feeds/Manifest','sap/viz/data/feed/Constants'],
function Setup(Manifest, constants) {
  var colorFeed = {
    'id' : 'regionColor',
    'name' : 'IDS_REGIONCOLOR',
    'type' : constants.Type.Dimension,
    'min' : 0,
    'max' : 2,
    'aaIndex' : 2,
    'acceptMND' : 1
  };

  var valueAxis1 = {
    'id' : 'primaryValues',
    'name' : 'IDS_PRIMARYVALUES',
    'type' : constants.Type.Measure,
    'min' : 1,
    'max' : constants.Constraints.INF,
    'mgIndex' : 1
  };

  var valueAxis2 = {
    'id' : 'secondaryValues',
    'name' : 'IDS_SECONDARYVALUES',
    'type' : constants.Type.Measure,
    'min' : 0,
    'max' : constants.Constraints.INF,
    'mgIndex' : 2
  };

  var dimension = {
    'id' : 'axisLabels',
    'name' : 'IDS_AXISLABELS',
    'type' : constants.Type.Dimension,
    'min' : 1,
    'max' : 2,
    'acceptMND' : 0,
    'aaIndex' : 1
  };

  var feeds = {
    id : "xy",
    feeds : [ colorFeed, dimension, valueAxis1, valueAxis2 ]
  };
  Manifest.register(feeds);
});
define('sap/viz/modules/manifests/xy/Base',['sap/viz/modules/manifests/Module','sap/viz/modules/Constants','sap/viz/feeds/XY'],
function Setup(Manifest, Constants) {
  var module = {
    'id' : 'sap.viz.modules.xy.base',
    'abstract' : true,
    'type' : Constants.Type.Chart,
    'name' : 'xy base module',
    'datastructure' : 'DATA STRUCTURE DOC',
    'properties' : {  
    'colorPalette':
      {
         'name' : 'colorPalette',
          'supportedValueType' : 'StringArray',
          'defaultValue' : Constants.COLOR.SAPColorSingleAxis,
          'description' : 'Set color palette for non-dual chart. Or dual chart\'s color palette when MND is not fed on legend color.',
          'example': "<a href='"+Constants.DocExample.SnippetUrl+"4449' target='_blank'>"+Constants.DocExample.TryThisValue+"</a>"
      },
        'primaryValuesColorPalette' : {
          'name' : 'primaryValuesColorPalette',
          'supportedValueType' : 'StringArray',
          'defaultValue' : Constants.COLOR.SAPColorDualAxis1,
          'description' : 'Set axis 1 color palette for dual chart.',
            'isExported' : true
        },  
        'secondaryValuesColorPalette' : {
          'name' : 'secondaryValuesColorPalette',
          'supportedValueType' : 'StringArray',
          'defaultValue' : Constants.COLOR.SAPColorDualAxis2,
          'description' : 'Set axis 2 color palette for dual chart.',
            'isExported' : true
        },
        'drawingEffect':{
          'name' : 'drawingEffect',
           'supportedValueType' : 'String',
            'supportedValues' : [ 'normal', 'glossy' ],
            'defaultValue' : 'normal',
            'description' : 'Set drawing effect of plotArea.',
            'isExported' : true
        },
    },
    'events' : {
      'initialized': Constants.Event.Initialized.desc,
      'selectData' : Constants.Event.SelectData.desc,
      'deselectData' : Constants.Event.DeSelectData.desc,
      'showTooltip' : Constants.Event.TooltipShow.desc,
      'hideTooltip' : Constants.Event.TooltipHide.desc
    },
    'feeds' : {
      id : "xy"
    },
    'css' : null,
    'configure' : null
  };

  Manifest.register(module);
});
define('sap/viz/modules/manifests/xy/Line',['sap/viz/modules/manifests/Module','sap/viz/modules/Constants','sap/viz/modules/line','sap/viz/modules/manifests/xy/Base'],
function Setup(Manifest,Constants,fn) {
  var module = {
    'id' : 'sap.viz.modules.line',
    'name' : 'line',
     base : 'sap.viz.modules.xy.base',
    'properties' : {
    'tooltip' : {
        'name' : 'tooltip',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'enabled' : {
            'name' : 'enabled',
            'supportedValueType' : 'Boolean',
            'defaultValue' : true,
            'description' : 'Set enabled/disabled tooltip.'
          }
        },
        'isExported' : false,
        'description' : 'Settings for tooltip related properties.'
      },
      'width' : {
        'name' : 'width',
        'supportedValueType' : 'PositiveInt',
        'defaultValue' : 2,
        'min' : '1',
        'max' : '7',
        'description' : 'Set width of line, range[1,7]. When beyond the range, the line width is default size 2.'
      },
      'animation' : {
          'name' : 'animation',
          'supportedValueType' : 'Object',
          'supportedValues' : {
            'dataLoading' : {
              'name' : 'dataLoading',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enable/disable data loading animation of plot area.'
            },
            'dataUpdating' : {
              'name' : 'dataUpdating',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enable/disable data updating animation of plot area.'
            },
            'resizing' : {
              'name' : 'resizing',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enable/disable resizing animation of plot area.'
            }
          },
          'description' : 'Settings for animation related properties.',
          'example': "<a href='"+Constants.DocExample.SnippetUrl+"8535' target='_blank'>"+Constants.DocExample.TryThisValue+"</a>"
     },
      'hoverline' : {
          'name' : 'hoverline',
          'supportedValueType' : 'Object',
          'description' : 'Settings for hoverline properties.',
          'supportedValues' : {
            'visible' : {
              'name' : 'visible',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set to enabled/disabled hoverline or not.',
            },
          },
      },
      'marker' : {
        'name' : 'marker',
      'description': 'Settings for marker/data point graphics',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'visible' : {
            'name' : 'visible',
            'supportedValueType' : 'Boolean',
            'defaultValue' : false,
            'description' : 'Set show marker or not.'
          },
          'shape' : {
            'name' : 'shape',
            'supportedValueType' : 'String',
        'supportedValues' : ['circle', 'diamond', 'triangleUp', 'triangleDown', 'triangleLeft', 'triangleRight', 'cross', 'intersection'],
            'defaultValue' : 'circle',
            'description' : 'Set marker shapes for chart.'
          },
          'size' : {
            'name' : 'size',
            'supportedValueType' : 'PositiveInt',
            'defaultValue' : "6",
            'min' : '4',
            'max' : '32',
            'description' : 'Set marker size of data point, range[4,32]. When beyond the range, the marker size is default size 6.'
          }
        }
      }
    },
    'css' : {     
      '.viz-plot-hoverline.v-hoverline': {
          'description' : 'Define style for hoverline in line.',
          'value' : {
            'stroke' : '#cccccc'
          }
      }
    },
    fn : fn
  };

  Manifest.register(module);
});
define('sap/viz/mvc/PanGestureDetector',['sap/viz/mvc/GestureDetector','sap/viz/base/Math'],
function Setup(GestureDetector, Math) {
	var ts = GestureDetector.TransitionState;
	var _distance = function(xy1, xy2) {
		var dx = xy1.x - xy2.x;
		var dy = xy1.y - xy2.y;
		return Math.sqrt(dx * dx + dy * dy);
	};
	/**
	 * This class defines detector for detecting Panning gesture. Panning
	 * gesture is detected when required number of fingers touch the screen and
	 * move a reasonable distance.
	 * 
	 * @name sap.viz.mvc.PanGestureDetector
	 * @class
	 * @augments sap.viz.mvc.GestureDetector
	 */
	var PanGestureDetector = GestureDetector.extend({
		constructor : function(touchesRequired) {
			this._touchesRequired = (touchesRequired > 0 && touchesRequired < 6) ? touchesRequired : 1;
			this._startXY = undefined;
			this._lastXY = undefined;
			this._currentXY = undefined;
			this._startWhen = 0;
			this._stopWhen = 0;
		},

		/**
		 * The number of touches required for tap to be detected.
		 * 
		 * @function
		 * @param {Number}
		 *            numOfTouches
		 * @returns {Number|this}
		 */
		touchesRequired : function(numOfTouches) {
			if (arguments.length) {
				this._touchesRequired = +numOfTouches;
				return this;
			}
			return this._touchesRequired;
		},

		doTouchBegin : function(touchStartEvent) {
			var currentNumOfTouches = this.totalTouches();
			if (currentNumOfTouches === this._touchesRequired && this.state === ts.Possible) {
				this._startWhen = this._stopWhen = touchStartEvent.timeStamp;
				this._startXY = this._lastXY = this._currentXY = this.globalLocOfTouchPoints();
				this.state = ts.Began;
			} else if (currentNumOfTouches > this._touchesRequired) {
				if (this.state === ts.Began || this.state === ts.Changed) {
					this._stopWhen = touchStartEvent.timeStamp;
					this._lastXY = this._currentXY;
					this._currentXY = this.globalLocOfTouchPoints();
					this.state = ts.Canceled;
				} else {
					this.state = ts.Failed;
				}
			}
		},
		doTouchMove : function(touchMoveEvent) {
			switch (this.state) {
			case ts.Began:
				if (_distance(this._startXY, this.globalLocOfTouchPoints()) > 10) {
					this._startWhen = this._stopWhen;
					this._stopWhen = touchMoveEvent.timeStamp;
					this._lastXY = this._currentXY;
					this._currentXY = this.globalLocOfTouchPoints();
					this.state = ts.Changed;
				}
				break;
			case ts.Changed:
				this._startWhen = this._stopWhen;
				this._stopWhen = touchMoveEvent.timeStamp;
				this._lastXY = this._currentXY;
				this._currentXY = this.globalLocOfTouchPoints();
				this.state = ts.Changed;
				break;
			}
		},
		doTouchEnd : function(touchEndEvent) {
			if ((this.state === ts.Began || this.state === ts.Changed)) {
				this._startWhen = this._stopWhen;
				this._stopWhen = touchEndEvent.timeStamp;
				this._lastXY = this._currentXY;
				this._currentXY = this.globalLocOfTouchPoints();
				this.state = ts.Ended;
			}
		},

		doTouchCancel : function(touchCancelEvent) {
			if (this.state === ts.Began || this.state === ts.Changed) {
				this._startWhen = this._stopWhen;
				this._stopWhen = touchCancelEvent.timeStamp;
				this._lastXY = this._currentXY;
				this._currentXY = this.globalLocOfTouchPoints();
				this.state = ts.Canceled;
			}
		},

		/**
		 * The current moving range in X,Y direction of the gesture
		 * 
		 * <pre>
		 * {
		 * 		x : ###,
		 * 		y : ###
		 * }
		 * </pre>
		 * 
		 * @name sap.viz.mvc.PanGestureDetector#rangeInXY
		 * @function
		 * @return {POINT}
		 */
		rangeInXY : function() {
			return {
				x : this._currentXY.x - this._startXY.x,
				y : this._currentXY.y - this._startXY.y
			};
		},

		/**
		 * The current moving velocity in X,Y direction of the gesture
		 * 
		 * <pre>
		 * {
		 * 		x : ###,
		 * 		y : ###
		 * }
		 * </pre>
		 * 
		 * @name sap.viz.mvc.PanGestureDetector#velocityInXY
		 * @function
		 * @return {POINT}
		 */
		velocityInXY : function() {
			var duration = this._stopWhen - this._startWhen;
			if (duration) {
				return {
					x : (this._currentXY.x - this._lastXY.x) / duration,
					y : (this._currentXY.y - this._lastXY.y) / duration
				};
			} else {
				return 0;
			}
		},
		reset : function() {
			this._super();
			this._startXY = undefined;
			this._lastXY = undefined;
			this._currentXY = undefined;
			this._startWhen = 0;
			this._stopWhen = 0;
		}
	});
	return PanGestureDetector;
});
define('sap/viz/modules/controller/touchmonitor',['sap/viz/modules/dispatch','sap/viz/mvc/TapGestureDetector','sap/viz/mvc/PanGestureDetector',
'sap/viz/mvc/GestureDetector'],
function Setup(dispatch, TapGestureDetector, PanGestureDetector,
        GestureDetector) {

    return function(manifest, ctx) {
        var gnode, props, originaltouchstartpoint, eventManager = ctx.eventManager;
        var d = dispatch('click', 'hover', 'lassostart', 'lassomove',
                'lassoend', 'mousedown', 'mouseup', 'mouseover', 'mouseout',
                'mouseleave');
        var oTapGestureDetector;
        var oPanGestureDetector;
        var status = 'hover';
        // mouse trigger
        var tm = function() {
            return tm;
        };

        tm.properties = function(_) {
            if (!arguments.length) {
                return props;
            }
            props = _;
            return tm;
        };

        tm.registerEvent = function(g) {
            if (oTapGestureDetector === undefined) {
                oTapGestureDetector = new TapGestureDetector();
                oTapGestureDetector.addGestureAction(tapHandler);
                oTapGestureDetector.enable(true);
                eventManager.addGestureDetector(oTapGestureDetector);
            }

            if (oPanGestureDetector === undefined) {
                oPanGestureDetector = new PanGestureDetector();
                oPanGestureDetector.addGestureAction(panHandler);
                oPanGestureDetector.enable(true);
                eventManager.addGestureDetector(oPanGestureDetector);
            }

            gnode = g.node();
            g.on('touchstart.monitor', touchstart).on('touchend.monitor',
                    touchend);
        };

        tm.dispatch = function(_) {
            if (!arguments.length) {
                return d;
            }
            d = _;
            return tm;
        };

        tm.destroy = function() {
          if(ctx){
            ctx.destroy();
            ctx = null;
          }
        };

                
        function isInTheArea(temptarget,classname){
            var result = false;
            
            if(temptarget){
                if (temptarget.tagName === 'svg'){
                    return false;
                }
                if(temptarget.getAttribute('class')){
                    if(temptarget.getAttribute('class').indexOf(" ")){
                      var class_array = temptarget.getAttribute('class').split(" ");
                      for(var i = 0;i < class_array.length;i++){
                        if(class_array[i] === classname){
                          result = true;
                          break;
                        }
                      }
                    }else if(temptarget.getAttribute('class') === classname){
                        result = true;
                    }
                } else {
                    result = isInTheArea(temptarget.parentNode,classname);
                }
                return result;
            }
        }
        
         function isEnableLasso(event) {
                var result = false;
                if (props.supportLassoEvent && (props.selectability.mode !== 'none' && props.selectability.mode !== 'single')) {    //illegal selectionModes would be treated as default value("multiple")
                    result = true;
                    if (props.selectability.lassoWithCtrlKey) {
                        var originalEvent = getCurrentEvent();
                        if (!originalEvent.ctrlKey) {
                            result = false;
                        }
                    }
                }
                return result;
            }
        
        var last_target=null;
        function tapHandler(go) {
            
            if (!isValid(getCurrentEvent())) {
                return;
            }
            
            if (!isAxisLabelArea(getCurrentEvent())) {
                var target = getCurrentEvent().target;
                if (target.tagName === 'text') {     
                    if (isInTheArea(target,'v-datalabel')) {
                        target = target.__data__.dataShape;
                    }
                }
              fireEvent('hover');

              fireEvent('mouseover', undefined, target);
                   
              if(isInTheArea(target,'v-m-plot') || isInTheArea(target,'v-datashapesgroup') || isInTheArea(target,'v-m-main')){
                  if(!isInTheArea(target,'v-datashape')){
                     if(last_target){
                      fireEvent('mouseout',undefined,last_target);
                     }
                  }
              }
          
            last_target=target;
            }
            
            fireEvent('click');
                                    
        }

        var islassoend = false, islassostart = false;
        function panHandler(go) {
            var target, containerBox, pointOnGesture, globalpointx, globalpointy;
            if (go.state === GestureDetector.TransitionState.Began) {
                target = document.elementFromPoint(
                        getCurrentEvent().changedTouches[0].clientX,
                        getCurrentEvent().changedTouches[0].clientY);
                if (isInMain(target) && isEnableLasso()) {
                    fireEvent('lassostart', originaltouchstartpoint);
                    status = 'lasso';
                    
                }

            } else if (go.state === GestureDetector.TransitionState.Changed) {
                containerBox = go.watchedComponent.container
                        .getBoundingClientRect(), pointOnGesture = go
                        .globalLocOfGesture();
                var gnodeBox = gnode
                        .getBoundingClientRect();
                globalpointx = pointOnGesture.x + containerBox.left, globalpointy = pointOnGesture.y + containerBox.top;

                target = document.elementFromPoint(globalpointx,
                        globalpointy);
                // If the gesture happened in the area of module, we fire lasso
                // move event, else fire lasso end event.
                if (isInMain(target) && status === 'lasso') {
                  islassostart = true;
                  fireEvent('lassomove', {
                        x : globalpointx,
                        y : globalpointy
                    });
                  
                } else {
                    if (!islassoend && status === 'lasso') {
                        fireEvent('lassoend');
                        // set lasso end to true, so that we can do not fire
                        // lasso end event.
                        islassoend = true;
                        status='hover';
                    }
                }

            } else {
              if( islassostart === true ){
                islassostart = false;
            if (islassoend) {
              islassoend = false;
            } else {
              target = document.elementFromPoint(
                  getCurrentEvent().changedTouches[0].clientX,
                  getCurrentEvent().changedTouches[0].clientY);
              if (!isInMain(target)) {
                  return;
              } else if (isTargetOnAxisLabel(target) && status === 'lasso') {  
                fireEvent('lassoend');
                status='hover';
                return;
              }
              containerBox = go.watchedComponent.container
                  .getBoundingClientRect(), pointOnGesture = go
                  .globalLocOfGesture();
              globalpointx = pointOnGesture.x + containerBox.left, globalpointy = pointOnGesture.y + containerBox.top;

              // fire lasso end event
              if (status === 'lasso') {
                  fireEvent('lassoend');
                  status='hover';
              }
             
              // fire hover event
              fireEvent('hover', {
                x : globalpointx,
                y : globalpointy
              });
              // fire mouse over event,we should figure out the target and
              // mouse point
              fireEvent('mouseover', {
                x : globalpointx,
                y : globalpointy
              }, target);

            }
              }
            }
        }

        function touchstart() {
            var originalEvent = getCurrentEvent();
            var touch = originalEvent.touches[0];
            originaltouchstartpoint = {
                x : touch.clientX,
                y : touch.clientY
            };

            if (isAxisLabelArea(originalEvent) && (props.selectability.mode !== 'none')) {
                fireEvent('mousedown');
            }
            return true;
        }

        function touchend() {
            if (isAxisLabelArea(getCurrentEvent()) && (props.selectability.mode !== 'none')) {
                        fireEvent('mouseup');
                        fireEvent('mouseout');
            }
        
        }

        //check the event end point whether locate in axis area
        function isTargetOnAxisLabel(target){
            var classname=target.getAttribute('class');
            var isInAxisLabelArea = false;
            if (classname && classname.indexOf('v-labelarea') >= 0)// find it
            {
                if (props.selectability.mode !== 'single') {
                    // do not have label selection in 'single'
                    isInAxisLabelArea = true;
                }
            }
            return isInAxisLabelArea;
        }
        
        function isAxisLabelArea(event) {
            var target = event.target, classname = target.getAttribute('class');
            var isInAxisLabelArea = false;
            if (classname && classname.indexOf('v-labelarea') >= 0)// find it
            {
                if (props.selectability.mode !== 'single') {
                    // do not have label selection in 'single'
                    isInAxisLabelArea = true;
                }
            }
            return isInAxisLabelArea;
        }

        function isInMain(node) {
            if(!node){
                if(status === 'lasso'){
                    fireEvent('lassoend');
                    status = 'hover';
                }
               return false;
            }
            var result = false;
            if (node.tagName === 'svg') {
                return false;
            } else {
                if (node === gnode) {
                    return true;
                }
                result = isInMain(node.parentNode);
            }
            return result;
        }

        function isValid(event) {
            return isInMain(event.target);
        }

        function getCurrentEvent() {
            if (d3.event) {
                return d3.event;
            } else {
                return window.event;
            }
        }

        function fireEvent(type, point, target) {
            var temppoint, temptarget;
            if (point) {
                temppoint = point;
            } else {
                temppoint = originaltouchstartpoint;
            }
            if (target) {
                temptarget = target;
            } else {
                temptarget = getCurrentEvent().target;
            }
            var tempEvent = {
                name : type,
                data : {
                    point : temppoint,
                    target : temptarget
                }
            };
            

            switch (type) {
            case 'mousedown':
                if (props.enableMouseDown) {
                    d.mousedown(tempEvent);
                }
                break;
            case 'mouseup':
                if (props.enableMouseUp) {
                    d.mouseup(tempEvent);
                }
                break;
            case 'mousemove':
                if (props.enableMouseMove) {
                    d.mousemove(tempEvent);
                }
                break;
            case 'mouseover':
                if (props.enableMouseOver) {
                    
                    d.mouseover(tempEvent);
                }
                break;
            case 'mouseout':
                if (props.enableMouseOut) {
                    d.mouseout(tempEvent);
                }
                break;
            case 'hover':
                if (props.enableHover) {
                    d.hover(tempEvent);
                }
                break;
            case 'lassostart':
                d.lassostart(tempEvent);
                break;
            case 'lassomove':
                d.lassomove(tempEvent);
                break;
            case 'lassoend':
                
                d.lassoend(tempEvent);
                break;
            case 'click':
                if (props.enableClick) {
                    d.click(tempEvent);
                }
                break;
            default:
                break;
            }
        }

        return tm;
    };
});
define('sap/viz/modules/controller/mousemonitor',['jquery','sap/viz/modules/dispatch', 'sap/viz/base/UADetector'],
function Setup($, dispatch, UADetector) {
    
    return function(manifest, ctx){
        var MIN_LASSO_DISTANCE = 3;
        var m,
            g,
            node,
            props,
            mousedownpoint = null,
            status = 'hover', // lasso, unknown
            eventManager = ctx.eventManager;
        var d = dispatch('click', 'hover', 'lassostart', 'lassomove', 'lassoend', 'mousedown', 'mouseup', 'mouseover', 'mouseout', 'mouseleave');

        //mouse trigger
        var mm = function(){
            return mm;
        };
        
        mm.module = function(_){
            if(!arguments.length){
                return m;
            }
            m = _; g = m.parent(); node = g.node();
            return mm;
        };
        
        mm.properties = function(_){
            if(!arguments.length){
                return props;
            }
            props = _;
            return mm;
        };
        
        mm.registerEvent = function(g){
            g.on('mousedown.monitor', mousedown, true)
             .on('mouseup.monitor', mouseup)
             .on('mousemove.monitor', mousemove)
             .on('mouseover.monitor', mouseover)
             .on('mouseout.monitor', mouseout);
            
            if( UADetector.isIE() ){
              g.on("mouseleave.monitor", function(){
                mouseleave(d3.event);
              });
            } else{
              $(g.node()).mouseleave(mouseleave);
            }
            
        };
        
        mm.destroy = function(g){
            g.on('mousedown.monitor', null)
             .on('mouseup.monitor', null)
             .on('mousemove.monitor', null)
             .on('mouseover.monitor', null)
             .on('mouseout.monitor', null);
            
            if( UADetector.isIE() ){
              g.on("mouseleave.monitor", null);
            } else {
              $(g.node()).unbind("mouseleave");
            }
            
            if(ctx){
              ctx.destroy();
              ctx = null;
            }
            
        };
        
        mm.dispatch = function(_){
            if(!arguments.length){
                return d;
            }
            d = _;
            return mm;
        };
              
        function mousedown(){
            //console.log('mousedown');
           var originalEvent = getCurrentEvent();
           if(originalEvent.which!==1){
               //return if current event not focus to left button
               return;
            }
            mousedownpoint = {
               x : originalEvent.clientX,
               y : originalEvent.clientY
           };
            status = 'unknown';
            
            fireEvent('mousedown');
            //As in geo chart, the drag feature is implemented by d3. we should stop propagation if starting lasso
            if( isEnableLasso()){
                stopEvent();
            }
         }
        
        function mousemove(){
            //console.log('mousemove');
            if (status === 'lasso') {
                fireEvent('lassomove');
            } else if (status === 'hover') {
                fireEvent('hover');
            } else {
                if (checkMouseDownUpDistance()) {
                    if (isEnableLasso()) {
                        fireEvent('lassostart', mousedownpoint);
                        status = 'lasso';
                        fireEvent('lassomove');
                     } else {
                        status = 'hover';
                        fireEvent('hover');
                    } 
                }
            }
        }
               
        function mouseup(){
            //console.log('mouseup');
            if (status === 'lasso') {
                //fire mouse over event as in bubble or pie chart, we should show tooltip when lasso end.
                fireEvent('mouseover');
                fireEvent('lassoend');
		// to fix BITVIZ1-362: when lasso end, if mouse over on datapoint, 
		//pie chart should show tooltip pointed the dadapoint no matter how many datapoints are selected
                if(isDatapointArea(getCurrentEvent())){
                    fireEvent('mouseover');
                }
              } else {
                if (!checkMouseDownUpDistance()){
                    fireEvent('click');
                }
            }
            mousedownpoint = null;
            status = 'hover';

            fireEvent('mouseup');
        }
        
        function mouseout(){
            //console.log('mouseout');
            if( status !== 'lasso'){
                fireEvent('mouseout');
            }
        }
        
        function mouseover() {
            //console.log('mouseover');
            if( status !== 'lasso'){
                fireEvent('mouseover');
            }
        }

        function mouseleave(evt){
            var point = {
                    clientX : evt.clientX,
                    clientY : evt.clientY
            };
            var target = evt.target;

            if (status === 'lasso'){
                fireEvent('lassoend', point, target);
                status = 'hover';
            }
            
            fireEvent('mouseleave', point, target);
        }
        
        function isDatapointArea(event){
            var target = event.target, classname = target.getAttribute('class');
            var isInAxisLabelArea = false;
            if (classname && classname.indexOf('v-datapoint') >= 0)// find it
            {
                    isInAxisLabelArea = true;
            }
            return isInAxisLabelArea;
        }
        
        function isEnableLasso(event) {
            var result = false;
            if (props.supportLassoEvent && (props.selectability.mode !== 'none' && props.selectability.mode !== 'single')) {    //illegal selectionModes would be treated as default value("multiple")
                result = true;
                if (props.selectability.lassoWithCtrlKey) {
                    var originalEvent = getCurrentEvent();
                    if (!originalEvent.ctrlKey) {
                        result = false;
                    }
                }
            }
            return result;
        }
        
        function distance(p1, p2) {
            return Math.sqrt((p1.x-p2.x)*(p1.x-p2.x) + (p1.y-p2.y)*(p1.y-p2.y));
        }

        function getCurrentEvent() {
            if (d3.event) {
                return d3.event;
            } else {
                return window.event;
            }
        }
        
        function checkMouseDownUpDistance() {
            var originalEvent = getCurrentEvent();
            var tmp = {
                    x : originalEvent.clientX,
                    y : originalEvent.clientY
                };
            if ((mousedownpoint !== null) && 
                (distance(mousedownpoint, tmp) < MIN_LASSO_DISTANCE)) {
                return false;
            } else {
                return true;
            }
        }

        function fireEvent(type, point, target) {
            var originalEvent = getCurrentEvent();
            var temppoint, temptarget;
            if (point) {
                temppoint = point;
            } else {
                temppoint = {
                       x : originalEvent.clientX,
                       y : originalEvent.clientY
                    };
            }
            if (target) {
                temptarget = target;
            } else {
                temptarget = originalEvent.target;
            }
            var tempEvent = {
                name: type,
                data : {
                    point : temppoint,
                    target : temptarget
                }
            };
            
            switch (type) {
            case 'mousedown':
                if (props.enableMouseDown) {
                    d.mousedown(tempEvent);
                }
                break;
            case 'mouseup':
                if (props.enableMouseUp) {
                    d.mouseup(tempEvent);
                }
                break;
            case 'mousemove':
                if (props.enableMouseMove) {
                    d.mousemove(tempEvent);
                }
                break;
            case 'mouseover':
                if (props.enableMouseOver) {
                    d.mouseover(tempEvent);
                }
                break;
            case 'mouseout':
                if (props.enableMouseOut) {
                    d.mouseout(tempEvent);
                }
                break;
            case 'hover':
                if (props.enableHover) {
                    d.hover(tempEvent);
                }
                break;
            case 'lassostart':
                d.lassostart(tempEvent); break;
            case 'lassomove':
                d.lassomove(tempEvent); break;
            case 'lassoend':
                d.lassoend(tempEvent); break;
            case 'click':
                if (props.enableClick) {
                    d.click(tempEvent);
                }
                break;
            case 'mouseleave' :
                d.mouseleave(tempEvent);
                break;
            default:
                break;
            }
        }
        
        function stopEvent(){
            if ( d3.event ) {
                d3.event.stopPropagation();
                d3.event.preventDefault();
            }
        }
        return mm;
    };
});
define('sap/viz/data/handler/RuntimeSelectionDataHandler',['sap/viz/base/utils/Objects'],

function Setup(Objects){
  
  var RuntimeSelectionDataHandler = {

    mgMapGen : function(data)
    {
        //var aaData = data.getAnalysisAxisDataByIdx();
        var meData = data.getMeasureValuesGroupDataByIdx();
        var numMG = meData.length;

        var mgMap = [];
        var i;

        for(i = 0; i < numMG; i++)
        {
            var item = {};
            item.measureValuesGroup = (meData[i].index + 1);
            mgMap.push(item);
        }
        return mgMap;
    },

    miMapGen : function(data)
    {
        var meData = data.getMeasureValuesGroupDataByIdx();
        var miMap = [];

        var k;
        var i;
        for(k = 0; k < meData.length; k++)
        {
            var inItem = [];
            for(i = 0; i < meData[k].values.length; i++)
            {
                var item = {};
                item.Measure = meData[k].values[i].col;
                inItem.push(item);
            }
            miMap[meData[k].index] = inItem;
        }
        return miMap;
    },

    mapGenHelper : function(data, mapIndex)
    {
        var aaData = data.getAnalysisAxisDataByIdx();
        //choose values
        var aaValues;
        var i;
        for(i = 0; i < aaData.length; i++)
        {
            if(aaData[i].index === mapIndex)
            {
                aaValues = aaData[i].values;
                break;
            }
        }

        //to figure out the size of dii map
        var mapLen = 0;
        if(aaValues && aaValues.length > 0)
        {
            for(i = 0; i < aaValues.length; i++)
            {
                if(aaValues[i].type !== "MND")
                {
                    mapLen = aaValues[i].rows.length;
                }
            }
        }

        var diiMap = [];
        if(aaValues && aaValues.length > 0)
        {
            var j;
            for(j = 0; j < mapLen; j++)
            {
                var item = {};
                for(i = 0; i < aaValues.length; i++)
                {
                    if(aaValues[i].type !== "MND")
                    {
                        item[aaValues[i].col.val] = aaValues[i].rows[j].val;
                    }
                }
                diiMap.push(item);
            }
        }

        return diiMap;
    },

    indexOfMND : function(data)
    {
        var indexMND = -1;
        var aaData = data.getAnalysisAxisDataByIdx();
        var i;
        for(i = 0; i < aaData.length; i++)
        {
            if( aaData[i].values[0] && aaData[i].values[0].type === "MND" &&
                aaData[i].values.length === 1)
            {
                indexMND = aaData[i].index;
                break;
            }
        }
        return indexMND;
    },


    diiA1MapGen : function(data)
    {
        var diiA1Index = 0;
        var indexMND = this.indexOfMND(data); 
        if(indexMND === 0)
        {
            diiA1Index = 1;
        }
        var diiA1Map = this.mapGenHelper(data, diiA1Index);//index is 0 based.
        return diiA1Map;
    },

    diiA2MapGen : function(data)
    {
        var diiA2Index = 1;
        var indexMND = this.indexOfMND(data);
        if(indexMND === 0 || indexMND === 1)
        {
            diiA2Index = 2;
        }
        var diiA2Map = this.mapGenHelper(data, diiA2Index);//index is 0 based.
        return diiA2Map;
    },

    ctxArrayToObjArray : function(data, dataItems)
    {
        //the function converts
        //[{"ctx":{"type":"Measure","path":{"mg":0,"mi":1,"dii_a1":0,"dii_a2":1}},"val":158}]
        //to
        //[{"GroupNum":"Group1","Product":"Car","Country":"USA","Year":"2002","measureValuesGroup":1,"Measure":"Revenue","value":158}]
        //and then to
        //final object
        //
        var ctxToObj = function(handler, data, context)
        {
            var objResArray = [];
            var k;
            for(k = 0; k < context.length; k++)
            {
                var ctx = context[k].ctx.path;
                var val = context[k].val;

                var objRes = {};
                //make a "user friendly" obj for the ctx
                var mgMap = handler.mgMapGen(data);
                var miMap = handler.miMapGen(data);
                var diiA1Map = handler.diiA1MapGen(data);
                var diiA2Map = handler.diiA2MapGen(data);

                if(diiA1Map.length >= 1)
                {
                    objRes = Objects.extend(true, objRes, diiA1Map[ctx.dii_a1]);
                }

                if(diiA2Map.length >= 1)
                {
                    objRes = Objects.extend(true, objRes, diiA2Map[ctx.dii_a2]);
                }

                if(mgMap.length >= 1)
                {
                    objRes = Objects.extend(true, objRes, mgMap[ctx.mg]);
                }

                if(miMap.length >= 1)
                {
                    objRes = Objects.extend(true, objRes, miMap[ctx.mg][ctx.mi]);
                }

                objRes.__value__ = val;
                objResArray.push(objRes);
            }
            return objResArray;
        };

        var i;
        var objArray = [];
        for(i = 0; i < dataItems.length; i++)
        {
            var obj = ctxToObj(this, data, dataItems[i]);
            objArray.push(obj);
        }

        var finalArray = this.objArrayToFinalArray(objArray);
        return finalArray;
    },

    oneObjItemToCtxArray : function(data, objItemArray)
    {
        //the function converts
        //[{"GroupNum":"Group1","Product":"Car","Country":"USA","Year":"2002","measureValuesGroup":1,"Measure":"Revenue","value":158}]
        //to
        //[{"ctx":{"type":"Measure","path":{"mg":0,"mi":1,"dii_a1":0,"dii_a2":1}},"val":158}]
        var i;
        var j;
        var k;
        if(!(objItemArray instanceof Array))
        {
            var item = objItemArray;
            objItemArray = [];
            objItemArray.push(item);
        }

        var objMatch = function(baseObj, userObj)
        {
            var isMatch = true;
            var prop;
            for(prop in baseObj)
            {
                if(baseObj.hasOwnProperty(prop))
                {
                    //check 
                    if(userObj[prop] !== undefined)
                    {
                        if(userObj[prop] !== baseObj[prop])
                        {
                            isMatch = false;
                            break;
                        }
                    }
                }
            }
            return isMatch;
        };

        var isInvalidObjItem = function(mapArray, objItem)
        {
            var itemMatch = function(mapItem, objItem)
            {
                //if the item match one of the prop/value pair
                //we think the item is valid.
                var isMatch = false;
                var prop;
                for(prop in objItem)
                {
                    if(objItem.hasOwnProperty(prop))
                    {
                        //check
                        if(mapItem[prop] === objItem[prop])
                        {
                            isMatch = true;
                            break;
                        }
                    }
                }
                return isMatch;
            };

            if(Object.keys(objItem).length === 0)
            {
                //objItem has nothing. 
                //But it means the original one has * items, and these items are deleted.
                //we should select all.
                return false;
            }
            
            //at least match one prop/value in mapArray
            var i;
            var j;
            var k;
            for(i = 0; i < mapArray.length; i++)
            {
                for(j = 0; j < mapArray[i].length; j++)
                {
                    if(mapArray[i][j] instanceof Array)
                    {
                        for(k = 0; k < mapArray[i][j].length; k++)
                        {
                            if(itemMatch(mapArray[i][j][k], objItem))
                            {
                                return false;
                            }
                        }
                    }
                    else
                    {
                        if(itemMatch(mapArray[i][j], objItem))
                        {
                            return false;
                        }
                    }
                }
            }

            return true;
        };

        var ctxResArray = [];
        
        var mgMap = this.mgMapGen(data);
        var miMap = this.miMapGen(data);
        var diiA1Map = this.diiA1MapGen(data);
        var diiA2Map = this.diiA2MapGen(data);

        var mapArray = [];
        mapArray.push(mgMap);
        mapArray.push(miMap);
        mapArray.push(diiA1Map);
        mapArray.push(diiA2Map);

        var isObjItemArrayInvalid = true;
        for(k = 0; k < objItemArray.length; k++)
        {
            var objItem = objItemArray[k];


            var ctxRes = [];
            var ctxItemCandidate = {"ctx":{"path":{"mg":null,"mi":null,"dii_a1":null,"dii_a2":null}}};

            //special check:
            //if users just write {"data":{"Product":"Truck"}}, we think all of other dimensions 
            //and measures are matched. However, if users write a object which does not match any of the 
            //map item, we think they want to select nothing, not everything.
            if(isInvalidObjItem(mapArray, objItem))
            {
                continue;
            }
            else
            {
                //if one item is valid, the array is valid
                isObjItemArrayInvalid = false;
            }

            //mg
            ctxItemCandidate.ctx.path.mg = [];
            if(objItem.measureValuesGroup)
            {
                ctxItemCandidate.ctx.path.mg.push(objItem.measureValuesGroup - 1);
            }
            else
            {
                var mgNum = mgMap.length;
                for(i = 0; i < mgNum; i++)
                {
                    ctxItemCandidate.ctx.path.mg.push(i);
                }
            }

            //mi
            ctxItemCandidate.ctx.path.mi = [];
            if(objItem.Measure === undefined)
            {
                if(miMap.length > 0)
                {
                    for(j = 0; j < miMap[0].length; j++)
                    {
                        ctxItemCandidate.ctx.path.mi.push(j);
                    }
                }
            }
            else
            {
                for(i = 0; i < miMap.length; i++)
                {
                    for(j = 0; j < miMap[i].length; j++)
                    {
                        if(miMap[i][j].Measure === objItem.Measure)
                        {
                            ctxItemCandidate.ctx.path.mi.push(j);
                        }
                    }
                }
            }
       
            //dii_a1
            ctxItemCandidate.ctx.path.dii_a1 = [];
            if(diiA1Map.length > 0)
            {
                for(i = 0; i < diiA1Map.length; i++)
                {
                    if(objMatch(diiA1Map[i], objItem))
                    {
                        ctxItemCandidate.ctx.path.dii_a1.push(i);
                    }
                }
            }
            else
            {
                ctxItemCandidate.ctx.path.dii_a1.push(null);
            }

            //dii_a2
            ctxItemCandidate.ctx.path.dii_a2 = [];
            if(diiA2Map.length)
            {
                for(i = 0; i < diiA2Map.length; i++)
                {
                    if(objMatch(diiA2Map[i], objItem))
                    {
                        ctxItemCandidate.ctx.path.dii_a2.push(i);
                    }
                }
            }
            else
            {
                ctxItemCandidate.ctx.path.dii_a2.push(null);
            }

            //value
            if(objItem.__value__ !== undefined)
            {
                ctxItemCandidate.val = objItem.__value__;
            }

            ctxRes = this.buildCtxArray(ctxItemCandidate);
            ctxResArray = ctxResArray.concat(ctxRes);
        }

        if(isObjItemArrayInvalid)
        {
            return undefined;
        }
        else
        {
            return ctxResArray;
        }
    },

    buildCtxArray : function(ctxItemCandidate)
    {
        var ctxRes = [];
        var i;
        var k;
        var item;
        //mg
        for(i = 0; i < ctxItemCandidate.ctx.path.mg.length; i++)
        {
            item = Objects.extend(true, {}, ctxItemCandidate);
            item.ctx.path.mg = ctxItemCandidate.ctx.path.mg[i];
            ctxRes.push(item);
        }

        //mi
        ctxItemCandidate = ctxRes;
        ctxRes = [];
        for(k = 0; k < ctxItemCandidate.length; k++)
        {
            for(i = 0; i < ctxItemCandidate[k].ctx.path.mi.length; i++)
            {
                item = Objects.extend(true, {}, ctxItemCandidate[k]);
                item.ctx.path.mi = ctxItemCandidate[k].ctx.path.mi[i];
                ctxRes.push(item);
            }
        }

        //dii_a1
        ctxItemCandidate = ctxRes;
        ctxRes = [];
        for(k = 0; k < ctxItemCandidate.length; k++)
        {
            for(i = 0; i < ctxItemCandidate[k].ctx.path.dii_a1.length; i++)
            {
                item = Objects.extend(true, {}, ctxItemCandidate[k]);
                item.ctx.path.dii_a1 = ctxItemCandidate[k].ctx.path.dii_a1[i];
                ctxRes.push(item);
            }
        }

        //dii_a2
        ctxItemCandidate = ctxRes;
        ctxRes = [];
        for(k = 0; k < ctxItemCandidate.length; k++)
        {
            if(ctxItemCandidate[k].ctx.path.dii_a2.length > 0)
            {
                for(i = 0; i < ctxItemCandidate[k].ctx.path.dii_a2.length; i++)
                {
                    item = Objects.extend(true, {}, ctxItemCandidate[k]);
                    item.ctx.path.dii_a2 = ctxItemCandidate[k].ctx.path.dii_a2[i];
                    ctxRes.push(item);
                }
            }
            else
            {
                item = Objects.extend(true, {}, ctxItemCandidate[k]);
                item.ctx.path.dii_a2 = 0;
                ctxRes.push(item);
            }
        }
        return ctxRes;
    },
        
    objArrayToCtxArray : function(data, objItems)
    {
        var objArray = this.finalArrayToObjArray(data, objItems);

        //convert objArray to ctx array. One objArray item may have 2 or more corresponding ctxItems. 
        var i;
        var ctxArray = [];
        for(i = 0; i < objArray.length; i++)
        {
            var ctxs = this.oneObjItemToCtxArray(data, objArray[i]);
            if(ctxs === undefined)
            {
                ctxArray = undefined;
                break;
            }
            ctxArray.push(ctxs);
        }
        return ctxArray;
    },

    objArrayToFinalArray : function(objArray)
    {
        //the source obj is created by the app, so every measure has a value.
        //and do not need "*" handling
        //the source:
        //[
        //    [{"Region":"North America","Company":"DL","measureValuesGroup":1,"Measure":"Revenue","value":13.2},
        //    {"Region":"North America","Company":"DL","measureValuesGroup":2,"Measure":"Number of Planes","value":119},
        //    {"Region":"North America","Company":"DL","measureValuesGroup":3,"Measure":"Number of Countries","value":18}],
        //
        //    [{"Region":"North America","Company":"UA","measureValuesGroup":1,"Measure":"Revenue","value":22.1},
        //    {"Region":"North America","Company":"UA","measureValuesGroup":2,"Measure":"Number of Planes","value":129},
        //    {"Region":"North America","Company":"UA","measureValuesGroup":3,"Measure":"Number of Countries","value":21}]
        //]
        //the target:
        //[
        //    {"Region":"North America","Company":"DL","Revenue":13.2,"Number of Planes":119,"Number of Countries":18},
        //    {"Region":"North America","Company":"UA","Revenue":22.1,"Number of Planes":129,"Number of Countries":21},
        //]

        //return objArray; //for debug.Do not delete this!
        var oneObjToFinal = function(oneDataPointObjArray)
        {
            var finalObj = {};
            var i;
            //build dimensions
            if(oneDataPointObjArray.length > 0)
            {
                var item = oneDataPointObjArray[0];
                var prop;
                for(prop in item)
                {
                    if(item.hasOwnProperty(prop))
                    {
                        if( prop !== "__value__" &&
                            prop !== "Measure" &&
                            prop !== "measureValuesGroup"
                          )
                        {
                            finalObj[prop] = item[prop];
                        }
                    }
                }
            }

            //build measures
            for(i = 0; i < oneDataPointObjArray.length; i++)
            {
                var measureName = oneDataPointObjArray[i].Measure;
                var measureValue = oneDataPointObjArray[i].__value__;
                finalObj[measureName] = measureValue;
            }
            return finalObj;
        };

        var i;
        var finalRe = [];
        for(i = 0; i < objArray.length; i++)
        {
            var item = oneObjToFinal(objArray[i]);
            finalRe.push(item);
        }
        return finalRe;
    },

    finalArrayToObjArray : function(data, finalArray)
    {
        //1 . the "*" for dimensions should be removed. 
        //2 . the "*" for measures should be changed.
        //3. measureValuesGroup should be added. 
        //the source:
        //[
        //    {"Region":"North America","Company":"DL","Revenue":13.2,"Number of Planes":119,"Number of Countries":18},
        //    {"Region":"North America","Company":"UA","Revenue":22.1,"Number of Planes":129,"Number of Countries":21},
        //]
        //the target:
        //[
        //    [{"Region":"North America","Company":"DL","measureValuesGroup":1,"Measure":"Revenue","value":13.2},
        //    {"Region":"North America","Company":"DL","measureValuesGroup":2,"Measure":"Number of Planes","value":119},
        //    {"Region":"North America","Company":"DL","measureValuesGroup":3,"Measure":"Number of Countries","value":18}],
        //
        //    [{"Region":"North America","Company":"UA","measureValuesGroup":1,"Measure":"Revenue","value":22.1},
        //    {"Region":"North America","Company":"UA","measureValuesGroup":2,"Measure":"Number of Planes","value":129},
        //    {"Region":"North America","Company":"UA","measureValuesGroup":3,"Measure":"Number of Countries","value":21}]
        //]

        //return finalArray; //for debug.Do not delete this!
        var miMap = this.miMapGen(data);

        var measureGroupNumber = function(prop)
        {
            var iFind = -1;
            var iGroup;
            for(iGroup = 0; iGroup < miMap.length; iGroup++)
            {
                var i;
                var groupItem = miMap[iGroup];
                for(i = 0; i < groupItem.length; i++)
                {
                    if(groupItem[i].Measure === prop)
                    {
                        iFind = iGroup;
                        break;
                    }
                }
            }
            return iFind;
        };

        var oneFinalToObj = function(item)
        {
            var i;
            var objArrayRe = [];
            var diiObj = {};
            var meGroups = [];
            //To figure out how many measure groups, and record all dimensions
            var prop;
            for(prop in item)
            {
                if(item.hasOwnProperty(prop))
                {
                    //check if the prop is a Measure name, 
                    //if it is, return measureGroupNumber
                    //or return -1;
                    var meGroupNum = measureGroupNumber(prop);
                    if(meGroupNum < 0)//dimansion
                    {
                        diiObj[prop] = item[prop];
                    }
                    else
                    {
                        var meItem = {};
                        meItem.measureValuesGroup = (meGroupNum + 1);
                        meItem.Measure = prop;
                        meItem.__value__ = item[prop];
                        meGroups.push(meItem);
                    }
                }
            }

            if(meGroups.length <= 0) //no measure
            {
                objArrayRe.push(diiObj);
            }
            else //extend measure array
            {
                for(i = 0; i < meGroups.length; i++)
                {
                    objArrayRe.push(Objects.extend(true, meGroups[i], diiObj));
                }
            }

            //remove all props which have "*" value
            for(i = 0; i < objArrayRe.length; i++)
            {
                var itemRe = objArrayRe[i];
                for(prop in itemRe)
                {
                    if(itemRe.hasOwnProperty(prop))
                    {
                        if(itemRe[prop] === "*")
                        {
                            delete itemRe[prop];
                        }
                    }
                }
            }

            return objArrayRe;
        };

        var i;
        var objRe = [];
        for(i = 0; i < finalArray.length; i++)
        {
            var item = oneFinalToObj(finalArray[i]);
            objRe.push(item);
        }
        return objRe;
    },

    buildCtxItems : function(DOMItems)
    {
        var dataItems = [];
        for(var i = 0; i < DOMItems.length; i++)
        {
            var oneDataPointItem = [];
            if(DOMItems[i].__data__.ctx instanceof Array)
            {
                //val is an array as well
                var j;
                for(j = 0; j < DOMItems[i].__data__.ctx.length; j++)
                {
                    if(DOMItems[i].__data__.ctx[j] !== null)
                    {
                        var oneCtxItem = {};
                        oneCtxItem.ctx = Objects.extend(true, {}, DOMItems[i].__data__.ctx[j]);
                        oneCtxItem.val = DOMItems[i].__data__.val[j];
                        oneDataPointItem.push(oneCtxItem);
                    }
                }
            }
            else
            {
                if(DOMItems[i].__data__.ctx !== null)
                {
                    var oneCtxItemS = {};
                    oneCtxItemS.ctx = Objects.extend(true, {}, DOMItems[i].__data__.ctx);
                    if( DOMItems[i].__data__.value !== undefined &&
                       (!(DOMItems[i].__data__.value instanceof Object)) && 
                       (!(DOMItems[i].__data__.value instanceof Array)))
                    {
                        oneCtxItemS.val = DOMItems[i].__data__.value;
                    }
                    else
                    {
                        oneCtxItemS.val = DOMItems[i].__data__.val;
                    }
                    oneDataPointItem.push(oneCtxItemS);
                }
            }

            dataItems.push(oneDataPointItem);
        }
        return dataItems;
    },

    buildInfoArray : function(DOMItems)
    {
        var dataItems = [];
        for(var i = 0; i < DOMItems.length; i++)
        {
            var oneDataPointItem = [];
            if(DOMItems[i].__data__.info instanceof Array)
            {
                //val is an array as well
                var j;
                for(j = 0; j < DOMItems[i].__data__.info.length; j++)
                {
                    if(DOMItems[i].__data__.info[j] !== null)
                    {
                        var oneInfoItem;
                        oneInfoItem = Objects.extend(true, {}, DOMItems[i].__data__.info[j]);
                    
                        //just return additionalData
                        if(oneInfoItem)
                        {
                            oneInfoItem = oneInfoItem.additionalData;
                        }
                        oneDataPointItem.push(oneInfoItem);
                    }
                }
            }
            else
            {
                if(DOMItems[i].__data__.info !== null)
                {
                    var oneInfoItemS;
                    oneInfoItemS = Objects.extend(true, {}, DOMItems[i].__data__.info);

                    //just return additionalData
                    if(oneInfoItemS)
                    {
                        oneInfoItemS = oneInfoItemS.additionalData;
                    }
                    oneDataPointItem.push(oneInfoItemS);
                }
            }

            dataItems.push(oneDataPointItem);
        }
        return dataItems;
    },

    //get/set interfaces
    getSelectedObjArray : function(data, DOMItems, withDataCtx, withInfo)
    {
        //returned obj array is like
        //[
        //  {
        //    data: {"key":"value",...}
        //    ctx: [{"mi":0, ...}, {...}, ...]
        //    info: [{obj},null,... }//optional
        //  },
        //
        //  {
        //    data: {"key":"value",...}
        //    ctx: [{"mi":0, ...}, {...}, ...]
        //    info: [{obj},null,... }//optional
        //  },
        //  ...
        //]
        //build dataArray
        var ctxItems = this.buildCtxItems(DOMItems);
        var dataArray = this.ctxArrayToObjArray(data, ctxItems);

        //build ctxArray
        var ctxArray = [];
        var i;
        var j;
        for(i = 0; i < ctxItems.length; i++)
        {
            var oneDataPointCtx = [];
            for(j = 0; j < ctxItems[i].length; j++)
            {
                var oneCtx = Objects.extend(true, {}, ctxItems[i][j].ctx.path);
                oneDataPointCtx.push(oneCtx);
            }
            ctxArray.push(oneDataPointCtx);
        }

        //buildInfoArray
        var infoArray = this.buildInfoArray(DOMItems);

        //merge to reArray
        var reArray = [];
        for(i = 0; i < dataArray.length; i++)
        {
            var item = {};
            item.data = dataArray[i];
            if(withDataCtx)
            {
                item.ctx = ctxArray[i];
            }
            if(withInfo)
            {
                item.info = infoArray[i];
            }
            reArray.push(item);
        }

        return reArray;
    },

    setSelectedObjArray : function(data, objItems)
    {
        //selection([...], clearFlag/*optional*/)
        //[
        //  {
        //    data: {"key":"value",...}
        //    ctx: [{"mi":0, ...}, {...}, ...]//!important 
        //  },
        //
        //  {
        //    data: {"key":"value",...}
        //    ctx: [{"mi":0, ...}, {...}, ...]//!important
        //  },
        //  ...
        //] 
        var ctxItems = [];
        var i;
        var j;

        var useCtx = false;//if there is ctx, ctx is !important
        //if objItems.length === 0, we thing it is legal (selection nothing).
        if(objItems === undefined || objItems === null){
          ctxItems = undefined;
        } else if(objItems.length > 0){
            if(objItems[0].ctx)
            {
                useCtx = true;
            }

            if(useCtx)
            {
                //build ctxItems from ctx
                for(i = 0; i < objItems.length; i++)
                {
                    var oneItem = [];
                    for(j = 0; j < objItems[i].ctx.length; j++)
                    {
                        var oneCtx = {};
                        oneCtx.ctx = {};
                        oneCtx.ctx.path = objItems[i].ctx[j];
                        oneItem.push(oneCtx);
                    }
                    ctxItems.push(oneItem);
                }
            }
            else
            {
                //build dataArray, and then convert it to ctxItems.
                var dataArray = [];
                for(i = 0; i < objItems.length; i++)
                {
                    if(objItems[i].data)
                    {
                        dataArray.push(objItems[i].data);
                    }
                }

                if(dataArray.length > 0)
                {
                    if(dataArray.length === 1 &&
                       Object.keys(dataArray[0]).length === 0)
                    {
                        //empty data
                        ctxItems = [];
                    }
                    else
                    {
                        ctxItems = RuntimeSelectionDataHandler.objArrayToCtxArray(data, dataArray);
                    }
                }
                else
                {
                    ctxItems = undefined;
                }
            }
        }

        return ctxItems;
    }

  };
  
  return RuntimeSelectionDataHandler;
});
define('sap/viz/modules/controller/interaction',['sap/viz/util/TextUtils','sap/viz/modules/dispatch','sap/viz/base/utils/TypeUtils','sap/viz/modules/Constants',
'sap/viz/base/utils/Objects','sap/viz/modules/controller/touchmonitor','sap/viz/modules/controller/mousemonitor',
'sap/viz/util/BoundingBox','sap/viz/base/utils/ObjectUtils',
'sap/viz/base/UADetector', 'sap/viz/data/handler/RuntimeSelectionDataHandler', 'sap/viz/base/utils/FunctionUtils'],
function Setup(TextUtils, dispatch, TypeUtils,Constants, Objects, TouchMonitor, MouseMonitor, BoundingBox, ObjectUtils, UADetector, RuntimeSelectionDataHandler, FunctionUtils) {
  var ret = function(manifest,ctx){
    
    var g = null, m, eventLayer = null; 
    var eDispatch = new dispatch('selectData', 'deselectData', 'deselectLegend');
    var props;
    var selectionMode = 'multiple', preserveSelectionWhenDragging = false, holdSelection = false;
    var defaultProps = {enableMouseUp:true, enableMouseDown:true, enableHover:true, enableClick:true};
    
    var lassoHelper, //a rect holder
        hitTestRect = {}, eFilter = '.v-datapoint';
    
    var plots = [], lastSelected = [], lastHovered = [], lastOvered = [],
        isRegister = false, mousedownPos = null, monitor;

    var m_lastSelectedItems = [];

    init();

    function init() {
        props = ObjectUtils.extend(true , defaultProps, manifest.props(null));
    
        if (UADetector.isMobile()){
          monitor = new TouchMonitor(manifest, ctx);
        }else{
          monitor = new MouseMonitor(manifest, ctx);
        }

        monitor.dispatch()
            .on('click', clickHandler)
            .on('hover', hoverHandler)
            .on('lassostart', lassoStartHandler)
            .on('lassomove', lassoMoveHandler)
            .on('lassoend', lassoEndHandler)
            .on('mousedown', mouseDownHandler)
            .on('mouseup', mouseUpHandler)
            .on('mouseover', mouseOverHandler)
            .on('mouseout', mouseOutHandler)
            .on('mouseleave', mouseLeaveHandler);
    }
    
    var reset = function(){
      isRegister = false;
      plots = [];
      lastSelected.splice(0, lastSelected.length);
      lastHovered.splice(0, lastHovered.length);
      lastOvered.splice(0, lastOvered.length);
      m_lastSelectedItems = [];
    };

    /*
     * alternative to mouse
     * reason: the result is incorrect in chrome/ie9 when browser zoom != 1
     */
    var mouse = function(point) {
      // geo needs to use eventLayer due to the fact that domElement will a bounding rect
      // that is greater than the viewport
      node = !eventLayer.empty() ? eventLayer.node() : g.node(), 
      rect = node.getBoundingClientRect(),
      x = point.x - rect.left,
      y = point.y - rect.top;

      return [ x, y ];
    };

    // return a bounding box for the provided node
    var getBoundingBox = function(node) {
      var rect = node.getBoundingClientRect();
      return { x: rect.left, y: rect.top, height: rect.height, width: rect.width, right : rect.right, bottom: rect.bottom };
    };
    //filter the selectees to see whether the shape intersect with hitTestRect. 
    var filter = function(selectees, hitTestRect, boundRect){
      var res = [];
      
      selectees.filter(function(d, m){
        var rect = getBoundingBox(this);
        if ( !boundRect.empty() ){
          var boundingrect = boundRect.node().getBoundingClientRect();
          
          rect.x = rect.x > boundingrect.left ? rect.x : boundingrect.left;
          rect.y = rect.y > boundingrect.top ? rect.y : boundingrect.top;
          rect.width = rect.right > boundingrect.right ? (boundingrect.right - rect.x) : (rect.right - rect.x);
          rect.height = rect.bottom > boundingrect.bottom ? (boundingrect.bottom - rect.y) : (rect.bottom - rect.y);
          
        }
        if(BoundingBox.intersects(rect , hitTestRect)){
          res.push(this);
        }
      });

      return res;
    };

    function lassoStartHandler(event) {
    
      //when touch too frequently on mobile, lassoHelper might be initialized by lassoStartHandler before removed by lassoEndHandler 
      //if lassoHelper has not been removed by lassoEndHandler before another lassoStart event fired, do it 
      if(lassoHelper){
           lassoHelper.remove();
      }
     
      startPos = mouse(event.data.point);
      
      lassoHelper = g.append('rect')
        .attr('x', startPos[0])
        .attr('y', startPos[1])
        .attr('width', 0)
        .attr('height', 0)
        .attr('pointer-events', 'none')
        .attr('fill', 'rgba(64,176,240, 0.4)')
        .style('stroke-width', '2px')
        .attr('stroke', 'rgb(64, 176, 240)');
    }
    function lassoMoveHandler(event) {
    var pos = mouse(event.data.point),
        x = Math.min(pos[0], startPos[0]),
        y = Math.min(pos[1], startPos[1]),
        width = Math.abs(pos[0] - startPos[0]), 
        height = Math.abs(pos[1] - startPos[1]);

      lassoHelper.attr('x', x).attr('y', y).attr('width', width).attr('height', height);
    }
    function lassoEndHandler(event) {
      var clientPoint = event.data.point;

      var bnode = lassoHelper.node(), 
          box = getBoundingBox(bnode), 
          bwidth = parseFloat(bnode.getAttribute('width')), 
          bheight = parseFloat(bnode.getAttribute('height')),
          selectedData = [], 
          deselectedData = [];

   // remove the lasso element after this function executes
      setTimeout(function() {
        lassoHelper.remove();
        lassoHelper = null;
        }, 0);
      
    
      if(bwidth || bheight){
        var plot, candidates, isInShape = false, selectees = null, selectedObj = [], 
            plotSubLayer = null,
            plotBox = null,
            intersectedBox = null;
        for(var i = 0, len= plots.length; i< len; i++) {
          plot = plots[i];
          candidates = null;

          if (TypeUtils.isFunction(plot.getDatapointsInRect)) {
            // if the plot supports this function, use it to retrieve datapoints within the 
            // bounds of the lasso element
            candidates = plot.getDatapointsInRect(lassoHelper.node());
          }
          else {
            // get a rectangle that represent the viewbox of the plot module
            plotSubLayer = plot.parent().select('rect.viz-event-sub-layer').node();

            // find the intersection of the plot rectangle with the lasso rectangle
            plotBox = plotSubLayer ? getBoundingBox(plotSubLayer) : null;
            intersectedBox = plotBox ? BoundingBox.intersection(plotBox, box) : box; // fall back to lasso rect if plot rectangle not available

            if (!intersectedBox) {
              // this is null if the lasso was not over the plot's area
              // no need to check datapoints for this plot
              continue;
            }

            selectees = plot.parent().selectAll('.v-datapoint');

            if(selectees[0].length > 0){
              candidates = filter( selectees , intersectedBox, plot.parent().select('.v-bound'));
            }
          }

          if(candidates && candidates.length > 0 ){
            selectedObj.push({
              plot: plot,
              selected: candidates
            });
          }
        }
        
        if(selectedObj.length > 0){
          if(lastSelected.length  == 0){
            unhighlightTarget(lastSelected, false);
            clearPlots(true);
          }
          
          //if the length of lastSelect is large than 0, it means that the chart is in highlight status, do not need to clear the chart to gray
          var plot = null, selected = null, isHighlight = false, lastSelectedBack = ObjectUtils.extend(true , [], lastSelected);
          for(var i=0, len= selectedObj.length; i < len; i++){
            plot = selectedObj[i].plot, selected = selectedObj[i].selected;
            for(var j=0, jlen = selected.length; j < jlen; j++){
              for(var t =0, tlen = lastSelectedBack.length; t < tlen; t++){
                if(selected[j] == lastSelectedBack[t]){
                  isHighlight = true;
                  break;
                }
              }
              
              //If the shape is not in queue of lastSelected
              //maybe we should deselect the shape which is already in highlight status, currently, do not need
              if(isHighlight){
                //lastSelected.splice((t - 1, 1));
                selectedData.push(selected[j]); // only fire the change the data
              }else{
                lastSelected.push(selected[j]);
                selectedData.push(selected[j]); // only fire the change the data
              }

              isHighlight = false;
            }
            //highlight selected shapes
            plot.highlight(selected, false, selectionMode, false);
          }
        }else{
          //there are no shapes selected
          if(lastSelected.length > 0){
            //if there are selected before, clear all
            unhighlightTarget(lastSelected, false);
            clearPlots();
          }
          
          deselectedData  = deselectedData.concat(lastSelected);
          lastSelected.splice(0, lastSelected.length);
        }
        
        //eDispatch.lassoEnd(candidates);
        if(selectedData.length > 0){
          fireSelectDataEvent(selectedData);
        }
        
        if(deselectedData.length >0){
          fireDeselectDataEvent(deselectedData);
        }
      }
    }

    var selection = function(){
      return selection;
    };
    
    var clearPlots  = function(_){
      for(var i = 0; i< plots.length; i++){
        if(plots[i].clear){
          plots[i].clear(_);
        }
      }
    };

    var pointInPlot = function(t, plot){
      var p, boundRect = plot.parent().select('.v-bound');
      if( !boundRect.empty() ){
        p =  boundRect.node().getBoundingClientRect();
      } else {
        p =  plot.parent()[0][0].getBoundingClientRect();
      }
      return (t.x >= p.left && t.x <= p.left + p.width && t.y >= p.top && t.y <= p.top + p.height);
    };

    // returns an array of the plot's parent nodes, in the same order as the "plots" array
    var getPlotNodes = function() {
      var nodes = [];
      for (var i = 0, len = plots.length; i < len; i++) {
        if (plots[i].parent()) {
          nodes.push(plots[i].parent().node());
        }
      }
      return nodes;
    };

    // returns the index of the plot (in the "plots" array) that contains the target element
    // nodes is optional and should contain the container elements for the plots
    var plotIndexContainingTarget = function(target, nodes) {
      var n = target,
        plotNodes = nodes || getPlotNodes(),
        idx;

      for (; n && n.ownerSVGElement; n = n.parentNode) {
        idx = plotNodes.indexOf(n);
        if (idx !== -1) {
          return idx;
        }
      }

      return -1;
    };

    // returns the plot module object that contains the target element
    var plotContainingTarget = function(target, nodes) {
      var plotIdx = plotIndexContainingTarget(target, nodes);

      if (plotIdx !== -1) {
        return plots[plotIdx];
      }

      return null;
    };

    // returns the input targets, organized by their parent plot
    // the result object is an array, with each entry corresponding to a plot in the "plot" array
    // each entry is an array of targets
    var groupTargetsByPlot = function(targets) {
      var plotNodes = getPlotNodes(),
          results = [];

      for (var i = 0, len = plots.length; i < len; i++) {
        results.push([]);
      }

      for (var i = 0, len = targets.length; i < len; i++) {
        var target = targets[i],
          idx = plotIndexContainingTarget(target, plotNodes),
          plotTargets;

        if (idx !== -1) {
          plotTargets = results[idx];
          plotTargets.push(target);
        }
        else {
          // log/throw error?
        }
      }

      return results;
    };

    var highlightTarget = function(target) {
      var plot = plotContainingTarget(target);
      if (plot && plot.highlight) {
        plot.highlight(target, selectionMode);
      }
    };
    
    // CTIsDatapoint means the current target is datapoint shape or not
    // target can be an array or a single element
    var unhighlightTarget = function(target, CTIsDatapoint) {
      var targets = TypeUtils.isArray(target) ? target : [ target ],
          targetsGroupedByPlot = groupTargetsByPlot(targets);

      for (var i = plots.length - 1; i >= 0; i--) {
        var plot = plots[i],
            plotTargets = targetsGroupedByPlot[i];

        if (plotTargets && plotTargets.length > 0 && plot.unhighlight) {
          plot.unhighlight(plotTargets, CTIsDatapoint);
        }
      }
    };

    var setLastSelectedItems = function(_lastSelectedItems)
    {
        m_lastSelectedItems = _lastSelectedItems;
    };

    var getLastSelectedItems = function()
    {
        return m_lastSelectedItems;
    };

    var ctxEqual = function(ctxA, ctxB)
    {
        var diiA1Equal = false;
        var diiA2Equal = false;
        var mgEqual = false;
        var miEqual = false;

        if( (ctxA.dii_a1 === null || ctxA.dii_a1 === undefined) ||
            (ctxB.dii_a1 === null || ctxB.dii_a1 === undefined) ||
            ctxA.dii_a1 === ctxB.dii_a1)
        {
            diiA1Equal = true;
        }

        if( (ctxA.dii_a2 === null || ctxA.dii_a2 === undefined) ||
            (ctxB.dii_a2 === null || ctxB.dii_a2 === undefined) ||
            ctxA.dii_a2 === ctxB.dii_a2)
        {
            diiA2Equal = true;
        }

        if( (ctxA.mg === null || ctxA.mg === undefined) ||
            (ctxB.mg === null || ctxB.mg === undefined) ||
            ctxA.mg === ctxB.mg)
        {
            mgEqual = true;
        }

        if( (ctxA.mi === null || ctxA.mi === undefined) ||
            (ctxB.mi === null || ctxB.mi === undefined) ||
            ctxA.mi === ctxB.mi)
        {
            miEqual = true;
        }

        return (diiA1Equal && diiA2Equal && mgEqual && miEqual);
    };

    var itemMatch = function(DOMItemCtx, itemsToCheck)
    {
        var k;
        var matchCheck = function(ctx, val, itemToCheck)
        {
            var isMatch = false;
            var isCtxMatch = false;
            var isValueMatch = false;
            if(ctxEqual(ctx.path, itemToCheck.ctx.path))
            {
                isCtxMatch = true;
                if(itemToCheck.val === undefined)
                {
                    isValueMatch = true;
                }
                else
                {
                    isValueMatch = Objects.equal(val, itemToCheck.val);
                }    
                isMatch = isCtxMatch && isValueMatch;
            }
            return isMatch;
        };

        var isMatch = false;
        if(DOMItemCtx.ctx instanceof Array)
        {
            var i;
            var matchedItemsToCheck = [];
            var matchedDOMItems = [];
            for(k = 0; k < itemsToCheck.length; k++)
            {
                //the ctx must match at least one item in itemsToCheck
                for(i = 0; i < DOMItemCtx.ctx.length; i++)
                {
                    if(DOMItemCtx.ctx[i] !== null && DOMItemCtx.ctx[i] !== undefined)
                    {
                        var isItemMatch = matchCheck(DOMItemCtx.ctx[i], DOMItemCtx.val[i], itemsToCheck[k]);
                        if(isItemMatch)
                        {
                            if(matchedItemsToCheck.indexOf(k) < 0)
                            {
                                matchedItemsToCheck.push(k);
                            }

                            if(matchedDOMItems.indexOf(i) < 0)
                            {
                                matchedDOMItems.push(i);
                            }
                        }
                    }
                    else
                    {
                        if(matchedDOMItems.indexOf(i) < 0)
                        {
                            matchedDOMItems.push(i);
                        }
                    }

                }
            }

            if(matchedItemsToCheck.length === itemsToCheck.length || 
               matchedDOMItems.length === DOMItemCtx.ctx.length)
            {
                isMatch = true;
            }
        }
        else
        {
            for(k = 0; k < itemsToCheck.length; k++)
            {
                if( DOMItemCtx.value !== undefined &&
                    (!(DOMItemCtx.value instanceof Object)) && 
                    (!(DOMItemCtx.value instanceof Array)))
                {
                    isMatch = matchCheck(DOMItemCtx.ctx, DOMItemCtx.value, itemsToCheck[k]);
                }
                else
                {
                    isMatch = matchCheck(DOMItemCtx.ctx, DOMItemCtx.val, itemsToCheck[k]);
                }
                if(isMatch)
                {
                    break;
                }  
            }            
        }

        return isMatch;
    };

    var selectDOMElementsInOnePlot = function(plot, items, clearFlag)
    {
        var addLastSelected = function(objs, DOMItem)
        {
            var i;
            var findIt = false;
            for(i = 0; i < objs.length; i++)
            {
                if(objs[i] === DOMItem)
                {
                    findIt = true;
                    break;
                }
            }

            if(!findIt)
            {
                objs.push(DOMItem);
            }
        };

        var selected = [];
        var deSelected = [];
        var i;
        var j;
        var DOMItems = plot.parent().selectAll('.v-datapoint')[0];
        for(i = 0; i < DOMItems.length; i++)
        {
            var isItemCtxMatch = false;

            var DOMItemCtx = DOMItems[i].__data__;
            for(j = 0; j < items.length; j++)
            {
                //Here is "OR". Matching any items[*] should be OK.
                if(itemMatch(DOMItemCtx, items[j]))
                {
                    isItemCtxMatch = true;
                    break;
                }
            }

            if(isItemCtxMatch)
            {
                addLastSelected(selected, DOMItems[i]);
            }

            var currentSelected = getLastSelectedItems();
            var itemSelectedIndex = currentSelected.indexOf(DOMItems[i]);

            if( clearFlag &&
                itemSelectedIndex >= 0 && 
                !isItemCtxMatch )
            {
                deSelected.push(DOMItems[i]);
            }
        }

        var reObj = {
            "selected" : selected, 
            "deSelected" : deSelected
        };

        return reObj;
    };
    
    var selectDOMElements = function(items, clearFlag)
    {
        var selected = [];
        var deSelected = [];

        var i;
        var j;
        var k;
        for(k=0; k < plots.length; k++)
        {
            var reObj;
            reObj = selectDOMElementsInOnePlot(plots[k], items, clearFlag);

            selected = selected.concat(reObj.selected);
            deSelected = deSelected.concat(reObj.deSelected);
        }

        //now check selected
        var isSelectionInvalid = false;
        if(selectionMode === 'none' && selected.length > 0)
        {
            isSelectionInvalid = true;
        }
        else if(selectionMode === 'single' && selected.length > 1)
        {
            isSelectionInvalid = true;
        }

        var returnVal;
        if(!isSelectionInvalid)
        {
            //merge all selected items, and update LastSelectedItems
            var lastSelecedItems = getLastSelectedItems();

            //update GUI firstly to clean all selected (for pie)
            unhighlightTarget(lastSelecedItems, false);

            if(!clearFlag)
            {
                for(i = 0; i < selected.length; i++)
                {
                    var findIt = false;
                    for(j = 0; j < lastSelecedItems.length; j++)
                    {
                        if(selected[i] === lastSelecedItems[j])
                        {
                            findIt = true;
                            break;
                        }
                    }

                    if(!findIt)
                    {
                        lastSelecedItems.push(selected[i]);
                    }
                }
            }
            else
            {
                lastSelecedItems = selected;
            }

            setLastSelectedItems(lastSelecedItems);

            //update GUI
            var lastSelected = lastSelecedItems;
            if(lastSelected.length <= 0)
            {
                clearPlots();
            }
            else
            {
                clearPlots(true);
                for(var iHi = 0; iHi < lastSelected.length; iHi++)
                {
                    var plot = plotContainingTarget(lastSelected[iHi]);
                    if (plot && plot.highlight)
                    {
                        plot.highlight(lastSelected[iHi], false, selectionMode);
                    }
                }
            }

            //events
            if(lastSelected.length > 0)
            {
                fireSelectDataEvent(lastSelected);
            }

            if(deSelected.length > 0)
            {
                fireDeselectDataEvent(deSelected);
            }

            returnVal = true;
        }
        else
        {
            FunctionUtils.error("Invalid selection in current selectionMode.");
            returnVal = false;
        }

        return returnVal;
    };
    
    selection.getSelectedDOMItems = function()
    {
        var DOMItems = getLastSelectedItems();
        return DOMItems;
    };

    selection.setSelectedItems = function(items, clearFlag)
    {
        var reVal = false;
        if(items !== undefined)
        {
            var dataItems = items;
            //update GUI and LastSelectedItems            
            reVal = selectDOMElements(dataItems, clearFlag);
        }
        return reVal;
    };
    
    selection.getSelectedObjects = function(data, withDataCtx, withInfo)
    {
        var DOMItems = this.getSelectedDOMItems();
        var reArray = RuntimeSelectionDataHandler.getSelectedObjArray(data, DOMItems, withDataCtx, withInfo);
        return reArray;
    };

    selection.setSelectedObjects = function(data, objItems, clearFlag)
    {
        var ctxItems = RuntimeSelectionDataHandler.setSelectedObjArray(data, objItems);
        return this.setSelectedItems(ctxItems, clearFlag);
    };
    
    selection.defaultSelection = function(){
      var info, selectDatas = [], selectedTargets = [];
      var singleSelection = false;
      lastSelected = getLastSelectedItems();
     // clearPlots(true);
      for(var k=0; k<plots.length; k++){
        var targets = plots[k].parent().selectAll('.v-datapoint')[0];
        for(var i=0; i< targets.length; i++){
          if(singleSelection || selectionMode === 'none'){
            break;
          }
          info = targets[i].__data__.info;
          if( info ){
            if(info instanceof Array){
              for(var j=0; j<info.length; j++){
                if(info[j] && info[j].defaultSelection && info[j].defaultSelection.isSelected){
                  if(selectionMode === 'single'){
                    if(info[j].defaultSelection.index === 0){
                      selectedTargets.push(targets[i]);
                      singleSelection = true;
                      break;
                    }
                  }else{
                    selectedTargets.push(targets[i]);
                  }
                }
              }
            }else if(info.defaultSelection && info.defaultSelection.isSelected){
              if(selectionMode === 'single'){
                if(info.defaultSelection.index === 0){
                  selectedTargets.push(targets[i]);
                  break;
                }
              }else{
                selectedTargets.push(targets[i]);
              }
            }
          }
        }
      }
      if(selectedTargets.length > 0){
        clearPlots(true);
      }
      
      for(i=0; i<selectedTargets.length; i++){
        var plot = plotContainingTarget(selectedTargets[i]);
        if (plot && plot.highlight)
        {
            plot.highlight(selectedTargets[i], false, selectionMode);
        }
        lastSelected.push(selectedTargets[i]);
        selectDatas.push(selectedTargets[i]);
      } 

      setLastSelectedItems(lastSelected);

      if(selectDatas.length > 0){
        fireSelectDataEvent(selectDatas);
      }
    };
    
    
    selection.registerEvent = function(){
      //TODO, [Ian] register event function will be called more than once as in multi chart, modules will fire more than one complete animation event.
      if(isRegister == false) {
        isRegister = true;
        monitor.registerEvent(g);

        var temp = m.modules();
        for(var i in temp){
          if(temp.hasOwnProperty(i) && !(temp[i] instanceof Array) && (i.indexOf('rotate')==-1) && temp[i].hasOwnProperty('parent') && temp[i].parent()){
            plots.push(temp[i]);
          }
        }
        
        if(!eventLayer){
          eventLayer = g.insert("rect", "g").attr("x", 0).attr("y", 0).attr("fill-opacity", 0);
        }
        eventLayer.attr("width", m.width()).attr("height", m.height());

        // if (preserveSelectionWhenDragging === true) {
          // g.on('mousedown.preserveSelectionWhenDragging', function() {
              // mousedownPos = d3.mouse(g.node());
            // }, true);
        // }
      } else {
        eventLayer.attr('width', m.width()).attr('height', m.height());

        for(var i=0, len =lastHovered.length; i<len; i++){
          if(lastHovered[i].blurOut){
            lastHovered[i].blurOut();
          }
        }
        lastHovered.splice(0, lastHovered.length);
        
        for(var i=0, len = lastOvered.length; i< len; i++){
          if(lastOvered[i].plot.mouseout){
            lastOvered[i].plot.mouseout();
          }
        }
        lastOvered.splice(0, lastOvered.length);
        
        if(holdSelection == false){
          lastSelected.splice(0, lastSelected.length);
          m_lastSelectedItems = [];
        }
      }
    };
    
    //[2012/09/11 Christy] Get selection mode for legend.
    selection.getSelectionMode = function(){
      return selectionMode;
    };
    
    //[2012/09/10 Christy] Legend is selected.  
    selection.highlightedByLegend = function(selectedData, isSelected){
      lastSelected = getLastSelectedItems();
      if(selectionMode === 'single' || selectionMode === 'none'){
        //Doesn't work in single mode.
        return;
      }
      if(selectedData.ctx === undefined){
        return;
      }
      var datapoints = [], itemData, isSame = true, ctxDatapoints = [], isDeselected = true, selectedObjs = [], selectDatas = [], deselectDatas = [], selectDatapoints = [], deselectDatapoints = [];
      for(var i = 0, len = plots.length; i < len; i++){
        //Reset datapoints arrary which contains selectedData ctx.
        ctxDatapoints = [];
        
        if(selectedData.ctx.ranges){
          //MBC legend
          if(plots[i].getDatapointsByRange){
            ctxDatapoints = plots[i].getDatapointsByRange(selectedData);
            selectedObjs.push({
              plot: plots[i],
              ctxDatapoints : ctxDatapoints
            });
          }
        } else { 
          if (plots[i].getDatapointsByLegend) {
            ctxDatapoints = plots[i].getDatapointsByLegend(selectedData);
            selectedObjs.push({
              plot: plots[i],
              ctxDatapoints : ctxDatapoints
            });
          } else {
            datapoints = plots[i].parent().selectAll('.v-datapoint')[0];
            
            for(var j = 0, jLen = datapoints.length; j < jLen; j++){
              if(datapoints[j].__data__ && datapoints[j].__data__.ctx){
                if(datapoints[j].__data__.ctx.path) {
                  itemData = datapoints[j].__data__.ctx.path;
                }else{
                  //Multi measures. For bubble or tagcloud.
                  itemData = datapoints[j].__data__.ctx[0].path;
                }
                
                //Check selectedData contains this ctx.
                isSame = true;
                for(var k in itemData){
                  if(selectedData.ctx.path[k] != undefined){
                    if(selectedData.ctx.path[k].length > 0){
                      if(_contains(selectedData.ctx.path[k], itemData[k]) === false){
                        isSame = false;
                      }
                    }else{
                      if(selectedData.ctx.path[k] !== itemData[k]){
                        isSame = false;
                      }
                    }
                  }
                }
                if(isSame === true){
                  //Push datapoint which has the same ctx with selectedData.
                  ctxDatapoints.push(datapoints[j]);
                }
              }
            }
          
            if(datapoints.length > 0){
              selectedObjs.push({
                plot: plots[i],
                ctxDatapoints : ctxDatapoints
              });
            }
          }
        }
      }

      //Deselected this series datapoint or not.
      if(lastSelected.length === 0){
        isDeselected = false;
      } else {
        var numOfDataPoints = 0;
        
        for(var i = 0, len = selectedObjs.length; i < len; i++){
          ctxDatapoints = selectedObjs[i].ctxDatapoints;
          var kLen = ctxDatapoints.length;
          numOfDataPoints += kLen;
          for(var k= 0; k < kLen; k++){
            if(_contains(lastSelected, ctxDatapoints[k]) === false){
              //One ctxDatapoint is not selected. Highlight this series datapoints.
              isDeselected = false;
              break;
            }
          }
        }
        if (isDeselected && !numOfDataPoints) {
          isDeselected = false;
        }
      }
      
      for(var i = 0, len = selectedObjs.length; i < len; i++){
        ctxDatapoints = selectedObjs[i].ctxDatapoints;  
        selectDatapoints = [], deselectDatapoints = [];
        for(var k= 0, kLen = ctxDatapoints.length; k < kLen; k++){
          var index = _contains(lastSelected, ctxDatapoints[k]);
          if(isDeselected){
            //deselected
            deselectDatapoints.push(ctxDatapoints[k]);
            lastSelected.splice(index, 1);
            deselectDatas.push(ctxDatapoints[k]);
          }else{
            //selected
            if(lastSelected.length == 0){
              clearPlots(true);
            }
            selectDatapoints.push(ctxDatapoints[k]);
            selectDatas.push(ctxDatapoints[k]);
            if(index === false){
              lastSelected.push(ctxDatapoints[k]);
            }
          }
        }
        
        //update highlight and unhighlight effect.
        if(deselectDatapoints.length > 0){
          selectedObjs[i].plot.unhighlight(deselectDatapoints, false, selectionMode);
        }
        if(selectDatapoints.length > 0){
          selectedObjs[i].plot.highlight(selectDatapoints, false, selectionMode, false);
        }
        
        if(isDeselected){
          //remove legend selected effect.
          eDispatch.deselectLegend(selectedData);
        }
        if(lastSelected.length === 0){
          clearPlots();
        }
      }

      setLastSelectedItems(lastSelected);

      //Send select/deselect event
      if(selectDatas.length > 0){
          fireSelectDataEvent(selectDatas);
        }
        
        if(deselectDatas.length > 0){
          fireDeselectDataEvent(deselectDatas);
        }
        
      return isDeselected;
    };
    
    //[2012/09/10 Christy] utility method.
    var _contains = function(a, obj){
      for (var i = 0; i < a.length; i++) {
            if (a[i] === obj) {
                return i;
            }
        }
        return false;
    };
    
    selection.dispatch = function(_){
      if(!arguments.length){
        return eDispatch;
      }
      eDispatch = _;
      return selection;
    };
    
    function hoverHandler(event) {
        //console.log('in hover of interaction');
      var target = event.data.target;
      var cp = event.data.point;
      var hoveredplots = [];
      for(var i =0, len = plots.length; i<len; i++){
        if(plots[i].parent() && pointInPlot(cp, plots[i])){
          hoveredplots.push(plots[i]);
        }
      }
      
      var isHovered = false;
      for(var i =0, len= lastHovered.length; i< len; i++){
        for(var j=0, jlen = hoveredplots.length; j< jlen; j++){
          if(lastHovered[i] == hoveredplots[j]){
            isHovered = true;
            break;
          }
        }
        if(isHovered == false && lastHovered[i].blurOut){
          lastHovered[i].blurOut();
        }
        isHovered = false;
      }
      
      for(var i=0, len= hoveredplots.length; i < len; i++){
        if(hoveredplots[i].hoverOnPoint){
            var rect = hoveredplots[i].parent().node().getBoundingClientRect();
            // var node = !eventLayer.empty() ? eventLayer.node() : g.node(), 
                // rect = node.getBoundingClientRect();
             hoveredplots[i].hoverOnPoint({
               x : cp.x - rect.left,
               y : cp.y - rect.top,
               target : target
             });
        }
      }
      
      lastHovered.splice(0, lastHovered.length);
      for(var i=0, len = hoveredplots.length; i<len;i++){
        lastHovered.push(hoveredplots[i]);
      }
    }

    
    function mouseOverHandler (event){
        var target = event.data.target, classname = target.getAttribute('class');
        if(isAxisLabelArea(classname) && (selectionMode !== 'none'))
        {
            //plot is the axis
            var plot = plotContainingTarget(target);
            if (plot && plot.mouseover)
            {
                plot.mouseover(target);
            }
        }
        else
        {
           if(classname != null && classname.indexOf('v-datalabel') != -1){
             target = target.__data__.dataShape;
           }else {
             target = isDatapoint(target);
             classname = target.getAttribute('class');
           }
           
           if(classname != null && (classname.indexOf('v-datapoint') != -1 || classname.indexOf('v-datalabel') != -1) ){
             
             var isHighlighted = false;
             for(var i=0, len = lastSelected.length; i < len; i++){
               if(target === lastSelected[i]){
                 isHighlighted = true;
                 break;
               }
             }
            
             if(lastSelected.length == 0 ){
              isHighlighted = true;
            }

            var plot = plotContainingTarget(target);
            if (plot) {
              lastOvered.push({
                   plot: plot,
                   target: target
                });

              if(plot.mouseover){
                plot.mouseover(target, isHighlighted);
              }
            }
           }
        }
    };
    
    function mouseOutHandler (event){
       var target = event.data.target, classname = target.getAttribute('class');
       if(isAxisLabelArea(classname) && (selectionMode !== 'none'))
       {
            //plot is the axis
            var plot = plotContainingTarget(target);
            if (plot && plot.mouseout)
            {
                plot.mouseout(target);
            }
       }
       else
       {
           if(classname != null && classname.indexOf('v-datalabel') != -1){
             target = target.__data__.dataShape;
           }else {
             target = isDatapoint(target);
             classname = target.getAttribute('class');
           }
     
           if(classname != null && (classname.indexOf('v-datapoint') != -1 || classname.indexOf('v-datalabel') != -1) ){
             
             var isHighlighted = false;
             for(var i=0, len = lastSelected.length; i < len; i++){
               if(target === lastSelected[i]){
                 isHighlighted = true;
                 break;
               }
             }
             
            if(lastSelected.length == 0 ){
              isHighlighted = true;
            }
             
            var plot = plotContainingTarget(target);

            for (var i = 0, len = lastOvered.length; i < len; i++) {
              var lastOver = lastOvered[i];

              // FIXME always invoke mouseout event handler on plot?
              if (lastOver.target === target/* && lastOver.plot === plot*/) {
                lastOvered.splice(i, 1);
                if (plot.mouseout) {
                  plot.mouseout(target, isHighlighted);
                }
                break;
              }
            }
           }
       }
    };

    function mouseDownHandler (event){
       var target = event.data.target, classname = target.getAttribute('class');
       if(isAxisLabelArea(classname) && (selectionMode !== 'none'))
       {
            //plot is the axis
            var plot = plotContainingTarget(target);
            if (plot && plot.mousedown)
            {
                plot.mousedown(target);
            }
       }
    }
    
    function mouseUpHandler (event) {
       var target = event.data.target, classname = target.getAttribute('class');
       //clean all label areas
       var iPlot;
       for(iPlot = 0; iPlot < plots.length; iPlot++)
       {
           if(plots[iPlot] && plots[iPlot].cleanLabelAreas)
           {
               plots[iPlot].cleanLabelAreas();
           }
       }       
       if(isAxisLabelArea(classname) && (selectionMode !== 'none'))
       {
            //plot is the axis
            var plot = plotContainingTarget(target);
            if (plot && plot.mouseup)
            {
                plot.mouseup(target);
            }
       }
    }
    
    var isDatapoint = function(node){
      if(node === g.node()){
        return node;
      }else{
        var classname = node.getAttribute('class');
        if(classname != null && classname.indexOf('v-datapoint') != -1){
          return node;
        }else{
          return isDatapoint(node.parentNode);
        }
      }
      
    };

    var diia1Match = function(labelCtxPath, dataPointCtxPath)
    {
        var isMatch = false;

        if(labelCtxPath.aa !== undefined)
        {
            if(labelCtxPath.aa === 0)
            {
                if(labelCtxPath.dii === dataPointCtxPath.dii_a1)
                {
                    isMatch = true;
                }
            }
            else
            {
                isMatch = true;
            }
        }
        else if(labelCtxPath.dii_a1 !== undefined)
        {
            if(labelCtxPath.dii_a1 === dataPointCtxPath.dii_a1)
            {
                isMatch = true;
            }
        }
        else
        {
            isMatch = true;
        }

        return isMatch;
    };

    var diia2Match = function(labelCtxPath, dataPointCtxPath)
    {
        var isMatch = false;

        if(labelCtxPath.aa !== undefined)
        {
            if(labelCtxPath.aa === 1)
            {
                if(labelCtxPath.dii === dataPointCtxPath.dii_a2)
                {
                    isMatch = true;
                }
            }
            else
            {
                isMatch = true;
            }
        }
        else if(labelCtxPath.dii_a2 !== undefined)
        {
            if(labelCtxPath.dii_a2 === dataPointCtxPath.dii_a2)
            {
                isMatch = true;
            }
        }
        else
        {
            isMatch = true;
        }

        return isMatch;
    };

    var mxMatch = function(labelMx, dataPointMx)
    {
        var isMatch = false;

        if(labelMx !== undefined)
        {
            if(labelMx === dataPointMx)
            {
                isMatch = true;
            }
        }
        else
        {
            isMatch = true;
        }

        return isMatch;
    };

    var ctxMatch = function(labelCtx, dataPointCtx)
    {
        var isMatch = false;
        
        if(labelCtx && dataPointCtx)
        {
            var labelCtxPath = labelCtx.path;
            var dataPointCtxPath = dataPointCtx.path;

            if(labelCtxPath !== undefined 
               && dataPointCtxPath !== undefined)
            {
                var isDiiA1Match = false;
                var isDiiA2Match = false;
                var isMgMatch = false;
                var isMiMatch = false;

                isDiiA1Match = diia1Match(labelCtxPath, dataPointCtxPath);
                if(isDiiA1Match)
                {
                    isDiiA2Match = diia2Match(labelCtxPath, dataPointCtxPath);
                    if(isDiiA2Match)
                    {
                        isMgMatch = mxMatch(labelCtxPath.mg, dataPointCtxPath.mg);
                        if(isMgMatch)
                        {
                            isMiMatch = mxMatch(labelCtxPath.mi, dataPointCtxPath.mi);
                            if(isMiMatch)
                            {
                                isMatch = true;
                            }
                        }
                    }
                }
            }
        }

        return isMatch;
    }
    
    var findTargets = function(labelContext, allPoints)
    {
        var targets = [];
        var i;
        var j;
        for(i = 0; i < allPoints.length; i++)
        {
            if(allPoints[i])
            {
                for(j = 0; j < allPoints[i].length; j++)
                {
                    if(allPoints[i][j].__data__.ctx instanceof Array)
                    {
                        var index;
                        for(index = 0; index < allPoints[i][j].__data__.ctx.length; index++)
                        {
                            if(ctxMatch(labelContext, allPoints[i][j].__data__.ctx[index]))
                            {
                                targets.push(allPoints[i][j]);
                                break;
                            }
                        }
                    }
                    else
                    {
                        if(ctxMatch(labelContext, allPoints[i][j].__data__.ctx))
                        {
                            targets.push(allPoints[i][j]);
                        }
                    }
                }
            }
        }    
        return targets;
    }

    //label selection functions
    var labelSelectedTargets = function(node)
    {
        var targets = [];
        if(node)
        {
            var allPoints = [];
            var i;    
            //plot is the axis
            var axisPlot = plotContainingTarget(node);
            var singleChart = axisPlot.parent().node().parentNode;

            allPoints = d3.select(singleChart).selectAll('.v-datapoint');


            var labelContexts = node.labelContexts;
            //find it
            if(labelContexts && labelContexts.length > 0)
            {
                for(i = 0; i < labelContexts.length; i++)
                {
                    if(labelContexts[i])
                    {
                        var tempTargets;
                        tempTargets = findTargets(labelContexts[i], allPoints);
                        targets = targets.concat(tempTargets);
                    }
                }
            }
        }
        //remove duplicate items in targets
        var targetsToReturn = [];
        var m;
        var n;
        for(m = 0; m < targets.length; m++)
        {
            var isFind = false;
            for(n = 0; n < targetsToReturn.length; n++)
            {
                if(targets[m] === targetsToReturn[n])
                {
                    isFind = true;
                    break;
                }
            }
            if(!isFind)
            {
                targetsToReturn.push(targets[m]);
            }
        }

        return targetsToReturn;
    };

    //handle label selection
    var selectMultiObjs = function(selectedTargets, lastSelected)
    {
        var returnObj = {};
        returnObj.lastSelectedObjs = [];
        returnObj.selectObjs = [];
        returnObj.deselectObjs = [];
        
        var isAllTargetsSelected = true;
        var unselectedTargets = [];

        for(var iTarget = 0; iTarget < selectedTargets.length; iTarget++)
        {
            var isSelected = false;
            for(var iLastSelected = 0; iLastSelected < lastSelected.length; iLastSelected++)
            {
                if(selectedTargets[iTarget] === lastSelected[iLastSelected])
                {
                    isSelected = true;
                    break;
                }
            }
            if(!isSelected)
            {
                isAllTargetsSelected = false;
                unselectedTargets.push(selectedTargets[iTarget]);
            }
        }

        //if all the selectedTargets are already selected, we should deselect them all
        if(isAllTargetsSelected)
        {
            //build deselected objects
            returnObj.deselectObjs = selectedTargets;
            //build selected objects
            returnObj.selectObjs = [];
            for(var iLastSelected = 0; iLastSelected < lastSelected.length; iLastSelected++)
            {
                var isTarget = false;
                for(var iTarget = 0; iTarget < selectedTargets.length; iTarget++)
                {
                    if(lastSelected[iLastSelected] === selectedTargets[iTarget])
                    {
                        isTarget = true;
                        break;
                    }
                }
                if(!isTarget)
                {
                    returnObj.lastSelectedObjs.push(lastSelected[iLastSelected]);
                }
            }
        }
        else//we should select all "selectedTargets"
        {
            //build selected objects
            returnObj.selectObjs = selectedTargets;
            returnObj.deselectObjs = [];
            //build selected objects
            returnObj.lastSelectedObjs = unselectedTargets.concat(lastSelected);
        }
        //update UI
        for(var iHi = 0; iHi < returnObj.deselectObjs.length; iHi++)
        {
            unhighlightTarget(returnObj.deselectObjs[iHi],false);
        }

        //if all the itemas are unselected, we have to highlight them all
        if(returnObj.lastSelectedObjs.length <= 0)
        {
            clearPlots();
        }
        else
        {
            clearPlots(true);
            for(var iHi = 0; iHi < returnObj.lastSelectedObjs.length; iHi++)
            {
                var plot = plotContainingTarget(returnObj.lastSelectedObjs[iHi]);
                if (plot && plot.highlight)
                {
                    plot.highlight(returnObj.lastSelectedObjs[iHi], false, selectionMode, false);
                }
            }
        }

        return returnObj;
    };

    var isAxisLabelArea = function(classname)
    {
        var isInAxisLabelArea = false;
        if(classname && classname.indexOf('v-labelarea') >= 0)//find it
        {
          if(selectionMode !== 'single')
          {
              //do not have label selection in 'single'
              isInAxisLabelArea = true;
          }
        }
        return isInAxisLabelArea;
    };

    function findTargetByDatalabel (node){
        if(node === g.node()){
          return node;
        }else{
          var classname = node.getAttribute('class');
          if(classname != null && classname.indexOf('v-datalabel') != -1){
            return node;
          }else{
            return findTargetByDatalabel(node.parentNode);
          }
        }
    }
    function clickHandler(event) {
        //console.log("in highlightHandler of interaction");
      lastSelected = getLastSelectedItems();
       
      if(selectionMode !== 'none'){
          
          var target = event.data.target,  classname = target.getAttribute('class'), selectDatas = [], deselectDatas = [];
          var isInAxisLabelArea = isAxisLabelArea(classname);
          
          if(!isInAxisLabelArea){
              var node = findTargetByDatalabel(target);
              classname =  node.getAttribute('class');
              
              if( classname != null && classname.indexOf('v-datalabel') != -1) {
                  target = target.__data__.dataShape;
                  classname = target.getAttribute('class');
                }else {
                  target = isDatapoint(target);
                  classname = target.getAttribute('class');
                }
          }
          
          if(isInAxisLabelArea )
          { 
              var selectedTargets = labelSelectedTargets(target);
              var res = selectMultiObjs(selectedTargets, lastSelected);
            
              //shoue update lastSelected, selectDatas, deselectDatas
              lastSelected = res.lastSelectedObjs;
              selectDatas = res.selectObjs;
              deselectDatas = res.deselectObjs;
          }
          
            //if  the click is on eventLayer, deselect all
          else if( classname == null || 
             (classname.indexOf('v-datapoint') == -1 && classname.indexOf('v-datalabel') == -1) ) 
          {
            unhighlightTarget(lastSelected, false);

            clearPlots();
            deselectDatas = deselectDatas.concat(lastSelected);
            lastSelected.splice(0, lastSelected.length);
            
            //[2012/09/11 Christy] deselect all legend items.
            eDispatch.deselectLegend();
          }
          else
          {
            var isHighlighted = false;
            for(var i =0, len = lastSelected.length; i<len; i++){
              if(target == lastSelected[i]){
                isHighlighted = true;
                break;
              }
            }
            if(lastSelected.length == 0) { //it means the isHighlighted false
              
              clearPlots(true);
              highlightTarget(target);
              lastSelected.push(target);
              
              selectDatas.push(target);
            } else {
              if(isHighlighted){
                if(selectionMode == 'single'){
                  unhighlightTarget(lastSelected[0]);
                  
                  clearPlots();
                  lastSelected.splice(0, lastSelected.length);
                  
                  deselectDatas.push(target);
                }else{
                  var changeSelected = lastSelected.splice((i),1);
                  deselectDatas = deselectDatas.concat(changeSelected);
                  
                  if(lastSelected.length == 0){
                    unhighlightTarget(target);
                    clearPlots();
                  }else{
                    unhighlightTarget(target);
                  //  deselectDatas.push(target);
                  }
                }
              } else {
                if(selectionMode == 'single'){
                  unhighlightTarget(lastSelected[0], false);
                  deselectDatas.push(lastSelected[0]);
                  
                  highlightTarget(target);
                  selectDatas.push(target);
                  
                  lastSelected[0] = target;
                }else{
                  
                  selectDatas.push(target);
                  highlightTarget(target);
                  
                  lastSelected.push(target);
                }
              }
            }
          }

          setLastSelectedItems(lastSelected);
          
          if(selectDatas.length > 0){
            fireSelectDataEvent(selectDatas);
          }
          
          if(deselectDatas.length > 0){
            fireDeselectDataEvent(deselectDatas);
          }
        }
    }
    
    function mouseLeaveHandler(evt){
        //clean all label areas
        var iPlot;
        for(iPlot = 0; iPlot < plots.length; iPlot++)
        {
           if(plots[iPlot] && plots[iPlot].cleanLabelAreas)
           {
               plots[iPlot].cleanLabelAreas();
           }
        }    
        for(var i=0, len = lastHovered.length; i <len; i++){
          if(lastHovered[i].blurOut){
            lastHovered[i].blurOut();
          }
        }
          
        lastHovered.splice(0, lastHovered.length);

        //clear lastOvered effect
        for(var i =0, len = lastOvered.length; i< len;i++){
          if(lastOvered[i].plot.mouseout){
            lastOvered[i].plot.mouseout(lastOvered[i].target, true);
          }
        }
        
        lastOvered.splice(0, lastOvered.length);
    }
    
    function fireSelectDataEvent(selectedShapes){
      var selectData = [];
      for(var i=0, len= selectedShapes.length; i < len; i++){
        var tarData = [], value = selectedShapes[i].__data__;
        if(value.val instanceof Array){
          for(var j=0, jlen= value.val.length; j< jlen; j++ ){
            tarData.push({
              val: value.val[j],
              ctx: value.ctx[j]
            });
          }
        }else{
          tarData.push({
            val: selectedShapes[i].__data__.val,
            ctx: selectedShapes[i].__data__.ctx
          });
        }
        selectData.push({
          target: selectedShapes[i],
          data: tarData
        });
      }
      
      eDispatch.selectData({
        name: Constants.Event.SelectData.name,
        data: selectData
      });
    };
    
    function fireDeselectDataEvent(deselectShapes){
      var deselectData = [];
      for(var i=0, len= deselectShapes.length; i < len; i++){
        var tarData = [], value = deselectShapes[i].__data__;
        if(value.val instanceof Array){
          for(var j=0, jlen=value.val.length; j< jlen; j++ ){
            tarData.push({
              val: value.val[j],
              ctx: value.ctx[j]
            });
          }
        }else{
          tarData.push({
            val: deselectShapes[i].__data__.val,
            ctx: deselectShapes[i].__data__.ctx
          });
        }
        deselectData.push({
          target: deselectShapes[i],
          data: tarData
        });
      }
      
      eDispatch.deselectData({
        name: Constants.Event.DeSelectData.name,
        data: deselectData
      });
    };
    
    function parseOptions(){
      selectionMode = props.selectability.mode;
      if(selectionMode!='none'&&selectionMode!='single'&&selectionMode!='multiple'){
           selectionMode = 'multiple';
      }
      holdSelection = props.holdSelection;
      preserveSelectionWhenDragging = props.preserveSelectionWhenDragging;

    }
    selection.properties = function(_){
      if(!arguments.length){
        return props;
      }
      
      //FIXME: As selection module didn't be executed, so append deselect event here. 
      //Clear selection info when updating properties
      var selectedItems = getLastSelectedItems();
      if( selectedItems.length > 0){
        fireDeselectDataEvent(selectedItems);
      }
      setLastSelectedItems([]);
      
      Objects.extend(true, props, _);
      parseOptions();
      if (monitor) {
        monitor.properties(props);
      }
    };
    
    selection.module = function(_){
      if(!arguments.length){
        return m;
      }
      reset();//clear flag to have another chance to register event
      m = _, g = m.parent();
      return selection;
    };
    
    selection.destroy = function(){
      reset();
      if(monitor){
        monitor.dispatch()
            .on('click', null)
            .on('hover', null)
            .on('lassostart', null)
            .on('lassomove', null)
            .on('lassoend', null)
            .on('mousedown', null)
            .on('mouseup', null)
            .on('mouseover', null)
            .on('mouseout', null)
            .on('mouseleave', null);
        monitor.destroy(g);  
      }
      g = null;
      m = null;
      eventLayer = null;
      //destroy ctx
      if(ctx){
        ctx.destroy();
        ctx = null;
      }      
    };
    
    return selection;
  };
  return ret;
});

define('sap/viz/modules/manifests/controller/Base',['sap/viz/modules/manifests/Module','sap/viz/modules/Constants'],
function Setup(Manifest, Constants) {
  var module = {
    'id' : 'sap.viz.modules.controller.base',
    'abstract' : true,
    'type' : Constants.Type.Controller,
    'renderto' : Constants.RenderTo.NONE,
    'name' : 'controller base module',
    'properties' : null,
    'events' : null,
    'feeds' : null
  };

  Manifest.register(module);
});
define('sap/viz/modules/manifests/controller/Interaction',['sap/viz/modules/manifests/Module','sap/viz/modules/Constants','sap/viz/modules/controller/interaction','sap/viz/modules/manifests/controller/Base'],
function Setup(Manifest, Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.controller.interaction',
    'name' : 'selection',
    'base' : "sap.viz.modules.controller.base",
    'description': 'Settings for the interactions of the chart.',
    'properties' : {
      'selectability' : {
        'name' : 'selectability',
        'supportedValueType': 'Object',
        'supportedValues': {
          mode: {
             'name' : 'mode',
            'supportedValueType' : 'String',
            'supportedValues' : [ 'single', 'multiple', 'none' ],
            'defaultValue' : 'multiple',
            'description' : 'Set the selection mode. Single means you only can select one at the same time. Multiple means you can select several ones. None means you can not select anything. ',
            'example': "<a href='"+Constants.DocExample.SnippetUrl+"8756' target='_blank'>"+Constants.DocExample.TryThisValue+"</a>"
          },
          lassoWithCtrlKey: {
            name:"lassoWithCtrlKey",
            supportedValueType:"Boolean",
            defaultValue: false,
            description: "Set whether lasso selection needs ctrl key pressed.",
            isExported: false
          }
        },
        'description': 'Settings for selectability.'
      },
      supportedEventNames:{
        name: "supportedEventNames",
        supportedValueType: "StringArray",
        supportedValues: ['mouseup','mousedown','mousemove','mouseout','mouseover','touchstart'],
        defaultValue:['mouseup', 'mousedown', 'mousemove', 'mouseout', 'mouseover','touchstart'],
        description: "Set supported event names.",
        isExported: false
      },
      enableMouseMove:{
        name: "enableMouseMove",
        supportedValueType: "Boolean",
        defaultValue:true,
        description: "Set whether mouse move is enabled.",
        isExported: false
     },
      enableMouseOver:{
        name: "enableMouseOver",
        supportedValueType: "Boolean",
        defaultValue:true,
        description: "Set whether mouse over is enabled.",
        isExported: false
      },
      enableMouseOut:{
        name: "enableMouseOut",
        supportedValueType: "Boolean",
        defaultValue:true,
        description: "Set whether mouse out is enabled.",
        isExported: false
      },
      supportLassoEvent:{
        name: "supportLassoEvent",
        supportedValueType: "Boolean",
        defaultValue:true,
        description: "Set whether support lasso event is enabled.",
        isExported: false
      },
      holdSelection:{
        name: "holdSelection",
        supportedValueType: "Boolean",
        defaultValue:false,
        description: "Set whether hold selection is enabled.",
        isExported: false
      },
      preserveSelectionWhenDragging:{
        name: "preserveSelectionWhenDragging",
        supportedValueType: "Boolean",
        defaultValue:false,
        description: "Set whether preserve selection when dragging is enabled.",
        isExported: false
      }
    },
    'fn' : fn
  };

  Manifest.register(module);
});
define('sap/viz/manifests/MultiLineChart',['sap/viz/manifests/Viz','sap/viz/manifests/BaseChart','sap/viz/modules/manifests/XYContainer',
'sap/viz/modules/manifests/TableContainer','sap/viz/modules/manifests/Axis',
'sap/viz/modules/manifests/xy/Line','sap/viz/manifests/BaseMultipleChart','sap/viz/manifests/BaseMultipleXYChart',
'sap/viz/modules/manifests/controller/Interaction'],
function Setup(Manifest) {
  var multiBarChart = {
    id : 'viz/multi_line',
    name : 'IDS_MULTILINECHART',
    base : 'riv/base/multiple/xy',
    modules : {
      root : {
        modules : {
          legends : {
            modules : {              
              legend : {
                data : { aa : [ 3 ] }
              }
            }
          },
          tooltip : {
            configure : {
              properties : {
                chartType : 'line',
                orientation : 'left'
              }
            }
          },
        
          interaction : {
            id : 'sap.viz.modules.controller.interaction',
            configure : {
              clientID : 'main',
              propertyCategory : 'interaction'
            }
          },
        
          main : {
            configure : {
              properties : { 'mergeDataRange' : ['primary'] }
            },

            modules: {
              plot : {
                id : 'sap.viz.modules.xycontainer',
                modules : {
                  xAxis : {
                    id : 'sap.viz.modules.axis',
                    data : { aa : [ 1 ] },
                    configure : {
                      'description':'Settings for the category axis of an XY chart.',
                      propertyCategory : 'xAxis',
                      properties : {
                        title : { visible : false },
                        gridline : { visible : false },
                        type : 'category',
                        position : 'bottom'
                      },
                      propertiesOverride : {
                        title : { isExported : false },
                        gridline : { isExported : false },
                        label : { isExported : false },
                        axisline : { isExported : false },
                        scale : { 
                          fixedRange : {isExported : false},
                          minValue : {isExported : false},
                          maxValue : {isExported : false},
                          isExported : false 
                        }
                      }
                    }
                  },
                  /**
                   * 'xAxis2' : { },
                   */
        
                  yAxis : {
                    id : 'sap.viz.modules.axis',
                    configure : {
                      'description':'Settings for the value axis of an XY chart.',
                      propertyCategory : 'yAxis',
                      properties : {
                        type : 'value',
                        position : 'left'
                      },
                      propertiesOverride : {
                        title : { isExported : false }                    
                      }
                    }
                  },
                  dataLabel : {
                    id : 'sap.viz.modules.datalabel',
                    configure : {
                      propertyCategory : 'dataLabel',
                      properties : {
                        position : 'outside',
                        automaticInOutside : false,
                        orientation : 'vertical',
                        outsidePosition : 'up',
                        positionPreference : true
                      }
                    }
                  },
                  
                  plot : {
                    id : 'sap.viz.modules.line',
                    configure : {
                    description : 'Settings regarding the chart area and plot area as well as general chart options.',
                      propertyCategory : 'plotArea'
                    }
                  }
                }
              }
            }
          }
        }
      }  
    },
    
    feeds : {
      multiplier : { max:1 },
      secondaryValues : null,
      axisLabels : { max:1 }
    },
    
    dependencies : {
      attributes : [
      {
        targetModule : 'root.main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'root.main.plot.yAxis',
        source : 'range'
      },
      {
        targetModule : 'root.main.xAxis2',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'xCategoryScale'
      }, 
      {
        targetModule : 'root.main.yAxis',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'yCategoryScale'
      },
      {
        targetModule : 'root.main',
        target : 'primaryDataRange',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'root.main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'root.main',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'root.main.plot.xAxis',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'categoryScale'
      }, {
        targetModule : 'root.main.plot.yAxis',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryScale'
      }, {
        targetModule : 'root.main.plot.yAxis',
        target : 'title',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryAxisTitle'
      },
      {
        targetModule : 'root.legends.legend',
        target : 'colorPalette',
        sourceModule : 'root.main.plot.plot',
        source : 'getColorPalette'
      },
      {
        targetModule : 'root.legends.legend',
        target : 'shapes',
        sourceModule : 'root.main.plot.plot',
        source : 'shapePalette'
      }, {
        targetModule : 'root.legends.legend',
        target : 'setSelectionMode',
        sourceModule : 'root.interaction',
        source : 'getSelectionMode'
      }
      ],
      events : 
      [  
        {
          targetModule : 'root.interaction',
          listener : 'registerEvent',
          sourceModule : 'root.main',
          type : 'initialized.interaction'
        }, 
        {
          targetModule : 'root.tooltip',
          listener : 'showTooltip',
          sourceModule : 'root.main',
          type : 'showTooltip'
        }, 
        {
          targetModule : 'root.tooltip',
          listener : 'hideTooltip',
          sourceModule : 'root.main',
          type : 'hideTooltip'
        },
        {
          targetModule : 'root.interaction',
          listener : 'highlightedByLegend',
          sourceModule : 'root.legends.legend',
          type : 'highlightedByLegend'
        }, 
        {
          targetModule : 'root.legends.legend',
          listener : 'deselectLegend',
          sourceModule : 'root.interaction',
          type : 'deselectLegend'
        }, 
        {
          targetModule : 'root.main.plot.dataLabel',
          listener : 'showLabel',
          sourceModule : 'root.main.plot.plot',
          type : 'initialized.datalabel'
        }, 
        {
          targetModule : 'root.main.plot.dataLabel',
          listener : 'removeLabel',
          sourceModule : 'root.main.plot.plot',
          type : 'startToInit.datalabel'
        }
      ]
    }
  };

  Manifest.register(multiBarChart);
});
define('sap/viz/modules/horizontalline',['sap/viz/modules/util/dataUtil','sap/viz/modules/dispatch','sap/viz/modules/util/MNDHandler',
'sap/viz/base/utils/TypeUtils','sap/viz/util/Scaler','sap/viz/util/ColorSeriesGenerator',
'sap/viz/util/BoundingBox','sap/viz/util/NumberUtils','sap/viz/lang/langManager',
'sap/viz/util/DrawUtil','sap/viz/modules/util/tooltipDataHandler','sap/viz/modules/manifests/Module',
'sap/viz/base/utils/ObjectUtils','sap/viz/base/utils/Objects','sap/viz/base/UADetector',
'sap/viz/modules/util/BoundUtil','sap/viz/modules/util/defaultSelectionUtil','sap/viz/modules/Constants'],
function Setup(dataUtil, dispatch, MNDHandler, TypeUtils, Scaler, ColorSeries, BoundingBox, NumberUtils, langManager, DrawUtil, TooltipDataHandler, Manifest, ObjectUtils, Objects,UADetector,BoundUtil, defaultSelUtil,Constants) 
{
  return function(manifest, ctx) 
  {
    var CLASSMARKERSELECTED = Constants.CSS.CLASS.DATAPOINTSELECTED,
    CLASSMARKERHOVER = Constants.CSS.CLASS.DATAPOINTHOVER,
    CLASSMARKERDEFAULT = Constants.CSS.CLASS.DATAPOINTDEFAULT,
    CLASSDATAPOINT = Constants.CSS.CLASS.DATAPOINT,
    CLASSMORPHABLEDATAPOINT = Constants.CSS.CLASS.MORPHABLEDATAPOINT,
    CLASSMORPHABLELINE = Constants.CSS.CLASS.MORPHABLELINE;
    
    var CLASSLINES = "v-lines",
    SEL_CLASSLINES = "." + CLASSLINES;
    var CLASSLIGHTLINE = "v-lightLine",
    SEL_CLASSLIGHTLINE = "." + CLASSLIGHTLINE;
    
    var CLASSDATAPOINTCOMBINED = CLASSDATAPOINT + ' ' + CLASSMORPHABLEDATAPOINT,
        CLASSLINESCOMBINED = CLASSLINES + ' ' + CLASSMORPHABLELINE,
        CLASSLIGHTLINECOMBINED = CLASSLIGHTLINE + ' ' + CLASSMORPHABLELINE;
        
    var width, height;
    var data_ = null, props;
    var randomSuffix = ObjectUtils.guid();
    //alex su
    var tooltipData = null;
    var _tooltipDataHandler;

    var bgColor = "#FFFFFF";
    var hoverColor = "#cccccc";
    var selectedColor = "#333333";

    var xScale = d3.scale.ordinal();
    var mouseMoveLine;
    var preHighLightIndex;
    var g;
    var svgMarkersGroup, svgLinesGroup, svgLightLinesGroup;
    var eDispatch = new dispatch('showTooltip', 'hideTooltip', 'initialized', 'startToInit');
    var hasMND;
    var bMNDOnColor;
    var bMNDInner;
    var effectManager = ctx.effectManager;
    var valueAxis1Data = {
        data: [],
        scale: d3.scale.linear(),
        colorPalette:null,
        selectedMarkers: null,
        markers:[],
        bottomValue: null,
        topValue:null,
        highLines:[]
    };

    var valueAxis2Data = {
        data: [],
        scale: d3.scale.linear(),
        colorPalette:null,
        selectedMarkers: null,
        markers:[],
        bottomValue: null,
        topValue:null,
        highLines:[]
    };
    var colorPalette = [];
    var PREFIXAXIS1 = 'v-axis1';
    var PREFIXAXIS2 = 'v-axis2';

    var bAnimationComplete = false;
    var hasDefaultSelection = false;
    var isDataSchemaChanged = false, isDataLoading = true, isSizeChanged = false, isDatasetChanged = false;

    var selectedMarkerNum = 0;
    var gSelection = null;

    // clip defs for enimation

    var clipRect;    
    var OPACITY = 0.4;

    //@Alex Su, judge whether we should enable animation
    
    function enableAnimation(){
      var hasAnmation = false;
      if(isDataLoading){
        hasAnmation = props.animation.dataLoading;
      }else if(isDatasetChanged){
        hasAnmation = props.animation.dataUpdating;
      }else if(isSizeChanged){
        hasAnmation = props.animation.resizing;
      }
      return hasAnmation;
    }

    function horizontalline(selection) {
      BoundUtil.drawBound(selection, width, height);
      //selection.each(generate);
      
      //alex su
      _tooltipDataHandler = TooltipDataHandler();
      
      renderChart(selection);
      isDataSchemaChanged = false, isDataLoading = false, isSizeChanged = false, isDatasetChanged = false;
      return horizontalline;
    }

   
    function calculateMinMax(axisValue)
    {
      var minMax = {
          min:null,
          max:null
      };
      if(!axisValue.data || axisValue.data.length === 0){
        return null;
      }
      minMax.max = Number(d3.max(axisValue.data, function(d){
        return d3.max(d, function(_){ return _.val;});
      }));
      minMax.min = Number(d3.min(axisValue.data, function(d){
        return d3.min(d, function(_){ return _.val;});
      }));
      if(NumberUtils.isNoValue(minMax.max )) {
        return null;
      }
      if(minMax.min >= 0)
      {
        minMax.min = 0;
        minMax.max += minMax.max * 5 / width ;
      }
      else if(minMax.max <= 0){
        minMax.max = 0;
        minMax.min +=  minMax.min * 5 / width;
      }else{
        var temp = (minMax.max - minMax.min) * 5 / width;
        minMax.min -= temp;
        minMax.max += temp;
      }
      
      return minMax;
    }

    function createColorPalette()
    {
      colorPalette = [];
      var i = 0, j = 0;
      if(valueAxis2Data.data && valueAxis2Data.data.length > 0){
        valueAxis1Data.colorPalette = props.primaryValuesColorPalette ;
      } else { 
        valueAxis1Data.colorPalette = props.colorPalette;
      }

      valueAxis2Data.colorPalette = props.secondaryValuesColorPalette;
      
      if (hasMND && bMNDOnColor && bMNDInner) {
        var dva1 = data_.getMeasureValuesGroupDataByIdx(0);
        var dva2 = data_.getMeasureValuesGroupDataByIdx(1);
        var mg1mNum=0, mg2mNum=0, mNum=0, colorAxisDataNum=0;
        if (dva1 && dva1.values.length>0) { 
          mg1mNum = dva1.values.length;
          colorAxisDataNum = dva1.values[0].rows.length;
        }
        if (dva2 && dva2.values.length>0) {
          mg2mNum = dva2.values.length;
          colorAxisDataNum = dva2.values[0].rows.length;
        }

        for (i=0; i<colorAxisDataNum; i++) {
          for (j=0; j<mg1mNum; j++) {
            colorPalette.push(valueAxis1Data.colorPalette[i*mg1mNum+j % valueAxis1Data.colorPalette.length]);
          }
          for (j=0; j<mg2mNum; j++){
            colorPalette.push(valueAxis2Data.colorPalette[i*mg2mNum+j % valueAxis2Data.colorPalette.length]);
          }
        }
      } else {
        for(i = 0; i < valueAxis1Data.data.length; ++i){
          colorPalette.push(valueAxis1Data.colorPalette[i % valueAxis1Data.colorPalette.length]);
        }
        if(valueAxis2Data.data && valueAxis2Data.data.length > 0)
        {
          for(i = 0; i < valueAxis2Data.data.length; ++i){
            colorPalette.push(valueAxis2Data.colorPalette[i % valueAxis2Data.colorPalette.length]);
          }
        }
      }
    }

    function calculateScale(axisValue)
    {
      if(axisValue.data && axisValue.data.length > 0 )
      {
        if( axisValue.topValue === null || axisValue.topValue === undefined)
        {
          var minMax = calculateMinMax(axisValue);
          if(!minMax || (minMax.min === 0 && minMax.max === 0)){
            axisValue.scale.domain([]).range ([]);
            axisValue.bottomValue = null;
            axisValue.topValue = null;
          } else {
            axisValue.scale.domain([minMax.min, minMax.max]).range ([0, width]);
            axisValue.bottomValue = minMax.min;
            axisValue.topValue = minMax.max;
          }
        }
        else{
          axisValue.scale.domain([axisValue.bottomValue, axisValue.topValue]).range ([0, width]);
        }
      }
      else{
        axisValue.scale.domain([0,0]).range([0,0]);
      }
      return axisValue.scale;
    }

    function computeScales()
    {
      var domain = [];
      var categoryNum = 0;
      if (valueAxis1Data.data.length !== 0) {
        categoryNum = valueAxis1Data.data[0].length;
      } else {
        categoryNum = valueAxis2Data.data[0].length;
      }
      for (var i=0; i < categoryNum; i++){
        domain.push(i);
      }
      xScale.domain(domain).rangeBands([height, 0]);
      calculateScale(valueAxis1Data);
      calculateScale(valueAxis2Data);
      if (valueAxis1Data.data && valueAxis1Data.data.length > 0 &&
            valueAxis2Data.data && valueAxis2Data.data.length > 0 ) {
        
        if(valueAxis1Data.scale.domain().length === 0 && valueAxis2Data.scale.domain().length === 0){
          valueAxis1Data.scale.domain([0, 1]).range ([0, width]); 
          valueAxis2Data.scale.domain([0, 1]).range ([0, width]); 
        } else if(valueAxis1Data.scale.domain().length === 0 && valueAxis2Data.scale.domain().length !== 0){
          valueAxis1Data.scale.domain(valueAxis2Data.scale.domain()).range(valueAxis2Data.scale.range());
        } else if(valueAxis1Data.scale.domain().length !== 0 && valueAxis2Data.scale.domain().length === 0){
          valueAxis2Data.scale.domain(valueAxis1Data.scale.domain()).range(valueAxis1Data.scale.range());
        }
        
        if (!valueAxis1Data.manualRange && !valueAxis2Data.manualRange) {
            Scaler.perfectDual(valueAxis1Data.scale, valueAxis2Data.scale);
        } else if (!valueAxis1Data.manualRange) {
            Scaler.perfect(valueAxis1Data.scale);
            Scaler.getRoughTickNum(valueAxis2Data.scale);
        } else if (!valueAxis2Data.manualRange) {
            Scaler.perfect(valueAxis2Data.scale);
            Scaler.getRoughTickNum(valueAxis1Data.scale);
        } else {
            Scaler.getRoughTickNum(valueAxis1Data.scale);
            Scaler.getRoughTickNum(valueAxis2Data.scale);
        }
      } else if (valueAxis1Data.data && valueAxis1Data.data.length > 0) {
        if(valueAxis1Data.scale.domain().length === 0){
          valueAxis1Data.scale.domain([0, 1]).range ([0, width]);
        }
        if (!valueAxis1Data.manualRange) {
            Scaler.perfect(valueAxis1Data.scale);
        } else {
            Scaler.getRoughTickNum(valueAxis1Data.scale);
        }
      } else if (valueAxis2Data.data && valueAxis2Data.data.length > 0) {
        if(valueAxis2Data.scale.domain().length === 0){
          valueAxis2Data.scale.domain([0, 1]).range ([0, width]);
        }
        if (!valueAxis2Data.manualRange) {
            Scaler.perfect(valueAxis2Data.scale);
        } else {
            Scaler.getRoughTickNum(valueAxis2Data.scale);
        }
      }
    }

    function changeGroupMarker(groupIndex, visible, className)
    {
      if(groupIndex === undefined || groupIndex === null){
        return;
      }

      var seriesIndex = 0;
      for(seriesIndex = 0; seriesIndex < valueAxis1Data.data.length; ++seriesIndex)
      {   
        if(!valueAxis1Data.selectedMarkers[seriesIndex][groupIndex])
        {
          changeOneMarker(seriesIndex, groupIndex, className, valueAxis1Data);
        }
      }  

      if(!valueAxis2Data.data) {return;}

      for(seriesIndex = 0; seriesIndex < valueAxis2Data.data.length; ++seriesIndex)
      {
        if(!valueAxis2Data.selectedMarkers[seriesIndex][groupIndex])
        {
          changeOneMarker(seriesIndex, groupIndex, className, valueAxis2Data);
        }
      }
    }
   
    function lightLine(seriesIndex, xIndex, visible, valueAxis)
    {
      if(!valueAxis.highLines[seriesIndex])
      {
        valueAxis.highLines[seriesIndex] = [];
      }
      if(!valueAxis.highLines[seriesIndex][xIndex] && visible === "visible")
      {
             var d1 = valueAxis.data[seriesIndex][xIndex].val;
             var d2 = valueAxis.data[seriesIndex][xIndex + 1].val;
             valueAxis.highLines[seriesIndex][xIndex] = svgLightLinesGroup.append("svg:line");
             valueAxis.highLines[seriesIndex][xIndex].each(function(){
               this.setAttribute("class", CLASSLIGHTLINECOMBINED);
               this.setAttribute("x1", valueAxis.scale(d1));
               this.setAttribute("y1", xScale(xIndex) + xScale.rangeBand() / 2);
               this.setAttribute("x2", valueAxis.scale(d2));
               this.setAttribute("y2", xScale(xIndex + 1) + xScale.rangeBand() / 2);
               this.setAttribute("stroke-width", props.width);
               this.setAttribute("stroke",valueAxis.colorPalette[seriesIndex %  valueAxis.colorPalette.length]);
               this.setAttribute("visibility", "hidden");
             });
       }
       if(valueAxis.highLines[seriesIndex][xIndex])
       {
         valueAxis.highLines[seriesIndex][xIndex].attr("visibility", visible);
       }
    }

    function changeOneMarker(seriesIndex, xIndex, className, valueAxis)
    {
      var stroke, tempOpacity;

      if (className === CLASSMARKERSELECTED) {
        stroke = selectedColor;
        tempOpacity = 1;
        if(xIndex > 0 && valueAxis.selectedMarkers[seriesIndex][xIndex - 1]){
           lightLine(seriesIndex, xIndex - 1, "visible", valueAxis);
        }
        if(xIndex < valueAxis.markers[0].length - 1 && valueAxis.selectedMarkers[seriesIndex][xIndex + 1]) {
           lightLine(seriesIndex, xIndex, "visible", valueAxis);
        }
        valueAxis.selectedMarkers[seriesIndex][xIndex] = true;
      } else {
        if(xIndex > 0 && valueAxis.selectedMarkers[seriesIndex][xIndex - 1]) {
           lightLine(seriesIndex, xIndex - 1, "hidden", valueAxis);
        }
        if(xIndex < valueAxis.markers[0].length - 1 && valueAxis.selectedMarkers[seriesIndex][xIndex + 1]){
           lightLine(seriesIndex, xIndex, "hidden", valueAxis);
        }
        valueAxis.selectedMarkers[seriesIndex][xIndex] = false;
        if(selectedMarkerNum > 0) {
            tempOpacity = OPACITY;
        } else {
            tempOpacity = 1;
        }
        
        if (className === CLASSMARKERHOVER) {
            stroke = bgColor;
        } else {
            stroke = "transparent";
            if (props.marker.visible === false) {
                tempOpacity = 0;
            }
        }
      }
  
      d3.select(valueAxis.markers[seriesIndex][xIndex])
        .attr("class", CLASSDATAPOINTCOMBINED + ' ' + className).attr("stroke", stroke).attr("opacity", tempOpacity);
    }

    function getCategoryIndex(val)
    {
      var index = val / xScale.rangeBand();
      index = Math.floor(index);
      var categoryNum = 0;
      if (valueAxis1Data.data.length !== 0) {
        categoryNum = valueAxis1Data.data[0].length;
      } else {
        categoryNum = valueAxis2Data.data[0].length;
      }
      if(index > categoryNum - 1) { index = categoryNum - 1;}
      if(index < 0){ index = 0;}
      return categoryNum - 1 - index;
    }

    function processOneAxisSelect(valueAxis, marker) {
      var findFlag = false, yi, xi;
      for(var i = 0; i < valueAxis.markers.length && !findFlag; i++)
      {
        var xMarks = valueAxis.markers[i];
        for (var j = 0; j<xMarks.length && !findFlag ; j++)
        {
          if(xMarks[j] === marker) {
            findFlag = true;
            yi = i;
            xi = j;
          }
        } //for j
      }//for i

      if (!findFlag) {
        return false;
      }

      if (valueAxis.selectedMarkers[yi][xi]) {
        return true;
      }
      ++selectedMarkerNum;
      changeOneMarker(yi, xi, CLASSMARKERSELECTED, valueAxis);
    }

    function processOneAxisDeselect (valueAxis, marker) {
      var xi = preHighLightIndex;

      var findFlag = false, yi;
      for(var i = 0; i < valueAxis.markers.length && !findFlag; i++)
      {
        var xMarks = valueAxis.markers[i];
        for (var j = 0; j<xMarks.length && !findFlag ; j++)
        {
          if(xMarks[j] === marker) {
            findFlag = true;
            yi = i;
            xi = j;
          }
        } 
      }

      if (!findFlag) {
        return false;
      }

      if (!valueAxis.selectedMarkers[yi][xi]){
        return true;
      }

      if(xi === preHighLightIndex){
        changeOneMarker(yi, xi, CLASSMARKERHOVER, valueAxis);
      }
      else{
        changeOneMarker(yi, xi, CLASSMARKERDEFAULT, valueAxis);
      }

    }

    
    function processNullValue(axisValue)
    {
      var result = {
          data:[],
          color:[]
      };
      var arr = [], obj, k;

      for(var i = 0; i < axisValue.length; ++i)
      {
        var preIndex = 0;
        for(var j = 0; j < axisValue[i].length; ++j)
        {
          if(NumberUtils.isNoValue(axisValue[i][j].val))
          {
            if(j > preIndex)
            {
              arr = [];
              for(k = preIndex; k < j; k++)
              {
                obj = axisValue[i][k];
                obj.x = k;  
                arr.push(obj);
              }
              result.data.push(arr);
              result.color.push(i);
            }
            preIndex = j + 1;
          }
        }
        
        if(preIndex < axisValue[i].length)
        {
          arr = [];
          for(k = preIndex; k <  axisValue[i].length; k++)
          {
            obj = axisValue[i][k];
            obj.x = k;
            arr.push(obj);
          }
          result.data.push(arr);
          result.color.push(i);
        }
      }
      return result;
    }
    
    function processOneAxis(axisValue, prefix)
    {
      if(!axisValue.data || axisValue.data.length === 0){
        return;
      }
      var axisGroup = svgLinesGroup.select("g." + prefix);
      if(axisGroup.empty())
      {
        axisGroup = svgLinesGroup.append("svg:g").attr("class", prefix);
      }
      axisValue.selectedMarkers = new Array(axisValue.data.length);
      axisValue.markers = [];
      var result = processNullValue(axisValue.data);
      
      var lines = axisGroup.selectAll(SEL_CLASSLINES).data(result.data);
      
      lines.enter().append("path");
      lines.each(function(){
        this.setAttribute('class', CLASSLINESCOMBINED);
        this.setAttribute("stroke-width", props.width);
        this.setAttribute("stroke-linejoin", "round");
      });
      lines.exit().remove();
      lines.attr("stroke-width", props.width);//@Alex: add this line to update attributes.       
      var line = d3.svg.line().y(function(d,i) { return xScale(d.x) + xScale.rangeBand() / 2; }).x(function(d) {  return axisValue.scale(d.val); });
      lines.each(function(d, i) {
        var para = { graphType:"line", 
            fillColor:axisValue.colorPalette[result.color[i] %  axisValue.colorPalette.length]};
        var strokeEffect = effectManager.register(para);
        this.setAttribute("d", line(d));
        this.setAttribute("stroke",strokeEffect);
      });
      
      
      // draw markers
      for(var seriesIndex = 0; seriesIndex < axisValue.data.length; ++seriesIndex)
      {
        axisValue.selectedMarkers[seriesIndex] = [];
        for(var dataIndex = 0; dataIndex < axisValue.data[0].length; ++dataIndex)
        {
          axisValue.selectedMarkers[seriesIndex][dataIndex] = false;
        }
      }
      var markerGroup = svgMarkersGroup.select("g." + prefix);
      if(markerGroup.empty()){
        markerGroup = svgMarkersGroup.append("svg:g").attr("class", prefix);
      }
      var groups = markerGroup.selectAll("g.v-marker").data(axisValue.data);
      groups.enter().append("svg:g").attr("class", "v-marker");
      groups.exit().remove();
      
      var visible = "hidden";
      if(props && props.marker && props.marker.visible){
        visible  = "visible";
      }
      groups.each(function(d, i) {
        
        var seriesMarkers = d3.select(this).selectAll(".v-datashape").data(d);
        var datashape = seriesMarkers.enter().append('g').attr('class','v-datashape').append("path");
        datashape.attr("class", CLASSDATAPOINTCOMBINED + " " + CLASSMARKERDEFAULT);
        seriesMarkers.exit().remove();
        var markerArr = [];
        var parameter = {
            drawingEffect:props.drawingEffect,
            graphType: props.marker.shape,
            fillColor : axisValue.colorPalette[i % axisValue.colorPalette.length],
            direction : 'vertical',
            rx: props.marker.size / 2,
            ry: props.marker.size / 2,
            borderWidth: 2,
            borderColor: props.style.marker.stroke,
            node:null,
            visibility: visible
        };
        seriesMarkers.attr("transform",function(point, index)
          {   
          if(NumberUtils.isNoValue(point.val))
          { 
            d3.select(this).remove();
            markerArr.push(null);
            return;
          }
          markerArr.push(d3.select(this).selectAll('path').node());
          parameter.node = d3.select(this).select('path');
          DrawUtil.drawGraph(parameter, effectManager);
          return "translate(" + axisValue.scale(point.val)+ "," + (xScale(index) + xScale.rangeBand() / 2)  + ")"; 
        });

        axisValue.markers.push(markerArr);
      });
    }

    function processOneAxisDeselectAll(valueAxis,  xIndex)
    {
      if(!valueAxis.selectedMarkers || valueAxis.selectedMarkers.length === 0){
        return;
      }
      
      for(var seriesIndex = 0; seriesIndex < valueAxis.selectedMarkers.length; ++seriesIndex)
      {
        for(var groupIndex = 0; groupIndex < valueAxis.selectedMarkers[0].length; ++groupIndex)
        {
          if(!valueAxis.selectedMarkers[seriesIndex][groupIndex]) {continue;}
          
          if(groupIndex === xIndex)
          {
            changeOneMarker(seriesIndex, groupIndex, CLASSMARKERHOVER, valueAxis);
          }
          else
          {
            changeOneMarker(seriesIndex, groupIndex, CLASSMARKERDEFAULT, valueAxis);
          }

          valueAxis.selectedMarkers[seriesIndex][groupIndex] = false;
        }
      }
    }
    function getCurrentEvent() {
        if (d3.event) {
            return d3.event;
        } else {
            return window.event;
        }
    }
    function deselectedAllHandler()
    {
      var event = getCurrentEvent();
      var ypoint =  (event ? event.clientY : 0) - g.node().getBoundingClientRect().top ;
      var xIndex = getCategoryIndex(ypoint);
      selectedMarkerNum = 0;
      processOneAxisDeselectAll(valueAxis1Data, xIndex);
      processOneAxisDeselectAll(valueAxis2Data, xIndex);
    }

    
    
    function renderChart(selection)
    {
      gSelection = selection;
      getCSSStyle();
      eDispatch.startToInit();
      if(!g) {
        g = selection.append("svg:g");  
      }
      
      if(!clipRect){
        clipRect = g.append("svg:defs").append("svg:clipPath").attr("id", "clip1_" + randomSuffix).append("rect");
      }
      
      clipRect.each(function(){
        this.setAttribute("x", 0);
        this.setAttribute("y",  height);
        this.setAttribute("height",  0 );
        this.setAttribute("width", width);
      });

      if(!mouseMoveLine){
        mouseMoveLine = g.append("svg:line");
        mouseMoveLine.each(function(){
          this.setAttribute("stroke", hoverColor);
          this.setAttribute("class", "v-hoverline viz-plot-hoverline");
        });
      }

      mouseMoveLine.each(function(){
        this.setAttribute("x1", 0);
        this.setAttribute("y1", 0);
        this.setAttribute("x2", width);
        this.setAttribute("y2", 0);
        this.setAttribute("stroke-width", 1);
        this.setAttribute("visibility", "hidden");
        this.setAttribute("shape-rendering", "crispEdges");
      });
      
      if(!svgLinesGroup)
      {
        svgLinesGroup = g.append("svg:g").attr("class", "v-datalines");
        svgLightLinesGroup = g.append("svg:g").attr("class", "v-lightLines");
        svgMarkersGroup = g.append("svg:g").attr("class", "v-markers v-datashapesgroup");
      }
      selectedMarkerNum = 0;
      lightAll();

      svgMarkersGroup.each(function(){
        this.setAttribute("clip-path", "url(#clip1_" + randomSuffix + ")");
        this.setAttribute("fill", "none");
      });
      svgLinesGroup.each(function(){
        this.setAttribute("clip-path", "url(#clip1_" + randomSuffix + ")");
        this.setAttribute("fill", "none");
      });
      svgLightLinesGroup.each(function(){
        this.setAttribute("clip-path", "url(#clip1_" + randomSuffix + ")");
        this.setAttribute("fill", "none");
      });
      svgLightLinesGroup.selectAll(SEL_CLASSLIGHTLINE).remove();
      //[21-Jan-2013 Nick] FIX BUG. Draw chart before 'initialized' event is fired out.
      processOneAxis(valueAxis1Data, PREFIXAXIS1);
      processOneAxis(valueAxis2Data, PREFIXAXIS2);
      
      if(enableAnimation()){
        clipRect
          .attr("x", 0).attr("y", height).attr("height", 0).attr("width", width).transition().duration(1000)
          .attr("height", function(){return height;}).attr("y", 0).each("end", function(){
          eDispatch.initialized();});
         
        }else{
          clipRect.each(function() {
              this.setAttribute("x", 0);
              this.setAttribute("y", 0);
              this.setAttribute("height", height);
              this.setAttribute("width", width);
          });
          eDispatch.initialized();
         }

    }

    function lightAll() {
      svgLightLinesGroup.selectAll(SEL_CLASSLIGHTLINE).attr("visibility", "hidden");
      svgLinesGroup.attr("opacity", 1);
      if(UADetector.isIE()){
        svgLinesGroup.selectAll(SEL_CLASSLINES).attr("visibility", "visible");
      }
      
      var tempopacity;
      if (props.marker.visible === true) {
        tempopacity = 1;
      } else {
        tempopacity = 0;
      }
      svgMarkersGroup.selectAll("g." +  PREFIXAXIS1).selectAll("g.v-marker").selectAll("."+ CLASSMARKERSELECTED + " " + CLASSMARKERDEFAULT)
      .attr("opacity", tempopacity).attr("class",  CLASSDATAPOINTCOMBINED);
      svgMarkersGroup.selectAll("g." +  PREFIXAXIS2).selectAll("g.v-marker").selectAll("."+ CLASSMARKERSELECTED + " " + CLASSMARKERDEFAULT)
      .attr("opacity", tempopacity).attr("class", CLASSDATAPOINTCOMBINED);
    }

    function grayAll() {
      svgLightLinesGroup.selectAll(SEL_CLASSLIGHTLINE).attr("visibility", "hidden");
      svgLinesGroup.attr("opacity", OPACITY);
      if(UADetector.isIE()) {
        svgLinesGroup.selectAll(SEL_CLASSLINES).attr("visibility", "visible");
      }
      var tempopacity;
      if (props.marker.visible === true) {
        tempopacity = OPACITY;
      } else {
        tempopacity = 0;
      }      
      svgMarkersGroup.selectAll("g." +  PREFIXAXIS1).selectAll("g.v-marker").selectAll("."+ CLASSMARKERSELECTED + " " + CLASSMARKERDEFAULT)
      .attr("opacity", tempopacity).attr("class",  CLASSDATAPOINTCOMBINED);
      svgMarkersGroup.selectAll("g." +  PREFIXAXIS2).selectAll("g.v-marker").selectAll("."+ CLASSMARKERSELECTED + " " + CLASSMARKERDEFAULT)
      .attr("opacity", tempopacity).attr("class", CLASSDATAPOINTCOMBINED);
    }
    
    function getCSSStyle() {
        if (!props.style){
          props.style = {};
        } 
        var cssDef;
        if (!props.style.marker){
          props.style.marker = {};
        }
        props.style.marker.stroke = "transparent";
        cssDef = ctx.styleManager.queryDefault('v-hoverline');
        if(cssDef)
        {
          if (cssDef['stroke']){
            hoverColor = cssDef['stroke'];
          }
        }
      }
      function resetDataRange(){
        valueAxis1Data.topValue = null;
        valueAxis1Data.bottomValue = null;
        valueAxis2Data.topValue = null;
        valueAxis2Data.bottomValue = null;
      }
    
    horizontalline.afterUIComponentAppear = function(){
      eDispatch.initialized(); 
    };
    
    horizontalline.width = function(value) {
      if (!arguments.length){
        return width;
      }
      isSizeChanged = (!isSizeChanged && (value === width)) ? false : true;
      width = value;
      if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(data_)){
        computeScales();
      }
      return horizontalline;
    };

    horizontalline.height = function(value) {
      if (!arguments.length){
        return height;
      }
      isSizeChanged = (!isSizeChanged && (value === width)) ? false : true;
      height = value;
      if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(data_)){
        computeScales();
      }
      return horizontalline;
    };
    
    /*;
     * get/set properties
     */
    horizontalline.properties = function(_) {
      if (!arguments.length){
        return props;
      }
        
      Objects.extend(true, props, _);
      if(props.marker.size < 4 || props.marker.size > 32) { props.marker.size = 6;}
      if(props.width < 1 || props.width > 7) {props.width = 2;}
      createColorPalette();
      return horizontalline;
    };
    
    horizontalline.primaryAxisColor = function(){
        if(valueAxis2Data.data && valueAxis2Data.data.length > 0){
          return effectManager.register({graphType:"line", fillColor: valueAxis1Data.colorPalette[0]});
        }else{
          return null;
        }
      };
        
      horizontalline.secondAxisColor = function(){
        return effectManager.register({graphType:"line", fillColor:  valueAxis2Data.colorPalette[0]});
      };     
    /**
     * get/set your event dispatch if you support event
     */
    horizontalline.dispatch = function(_){
      if(!arguments.length){
        return eDispatch;
      }
      eDispatch = _;
      return horizontalline;
    };
          
    /**
     * set/get data, for some modules like Title, it doesn't need data
     */
    horizontalline.data = function(value){
      if (!arguments.length){
        return data_;
      }
      isDatasetChanged = true;
      isDataSchemaChanged = false;
      if (! dataUtil().hasSameSchema(data_, value)){
        isDataSchemaChanged = true;
      }
      data_ = value;
      var obj = MNDHandler(data_);
      valueAxis1Data.data = obj["MG1"];
      valueAxis2Data.data = obj["MG2"];
      resetDataRange();
      
      var dataInfo = (valueAxis1Data.data.length === 0 ? valueAxis2Data.data[0][0] : valueAxis1Data.data[0][0]);
      if(dataInfo.info &&  dataInfo.info.defaultSelection){
        hasDefaultSelection = true;
      }else{
        hasDefaultSelection = false;
      }
      
      hasMND = obj["hasMND"];
      bMNDOnColor = obj["MNDOnColor"];
      bMNDInner = obj["MNDInner"];
      //alex su
      tooltipData = TooltipDataHandler.dataTransform(obj);
      if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(data_)){
        computeScales();
      }
      createColorPalette();
      return horizontalline;        
    };

    horizontalline.primaryAxisTitle = function(_){
        if(!arguments.length){
          var titles =  data_.getMeasureValuesGroupDataByIdx(0), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join(' & ');
        }
        return this;
      };
      
      horizontalline.secondAxisTitle = function(_){
        if(!arguments.length){
          var titles =  data_.getMeasureValuesGroupDataByIdx(1), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join(' & ');
        }
        return this;
      };
    /**
     * get color palette
     */
    horizontalline.getColorPalette = function() {
      if(colorPalette.length === 0)
      {
        createColorPalette();
      }
      return colorPalette;
    };


    horizontalline.shapePalette = function(_){
      if(!arguments.length){
        return [props.marker.shape];
      }
      return horizontalline;
    };


    horizontalline.primaryScale = function(scale)
    {
      if(!arguments.length)
      {
        return valueAxis1Data.scale;
      }
      valueAxis1Data.scale = scale;
      return horizontalline;
    };

    horizontalline.secondaryScale = function(scale)
    {
      if(!arguments.length)
      {
        return valueAxis2Data.scale;
      }
      valueAxis2Data.scale = scale;
      return horizontalline;
    };

    horizontalline.categoryScale = function(scale)
    {
      if(!arguments.length)
      {
        return xScale;
      }
      xScale = scale;
      return horizontalline;

    };

    horizontalline.primaryDataRange = function(range){
      if (!arguments.length) {
        return {
          min : valueAxis1Data.bottomValue,
          max : valueAxis1Data.topValue
        };
      }
      var tempMax, tempMin;
      if (range !== null) {
          if (!isNaN(range.max)) {
            tempMax = range.max;
          } else {
            tempMax = valueAxis1Data.scale.perfectDomainEnd;
          }
          if (!isNaN(range.min)) {
            tempMin = range.min;
          } else {
            tempMin = valueAxis1Data.scale.perfectDomainBegin;
          }
          if (tempMax > tempMin) {
            valueAxis1Data.topValue = tempMax;
            valueAxis1Data.bottomValue = tempMin;
          if (range.from === 'axis') {
            valueAxis1Data.manualRange = true;
          }
          if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
            calculateScale(valueAxis1Data);
            }
          }
      } else {
        if (valueAxis1Data.manualRange === true) {
          valueAxis1Data.topValue = valueAxis1Data.scale.perfectDomainEnd;
          valueAxis1Data.bottomValue = valueAxis1Data.scale.perfectDomainBegin;
          valueAxis1Data.manualRange = false;
          if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
            calculateScale(valueAxis1Data);
          }
        }
      }
      return horizontalline;
    };

    horizontalline.secondDataRange = function(range){
      if (!arguments.length) {
        return {
          min : valueAxis2Data.bottomValue,
          max : valueAxis2Data.topValue
        };
      }
      var tempMax, tempMin;
      if (range !== null) {
          if (!isNaN(range.max)) {
            tempMax = range.max;
          } else {
            tempMax = valueAxis2Data.scale.perfectDomainEnd;
          }
          if (!isNaN(range.min)) {
            tempMin = range.min;
          } else {
            tempMin = valueAxis2Data.scale.perfectDomainBegin;
          }
          if (tempMax > tempMin) {
            valueAxis2Data.topValue = tempMax;
            valueAxis2Data.bottomValue = tempMin;
          if (range.from === 'axis') {
            valueAxis2Data.manualRange = true;
          }
          if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
            calculateScale(valueAxis2Data);
            }
          }
      } else {
        if (valueAxis2Data.manualRange === true) {
          valueAxis2Data.topValue = valueAxis2Data.scale.perfectDomainEnd;
          valueAxis2Data.bottomValue = valueAxis2Data.scale.perfectDomainBegin;
          valueAxis2Data.manualRange = false;
          if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
            calculateScale(valueAxis2Data);
          }
        }
      }
      return horizontalline;
    };
    
    horizontalline.parent = function() { 
      return gSelection;
    };
    
    horizontalline.dataLabel = function(_){
     
    };
    /**
     * get/set size
     */
    horizontalline.size = function(_) {
      if (arguments.length === 0){
        return {
          width : horizontalline.width(),
          height : horizontalline.height()
        };
      }
      isSizeChanged = (!isSizeChanged && (_.width === width) && (_.height === height)) ? false : true;
      width = _.width;
      height = _.height;
      if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(data_)){
        computeScales();
      }
      return horizontalline;
    };
    
    horizontalline.clear = function (gray) {
      deselectedAllHandler();
      var markers = [];
      if (gray === null || gray === undefined || gray === false){
        lightAll();
        markers.push(svgMarkersGroup.selectAll("g." +  PREFIXAXIS1).selectAll("g.v-marker").selectAll("."+CLASSDATAPOINTCOMBINED));
        markers.push(svgMarkersGroup.selectAll("g." +  PREFIXAXIS2).selectAll("g.v-marker").selectAll("."+CLASSDATAPOINTCOMBINED));
        if(hasDefaultSelection){
          defaultSelUtil.clearSelectionInfo(gSelection, false, markers);
        }
      } else {
        grayAll();
      }
    };

    horizontalline.highlight = function (elements) {
      var elementArray;
      if (elements instanceof Array) {
        elementArray = elements;
      } else {
        elementArray = [];
        elementArray.push(elements);
      }

      for (var i=0; i<elementArray.length; i++)
      {
        var marker = elementArray[i];
        if(!processOneAxisSelect(valueAxis1Data, marker )){
          processOneAxisSelect(valueAxis2Data, marker );
        }
      }
      svgMarkersGroup.selectAll("g." +  PREFIXAXIS1).selectAll("g.v-marker").selectAll("."+ CLASSMARKERHOVER).attr("opacity", OPACITY);
      svgMarkersGroup.selectAll("g." +  PREFIXAXIS2).selectAll("g.v-marker").selectAll("."+ CLASSMARKERHOVER).attr("opacity", OPACITY);
      if (props.marker.visible){
        svgMarkersGroup.selectAll("g." +  PREFIXAXIS1).selectAll("g.v-marker")
        .selectAll("."+ CLASSMARKERDEFAULT).attr("opacity", OPACITY);
        svgMarkersGroup.selectAll("g." +  PREFIXAXIS2).selectAll("g.v-marker")
        .selectAll("."+ CLASSMARKERDEFAULT).attr("opacity", OPACITY);
      }
      if(hasDefaultSelection){
        defaultSelUtil.clearSelectionInfo(gSelection, true, elementArray);
      }
      
    };
    
    horizontalline.unhighlight = function (elements) {
      var elementArray;
      if (elements instanceof Array) {
        elementArray = elements;
      } else {
        elementArray = [];
        elementArray.push(elements);
      }
      
      selectedMarkerNum -= elementArray.length;
      for (var i=0; i<elementArray.length; i++)
      {
        var marker = elementArray[i];

        if(!processOneAxisDeselect(valueAxis1Data, marker)){
          processOneAxisDeselect(valueAxis2Data, marker);
        }
      }
      if(selectedMarkerNum === 0)
      {
        svgMarkersGroup.selectAll("g." +  PREFIXAXIS1).selectAll("g.v-marker").selectAll("."+ CLASSMARKERHOVER).attr("opacity", 1);
        svgMarkersGroup.selectAll("g." +  PREFIXAXIS2).selectAll("g.v-marker").selectAll("."+ CLASSMARKERHOVER).attr("opacity", 1);
        if (props.marker.visible){
          svgMarkersGroup.selectAll("g." +  PREFIXAXIS1).selectAll("g.v-marker")
          .selectAll("."+ CLASSMARKERDEFAULT).attr("opacity", 1);
          svgMarkersGroup.selectAll("g." +  PREFIXAXIS2).selectAll("g.v-marker")
          .selectAll("."+ CLASSMARKERDEFAULT).attr("opacity", 1);
        }
      }
      if(hasDefaultSelection){
        defaultSelUtil.clearSelectionInfo(gSelection, false, elementArray);
      }
    };
    horizontalline.hoverOnPoint = function(point)
    {  
      var point0 = point.x, point1 = point.y;
      if(point1 < 0 || point1 > height){
        return;
      }

      var xIndex = getCategoryIndex(point1);
      if(preHighLightIndex === xIndex) { return; }
      var yCoord = xScale(xIndex) + xScale.rangeBand() / 2;
      changeGroupMarker(preHighLightIndex, "hidden", CLASSMARKERDEFAULT);
      changeGroupMarker(xIndex, "visible", CLASSMARKERHOVER);  

      preHighLightIndex = xIndex;
      if (props.hoverline.visible) {
        mouseMoveLine.attr("y1", yCoord).attr("y2", yCoord);
        mouseMoveLine.attr("visibility", "visible");
      } else {
        mouseMoveLine.attr("visibility", "hidden");
      }
      if (props.tooltip.enabled) {
        var pt = {};
        var matrix = g.node().getTransformToElement(g.node().ownerSVGElement);
        pt.x = width * 3 / 4 + matrix.e;
        pt.y = yCoord + matrix.f;
        //var globalPoint = pt.matrixTransform(g.node().parentNode.parentNode.getScreenCTM().inverse());
        //var tData = generateTooltipData(xIndex);
        //alex su
        var tData = _tooltipDataHandler.generateTooltipData(data_, 
               tooltipData, 
               xIndex, 
               colorPalette, 
               [props.marker.shape]);
        tData.point = pt;
        tData.plotArea = {
            x : matrix.e,
            y : matrix.f,
            width : width,
            height : height
          };
        eDispatch.showTooltip(TooltipDataHandler.formatTooltipData(tData));
      }
    };
    
    horizontalline.blurOut = function()
    {  
      mouseMoveLine.attr("visibility", "hidden");
      changeGroupMarker(preHighLightIndex, "hidden", CLASSMARKERDEFAULT);
      preHighLightIndex = null;
      if (props.tooltip.enabled) { 
        eDispatch.hideTooltip();
      }
    };
    
    horizontalline.destroy = function() {
      //don't simply set m_scale to null
      //we need clear the internal cached index and range
      if(valueAxis1Data.scale){
        valueAxis1Data.scale.domain([0,1]).range([0,1]);
      }
      if(valueAxis2Data.scale){
        valueAxis2Data.scale.domain([0,1]).range([0,1]);
      }
      if(xScale){
        xScale.domain([0,1]).range([0,1]);
      }
      valueAxis1Data.markers = null;
      valueAxis2Data.markers = null;
      valueAxis1Data.data = null;
      valueAxis2Data.data = null;
      
      //set null
      valueAxis1Data = null;
      valueAxis2Data = null;
      clipRect = null;
      data_ = null;
      xScale = null;
      tooltipData = null;
      g = null;
      gSelection = null;
      mouseMoveLine = null;
      svgLinesGroup = null;
      svgLightLinesGroup = null;
      svgMarkersGroup = null;
      
      //destroy ctx
      if(ctx){
        ctx.destroy();
        ctx = null;
      }
    };
    
    props = manifest.props(null);
    return horizontalline;
  };
});

define('sap/viz/modules/manifests/xy/HorizontalLine',['sap/viz/modules/manifests/Module','sap/viz/modules/horizontalline',
'sap/viz/modules/manifests/xy/Line'],
function Setup(Manifest, fn) {
  var module = {
    'id' : 'sap.viz.modules.horizontalline',
    'name' : 'horizontalline',
    base : 'sap.viz.modules.line',
    
    fn : fn
  };

  Manifest.register(module);
});
define('sap/viz/manifests/MultiHorizontalLineChart',['sap/viz/manifests/Viz','sap/viz/manifests/BaseChart','sap/viz/modules/manifests/XYContainer',
'sap/viz/modules/manifests/TableContainer','sap/viz/modules/manifests/Axis',
'sap/viz/modules/manifests/xy/HorizontalLine','sap/viz/manifests/BaseMultipleChart',
'sap/viz/manifests/MultiLineChart'],
function Setup(Manifest) {
  var multiBarChart = {
    id : 'viz/multi_horizontal_line',
    name : 'IDS_MULTIHORIZONTALLINECHART',
    base : 'viz/multi_line',
    modules : {
      root : {
        modules : {
          tooltip : {
            configure : {
              properties : {
                chartType : 'horizontalline',
                orientation : 'left'
              }
            }
          },  
          main : {
            modules: {
              plot : {
                id : 'sap.viz.modules.xycontainer',
                modules : {
                  background : {
                    configure : {
                      properties : {
                        direction : 'horizontal'
                      }
                    }
                  },
                  xAxis : {
                    id : 'sap.viz.modules.axis',
                    data : null,
                    configure : {
                      'description':'Settings for the value axis of an XY chart.',
                      properties : {
                        type : 'value',
                        gridline : {
                          visible : true
                        }
                      },
                      propertiesOverride : {
                        gridline : { isExported : true },
                        label : { isExported : true },
                        axisline : { isExported : true },
                        scale : { 
                          fixedRange : {isExported : true},
                          minValue : {isExported : true},
                          maxValue : {isExported : true},
                          isExported : true 
                        }
                      }
                    }
                  },
                  /**
                   * 'xAxis2' : { },
                   */
        
                  yAxis : {
                    id : 'sap.viz.modules.axis',
                    data : {
                      aa : [ 1 ]
                    }, 
                    configure : {
                         'description':'Settings for the category axis of an XY chart.',
                      properties : {
                        type : 'category',
                        gridline : {
                          visible : false
                        }
                      },
                      propertiesOverride : {
                        gridline : { isExported : false },
                        label : { isExported : false },
                        axisline : { isExported : false },
                        scale : { 
                          fixedRange : {isExported : false},
                          minValue : {isExported : false},
                          maxValue : {isExported : false},
                          isExported : false 
                        }
                      }
                    }
                  },
                  dataLabel : {
                    id : 'sap.viz.modules.datalabel',
                    configure : {
                      propertyCategory : 'dataLabel',
                      properties : {
                        position : 'outside',
                        automaticInOutside : false,
                        orientation : 'horizontal',
                        outsidePosition : 'right',
                        positionPreference : true
                      }
                    }
                  },
                  plot : {
                    id : 'sap.viz.modules.horizontalline',
                    configure : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                      propertyCategory : 'plotArea'
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    feeds:{
      multiplier:{
      max:1
     },
      axisLabels:{
        max:1
      }
    },
    dependencies : {
      attributes : [
      {
        targetModule : 'root.main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'root.main.plot.xAxis',
        source : 'range'
      },
      {
        targetModule : 'root.main.xAxis2',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'xCategoryScale'
      }, 
      {
        targetModule : 'root.main.yAxis',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'yCategoryScale'
      },
      {
        targetModule : 'root.main',
        target : 'primaryDataRange',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'root.main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'root.main',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'root.main.plot.xAxis',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryScale'
      }, {
        targetModule : 'root.main.plot.xAxis',
        target : 'title',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryAxisTitle'
      },{
        targetModule : 'root.main.plot.yAxis',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'categoryScale'
      }, 
      {
        targetModule : 'root.legends.legend',
        target : 'colorPalette',
        sourceModule : 'root.main.plot.plot',
        source : 'getColorPalette'
      },
      {
        targetModule : 'root.legends.legend',
        target : 'shapes',
        sourceModule : 'root.main.plot.plot',
        source : 'shapePalette'
      } ]
    }
  };

  Manifest.register(multiBarChart);
});
define('sap/viz/manifests/MultiDualLineChart',['sap/viz/manifests/Viz','sap/viz/manifests/BaseChart','sap/viz/modules/manifests/RootContainer',
'sap/viz/modules/manifests/XYContainer','sap/viz/modules/manifests/TableContainer',
'sap/viz/modules/manifests/Axis','sap/viz/modules/manifests/xy/Line',
'sap/viz/manifests/BaseMultipleChart','sap/viz/manifests/BaseMultipleXYChart',
'sap/viz/manifests/MultiLineChart','sap/viz/modules/manifests/controller/Interaction'],
function Setup(Manifest) {
  var multiVBarChart = {
    id : 'viz/multi_dual_line',
    name : 'IDS_MULTIDUALLINECHART',
    base : 'viz/multi_line',
    modules : {
      root : {
        modules : {
          interaction : {
            id : 'sap.viz.modules.controller.interaction',
            configure : { 
              clientID : 'main',
              propertyCategory : 'interaction'
            }
          },
           main : {
            configure : {
              properties : {
                'mergeDataRange' : ['primary', 'second']
              }
            },

            modules: {              
              plot : {
                modules : {
                  plot : {
                    configure : {
                      propertiesOverride : {
                        primaryValuesColorPalette : { isExported: true },
                        secondaryValuesColorPalette: { isExported: true }
                    }
                  }
                },
                
                yAxis:{
                  id : 'sap.viz.modules.axis',
                  configure:{
                    description : 'Settings for the value axis at left or bottom of an XY chart with 2 value axis.'
                  }
                },
                
                yAxis2 : {
                  id : 'sap.viz.modules.axis',
                  configure : {
                    'description':'Settings for the value axis at right or top of an XY chart with 2 value axis.',
                    propertyCategory : 'yAxis2',
                    properties : {
                      title : { visible : false },
                      gridline : { visible : false },
                      type : 'value',
                      position : 'right'
                    },
                    propertiesOverride : {
                      title : { isExported : false }                    
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
     
    },
    feeds:{
      multiplier:{
      max:1
     },
     secondaryValues:
     {
       min: 1,
    max : Number.POSITIVE_INFINITY 
     },
    axisLabels:{
      max:1,
      acceptMND: -1
    },
    regionColor:{
      acceptMND: 1
    }
    },
    dependencies : {
      attributes : [
      {
        targetModule : 'root.main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'root.main.plot.yAxis',
        source : 'range'
      },
      {
        targetModule : 'root.main.plot.plot',
        target : 'secondDataRange',
        sourceModule : 'root.main.plot.yAxis2',
        source : 'range'
      },
      {
        targetModule : 'root.main.xAxis2',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'xCategoryScale'
      }, 
      {
        targetModule : 'root.main.yAxis',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'yCategoryScale'
      },
      {
        targetModule : 'root.main',
        target : 'primaryDataRange',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'root.main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'root.main',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'root.main',
        target : 'secondDataRange',
        sourceModule : 'root.main.plot.plot',
        source : 'secondDataRange'
      },
      {
        targetModule : 'root.main.plot.plot',
        target : 'secondDataRange',
        sourceModule : 'root.main',
        source : 'secondDataRange'
      },
      {
        targetModule : 'root.main.plot.yAxis',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryScale'
      },{
        targetModule : 'root.main.plot.yAxis',
        target : 'title',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryAxisTitle'
      },
      {
        targetModule : 'root.main.plot.yAxis2',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'secondaryScale'
      }, {
        targetModule : 'root.main.plot.yAxis2',
        target : 'title',
        sourceModule : 'root.main.plot.plot',
        source : 'secondAxisTitle'
      },
      
      {
        targetModule : 'root.main.plot.yAxis',
        target : 'color',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryAxisColor'
      },
      {
        targetModule : 'root.main.plot.yAxis2',
        target : 'color',
        sourceModule : 'root.main.plot.plot',
        source : 'secondAxisColor'
      },
      {
        targetModule : 'root.main.plot.xAxis',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'categoryScale'
      },
      {
        targetModule : 'root.legends.legend',
        target : 'colorPalette',
        sourceModule : 'root.main.plot.plot',
        source : 'getColorPalette'
      },
      {
        targetModule : 'root.legends.legend',
        target : 'shapes',
        sourceModule : 'root.main.plot.plot',
        source : 'shapePalette'
      }
      ],
      events : [  {
          targetModule : 'root.interaction',
          listener : 'registerEvent',
          sourceModule : 'root.main',
          type : 'initialized.interaction'
        }, {
            targetModule : 'root.tooltip',
            listener : 'showTooltip',
            sourceModule : 'root.main',
            type : 'showTooltip'
        }, {
            targetModule : 'root.tooltip',
            listener : 'hideTooltip',
            sourceModule : 'root.main',
            type : 'hideTooltip'
        } ]
    }
  };

  Manifest.register(multiVBarChart);
});
define('sap/viz/manifests/MultiDualHorizontalLineChart',['sap/viz/manifests/Viz','sap/viz/manifests/BaseChart','sap/viz/modules/manifests/XYContainer',
'sap/viz/modules/manifests/TableContainer','sap/viz/modules/manifests/Axis',
'sap/viz/modules/manifests/xy/Line','sap/viz/manifests/BaseMultipleChart',
'sap/viz/manifests/BaseMultipleXYChart','sap/viz/manifests/MultiHorizontalLineChart'],
function Setup(Manifest) {
  var multiBarChart = {
    id : 'viz/multi_dual_horizontal_line',
    name : 'IDS_MULTIDUALHORIZONTALLINECHART',
    base : 'viz/multi_horizontal_line',
    modules : {
      root : {
        modules : {
          main : {
            configure : {
              properties : { 'mergeDataRange' : ['primary', 'second'] }
            },
            modules: {
              plot : {
                id : 'sap.viz.modules.xycontainer',
                modules : {
                  plot : {
                    configure : {
                      propertiesOverride : {
                        primaryValuesColorPalette : { isExported: true },
                        secondaryValuesColorPalette: { isExported: true }
                      }
                    }
                  },
                  xAxis:{
                    id : 'sap.viz.modules.axis',
                    configure:{
                      description : 'Settings for the value axis at left or bottom of an XY chart with 2 value axis.'
                    }
                  },
                  xAxis2 : {
                    id : 'sap.viz.modules.axis',
                    configure : {
                      description : 'Settings for the value axis at right or top of an XY chart with 2 value axis.',
                      propertyCategory : 'xAxis2',
                      properties : {
                        title : { visible : false },
                        gridline : { visible : false },
                        type : 'value',
                        position : 'top'
                      },
                      propertiesOverride : {
                        title : { isExported : false }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    
    feeds : {
      multiplier:{ max:1 },
      secondaryValues: { min: 1, max : Number.POSITIVE_INFINITY },
      axisLabels : { max:1, acceptMND: -1 },
      regionColor : { acceptMND: 1 }
    },
    dependencies : {
      attributes : [
      {
        targetModule : 'root.main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'root.main.plot.xAxis',
        source : 'range'
      },
      {
        targetModule : 'root.main.plot.plot',
        target : 'secondDataRange',
        sourceModule : 'root.main.plot.xAxis2',
        source : 'range'
      },
      {
        targetModule : 'root.main.xAxis2',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'xCategoryScale'
      }, 
      {
        targetModule : 'root.main.yAxis',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'yCategoryScale'
      },
      {
        targetModule : 'root.main',
        target : 'primaryDataRange',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'root.main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'root.main',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'root.main',
        target : 'secondDataRange',
        sourceModule : 'root.main.plot.plot',
        source : 'secondDataRange'
      },
      {
        targetModule : 'root.main.plot.plot',
        target : 'secondDataRange',
        sourceModule : 'root.main',
        source : 'secondDataRange'
      },
      {
        targetModule : 'root.main.plot.xAxis',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryScale'
      },{
        targetModule : 'root.main.plot.xAxis',
        target : 'title',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryAxisTitle'
      },
      {
        targetModule : 'root.main.plot.xAxis2',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'secondaryScale'
      },{
        targetModule : 'root.main.plot.xAxis2',
        target : 'title',
        sourceModule : 'root.main.plot.plot',
        source : 'secondAxisTitle'
      },
      {
        targetModule : 'root.main.plot.xAxis',
        target : 'color',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryAxisColor'
      },
      {
        targetModule : 'root.main.plot.xAxis2',
        target : 'color',
        sourceModule : 'root.main.plot.plot',
        source : 'secondAxisColor'
      },
      {
        targetModule : 'root.main.plot.yAxis',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'categoryScale'
      }, 
      {
        targetModule : 'root.legends.legend',
        target : 'colorPalette',
        sourceModule : 'root.main.plot.plot',
        source : 'getColorPalette'
      },
      {
        targetModule : 'root.legends.legend',
        target : 'shapes',
        sourceModule : 'root.main.plot.plot',
        source : 'shapePalette'
      }
      ]
    }
  };

  Manifest.register(multiBarChart);
});
define('sap/viz/modules/pie/sector',['sap/viz/modules/Constants','sap/viz/util/NumberUtils'],
function Setup( Constants, NumberUtils ) {
  var CLASSDATAPOINT = Constants.CSS.CLASS.DATAPOINT,
      CLASSMORPHABLEDATAPOINT = Constants.CSS.CLASS.MORPHABLEDATAPOINT;
      
  var CLASSDATAPOINTCOMBINED = CLASSDATAPOINT + ' ' + CLASSMORPHABLEDATAPOINT;
  
  var pieLayout = d3.layout.pie().sort(null).value(function( d ) {
    return d.v;
  });

  function SectorData( mvObject, dimValueObjects, color, r, value, startAngle, endAngle, p ) {
    this.dimValueObjects = dimValueObjects;
    this.color = color;
    this.r = r;
    this._value = value;
    this.startAngle = startAngle;
    this.endAngle = endAngle;
    this.p = p;
    this.decoras = [];

    for ( var i in mvObject) {
      if ( mvObject.hasOwnProperty(i) ) {
        this[i] = mvObject[i];
      }
    }
  }

  SectorData.prototype = {
    midAngle : function() {
      return (this.endAngle + this.startAngle) / 2;
    },

    dimValues : function() {
      return this.dimValueObjects.map(function( o ) {
        var ret;
        if ( o.info ) {
          var clobj = o.info.customlabel;
          if ( clobj ) {
            if ( clobj.type === 'url' ) {
              ret = o.val;
            } else if ( clobj.type === 'string' ) {
              ret = clobj.val;
            }
          } else {
            ret = o.val;
          }
        } else {
          ret = o.val;
        }
        return ret;
      });
    },

    value : function( format ) {
      var v = this._value;
      if ( format ) {
        return d3.format(format)(v);
      }
      return v;
    },

    proportion : function( format ) {
      var v = (this.endAngle - this.startAngle) / (2 * Math.PI);
      if ( format ) {
        return d3.format(format)(v);
      }
      return v;
    }
  };

  function sectorDatas( d, effectManager ) {
    var mvs = d.measure.rows[0];
    var dimensions = d.dimensions;

    var domain = [];
    var datas = mvs.map(function( mv, i ) {
      domain.push(i);
      return {
        v : mv.val,
        i : i
      };
    }).filter(function( o ) {
      var v = o.v;
      return (!NumberUtils.isNoValue(v)) && v > 0;
    });

    var color = d.color.domain(domain);
    var r = d.or;
    var result = pieLayout(datas).map(function( data ) {
      var index = data.data.i;
      var fillID = effectManager.register({
        drawingEffect : d.drawingEffect,
        graphType : 'sector',
        fillColor : color(index),
        direction : 'vertical',
        radius : r
      });
      return new SectorData(mvs[index], dimensions.map(function( dimVs ) {
        return dimVs.rows[index];
      }), fillID, r, data.value, data.startAngle, data.endAngle, d.p);
    });
    return result;
  }

  var module = function() {
    function sector( sectorGroup, effectManager, styleManager ) {
      var sectors = module.all(sectorGroup).data(function( d ) {
        return sectorDatas(d, effectManager);
      });
      sectors.exit().remove();
      var newSectors = sectors.enter().append('svg:g').attr('class', 'v-datashape').append('svg:path');
      styleManager.queryDefault("v-sector").toAttrs(newSectors);
      sectors.attr('transform', null).select('g.v-datashape path').attr("fill", function( d ) {
        return d.color;
      }).attr("d", d3.svg.arc().outerRadius(function( d ) {
        return d.r;
      })).classed(CLASSDATAPOINTCOMBINED, true)
      .classed(Constants.CSS.CLASS.DATAPOINTDEFAULT, true)
      .classed("viz-pie-sector", true).classed("v-sector", true).attr('fill-opacity', null);
    }

    return sector;
  };

  module.all = function( sectorGroup ) {
    return sectorGroup.selectAll("g.v-datashape");
  };

  return module;
});
define('sap/viz/modules/pie/selection',['sap/viz/modules/pie/sector','sap/viz/modules/Constants', 'sap/viz/base/UADetector'],
function Setup( sectorModule, Constants, UADetector ) {
  var selectedSectorClass = Constants.CSS.CLASS.DATAPOINTSELECTED;
  var selectedDataLabel;
  function select( sect, flag, noAnimation ) {
    sect.classed(selectedSectorClass, flag).attr("fill-opacity", flag ? "1" : null);
    var dx = 0, dy = 0;
    if ( !noAnimation ) {
      sect = sect.transition().duration(200);
    }
    sect.each(function( d ) {
      dx = 0, dy = 0;
      if ( flag ) {
        if ( this.parentNode.parentNode.childNodes.length !== 1 ) {
          var a = d.midAngle();
          var r = d.r;
          var sectorMoveOffset;
          if ( r >= 96 ) {
            sectorMoveOffset = 6;
          } else if ( r >= 24 ) {
            sectorMoveOffset = 4;
          } else {
            sectorMoveOffset = 2;
          }
          dx = sectorMoveOffset * Math.sin(a);
          dy = -sectorMoveOffset * Math.cos(a);
        }
      }

      d3.select(this.parentNode).attr('transform', "translate(" + dx + "," + dy + ")");
    });
    sect.each('start', function( d ) {
      var transformStr = d3.select(this.parentNode).attr('transform');
      d.decoras.forEach(function( element, index, array ) {
        selectedDataLabel = d3.select(element);
        /**
         * we can't get the value in the start of the animation d3.select(this).attr('transform')
         */
        selectedDataLabel.transition().attr('transform', transformStr);
        if ( selectedDataLabel[0][0] !== null ) {
          if ( dx === 0 && dy === 0 ) {
            selectedDataLabel.attr('fill-opacity', null);
          } else {
            selectedDataLabel.attr('fill-opacity', '1');
          }
        } else {
          selectedDataLabel.attr('fill-opacity', '1');
        }
      }, this);
    });
  }

  function selected( sect ) {
    return sect.classed(selectedSectorClass);
  }

  return function() {
    return {
      allSelected : function( sectorGroup ) {
        return sectorGroup.selectAll("." + selectedSectorClass);
      },

      select : function( s, flag ) {
        select(s, flag);
      },

      clear : function( g, flag ) {
        /*
         * fix bug: https://tipjira.pgdev.sap.corp/browse/BITVIZA-2017
         * we found that if we make a big Dom element change can trigger the browser to render the element again.
         */
        if( UADetector.isIE()){
          g.attr('visibility', 'hidden');
          g.attr('visibility', 'visible');
        }
        g.attr("fill-opacity", flag ? "0.4" : null);
      },

      selected : function( sect ) {
        return sect.classed(selectedSectorClass);
      },

      clearAll : function( sectorGroup ) {
        var selected = this.allSelected(sectorGroup);
        if(selected.length === 0){
          this.clear(sectorGroup, false);
        }else{
          selected.call(select, true);
        }
      }
    };
  };
});

define('sap/viz/modules/pie/tooltip',['sap/viz/util/TextUtils','sap/viz/base/UADetector','sap/viz/base/utils/ObjectUtils'],
function Setup( TextUtils, UADetector, ObjectUtils ) {
  var wrapperClass = "v-pie-tooltip", caretClass = "v-pie-tooltip-caret", minRadius = 8.9 * 14 / 2;
  var caretAngle = 60, textsVSpacing = 8;

  var oldTextsClassNames = ["viz-pie-tooltip-label-dimensions", "viz-pie-tooltip-label-value",
      "viz-pie-tooltip-label-percentage"];
  var textClassNames = ["v-tooltip-label", "v-tooltip-value", "v-tooltip-percentage"];

  function renderCaret( p ) {
    var c = p.append("svg:path").attr("class", caretClass).attr("d", "M 0 0 Z").attr("fill", "#fff");
    if ( UADetector.isSafari() ) {
      c.style("-webkit-svg-shadow", "0 0 10px rgba(0, 0, 0, 0.25)");
    } else {
      var shadowFilterId = "tooltip-caret-shadow-" + ObjectUtils.guid();
      p.append("defs").call(createShadowFilterDef, shadowFilterId);
      c.attr("filter", "url(#" + shadowFilterId + ")");
    }
  }

  function createShadowFilterDef( defs, id ) {
    var shadowFilter = defs.append("filter").attr("id", id);

    shadowFilter.append("feGaussianBlur").attr("in", "SourceAlpha").attr("stdDeviation", 3).attr("result", "blur");
    var feMerges = shadowFilter.append("feMerge");
    feMerges.append("feMergeNode").attr("in", "blur");
    feMerges.append("feMergeNode").attr("in", "SourceGraphic");
  }

  function renderTexts( p, styleManager ) {
    for ( var i = 0; i < 3; i++) {
      var className = textClassNames[i];

      var text = p.append("svg:text").attr("dominant-baseline", "central").attr("text-anchor", "middle");

      styleManager.queryDefault(className).toAttrs(text);

      text.attr("class", oldTextsClassNames[i] + " " + className).datum(function( d ) {
        return {
          text : ""
        };
      });
    }
  }

  function texts( p ) {
    return p.selectAll("text");
  }

  function adjustTexts( texts, styleManager ) {
    var textClass1 = textClassNames[1];
    var text1Height;
    texts.each(function( d ) {
      d.r = d3.select(this.parentNode).datum().r;
    }).filter("." + textClass1).attr("dy", function( d ) {
      var dy = 0, txt = d.text;
      if ( UADetector.isIE() ) {
        dy = TextUtils.verticalCentralOffset(txt, this);
      }

      TextUtils.ellipsisInCircle(txt, this, d.r, 0, styleManager.cssText(textClass1));
      text1Height = this.getBBox().height;

      return dy;
    });
    texts.filter(":not(." + textClass1 + ")").attr("dy", function( d, i ) {
      var txt = d.text;
      var txtHeight = TextUtils.measure(txt, this).height;

      var dy = (UADetector.isIE() ? (i === 0 ? 0 : txtHeight) : (txtHeight / 2)) + text1Height / 2 + textsVSpacing;

      var maxLength = Math.sqrt(Math.pow(d.r, 2) - Math.pow(txtHeight + text1Height / 2 + textsVSpacing, 2)) * 2;

      TextUtils.ellipsis(txt, this, maxLength, styleManager.cssText(textClassNames[i === 0 ? 0 : 2]));
      if ( i === 0 ) {
        dy = -dy;
      }

      return dy;
    });
  }

  function normalizeAngle( a ) {
    a %= 360;

    if ( a < 0 ) {
      a += 360;
    }
    return a;
  }

  function caretRotateTween( el, endAngle ) {
    var transformList = el.transform.baseVal;
    var startAngle = transformList.numberOfItems === 0 ? 0 : normalizeAngle(transformList.getItem(0).angle);

    var endAngles = [];
    endAngles[0] = normalizeAngle(endAngle);
    endAngles[1] = endAngles[0] - 360;
    endAngles[2] = endAngles[0] + 360;

    var minRange = 360, index = null;
    for ( var i = 0; i < endAngles.length; i++) {
      var range = Math.abs(endAngles[i] - startAngle);
      if ( range < minRange ) {
        minRange = range;
        index = i;
      }
    }

    var interpolator = d3.interpolateNumber(startAngle, endAngles[index]);
    return function( t ) {
      return "rotate(" + interpolator(t) + ")";
    };
  }

  function computeCaretSize( or ) {
    if ( or >= 12 * 14 ) {
      return 14;
    }

    if ( or >= 8 * 14 ) {
      return 0.8 * 14;
    }

    return 0.5 * 14;
  }

  return function() {
    function tooltip( p, styleManager ) {
      var wrapper = p.selectAll("g." + wrapperClass).data(function( d, i ) {
        var data;
        if ( d.or > minRadius ) {
          data = [{
            r : d.ir,
            caretSize : computeCaretSize(d.or)
          }];
        } else {
          data = new Array(0);
        }
        return data;
      });
      wrapper.exit().remove();
      
      texts(wrapper).call(adjustTexts, styleManager);
      
      wrapper.enter().append("svg:g").attr("class", wrapperClass).style("opacity", 0).attr("visibility", "hidden")
          .attr("pointer-events", "none").call(renderCaret).call(renderTexts, styleManager);
    }

    tooltip.select = function( p, dispatch ) {
      var wrapper = p.selectAll("g." + wrapperClass);
      if ( wrapper.empty() ) {
        return null;
      }

      return {
        show : function() {
          wrapper.attr("visibility", null).transition().duration(200).style("opacity", 1);
          dispatch.showTooltip();
          return this;
        },
        isShown : function(){
          return wrapper.attr('visibility') !== 'hidden';
        },
        hide : function() {
          wrapper.transition().each("end", function() {
            wrapper.attr("visibility", "hidden");
          }).duration(200).style("opacity", 0);
          dispatch.hideTooltip();
          return this;
        },
        texts : function() {
          var values = arguments;
          texts(wrapper).each(function( d, i ) {
            d.text = values[i];
          }).call(adjustTexts, values[3]);
          return this;
        },
        caret : function() {
          var caret = wrapper.select("." + caretClass);

          return {
            show : function() {
              caret.attr("d", function( d ) {
                var x = Math.tan(caretAngle * Math.PI / 360) * d.caretSize;
                var y = Math.sqrt(d.r * d.r - x * x);
                return "M 0 " + -(y + d.caretSize) + " L " + x + " " + -y + " A " + d.r + " " + d.r + " 0 1 1 " + -x +
                    " " + -y + " Z";
              });
              return this;
            },
            hide : function() {
              caret.attr("d", function( d ) {
                return "M 0 " + d.r + " A " + d.r + " " + d.r + " 0 1 1 0 " + -d.r + " A " + d.r + " " + d.r +
                    " 0 1 1 0 " + d.r + " Z";
              });
              return this;
            },
            rotateTo : function( angle ) {
              caret.transition().duration(200).attrTween("transform", function() {
                return caretRotateTween(this, angle * 180 / Math.PI);
              });

              return this;
            }
          };
        }
      };
    };

    return tooltip;
  };
});
define('sap/viz/modules/pie',['sap/viz/base/utils/oo', 'sap/viz/modules/Base', 'sap/viz/modules/pie/sector','sap/viz/modules/pie/selection','sap/viz/modules/pie/tooltip',
'sap/viz/util/TextUtils','sap/viz/util/ColorSeriesGenerator','sap/viz/modules/dispatch',
'sap/viz/base/UADetector','sap/viz/base/utils/FunctionUtils','sap/viz/base/utils/TypeUtils',
'sap/viz/base/utils/ObjectUtils','sap/viz/base/utils/Objects','sap/viz/format/FormatManager',
'sap/viz/lang/langManager','sap/viz/modules/util/BoundUtil','sap/viz/modules/util/dataUtil',
'sap/viz/modules/util/defaultSelectionUtil','sap/viz/modules/Constants'],
function Setup(oo, Base, sectorModule, selectionModule, tooltip, TextUtils, ColorSeriesGenerator, dispatch, UADetector,
    FunctionUtils, TypeUtils, ObjectUtils, Objects, formatManager, langManager, BoundUtil, dataUtil, defaultSelUtil,Constants ) {
  var horizontalMarginRatio = 2.414;

  var innerRadiusRatio = function( outerRadius ) {
    // 12em
    // return outerRadius >= 12 * 14 ? horizontalMarginRatio : 1.618;
    return horizontalMarginRatio;
  };
  
  var defaultPaddingValue = 6;

  var loadingAnimationDuration = 600;
  var defaultColorPalette = ColorSeriesGenerator.sap32();

  var id = "v-pie";

  var clipPathIdPrefix = id + "-clipPath-";
  var wrapperClass = id, mainshapeClass = 'v-datashapesgroup', donutTitleClass = "v-donut-title", sectorGroupClass = "v-sectorgroup";
  var CLASSDATAPOINTSELECTED = Constants.CSS.CLASS.DATAPOINTSELECTED,
      CLASSDATAPOINTHOVER = Constants.CSS.CLASS.DATAPOINTHOVER,
      CLASSDATAPOINTDEFAULT = Constants.CSS.CLASS.DATAPOINTDEFAULT,
      CLASSDATAPOINT = Constants.CSS.CLASS.DATAPOINT;
  var selection = selectionModule();

  var tooltipFunc = tooltip();

  var sectorFunc = sectorModule();

  var rotateTootltipBySector = function( d, tip, caret, styleManager ) {
    if ( !caret ) {
      caret = tip.caret();
    }
    caret.show().rotateTo(d.midAngle());
    var tipValue, tipPercentage;
    tipValue = d.value();
    tipPercentage = d.proportion();
    if ( TypeUtils.isExist(d.p.tooltip.formatString) ) {
      tipValue = formatManager.format(tipValue, d.p.tooltip.formatString[0]);
      tipPercentage = formatManager.format(tipPercentage, d.p.tooltip.formatString[1]);
    } else {
      tipValue = d.value(d.p.tooltip.valueFormat);
      tipPercentage = d.proportion(d.p.tooltip.percentageFormat);
    }

    tip.texts(d.dimValues().map(function( s ) {
      return s === null ? langManager.get('IDS_ISNOVALUE') : s;
    }).filter(function( a ) {
      return a !== '';
    }).join(" - "), tipValue, tipPercentage, styleManager).show();
  };

  var donutTitle = function( wrapper ) {
    var text = wrapper.selectAll("text." + donutTitleClass).data(function( d ) {
      if ( d.p.isDonut ) {
        var title = d.measure.col;
        if ( title === null ) {
          title = langManager.get('IDS_ISNOVALUE');
        }

        return [{
          width : d.ir,
          title : title
        }];
      }

      return [];
    });
    text.exit().remove();
    text.enter().insert("svg:text", "." + sectorGroupClass).attr("class", donutTitleClass).attr("font-family",
        "'Open Sans',Arial,Helvetica,sans-serif").attr("text-anchor", "middle").attr("font-weight", "bold").attr(
        "font-size", "16px").attr("fill", "#333").attr("dominant-baseline", "middle");

    text.each(function( d ) {
      TextUtils.ellipsisInCircle(d.title, this, d.width, 0);
    });
  };

  var calculateOuterRadiusByHeight= function( h , padding) {
    return h / 2 - padding;
  };

  var calculateOuterRadiusByWidth = function( w , padding) {
    var rCandidate = Math.max(w / 2 / (1 + 1 / horizontalMarginRatio), padding * horizontalMarginRatio);
    return Math.min(rCandidate, w / 2 - padding);
  };

  var calculateOuterRadius = function( w, h, maxRadius , padding) {
    if ( maxRadius ) {
      return Math.min(h / 2, w / 2);
    }
    return Math.min(calculateOuterRadiusByHeight(h,padding), calculateOuterRadiusByWidth(w,padding));
  };

  var calculateInnerRadius = function( outerRadius ) {
    return outerRadius / innerRadiusRatio(outerRadius);
  };

  var clipPathArc = d3.svg.arc();

  var clipPathTween = function( d ) {
    var clipPathInterpolate = d3.interpolateNumber(d.startAngle, d.endAngle);
    return function( t ) {
      d.endAngle = clipPathInterpolate(t);
      return clipPathArc(d);
    };
  };

  var highlight = function( el, flag, onSector, tip, sectorGroup, styleManager , isFromDatapoint) {
    selection.select(TypeUtils.isArray(el) ? d3.selectAll(el) : d3.select(el), flag);
    if ( onSector === false ) {
      refreshTooltip(tip, sectorGroup, styleManager, isFromDatapoint, flag);
     }else if(onSector === 'single'){
      var s = d3.select(el);
        var d = s.datum();
        if ( d.p.tooltip.visible ) {
          if ( tip ) {
            rotateTootltipBySector(d, tip, undefined, styleManager);
          }
        } else {
          if ( tip ) {
            tip.hide();
          }
        }
    }
  };

  var refreshTooltip = function( tip, sectorGroup, styleManager, isFromDatapoint, flag) {
    if ( !tip ) {
      return;
    }
    var selectedSectors = selection.allSelected(sectorGroup);

    if ( selectedSectors.empty() ) {
      tip.hide();
    } else if ( !UADetector.isMobile() ) {
      // currently, to keep behavior consistent with other charts, we do not show aggregate value;
      var d = sectorGroup.datum();
      if ( !d.p.tooltip.visible ) {
        tip.hide();
      } else {
        var sum = 0;
        var proportionSum = 0;
        var numer = 0;
        selectedSectors.each(function( d ) {
          sum += d.val;
          proportionSum += d.proportion();
          numer++;
        });
        var caret = tip.caret();
        if( isFromDatapoint === false || numer !== 1 || flag === false){
          tip.texts(numer + " selected", d3.format(d.p.tooltip.valueFormat)(sum), d3.format(
                  d.p.tooltip.percentageFormat)(proportionSum), styleManager);
          caret.hide();
          if( !tip.isShown() ){
            tip.show();
          }
        } else {
          rotateTootltipBySector(selectedSectors.datum(), tip, caret, styleManager);
        }
      }
    }
  };

  var Pie = function( manifest, ctx ) {
    this._pie_width = null;
    this._pie_height = null; 
    this._pie_data = null; 
    this._pie_props = manifest.props(null); 
    this._pie_colorPalette = undefined;
    this._pie_plotScale = this._pie_props.plotScale;
    this._pie_effectManager = ctx.effectManager;
    this._pie_styleManager = ctx.styleManager;
    this._pie_widthFunctor = undefined;
    this._pie_heightFunctor = undefined;
    this._pie_propsFunctor = FunctionUtils.noop;

    this._pie_parent = undefined;
    this._pie_sectorGroup = undefined;
    this._pie_wrapper = undefined;
    this._pie_tip = undefined;

    this._pie_isDataSchemaChanged = false;
    this._pie_isDataLoading = true;
    this._pie_isSizeChanged = false;
    this._pie_isDatasetChanged = false;

    this._pie_hasDefaultSelection = false;
    
    this._pie_dispatch = dispatch("selectData", "deselectData", "initialized", 'startToInit', "showTooltip", "hideTooltip");
  };
  
  oo.extend(Pie, Base);
  
  Pie.prototype.render = function(selections){
    this._pie_parent = selections;
    BoundUtil.drawBound(this._pie_parent, this._pie_width, this._pie_height);

    this._pie_dispatch.startToInit();

    this._pie_wrapper = selections.selectAll("g." + wrapperClass).data(this._pie_pieWrapperData(this._pie_data));
    var wrapper = this._pie_wrapper;
    
    this._pie_wrapper.exit().each(function( d ) {
      document.documentElement.removeEventListener("keydown", d.keydownListener);
      delete d.keydownListener;
    }).remove();

    var enterWrapper = wrapper.enter().append("g").attr("class", wrapperClass);
    enterWrapper.append("g").attr("class", sectorGroupClass + (this._pie_props.isGeoPie ? "" : " " + mainshapeClass));

    var that = this;
    wrapper.attr("transform", function( d ) {
      if ( d.p.alignCenter ) {
        return null;
      }
      return "translate(" + d.w / 2 + "," + (d.p.valign === "center" ? d.h / 2 : (d.or + d.padding)) + ")" + 'scale(' +
          that._pie_plotScale + ')';
    });

    var clipPath = wrapper.selectAll(function() {
      var result = [];
      Array.prototype.forEach.call(this.childNodes, function( node ) {
        if ( node.tagName === 'clipPath' ) {
          result.push(node);
        }
      });
      return result;
    }).data(function( d ) {
      var result = [];
      var isDonut = d.p.isDonut;
      var animation = d.animation = that._pie_enableAnimation(d.p);
      if ( isDonut || animation ) {
        result.push({
          innerRadius : isDonut ? d.ir : 0,
          outerRadius : d.or + d.padding,
          startAngle : 0,
          endAngle : Math.PI * 2,
          animation : animation
        });
      }
      return result;
    });

    clipPath.exit().remove();
    clipPath.enter().append("svg:clipPath").attr("id", function() {
      var id, k = 0;
      while (true) {
        id = clipPathIdPrefix + (k++);
        if ( !document.getElementById(id) ) {
          break;
        }
      }
      this.parentNode.querySelector("." + sectorGroupClass).setAttribute("clip-path", "url(#" + id + ")");
      return id;
    }).append("svg:path").attr("clip-rule", "evenodd").attr("d", clipPathArc);

    wrapper.call(donutTitle);
    this._pie_sectorGroup = wrapper.select("g." + sectorGroupClass).call(sectorFunc, this._pie_effectManager, this._pie_styleManager);

    selection.clearAll(this._pie_sectorGroup);

    wrapper.call(tooltipFunc, this._pie_styleManager);
    
    this._pie_tip = tooltipFunc.select(wrapper, this._pie_dispatch);
    var tip = this._pie_tip;
    var selected = selection.allSelected(this._pie_sectorGroup);
    if ( tip && !selected.empty()) {
      refreshTooltip(this._pie_tip, this._pie_sectorGroup, this._pie_styleManager, false);
    }
    clipPath.filter(function( d ) {
      return d.animation;
    }).select(":first-Child").transition().duration(loadingAnimationDuration).each("end", function( d ) {
      var clipPathNode = this.parentNode;
      var wrapperNode = clipPathNode.parentNode;
      if ( wrapperNode ) {
        if ( d.innerRadius === 0 ) {
          wrapperNode.removeChild(clipPathNode);
          wrapperNode.querySelector("." + sectorGroupClass).removeAttribute("clip-path");
        }
        var wrapperData = d3.select(wrapperNode).datum();
        wrapperData.animationEnd = true;
        that._pie_fireInitializedEvent.call(that, wrapperData);
      }
    }).attrTween("d", clipPathTween);

    clipPath.filter(function( d ) {
      return !d.animation;
    }).select(":first-Child").attr("d", clipPathArc);

    wrapper.each(function( d ) {
      d.domInitialized = true;
      that._pie_fireInitializedEvent.call(that, d);
    });
    
    this._pie_isDataSchemaChanged = false, this._pie_isDataLoading = false, this._pie_isSizeChanged = false, this._pie_isDatasetChanged = false;
  };
    
  Pie.prototype._pie_enableAnimation = function( p ) {
    var hasAnmation = false;
    if ( this._pie_isDataLoading ) {
      hasAnmation = p.animation.dataLoading;
    } else if ( this._pie_isDatasetChanged ) {
      hasAnmation = p.animation.dataUpdating;
    } else if ( this._pie_isSizeChanged ) {
      hasAnmation = p.animation.resizing;
    }
    return hasAnmation;
  };

  Pie.prototype._pie_pieWrapperData = function( d ) {
    var p = this._pie_propsFunctor.apply(this, arguments);
    var w = this._pie_widthFunctor.apply(this, arguments);
    var h = this._pie_heightFunctor.apply(this, arguments);
    var padding = this._pie_calculatePadding(w, h);
    var or = calculateOuterRadius(w, h, p.maxRadius, padding);
    var colorRange = d3.functor(this._pie_colorPalette).apply(this, arguments);

    var result = {
      padding: padding,
      w : w,
      h : h,
      p : p,
      or : or,
      ir : calculateInnerRadius(or),
      color : colorRange ? d3.scale.ordinal().range(colorRange) : this._pie_defaultColorPalette.copy(),
      measure : d.getMeasureValuesGroupDataByIdx(0).values[0],
      dimensions : d.getAnalysisAxisDataByIdx(0).values
    };
    result.drawingEffect = result.p.drawingEffect;

    return [result];
  };

  Pie.prototype._pie_fireInitializedEvent= function( d ) {
    if ( d.domInitialized && (!d.animation || d.animationEnd) ) {
      setTimeout(this._pie_dispatch.initialized, 0);
    }
  };
  
  Pie.prototype._pie_hoverSector = function( s, flag ) {
    s.attr("fill-opacity", flag ? "1" : (selection.selected(s) ? "1" : null));
  };

  Pie.prototype.afterUIComponentAppear = function() {
    this._pie_dispatch.initialized();
  };

  Pie.prototype.dataLabel = function( _ ) {
  };

  Pie.prototype.parent = function() {
    return this._pie_parent;
  };

  Pie.prototype.clear = function( flag ) {
    selection.clear(this._pie_sectorGroup, flag);
    d3.selectAll("." + CLASSDATAPOINTHOVER).attr('fill-opacity', '1').attr('stroke-opacity', '1');
    if ( this._pie_hasDefaultSelection && !flag ) {
      defaultSelUtil.clearSelectionInfo(this._pie_parent, false, this._pie_sectorGroup);
    }
    return this;
  };

  Pie.prototype.highlight = function( el, onSector, selectionMode, /*if true, means the event is from datapoint, otherwise, it is from legend or lasso or label selection*/isFromDataPoint) {
    var s = TypeUtils.isArray(el) ? d3.selectAll(el) : d3.select(el);
     s.classed(CLASSDATAPOINTDEFAULT, false).classed(CLASSDATAPOINTHOVER, false);
    highlight(el, true, onSector, this._pie_tip, this._pie_sectorGroup, this._pie_styleManager, isFromDataPoint);
    if ( this._pie_hasDefaultSelection ) {
      defaultSelUtil.clearSelectionInfo(this._pie_parent, true, el);
    }
    return this;
  };

  Pie.prototype.unhighlight = function( el, onSector ) {
    highlight(el, false, onSector, this._pie_tip, this._pie_sectorGroup, this._pie_styleManager);
    var s = TypeUtils.isArray(el) ? d3.selectAll(el) : d3.select(el);
    if( !UADetector.isMobile() ){
      if(onSector !== false){
        s.classed(CLASSDATAPOINTHOVER, true);
        this._pie_hoverSector(s, true);
      }else {
         s.classed(CLASSDATAPOINTDEFAULT, true);
      }
    } else {
      s.classed(CLASSDATAPOINTDEFAULT, true);
    }
    
    if ( this._pie_hasDefaultSelection ) {
      defaultSelUtil.clearSelectionInfo(this._pie_parent, false, el);
    }
    return this;
  };

  Pie.prototype.mouseover = function( el ) {
    var s = d3.select(el);
    if(!s.classed(CLASSDATAPOINTSELECTED))
    {
        s.classed(CLASSDATAPOINTDEFAULT, false).classed(CLASSDATAPOINTHOVER, true);
     }
    this._pie_hoverSector(s, true);
    var d = s.datum();
    if ( d.p.tooltip.visible ) {
      if ( this._pie_tip ) {
        rotateTootltipBySector(d, this._pie_tip, undefined, this._pie_styleManager);
      }
    } else {
      if ( this._pie_tip ) {
        this._pie_tip.hide();
      }
    }
    return this;
  };

  Pie.prototype.mouseout = function( el ) {
    if ( el ) {
      var sect = d3.select(el);
      d3.selectAll("." + CLASSDATAPOINTHOVER).classed(CLASSDATAPOINTHOVER, false).classed(CLASSDATAPOINTDEFAULT, true);
      this._pie_hoverSector(sect, false);
    }
    if ( !this._pie_tip ) {
      return;
    }

    refreshTooltip(this._pie_tip, this._pie_sectorGroup, this._pie_styleManager, false);
    return this;
  };
  
  Pie.prototype._pie_calculatePadding = function(w, h)
  {
      var padding;
      var boundary = Math.min(w, h);
      if(boundary < defaultPaddingValue*2)
      {
          if(boundary < (defaultPaddingValue/4)*2)
          {
              if(boundary < (defaultPaddingValue/8)*2)
              {
                  padding = 0;
              }
              else
              {
                  padding = defaultPaddingValue/8;
              }
          }
          else
          {
              padding = defaultPaddingValue/4;
          }
      }
      else
      {
          padding = defaultPaddingValue;
      }
      return padding;
  };

    /**
     * get/set width
     */
    Pie.prototype.width = function( _ ) {
      if ( arguments.length === 0 ) {
        return this._pie_width;
      }
      this._pie_isSizeChanged = (!this._pie_isSizeChanged && (_ === this._pie_width)) ? false : true;
      this._pie_width = _;
      this._pie_widthFunctor = d3.functor(this._pie_width);
      return this;
    };

    /**
     * get/set height
     */
    Pie.prototype.height = function( _ ) {
      if ( arguments.length === 0 ) {
        return this._pie_height;
      }
      this._pie_isSizeChanged = (!this._pie_isSizeChanged && (_ === this._pie_height)) ? false : true;
      this._pie_height = _;
      this._pie_heightFunctor = d3.functor(this._pie_height);
      return this;
    };
    
    /**
     * get/set size
     */
    Pie.prototype.size = function(_) {
      if ( arguments.length === 0 ) {
        return {
          width : this.width(),
          height : this.height()
        };
      }
      this._pie_isSizeChanged = (!this._pie_isSizeChanged && (_.width === this._pie_width) && (_.height === this._pie_height)) ? false : true;
      this._pie_width = _.width;
      this._pie_height = _.height;
      this._pie_widthFunctor = d3.functor(this._pie_width);
      this._pie_heightFunctor = d3.functor(this._pie_height);
      return this;
    };

    /**
     * get/set data
     */
    Pie.prototype.data = function( _ ) {
      if ( arguments.length === 0 ) {
        return this._pie_data;
      }
      this._pie_isDatasetChanged = true;
      this._pie_isDataSchemaChanged = false;
      if ( !dataUtil().hasSameSchema(this._pie_data, _) ) {
        this._pie_isDataSchemaChanged = true;
      }
      this._pie_data = _;

      var info = this._pie_data.getMeasureValuesGroupDataByIdx(0).values[0].rows[0][0].info;
      if ( info && info.defaultSelection ) {
        this._pie_hasDefaultSelection = true;
      } else {
        this._pie_hasDefaultSelection = false;
      }

      return this;
    };

    /**
     * get event dispath
     */
    Pie.prototype.dispatch = function( _ ) {
      return this._pie_dispatch;
    };

    /**
     * get/set properties
     */
    Pie.prototype.properties = function( _ ) {
      if ( arguments.length === 0 ) {
        return this._pie_props;
      }
      Objects.extend(true, this._pie_props, _);
      this._pie_plotScale = this._pie_props.plotScale;
      this._pie_propsFunctor = d3.functor(this._pie_props);

      if ( typeof (props) === "function" ) {
        this._pie_colorPalette = function( d, i ) {
          return this._pie_propsFunctor.apply(this, arguments).colorPalette;
        };
      } else if ( this._pie_props.colorPalette ) {
        this._pie_colorPalette = this._pie_props.colorPalette;
      }
      return this;
    };

    /**
     * get/set color palette
     */
    Pie.prototype.colorPalette = function( _ ) {
      if ( arguments.length === 0 ) {
        return this._pie_colorPalette || this._pie_defaultColorPalette.range();
      }
      this._pie_colorPalette = _;
      return this;
    };
  return Pie;
});

define('sap/viz/feeds/Pie',['sap/viz/feeds/Manifest','sap/viz/data/feed/Constants'],
function Setup(Manifest, constants) {
  var feeds = {
    id : "pie",
    feeds : [ {
      'id' : 'pieSectorColor',
      'name' : 'IDS_PIESECTORCOLORNAME',
      'type' : constants.Type.Dimension,
      'min' : 1,
      'max' : 1,
      'aaIndex' : 1,
      'acceptMND': -1
    }, {
      'id' : 'pieSectorSize',
      'name' : 'IDS_PIESECTORSIZE',
      'type' : constants.Type.Measure,
      'min' : 1,
      'max' : 1,
      'mgIndex' : 1
    }, {
      'id' : 'pieDepthSize',
      'name' : 'IDS_PIEDEPTHSIZE',
      'type' : constants.Type.Measure,
      'min' : 1,
      'max' : 1,
      'mgIndex' : 2
    } ]
  };
  Manifest.register(feeds);
});
define('sap/viz/modules/manifests/Pie',['sap/viz/modules/manifests/Module','sap/viz/modules/Constants','sap/viz/modules/pie','sap/viz/feeds/Pie'],
function Setup( Manifest, Constants, fn ) {
  var module = {
    'id' : 'sap.viz.modules.pie',
    'type' : Constants.Type.Chart,
    'name' : 'pie',
    'properties' : {
      'animation' : {
        'name' : 'animation',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'dataLoading' : {
            'name' : 'dataLoading',
            'supportedValueType' : 'Boolean',
            'defaultValue' : true,
            'description' : 'Set enable/disable data loading animation of plot area.'
          },
          'dataUpdating' : {
            'name' : 'dataUpdating',
            'supportedValueType' : 'Boolean',
            'defaultValue' : true,
            'description' : 'Set enable/disable data updating animation of plot area.'
          },
          'resizing' : {
            'name' : 'resizing',
            'supportedValueType' : 'Boolean',
            'defaultValue' : true,
            'description' : 'Set enable/disable resizing animation of plot area.'
          }
        },
        'description' : 'Settings for animation of plot area.',
        'example': "<a href='"+Constants.DocExample.SnippetUrl+"8535' target='_blank'>"+Constants.DocExample.TryThisValue+"</a>"
      },
      'colorPalette' : {
        'name' : 'colorPalette',
        'supportedValueType' : 'StringArray',
        'defaultValue' : Constants.COLOR.SAPColorSingleAxis,
        'description' : 'Set the color palette for sectors.',
        'example': "<a href='"+Constants.DocExample.SnippetUrl+"4449' target='_blank'>"+Constants.DocExample.TryThisValue+"</a>"
      },
      'isDonut' : {
        'name' : 'isDonut',
        'supportedValueType' : 'Boolean',
        'defaultValue' : false,
        'description' : 'Set whether is a donut or pie.'
      },
      'isGeoPie' : {
        'name' : 'isGeoPie',
        'supportedValueType' : 'Boolean',
        'defaultValue' : false,
        'description' : 'Set whether is a geo pie.',
        'isExported' : false
      },
      'valign' : {
        'name' : 'valign',
        'supportedValueType' : 'String',
        'supportedValues' : ['top', 'center'],
        'defaultValue' : "top",
        'description' : 'Set vertical aligment.',
        'isExported' : false
      },
      'tooltip' : {
        'name' : 'tooltip',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'visible' : {
            'name' : 'visible',
            'supportedValueType' : 'Boolean',
            'defaultValue' : true,
            'description' : 'Set whether tooltip is enabled.'
          },
          'valueFormat' : {
            'name' : 'valueFormat',
            'supportedValueType' : 'String',
            'defaultValue' : 'n',
            'description' : 'Set the number format of measure value in tooltip.',
            'isExported' : false
          },
          'percentageFormat' : {
            'name' : 'percentageFormat',
            'supportedValueType' : 'String',
            'defaultValue' : ".0%",
            'description' : 'Set the number format of percentage label in tooltip.',
            'isExported' : false
          },
          'formatString' : {
            'name' : 'formatString',
            'supportedValueType' : 'StringArray',
            'defaultValue' : null,
            'description' : 'Set format string of tooltip. The first string is applied to value and the second is applied to percentage.Any character in "MDYHSAmdyhsa#?%0@" is reserved as a token for format code.'
          }
        },
        'description' : 'Settings for tooltip related properties.'
      },
      'drawingEffect' : {
        'name' : 'drawingEffect',
        'supportedValueType' : 'String',
        'supportedValues' : ['normal', 'glossy'],
        'defaultValue' : 'normal',
        'description' : 'Set drawing effect of Pie.',
        'isExported' : true
      },
      'plotScale' : {
        'name' : 'plotScale',
        'supportedValueType' : 'PositiveFloat',
        'defaultValue' : 1,
        'description' : 'Set plot scale of Pie.',
        'isExported' : false,
        'isExperimental' : true
      }
    },
    'events' : {
      'initialized' : Constants.Event.Initialized.desc,
      'selectData' : Constants.Event.SelectData.desc,
      'deselectData' : Constants.Event.DeSelectData.desc,
      'showTooltip' : Constants.Event.TooltipShow.desc,
      'hideTooltip' : Constants.Event.TooltipHide.desc
    },
    'feeds' : {
      id : "pie",
      configure : {
        pieDepthSize : null
      }
    },
    'css' : {
      '.v-tooltip-label.viz-pie-tooltip-label-dimensions' : {
        'description' : 'Define style for the first label(dimension values) in tooltip.',
        'value' : {
          'font-family' : "'Open Sans', Arial, Helvetica, sans-serif",
          'font-size' : '12px',
          'font-weight' : 'normal',
          'fill' : '#000000'
        }
      },
      '.v-tooltip-value.viz-pie-tooltip-label-value' : {
        'description' : 'Define style for the second label(measure value) in tooltip.',
        'value' : {
          'font-family' : "'Open Sans', Arial, Helvetica, sans-serif",
          'font-size' : '13px',
          'font-weight' : 'bold',
          'fill' : '#000000'
        }
      },
      '.v-tooltip-percentage.viz-pie-tooltip-label-percentage' : {
        'description' : 'Define style for the third label(percentage) in tooltip.',
        'value' : {
          'font-family' : "'Open Sans', Arial, Helvetica, sans-serif",
          'font-size' : '10.5px',
          'font-weight' : 'normal',
          'fill' : '#333333'
        }
      },
      '.v-sector.viz-pie-sector' : {
        'description' : 'Define style for sector in pie.',
        'value' : {
          'stroke' : '#FFFFFF'
        }
      }
    },
    fn : fn
  };

  Manifest.register(module);
});
define('sap/viz/manifests/pie/PieChart',['sap/viz/manifests/Viz','sap/viz/manifests/BaseSingleChart','sap/viz/modules/manifests/RootContainer',
'sap/viz/modules/manifests/Pie','sap/viz/modules/manifests/DataLabel',
'sap/viz/modules/manifests/controller/Interaction','sap/viz/modules/manifests/DataTransform'],
function Setup ( Manifest ) {
  var pieChart = {
    id : 'viz/pie',
    name : 'IDS_PIECHART',
    base : 'riv/base/single',
    modules : {
      dataTransform : {
        id : 'sap.viz.modules.datatransform',
        configure : {
          propertyCategory : 'dataTransform',
          properties : {
            autoBinning : {
              enable : false     
            },
            dataSampling : {
              enable : null
            }
          },
          propertiesOverride : {
            dataSampling : {
              isExported : false
            }
          }
        }
      },
      root : {
        modules : {
          legends : {
            modules : {
               legend : {
                data : { aa : [ 1 ] }
              }
            }
          },
          
          interaction : {
            id : 'sap.viz.modules.controller.interaction',
            configure : {
              clientID : 'main',
              propertyCategory : 'interaction',
              properties : {
                supportedEventNames : [ 'mouseup', 'mouseover', 'mouseout', 'touchstart' ],
                holdSelection : true
              }
            }
          },
          
          main : {
            modules : {
              plot : {
                id : 'sap.viz.modules.pie',
                configure : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory : 'plotArea'
                }
              },
              dataLabel : {
                id : 'sap.viz.modules.datalabel',
                configure : {
                  propertyCategory : 'dataLabel',
                  properties : {
                    paintingMode : 'polarCoordinate',
                    visible : false,
                    type : 'label and value',
                    formatString : [['0.00%'],[]],
                    automaticInOutside : false,
                    outsideVisible : true    
                  },
                  propertiesOverride:{
                    position : {
                      isExported : false
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    dependencies : {
      attributes : [ {
        targetModule : 'root.legends.legend',
        target : 'colorPalette',
        sourceModule : 'root.main.plot',
        source : 'colorPalette'
      }, {
        targetModule : 'root.legends.legend',
        target : 'setSelectionMode',
        sourceModule : 'root.interaction',
        source : 'getSelectionMode'
      } ],
      events : [ {
        targetModule : 'root.interaction',
        listener : 'registerEvent',
        sourceModule : 'root.main.plot',
        type : 'initialized.interaction'
      }, {
        targetModule : 'root.interaction',
        listener : 'highlightedByLegend',
        sourceModule : 'root.legends.legend',
        type : 'highlightedByLegend'
      }, {
        targetModule : 'root.legends.legend',
        listener : 'deselectLegend',
        sourceModule : 'root.interaction',
        type : 'deselectLegend'
      } , {
        targetModule : 'root.main.dataLabel',
        listener : 'showLabel',
        sourceModule : 'root.main.plot',
        type : 'initialized.datalabel'
      }, {
        targetModule : 'root.main.dataLabel',
        listener : 'removeLabel',
        sourceModule : 'root.main.plot',
        type : 'startToInit.datalabel'
      }, {
        targetModule : 'root.interaction',
        listener : 'defaultSelection',
        sourceModule : 'root.main.plot',
        type : 'initialized.defaultSelection'
      }]
    }
  };

  Manifest.register(pieChart);
});
define('sap/viz/manifests/pie/DonutChart',['sap/viz/manifests/Viz','sap/viz/modules/manifests/RootContainer','sap/viz/manifests/pie/PieChart'],
function Setup ( Manifest ) {
  var donutChart = {
    'id' : 'viz/donut',
    'name' : 'IDS_DONUTCHART',
    base : 'viz/pie',
    'modules' : {
      root : {
        modules : {
          'main' : {
            'modules' : {
              'plot' : {
                'configure' : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                  'propertyCategory' : 'plotArea',
                  'properties' : {
                    'isDonut' : true
                  }
                }
              },
              dataLabel : {
                id : 'sap.viz.modules.datalabel',
                configure : {
                  propertyCategory : 'dataLabel',
                  properties : {
                    isDonut : true
                  }
                }
              }
            }
          }
        }
      }
    }
  };

  Manifest.register(donutChart);
});
define('sap/viz/modules/piewithdepth',['sap/viz/modules/pie/sector','sap/viz/modules/pie/selection','sap/viz/modules/pie/tooltip',
'sap/viz/util/TextUtils','sap/viz/util/ColorSeriesGenerator','sap/viz/modules/dispatch',
'sap/viz/base/UADetector','sap/viz/base/utils/FunctionUtils','sap/viz/base/utils/TypeUtils',
'sap/viz/base/utils/ObjectUtils','sap/viz/base/utils/Objects','sap/viz/format/FormatManager',
'sap/viz/lang/langManager','sap/viz/modules/util/BoundUtil','sap/viz/modules/util/tooltipDataHandler'],
function Setup(sectorModule, selectionModule, tooltip, TextUtils,
    ColorSeriesGenerator, dispatch, UADetector, FunctionUtils, TypeUtils,
    ObjectUtils, Objects, formatManager, langManager, BoundUtil, tooltipDataHandler) {

    var fn = function(manifest,ctx) {
        var width = 500, height = 300, padding = 0;
        var data = null, props = {};
        var zAngle = Math.PI / 4;
        var rx = 0, ry = 0, drx = 0, dry = 0, baseHeight = 0, bottomCX = 0, bottomCY = 0;
        var sum = 0, maxDepthVal = 0;
        var heightScale = d3.scale.linear();
        var color = ColorSeriesGenerator.sap32().range();
        var isDonut = false, number;
        var drawingEffect = "normal";
        var _selection, _transform;
        var rotationAngle = 0;
        var _dispatch = dispatch('selectData', 'deselectData', 'showTooltip', 'hideTooltip', 'initialized', 'startToInit');
        
        var CLASS_MARKER_SELECTED = "v-datapoint-selected",
            CLASS_MARKER_ORIGINAL = "v-datapoint-default",
            CLASS_DATAPOINT = "v-datashape v-datapoint v-morphable-datapoint",
            OPACITY = 1,
            OPACITY_UNSELECTED = '0.4';
        var markerStyle = {
            'stroke' : '#ffffff',
            'stroke-width' : 1
        };
        var selectedMarkerStyle = {
            'stroke' : '#333333',
            'stroke-width' : 1
        };

        var effectManager = ctx.effectManager;
        
        function pie(selection) {
            BoundUtil.drawBound(selection, width, height);
            _selection = selection;
            renderChart(selection);
            return pie;
        }


        pie.width = function(value) {
            if (!arguments.length) {
                return width;
            }
            width = value;
            if (TypeUtils.isExist(width) && TypeUtils.isExist(height)) {
                getPieLayout();
                heightScale.domain([0, maxDepthVal]).range([0, baseHeight]);
            }
            return pie;
        };

        pie.height = function(value) {
            if (!arguments.length) {
                return height;
            }
            height = value;
            if (TypeUtils.isExist(width) && TypeUtils.isExist(height)) {
                getPieLayout();
                heightScale.domain([0, maxDepthVal]).range([0, baseHeight]);
            }
            return pie;
        };

        pie.padding = function(value) {
            if (!arguments.length) {
                return padding;
            }
            padding = value;
            if (TypeUtils.isExist(width) && TypeUtils.isExist(height)) {
                getPieLayout();
                heightScale.domain([0, maxDepthVal]).range([0, baseHeight]);
            }
            return pie;
        };

        pie.properties = function(_) {
            if (!arguments.length) {
                return props;
            }
            Objects.extend(true, props, _);
            parseOptions();
            return pie;
        };

        pie.parent = function() {
            return _selection;
        };
        
        pie.dispatch = function(_) {
            return _dispatch;
        };
        
        pie.afterUIComponentAppear = function(){
          _dispatch.initialized(); 
        };
        
        pie.dataLabel = function(_) {
        };

        pie.data = function(value) {
            if (!arguments.length) {
                return data;
            }
            data = value;
            if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(data)){
                sum = 0;
                maxDepthVal = 0;
                calculateBoundaryValues();
                heightScale.domain([0, maxDepthVal]).range([0, baseHeight]);
            }
            return pie;
        };
        
        pie.colorPalette = function(_) {
            if (arguments.length === 0) {
                return color;
            }
            color = _;
            return pie;
        }; 
        
        pie.rotate = function(_) {
            if (number == 1) return pie; // no need rotate if only one sector
            if (arguments.length === 0) {
                return {
                    xAngle : 0,
                    yAngle : rotationAngle * 180 / Math.PI
                };
            }
            rotationAngle = _.yAngle * Math.PI / 180;
            renderChart(_selection);
            return pie;
        };
        
        pie.hoverOnPoint = function(_) {
            var item = _.target;
            if (item.parentNode) {
                item = d3.select(item.parentNode);
                if (item.attr('class') && item.attr('class').indexOf('v-datapoint') >= 0) {
                    var pos = {
                        x : _.x + _transform.e + 3, // workaround for Safari, since it cannot bubble event on tooltip
                        y : _.y + _transform.f
                    };
                    showTooltip(item.datum(), pos);
                    return;
                }
            }
            hideTooltip();
        };
        
        pie.blurOut = function(){
          hideTooltip();
        };
        
        pie.highlight = function(elems) {
            var item;
            elems = parseHighlightElems(elems);
            if (TypeUtils.isArray(elems)) {
                for (var i = 0, len = elems.length; i < len; i++) {
                    item = d3.select(elems[i]);
                    item.attr('class', CLASS_MARKER_SELECTED+' '+CLASS_DATAPOINT)
                    .attr('stroke', selectedMarkerStyle['stroke'])
                    .attr('stroke-width', selectedMarkerStyle['stroke-width']);
                    item.selectAll('*').attr('opacity', OPACITY);
                }
            } else {
                item = d3.select(elems);
                item.attr('class', CLASS_MARKER_SELECTED+' '+CLASS_DATAPOINT)
                .attr('stroke', selectedMarkerStyle['stroke'])
                .attr('stroke-width', selectedMarkerStyle['stroke-width']);
                item.selectAll('*').attr('opacity', OPACITY);
            }
        };
        
        pie.unhighlight = function(elems) {
            var item;
            elems = parseHighlightElems(elems);
            if (TypeUtils.isArray(elems)) {
                for (var i = 0, len = elems.length; i < len; i++) {
                    item = d3.select(elems[i]);
                    item.attr('class', CLASS_MARKER_ORIGINAL + " " + CLASS_DATAPOINT)
                    .attr('stroke', markerStyle['stroke'])
                    .attr('stroke-width', markerStyle['stroke-width']);
                    item.selectAll('*').attr('opacity', OPACITY_UNSELECTED)
                }
            } else {
                item = d3.select(elems);
                item.attr('class', CLASS_MARKER_ORIGINAL + " " + CLASS_DATAPOINT)
                .attr('stroke', markerStyle['stroke'])
                .attr('stroke-width', markerStyle['stroke-width']);
                item.selectAll('*').attr('opacity', OPACITY_UNSELECTED)
            }
        };
        
        pie.clear = function(gray) {
            var item = _selection.selectAll('.v-datapoint').attr('class', CLASS_MARKER_ORIGINAL + " " + CLASS_DATAPOINT).each(function(s) {
                d3.select(this).attr('stroke', markerStyle['stroke'])
                        .attr('stroke-width', markerStyle['stroke-width']);

                d3.select(this).selectAll('*').attr('opacity', gray ? OPACITY_UNSELECTED : OPACITY);
            });
        };
        
        pie.heightDataRange = function(range) {
            if (!arguments.length) {
                return {
                    min : 0,
                    max : maxDepthVal
                };
            }
            maxDepthVal = range.max;
            if (TypeUtils.isExist(width) && TypeUtils.isExist(height)) {
                heightScale.domain([0, maxDepthVal]).range([0, baseHeight]);
            }
            return pie;
        }; 

        
        function parseHighlightElems(elems) {
            var item, result, separate = false;
            if (TypeUtils.isArray(elems)) {
                result = elems.concat();
                for (var i = 0, len = elems.length; i < len; i++) {
                    item = d3.select(elems[i]);
                    if (item.datum().part >= 0) {
                        separate = true;
                        break;
                    }
                }
            } else {
                result = [].concat(elems);
                item = d3.select(elems);
                if (item.datum().part >= 0) {
                    separate = true;
                }
            }
            
            if (separate) {
                _selection.selectAll('.v-datapoint').each(function(s) {
                    if (d3.select(this).datum().part >= 0) {
                        result.push(d3.select(this).node());
                    }
                }); 
            }
            return result;
        };
        
        function showTooltip(d, pos) {
            var sectorFeed = data.getMeasureValuesGroupDataByIdx(0);
            var depthFeed = data.getMeasureValuesGroupDataByIdx(1);
            var colorFeed = data.getAnalysisAxisDataByIdx(0);
            var tooltipData = {
                body: [],
                footer: []
            };
            
            tooltipData.body.push({
              name : !TypeUtils.isExist(sectorFeed.values[0].col) ? langManager.get('IDS_ISNOVALUE') : sectorFeed.values[0].col,
              val : [{
                color : d.colorValue,
                shape : 'circle',
                value : !TypeUtils.isExist(d.val[0]) ? langManager.get('IDS_ISNOVALUE') : d.val[0]
              }]
            });
            
            tooltipData.body.push({
              name : !TypeUtils.isExist(depthFeed.values[0].col) ? langManager.get('IDS_ISNOVALUE') : depthFeed.values[0].col,
              val :[{
                color : d.colorValue,
                shape : 'circle',
                value : !TypeUtils.isExist(d.val[1]) ? langManager.get('IDS_ISNOVALUE') : d.val[1]
              }]
            });
            
            for (var i = 0; i < colorFeed.values.length; i++) {
                tooltipData.footer.push({
                    label : colorFeed.values[i].col.val,
                    value : colorFeed.values[i].rows[d.index].val
                });
            }
            
            tooltipData.point = {
               x : pos.x,
               y : pos.y
            };
            
            tooltipData.plotArea = {
               x : _transform.e,
               y : _transform.f,
               width : width,
               height : height
            };

            _dispatch.showTooltip(tooltipDataHandler.formatTooltipData(tooltipData));
        };
        
        function hideTooltip() {
             _dispatch.hideTooltip();
        };

        function parseOptions() {
            color = props.colorPalette;
            isDonut = props.isDonut;
            drawingEffect = props.drawingEffect;
        };

        function getPieLayout() {
            var base = Math.min(width, height);
            rx = base / 2;
            ry = rx * Math.cos(zAngle);
            drx = rx / 2.414;
            dry = ry / 2.414;
            bottomCX = width / 2;
            bottomCY = height / 2 + base / 2 - ry;
            baseHeight = base - 2 * ry;
        };

        function renderChart(selection) {
            selection.select('.v-datashapesgroup').remove();
            var sectors = prepareData();
            var g = selection.append('g').attr('class', 'v-datashapesgroup');
            renderSectors(sectors, g);
            _transform = _selection[0][0].getTransformToElement(_selection[0][0].ownerSVGElement);
        };
        
        function calculateBoundaryValues() {
            var sectorFeed = data.getMeasureValuesGroupDataByIdx(0);
            var depthFeed = data.getMeasureValuesGroupDataByIdx(1);
            number = 0;
            
            for (var i = 0; i < sectorFeed.values[0].rows[0].length; i++) {
                var sv = TypeUtils.isNaN(sectorFeed.values[0].rows[0][i].val) ? 0 : Math.abs(sectorFeed.values[0].rows[0][i].val);
                var sd = TypeUtils.isNaN(depthFeed.values[0].rows[0][i].val) ? 0 : Math.abs(depthFeed.values[0].rows[0][i].val);
                sum += sv;
                maxDepthVal = Math.max(maxDepthVal, sd);
                if (sv > 0) {
                    number++;
                }
            }
        };

        function prepareData() {
            var sectorFeed = data.getMeasureValuesGroupDataByIdx(0);
            var depthFeed = data.getMeasureValuesGroupDataByIdx(1);

            var result = [];
            for (var i = 0, lastAngle = rotationAngle - Math.PI / 2; i < sectorFeed.values[0].rows[0].length; i++) {
                if (TypeUtils.isNaN(sectorFeed.values[0].rows[0][i].val) || sectorFeed.values[0].rows[0][i].val === 0) {
                    continue;            
                }
                
                var depthVal = TypeUtils.isNaN(depthFeed.values[0].rows[0][i].val) ? 0 : Math.abs(depthFeed.values[0].rows[0][i].val);
                var obj = {
                    startAngle : lastAngle,
                    endAngle : lastAngle + Math.abs(sectorFeed.values[0].rows[0][i].val) / sum * Math.PI * 2,
                    cy : bottomCY - heightScale(depthVal),
                    colorValue : color[i % color.length],
                    val : [
                        sectorFeed.values[0].rows[0][i].val,
                        depthFeed.values[0].rows[0][i].val
                    ],
                    ctx : [
                        sectorFeed.values[0].rows[0][i].ctx,
                        depthFeed.values[0].rows[0][i].ctx
                    ],
                    index : i
                };
                obj.topPoint1 = [bottomCX + rx * Math.cos(obj.startAngle), obj.cy + ry * Math.sin(obj.startAngle)];
                obj.topPoint2 = [bottomCX + rx * Math.cos(obj.endAngle), obj.cy + ry * Math.sin(obj.endAngle)];
                obj.bottomPoint1 = [bottomCX + rx * Math.cos(obj.startAngle), bottomCY + ry * Math.sin(obj.startAngle)];
                obj.bottomPoint2 = [bottomCX + rx * Math.cos(obj.endAngle), bottomCY + ry * Math.sin(obj.endAngle)];
                
                if (isDonut) {
                    obj.topPoint4 = [bottomCX + drx * Math.cos(obj.startAngle), obj.cy + dry * Math.sin(obj.startAngle)];
                    obj.topPoint3 = [bottomCX + drx * Math.cos(obj.endAngle), obj.cy + dry * Math.sin(obj.endAngle)];
                    obj.bottomPoint4 = [bottomCX + drx * Math.cos(obj.startAngle), bottomCY + dry * Math.sin(obj.startAngle)];
                    obj.bottomPoint3 = [bottomCX + drx * Math.cos(obj.endAngle), bottomCY + dry * Math.sin(obj.endAngle)];
                }

                result.push(obj);
                lastAngle = obj.endAngle;
            }
            return result;
        };

        function renderSectors(sectors, g) {
            var s = processSpecialSector(sectors);
            
            // sort sectors to handle cover relationship
            s.sort(function(a, b) {
                if (TypeUtils.isDefined(a.part) && TypeUtils.isDefined(b.part)) {
                    return a.part - b.part;
                }
                
                var asa = getSimpleAngle(a.startAngle);
                var aea = getSimpleAngle(a.endAngle);
                var bsa = getSimpleAngle(b.startAngle);
                var bea = getSimpleAngle(b.endAngle);
                
                if (asa < Math.PI / 2 && aea > Math.PI / 2) {
                    return 1;
                }
                if (bsa < Math.PI / 2 && bea > Math.PI / 2) {
                    return -1;
                }
                if (aea < asa) {
                    return -1;   
                }
                if (bea < bsa) {
                    return 1;
                }
                return Math.max(a.bottomPoint1[1], a.bottomPoint2[1]) - Math.max(b.bottomPoint1[1], b.bottomPoint2[1]);
            });
            

            for (var i = 0; i < s.length; i++) {
                var sectorWrapper = g.append('g').attr('class', CLASS_MARKER_ORIGINAL + " " + CLASS_DATAPOINT)
                .attr('stroke', markerStyle['stroke'])
                .attr('stroke-width', markerStyle['stroke-width']);
                
                sectorWrapper.datum(s[i]);
                renderSingleSector(s[i], sectorWrapper);
            }
            
            _dispatch.initialized({
                name : 'initialized'
            });
        };
        
        function getSimpleAngle(angle) {
            if (angle >= - Math.PI / 2 && angle <= Math.PI / 2 * 3) {
                return angle;
            } else if (angle < - Math.PI / 2) {
                return getSimpleAngle(2 * Math.PI + angle);
            } else if (angle > Math.PI / 2 * 3) {
                return getSimpleAngle(angle - 2 * Math.PI);
            }
        };
        
        function getDarkColor(color) {
            var hsl = d3.rgb(color).hsl();
            return d3.hsl(hsl.h, hsl.s, hsl.l * 0.9).rgb().toString();
        };
        
        function processSpecialSector(sectors) {
            var special = sectors.filter(function(element, index, array) {
                var sa = getSimpleAngle(element.startAngle);
                var ea = getSimpleAngle(element.endAngle);
                return ((sa < Math.PI / 2 || ea > Math.PI / 2) && ea < sa);
            });
            
            if (special.length > 0) {
                special[0].part = 0;
                var sa = getSimpleAngle(special[0].startAngle);
                var sector1 = {
                    startAngle : sa < Math.PI / 2 ? Math.PI : special[0].startAngle,
                    endAngle : sa < Math.PI / 2 ? special[0].endAngle : 0,
                    cy : special[0].cy,
                    colorValue : special[0].colorValue,
                    val : special[0].val,
                    ctx : special[0].ctx,
                    index : special[0].index,
                    part : sa < Math.PI / 2 ? 1 : 2
                };
                var sector2 = {
                    startAngle : sa < Math.PI / 2 ? special[0].startAngle : 0,
                    endAngle : sa < Math.PI / 2 ? Math.PI : special[0].endAngle,
                    cy : special[0].cy,
                    colorValue : special[0].colorValue,
                    val : special[0].val,
                    ctx : special[0].ctx,
                    index : special[0].index,
                    part : sa < Math.PI / 2 ? 3 : 4
                };
                special = [sector1, sector2];
                for (var i = 0; i < special.length; i++) {
                    special[i].topPoint1 = [bottomCX + rx * Math.cos(special[i].startAngle), special[i].cy + ry * Math.sin(special[i].startAngle)];
                    special[i].topPoint2 = [bottomCX + rx * Math.cos(special[i].endAngle), special[i].cy + ry * Math.sin(special[i].endAngle)];
                    special[i].bottomPoint1 = [bottomCX + rx * Math.cos(special[i].startAngle), bottomCY + ry * Math.sin(special[i].startAngle)];
                    special[i].bottomPoint2 = [bottomCX + rx * Math.cos(special[i].endAngle), bottomCY + ry * Math.sin(special[i].endAngle)];
                    if (isDonut) {
                        special[i].topPoint4 = [bottomCX + drx * Math.cos(special[i].startAngle), special[i].cy + dry * Math.sin(special[i].startAngle)];
                        special[i].topPoint3 = [bottomCX + drx * Math.cos(special[i].endAngle), special[i].cy + dry * Math.sin(special[i].endAngle)];
                        special[i].bottomPoint4 = [bottomCX + drx * Math.cos(special[i].startAngle), bottomCY + dry * Math.sin(special[i].startAngle)];
                        special[i].bottomPoint3 = [bottomCX + drx * Math.cos(special[i].endAngle), bottomCY + dry * Math.sin(special[i].endAngle)];
                    }
                }
                return sectors.concat(special);
            }
            return sectors;
        };
        
        function renderSingleSector(sector, g) {
            if (isDonut) {
                if (TypeUtils.isUndefined(sector.part)) {
                    renderDonutBottom(sector, g);
                    renderInvisibleSectorCylinder(sector, g);
                    renderDonutSide(sector, g);
                    renderSectorCylinder(sector, g);
                    renderDonutTop(sector, g);
                } else if (sector.part === 0) {
                    renderDonutBottom(sector, g);
                    renderInvisibleSectorCylinder(sector, g);
                    renderDonutCylinder(sector, g);
                } else if (sector.part > 0) {
                    renderSpecialSectorSide(sector, g);
                    renderSectorCylinder(sector, g);
                    renderDonutTop(sector, g);
                }
                
            } else {
                if (TypeUtils.isUndefined(sector.part)) {
                    renderSectorBottom(sector, g);
                    renderInvisibleSectorCylinder(sector, g);
                    renderSectorSide(sector, g);
                    renderSectorCylinder(sector, g);
                    renderSectorTop(sector, g);
                } else if (sector.part === 0) {
                    renderSectorBottom(sector, g);
                    renderInvisibleSectorCylinder(sector, g);
                } else if (sector.part > 0) {
                    renderSpecialSectorSide(sector, g);
                    renderSectorCylinder(sector, g);
                    renderSectorTop(sector, g);
                }
            }
        };

        
        function getEffectColor(color){
          var parameter = {
              drawingEffect: drawingEffect,
              fillColor : color,
              graphType : "sectorSide"
          };
          return effectManager.register(parameter);
        }
        
        function getEclipseEffectColor(color){
          var parameter = {
              drawingEffect: drawingEffect,
              fillColor : color,
              graphType : "3dSector"
          };
          return effectManager.register(parameter);
        }
        
        function renderSectorSide(sector, g) {
            if (number == 1) {
                return;
            }
            var topPoint1, bottomPoint1, topPoint2, bottomPoint2;
            if (sector.bottomPoint1[1] >= sector.bottomPoint2[1]) {
                topPoint1 = sector.topPoint2;
                bottomPoint1 = sector.bottomPoint2;
                topPoint2 = sector.topPoint1;
                bottomPoint2 = sector.bottomPoint1;
            } else {
                topPoint1 = sector.topPoint1;
                bottomPoint1 = sector.bottomPoint1;
                topPoint2 = sector.topPoint2;
                bottomPoint2 = sector.bottomPoint2;
            }
            var def = 'M' + bottomCX + ',' + bottomCY
                    + 'L' + bottomCX + ',' + sector.cy
                    + 'L' + topPoint1[0] + ',' + topPoint1[1]
                    + 'L' + bottomPoint1[0] + ',' + bottomPoint1[1] + 'z';
            g.append('path').attr('d', def).attr('fill', getEffectColor(getDarkColor(sector.colorValue)));

            def = 'M' + bottomCX + ',' + bottomCY
                    + 'L' + bottomCX + ',' + sector.cy
                    + 'L' + topPoint2[0] + ',' + topPoint2[1]
                    + 'L' + bottomPoint2[0] + ',' + bottomPoint2[1] + 'z';
            g.append('path').attr('d', def).attr('fill', getEffectColor(getDarkColor(sector.colorValue)));
        };
        
        function renderSpecialSectorSide(sector, g) {
            var topPoint1, topPoint2, bottomPoint1, bottomPoint2;
            if (sector.part === 1 || sector.part === 4) {
                topPoint1 = sector.topPoint2;
                bottomPoint1 = sector.bottomPoint2;
                topPoint2 = sector.topPoint3;
                bottomPoint2 = sector.bottomPoint3;
            } else if (sector.part === 2 || sector.part === 3) {
                topPoint1 = sector.topPoint1;
                bottomPoint1 = sector.bottomPoint1;
                topPoint2 = sector.topPoint4;
                bottomPoint2 = sector.bottomPoint4;
            }
            
            var def;
            if (isDonut) {
                def = 'M' + topPoint1[0] + ',' + topPoint1[1]
                        + 'L' + topPoint2[0] + ',' + topPoint2[1]
                        + 'L' + bottomPoint2[0] + ',' + bottomPoint2[1]
                        + 'L' + bottomPoint1[0] + ',' + bottomPoint1[1] + 'z';
            } else {
                def = 'M' + bottomCX + ',' + bottomCY
                        + 'L' + bottomCX + ',' + sector.cy
                        + 'L' + topPoint1[0] + ',' + topPoint1[1]
                        + 'L' + bottomPoint1[0] + ',' + bottomPoint1[1] + 'z';
            }
            g.append('path').attr('d', def).attr('fill', getEffectColor(getDarkColor(sector.colorValue)));

        }
        
        function renderDonutSide(sector, g) {
            if (number == 1) {
                renderDonutCylinder(sector, g);
                return;
            }
            var topPoint1, topPoint2, topPoint3, topPoint4, bottomPoint1, bottomPoint2, bottomPoint3, bottomPoint4;
            if (sector.bottomPoint1[1] >= sector.bottomPoint2[1]) {
                topPoint1 = sector.topPoint2;
                topPoint2 = sector.topPoint3;
                topPoint3 = sector.topPoint1;
                topPoint4 = sector.topPoint4;
                bottomPoint1 = sector.bottomPoint2;
                bottomPoint2 = sector.bottomPoint3;
                bottomPoint3 = sector.bottomPoint1;
                bottomPoint4 = sector.bottomPoint4;
            } else {
                topPoint1 = sector.topPoint1;
                topPoint2 = sector.topPoint4;
                topPoint3 = sector.topPoint2;
                topPoint4 = sector.topPoint3;
                bottomPoint1 = sector.bottomPoint1;
                bottomPoint2 = sector.bottomPoint4;
                bottomPoint3 = sector.bottomPoint2;
                bottomPoint4 = sector.bottomPoint3;
            }
            var def1 = 'M' + topPoint1[0] + ',' + topPoint1[1]
                    + 'L' + topPoint2[0] + ',' + topPoint2[1]
                    + 'L' + bottomPoint2[0] + ',' + bottomPoint2[1]
                    + 'L' + bottomPoint1[0] + ',' + bottomPoint1[1] + 'z';

            var def2 = 'M' + topPoint3[0] + ',' + topPoint3[1]
                    + 'L' + topPoint4[0] + ',' + topPoint4[1]
                    + 'L' + bottomPoint4[0] + ',' + bottomPoint4[1]
                    + 'L' + bottomPoint3[0] + ',' + bottomPoint3[1] + 'z';
            
            var sa = getSimpleAngle(sector.startAngle);
            var ea = getSimpleAngle(sector.endAngle);
            if (sa <= 0 && (ea >= Math.PI || ea < sa) || sa >= Math.PI && ea >= Math.PI && ea < sa) {
                g.append('path').attr('d', def1).attr('fill', getEffectColor(getDarkColor(sector.colorValue)));
                g.append('path').attr('d', def2).attr('fill', getEffectColor(getDarkColor(sector.colorValue)));
                renderDonutCylinder(sector, g);
            } else if (sa > 0 && sa < Math.PI && ea > 0 && ea < sa) {
                renderDonutCylinder(sector, g);
                g.append('path').attr('d', def1).attr('fill', getEffectColor(getDarkColor(sector.colorValue)));
                g.append('path').attr('d', def2).attr('fill', getEffectColor(getDarkColor(sector.colorValue)));
            } else {
                g.append('path').attr('d', def1).attr('fill', getEffectColor(getDarkColor(sector.colorValue)));
                renderDonutCylinder(sector, g);
                g.append('path').attr('d', def2).attr('fill', getEffectColor(getDarkColor(sector.colorValue)));
            }
        };

        function renderSectorCylinder(sector, g) {
            var sa = getSimpleAngle(sector.startAngle);
            var ea = getSimpleAngle(sector.endAngle);
            
            if (sa >= 0 && ea > sa && ea <= Math.PI) {
                var def = 'M' + sector.topPoint1[0] + ',' + sector.topPoint1[1]
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,1 '
                    + sector.topPoint2[0] + ',' + sector.topPoint2[1]
                    + 'L' + sector.bottomPoint2[0] + ',' + sector.bottomPoint2[1]
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,0 '
                    + sector.bottomPoint1[0] + ',' + sector.bottomPoint1[1] + 'z';
                g.append('path').attr('d', def).attr('fill', getEffectColor(getDarkColor(sector.colorValue)));
            } else if ((sa <= 0 || sa >= Math.PI) && ea <= Math.PI && ea >= 0) {
                var def = 'M' + (bottomCX + rx) + ',' + sector.cy
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,1 '
                    + sector.topPoint2[0] + ',' + sector.topPoint2[1]
                    + 'L' + sector.bottomPoint2[0] + ',' + sector.bottomPoint2[1]
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,0 '
                    + (bottomCX + rx) + ',' + bottomCY + 'z';
                g.append('path').attr('d', def).attr('fill', getEffectColor(getDarkColor(sector.colorValue)));
            } else if (sa >= 0 && sa <= Math.PI && (ea >= Math.PI || ea <= 0)) {
                var def = 'M' + sector.topPoint1[0] + ',' + sector.topPoint1[1]
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,1 '
                    + (bottomCX - rx) + ',' + sector.cy
                    + 'L' + (bottomCX - rx) + ',' + bottomCY
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,0 '
                    + sector.bottomPoint1[0] + ',' + sector.bottomPoint1[1] + 'z';
                g.append('path').attr('d', def).attr('fill', getEffectColor(getDarkColor(sector.colorValue)));
            } else if (sa <= 0 && (ea >= Math.PI || ea < sa) || sa >= Math.PI && ea >= Math.PI && ea < sa) {
                var def = 'M' + (bottomCX + rx) + ',' + sector.cy
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,1 '
                    + (bottomCX - rx) + ',' + sector.cy
                    + 'L' + (bottomCX - rx) + ',' + bottomCY
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,0 '
                    + (bottomCX + rx) + ',' + bottomCY + 'z';
                g.append('path').attr('d', def).attr('fill', getEffectColor(getDarkColor(sector.colorValue)));
            } else if (sa >= 0 && sa <= Math.PI && ea >= 0 && ea < sa) {
                var def1 = 'M' + (bottomCX + rx) + ',' + sector.cy
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,1 '
                    + sector.topPoint2[0] + ',' + sector.topPoint2[1]
                    + 'L' + sector.bottomPoint2[0] + ',' + sector.bottomPoint2[1]
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,0 '
                    + (bottomCX + rx) + ',' + bottomCY + 'z';
                var def2 = 'M' + sector.topPoint1[0] + ',' + sector.topPoint1[1]
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,1 '
                    + (bottomCX - rx) + ',' + sector.cy
                    + 'L' + (bottomCX - rx) + ',' + bottomCY
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,0 '
                    + sector.bottomPoint1[0] + ',' + sector.bottomPoint1[1] + 'z';
                g.append('path').attr('d', def1).attr('fill', getEffectColor(getDarkColor(sector.colorValue)));
                g.append('path').attr('d', def2).attr('fill', getEffectColor(getDarkColor(sector.colorValue)));
           }
        };
        
        function renderInvisibleSectorCylinder(sector, g) {
            var sa = getSimpleAngle(sector.startAngle);
            var ea = getSimpleAngle(sector.endAngle);
            
            if (sa < 0 && ea < 0 && ea > sa 
                || sa > Math.PI && (ea > sa || ea < 0)) {
                var def = 'M' + sector.topPoint1[0] + ',' + sector.topPoint1[1]
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,1 '
                    + sector.topPoint2[0] + ',' + sector.topPoint2[1]
                    + 'L' + sector.bottomPoint2[0] + ',' + sector.bottomPoint2[1]
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,0 '
                    + sector.bottomPoint1[0] + ',' + sector.bottomPoint1[1] + 'z';
                g.append('path').attr('d', def).attr('fill', getEffectColor(getDarkColor(sector.colorValue)));
            } else if ((sa < 0 || sa > Math.PI) && ea < Math.PI && ea > 0) {
                var def = 'M' + sector.topPoint1[0] + ',' + sector.topPoint1[1]
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,1 '
                    + (bottomCX + rx) + ',' + sector.cy
                    + 'L' + (bottomCX + rx) + ',' + bottomCY
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,0 '
                    + sector.bottomPoint1[0] + ',' + sector.bottomPoint1[1] + 'z';
                g.append('path').attr('d', def).attr('fill', getEffectColor(getDarkColor(sector.colorValue)));
            } else if (sa > 0 && sa < Math.PI && (ea > Math.PI || ea < 0)) {
                var def = 'M' + (bottomCX - rx) + ',' + sector.cy
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,1 '
                    + sector.topPoint2[0] + ',' + sector.topPoint2[1]
                    + 'L' + sector.bottomPoint2[0] + ',' + sector.bottomPoint2[1]
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,0 '
                    + (bottomCX - rx) + ',' + bottomCY + 'z';
                g.append('path').attr('d', def).attr('fill', getEffectColor(getDarkColor(sector.colorValue)));
            } else if (sa <= 0 && (ea >= Math.PI || ea < sa) || sa >= Math.PI && ea >= Math.PI && ea < sa) {
                var def1 = 'M' + sector.topPoint1[0] + ',' + sector.topPoint1[1]
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,1 '
                    + (bottomCX + rx) + ',' + sector.cy
                    + 'L' + (bottomCX + rx) + ',' + bottomCY
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,0 '
                    + sector.bottomPoint1[0] + ',' + sector.bottomPoint1[1] + 'z';
                var def2 = 'M' + (bottomCX - rx) + ',' + sector.cy
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,1 '
                    + sector.topPoint2[0] + ',' + sector.topPoint2[1]
                    + 'L' + sector.bottomPoint2[0] + ',' + sector.bottomPoint2[1]
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,0 '
                    + (bottomCX - rx) + ',' + bottomCY + 'z';
                g.append('path').attr('d', def1).attr('fill', getEffectColor(getDarkColor(sector.colorValue)));
                g.append('path').attr('d', def2).attr('fill', getEffectColor(getDarkColor(sector.colorValue)));
            } else if (sa > 0 && sa < Math.PI && ea > 0 && ea < sa) {
                var def = 'M' + (bottomCX - rx) + ',' + sector.cy
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,1 '
                    + (bottomCX + rx) + ',' + sector.cy
                    + 'L' + (bottomCX + rx) + ',' + bottomCY
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,0 '
                    + (bottomCX - rx) + ',' + bottomCY + 'z';
                g.append('path').attr('d', def).attr('fill', getEffectColor(getDarkColor(sector.colorValue)));
            }
        };
        
        function renderDonutCylinder(sector, g) {
            var largeAngle = sector.endAngle - sector.startAngle > Math.PI ? '1' : '0';
            var def;
            if (number == 1) {
                def = 'M' + (bottomCX - drx) + ',' + sector.cy 
                        + 'A' + drx + ',' + dry + ' 0 1,1 '
                        + (bottomCX + drx) + ',' + sector.cy 
                        + 'L' + (bottomCX + drx) + ',' + bottomCY
                        + 'A' + drx + ',' + dry + ' 0 1,0 '
                        + (bottomCX - drx) + ',' + bottomCY;
            } else {
                def = 'M' + sector.topPoint4[0] + ',' + sector.topPoint4[1]
                    + 'A' + drx + ',' + dry + ' 0 ' + largeAngle + ',1 '
                    + sector.topPoint3[0] + ',' + sector.topPoint3[1]
                    + 'L' + sector.bottomPoint3[0] + ',' + sector.bottomPoint3[1]
                    + 'A' + drx + ',' + dry + ' 0 ' + largeAngle + ',0 '
                    + sector.bottomPoint4[0] + ',' + sector.bottomPoint4[1] + 'z';
            }
            g.append('path').attr('d', def).attr('fill', getEffectColor(getDarkColor(sector.colorValue)));
        };


        function renderSectorTop(sector, g) {
            if (number == 1) {
                g.append('ellipse').attr('cx', bottomCX).attr('cy', sector.cy)
                        .attr('rx', rx).attr('ry', ry).attr('fill', getEclipseEffectColor(sector.colorValue));
                return;
            }
            
            var def;
            if (TypeUtils.isUndefined(sector.part)) {
                def = 'M' + bottomCX + ',' + sector.cy 
                        + 'L' + sector.topPoint1[0] + ',' + sector.topPoint1[1] 
                        + 'A' + rx + ',' + ry + ' 0 ' 
                        + (sector.endAngle - sector.startAngle > Math.PI ? '1' : '0') + ',1 ' 
                        + sector.topPoint2[0] + ',' + sector.topPoint2[1] + 'z';
            } else if (sector.part === 1 || sector.part === 4) {
                def = 'M' + sector.topPoint1[0] + ',' + sector.topPoint1[1] 
                        + 'A' + rx + ',' + ry + ' 0 ' 
                        + (sector.endAngle - sector.startAngle > Math.PI ? '1' : '0') + ',1 ' 
                        + sector.topPoint2[0] + ',' + sector.topPoint2[1]
                        + 'L' + bottomCX + ',' + sector.cy;
            } else if (sector.part === 2 || sector.part === 3) {
                def = 'M' + bottomCX + ',' + sector.cy 
                        + 'L' + sector.topPoint1[0] + ',' + sector.topPoint1[1] 
                        + 'A' + rx + ',' + ry + ' 0 ' 
                        + (sector.endAngle - sector.startAngle > Math.PI ? '1' : '0') + ',1 ' 
                        + sector.topPoint2[0] + ',' + sector.topPoint2[1];
            }
            g.append('path').attr('d', def).attr('fill', getEclipseEffectColor(sector.colorValue));
        };
        
        function renderSectorBottom(sector, g) {
            if (number == 1) {
                g.append('ellipse').attr('cx', bottomCX).attr('cy', bottomCY)
                        .attr('rx', rx).attr('ry', ry).attr('fill', getEffectColor(sector.colorValue))
                        .attr('stroke', markerStyle['stroke']).attr('stroke-width', markerStyle['stroke-width']);
                return;
            }
            var def = 'M' + bottomCX + ',' + bottomCY 
                    + 'L' + sector.bottomPoint1[0] + ',' + sector.bottomPoint1[1] 
                    + 'A' + rx + ',' + ry + ' 0 ' 
                    + (sector.endAngle - sector.startAngle > Math.PI ? '1' : '0') + ',1 ' 
                    + sector.bottomPoint2[0] + ',' + sector.bottomPoint2[1] + 'z';
            g.append('path').attr('d', def).attr('fill', getEffectColor(sector.colorValue));
        };
        
        function renderDonutTop(sector, g) {
            var def;
            if (number == 1) {
                def = 'M' + sector.topPoint1[0] + ',' + sector.topPoint1[1] 
                        + 'A' + rx + ',' + ry + ' 0 1,1 ' 
                        + (sector.topPoint2[0] - 1) + ',' + sector.topPoint2[1]
                        + 'M' + (sector.topPoint3[0] - 1) + ',' + sector.topPoint3[1]
                        + 'A' + drx + ',' + dry + ' 0 1,0 ' 
                        + sector.topPoint4[0] + ',' + sector.topPoint4[1];
            } else if (TypeUtils.isUndefined(sector.part)) {
                def = 'M' + sector.topPoint1[0] + ',' + sector.topPoint1[1] 
                        + 'A' + rx + ',' + ry + ' 0 ' 
                        + (sector.endAngle - sector.startAngle > Math.PI ? '1' : '0') + ',1 ' 
                        + sector.topPoint2[0] + ',' + sector.topPoint2[1]
                        + 'L' + sector.topPoint3[0] + ',' + sector.topPoint3[1]
                        + 'A' + drx + ',' + dry + ' 0 ' 
                        + (sector.endAngle - sector.startAngle > Math.PI ? '1' : '0') + ',0 ' 
                        + sector.topPoint4[0] + ',' + sector.topPoint4[1] + 'z';
            } else if (sector.part === 1 || sector.part === 4) {
                def = 'M' + sector.topPoint1[0] + ',' + sector.topPoint1[1] 
                        + 'A' + rx + ',' + ry + ' 0 ' 
                        + (sector.endAngle - sector.startAngle > Math.PI ? '1' : '0') + ',1 ' 
                        + sector.topPoint2[0] + ',' + sector.topPoint2[1]
                        + 'L' + sector.topPoint3[0] + ',' + sector.topPoint3[1]
                        + 'A' + drx + ',' + dry + ' 0 ' 
                        + (sector.endAngle - sector.startAngle > Math.PI ? '1' : '0') + ',0 ' 
                        + sector.topPoint4[0] + ',' + sector.topPoint4[1];
            } else if (sector.part === 2 || sector.part === 3) {
                def = 'M' + sector.topPoint2[0] + ',' + sector.topPoint2[1] 
                        + 'A' + rx + ',' + ry + ' 0 ' 
                        + (sector.endAngle - sector.startAngle > Math.PI ? '1' : '0') + ',0 ' 
                        + sector.topPoint1[0] + ',' + sector.topPoint1[1]
                        + 'L' + sector.topPoint4[0] + ',' + sector.topPoint4[1]
                        + 'A' + drx + ',' + dry + ' 0 ' 
                        + (sector.endAngle - sector.startAngle > Math.PI ? '1' : '0') + ',1 ' 
                        + sector.topPoint3[0] + ',' + sector.topPoint3[1];
            }
            g.append('path').attr('d', def).attr('fill', getEclipseEffectColor(sector.colorValue));
        };
        
        function renderDonutBottom(sector, g) {
            var def;
            if (number == 1) {
                def = 'M' + sector.bottomPoint1[0] + ',' + sector.bottomPoint1[1] 
                        + 'A' + rx + ',' + ry + ' 0 1,1 ' 
                        + (sector.bottomPoint2[0] - 1) + ',' + sector.bottomPoint2[1]
                        + 'M' + (sector.bottomPoint3[0] - 1) + ',' + sector.bottomPoint3[1]
                        + 'A' + drx + ',' + dry + ' 0 1,0 ' 
                        + sector.bottomPoint4[0] + ',' + sector.bottomPoint4[1];
            } else {
                def = 'M' + sector.bottomPoint1[0] + ',' + sector.bottomPoint1[1] 
                    + 'A' + rx + ',' + ry + ' 0 ' 
                    + (sector.endAngle - sector.startAngle > Math.PI ? '1' : '0') + ',1 '
                    + sector.bottomPoint2[0] + ',' + sector.bottomPoint2[1]
                    + 'L' + sector.bottomPoint3[0] + ',' + sector.bottomPoint3[1]
                    + 'A' + drx + ',' + dry + ' 0 ' 
                    + (sector.endAngle - sector.startAngle > Math.PI ? '1' : '0') + ',0 ' 
                    + sector.bottomPoint4[0] + ',' + sector.bottomPoint4[1] + 'z';
            }
            g.append('path').attr('d', def).attr('fill', getEclipseEffectColor(sector.colorValue));
        };
        
        props = manifest.props(null);
        return pie;
    };
  return fn;
});
define('sap/viz/modules/manifests/PieWithDepth',['sap/viz/modules/manifests/Module','sap/viz/modules/Constants','sap/viz/modules/piewithdepth'],
function Setup(Manifest, Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.piewithdepth',
    'name' : 'piewithdepth',
    'type' : Constants.Type.Chart,
    'properties' : {
      'colorPalette' : {
        'name' : 'colorPalette',
        'supportedValueType' : 'StringArray',
        'defaultValue' : Constants.COLOR.SAPColorSingleAxis,
        'description' : 'Set the color palette for sectors.',
        'example': "<a href='"+Constants.DocExample.SnippetUrl+"4449' target='_blank'>"+Constants.DocExample.TryThisValue+"</a>"
      },
      'isDonut' : {
        'name' : 'isDonut',
        'supportedValueType' : 'Boolean',
        'defaultValue' : false,
        'description' : 'Set whether is a donut or pie.'
      },
      'drawingEffect':{
        'name' : 'drawingEffect',
          'description' : 'Set drawing effect of 3D elements.',
        'supportedValueType' : 'String',
          'supportedValues' : [ 'normal', 'glossy' ],
          'defaultValue' : 'normal',
          'isExported' : true,
      }
    },
    'events' : {
      'initialized' : Constants.Event.Initialized.desc,
      'selectData' : Constants.Event.SelectData.desc,
      'deselectData' : Constants.Event.DeSelectData.desc
    },
    'feeds' : {
      id : "pie",
      configure : null
    },
    fn : fn
  };
  Manifest.register(module);
});
define('sap/viz/modules/controller/rotate',['jquery','sap/viz/base/utils/Objects'],
function Setup($, Objects) {
  
  return function(manifest){
    
    var m = null, g = null, props =  manifest.props(null), xAngle = 0, yAngle = 0, mousedown = false, oldX, oldY;
    
    var enableRotate = props.enableRotate;
    var rotate = function(){
      
      return rotate;
    };
    

    rotate.registerEvent = function() {
      g.on('mousedown.rotate', start).on('mousemove.rotate', move).on(
          'mouseup.rotate', end);
      
        $(g.node()).mouseleave(function(evt){
          mouseleave(evt);
        });

      var angle = m.rotate();
      xAngle = angle.xAngle;
      yAngle = angle.yAngle;
      
    };

    function start() {
      if (!isEnable()) {
        return;
      }
      oldX = d3.event.layerX;
      oldY = d3.event.layerY;
      mousedown = true;
    }

    function move() {
      if (!isEnable()) {
        return;
      }
      
      if(mousedown === true){
       var x = d3.event.layerX;
       var y = d3.event.layerY;
       
       yAngle += (oldX - x) /2;
       if(yAngle > 180){
         yAngle -= 360;
       }else if(yAngle < -180){
         yAngle += 360;
       }
       
       xAngle += (y - oldY)/2;
       if(xAngle > 90){
         xAngle = 90;
       } else if(xAngle < -90){
         xAngle = -90;
       }
       
       oldX = x;
       oldY = y;
       
       m.rotate({
         xAngle: xAngle,
         yAngle: yAngle
         });

       //stop event, as if we bubble this event. It will be caught by framework. It will find the UI component and fire error
       //message that the parent node is not exist.
       d3.event.stopPropagation();
       d3.event.preventDefault();
      }
    }

    function end() {
      if (!isEnable()) {
        return;
      }
      mousedown = false;
    }
    
    function mouseleave(evt){
      if (!isEnable(evt)) {
        return;
      }
      mousedown = false;
    }
    
    function isEnable(evt) {
      if (!enableRotate){
        return false;
      }
      var result = true;
      if (props.disableWithCtrlKey) {
          var originalEvent = getCurrentEvent() || evt;
          if (originalEvent.ctrlKey) {
              result = false;
          }
      }
      return result;
    }

    function getCurrentEvent() {
        if (d3.event) {
            return d3.event;
        } else {
            return window.event;
        }
    }

    rotate.module = function(_){
      if(!arguments.length){
        return m;
      }
      m = _; g = m.parent();
      return rotate;
    };
    
    rotate.properties = function(_){
      if(!arguments.length){
        return props;
      }
      Objects.extend(true, props, _);
      enableRotate = !!props.enableRotate;
      return rotate;
    };
    
    rotate.destroy = function(){
      m = null;
      g = null;
    };
    
    return rotate;
    
  };
});
define('sap/viz/modules/manifests/controller/Rotate',['sap/viz/modules/manifests/Module','sap/viz/modules/controller/rotate','sap/viz/modules/manifests/controller/Base'],
function Setup(Manifest, fn) {
  var module = {
    'id' : 'sap.viz.modules.controller.rotate',
    'name' : 'selection',
    'base' : "sap.viz.modules.controller.base",
    'description': 'Settings for the interactions of the chart.',
    'properties' : {
        disableWithCtrlKey: {
            name:"disableWithCtrlKey",
            supportedValueType:"Boolean",
            defaultValue: true,
            description: "Set whether rotate when ctrl key pressed.",
            isExported: false
        },
        enableRotate:{
          name:"enableRotate",
          supportedValueType:"Boolean",
          defaultValue:true,
          description:"Set whether disable rotate or not",
          isExported:false
        }
    },
    'fn' : fn
  };

  Manifest.register(module);
});
define('sap/viz/manifests/pie/PieWithDepthChart',['sap/viz/manifests/Viz','sap/viz/modules/manifests/RootContainer','sap/viz/manifests/pie/PieChart',
'sap/viz/modules/manifests/PieWithDepth','sap/viz/modules/manifests/DataLabel',
'sap/viz/modules/manifests/controller/Interaction','sap/viz/modules/manifests/controller/Rotate'],
function Setup(Manifest) {
  var chart = {
    id : 'viz/pie_with_depth',
    name : 'IDS_PIEWITHDEPTHCHART',
    base : "riv/base/single",
    modules : {
      root : {
        modules : {
          legends : {
            modules : {
              legend : {
                data : { aa : [ 1 ] }
              }
            }
          },
          
          tooltip : {
            id : 'sap.viz.modules.tooltip',
            configure : {
              propertyCategory : 'tooltip',
              properties : { 
                  chartType : 'pie_with_depth', 
                  orientation : 'left' 
              }
            }
          },
          
          rotate : {
            id : 'sap.viz.modules.controller.rotate',
            configure : {
              clientID : 'main',
              propertyCategory: 'rotate'
            }
          },
          
          interaction : {
            id : 'sap.viz.modules.controller.interaction',
            configure : {
              clientID : 'main',
              propertyCategory : 'interaction',
              properties : {
                selectability: {
                  mode: 'multiple',
                  lassoWithCtrlKey: true
                },
                preserveSelectionWhenDragging: true
              }
            }
          },
          
          main : {
            modules : {
              plot : {
                id : 'sap.viz.modules.piewithdepth',
                configure : {
                  description : 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory : 'plotArea'
                }
              }
            }
          }
        }
      }
    },
    dependencies : {
      attributes : [ {
        targetModule : 'root.legends.legend',
        target : 'colorPalette',
        sourceModule : 'root.main.plot',
        source : 'colorPalette'
      }],
      events : [ {
        targetModule : 'root.tooltip',
        listener : 'showTooltip',
        sourceModule : 'root.main.plot',
        type : 'showTooltip'
      }, {
        targetModule : 'root.tooltip',
        listener : 'hideTooltip',
        sourceModule : 'root.main.plot',
        type : 'hideTooltip'
      }, {
          targetModule : 'root.interaction',
          listener : 'registerEvent',
          sourceModule : 'root.main.plot',
          type : 'initialized.interaction'
      }, {
          targetModule : 'root.rotate',
          listener : 'registerEvent',
          sourceModule : 'root.main.plot',
          type : 'initialized.rotate'
      },{
          targetModule : 'root.interaction',
          listener : 'highlightedByLegend',
          sourceModule : 'root.legends.legend',
          type : 'highlightedByLegend'
      }, {
          targetModule : 'root.legends.legend',
          listener : 'deselectLegend',
          sourceModule : 'root.interaction',
          type : 'deselectLegend'
      }]
    }
  };

  Manifest.register(chart);
});
define('sap/viz/manifests/pie/DonutWithDepthChart',['sap/viz/manifests/Viz','sap/viz/modules/manifests/RootContainer','sap/viz/manifests/pie/PieWithDepthChart'],
function Setup ( Manifest ) {
  var donutChart = {
    'id' : 'viz/donut_with_depth',
    'name' : 'IDS_DONUTWITHDEPTHCHART',
    base : 'viz/pie_with_depth',
    'modules' : {
      root : {
        modules : {
          'main' : {
            'modules' : {
              'plot' : {
                'configure' : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                  'propertyCategory' : 'plotArea',
                  'properties' : {
                    'isDonut' : true
                  }
                }
              }
            }
          }
        }
      }
    }
  };

  Manifest.register(donutChart);
});
define('sap/viz/manifests/MultiPieChart',['sap/viz/manifests/Viz','sap/viz/data/feed/Constants','sap/viz/modules/manifests/RootContainer',
'sap/viz/manifests/BaseChart','sap/viz/modules/manifests/XYContainer','sap/viz/modules/manifests/TableContainer',
'sap/viz/modules/manifests/Axis','sap/viz/modules/manifests/Pie',
'sap/viz/manifests/BaseMultipleChart'],
function Setup(Manifest, constants) {
  var multiChart = {
    id : 'viz/multi_pie',
    name : 'IDS_MULTIPIECHART',
    base : 'riv/base/multiple',
    modules : {
      root : {
        modules : {
          legends : {
            modules : {
              legend : {
                data : { aa : [ 2 ] }
              }
            }
          },
          
          interaction : {
            id : 'sap.viz.modules.controller.interaction',
            configure : {
              clientID : "main",
              propertyCategory : 'interaction',
              properties : {
                supportedEventNames : [ 'mouseup', 'mouseover', 'mouseout', 'touchstart' ],
                holdSelection : true
              }
            }
          },
          
          main : {
            configure : {
              properties : { 'cellPadding' : 5 }
            },

            modules : {
              plot : {
                id : 'sap.viz.modules.xycontainer',
                modules : {
                  plot : {
                    id : 'sap.viz.modules.pie',
                    configure : {
                      'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                      propertyCategory : 'plotArea',
                      properties : {
                        valign : "center"
                      }
                    }
                  },
                  dataLabel : {
                    id : 'sap.viz.modules.datalabel',
                    configure : {
                      propertyCategory : 'dataLabel',
                      properties : {
                        paintingMode : 'polarCoordinate',
                        visible : false,
                        formatString : [['0.00%'],[]],
                        automaticInOutside : false,
                        outsideVisible : true,
                        type : 'label and value'
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    feeds : {
      multiplier : {
        acceptMND : 0,
        max : 2
      },
      pieSectorSize : {
        max : constants.Constraints.INF
      }
    },
    dependencies : {
      attributes : [ {
        targetModule : 'root.main.xAxis2',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'xCategoryScale'
      }, {
        targetModule : 'root.main.yAxis',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'yCategoryScale'
      }, {
        targetModule : 'root.legends.legend',
        target : 'colorPalette',
        sourceModule : 'root.main.plot.plot',
        source : 'colorPalette'
      }, {
        targetModule : 'root.legends.legend',
        target : 'setSelectionMode',
        sourceModule : 'root.interaction',
        source : 'getSelectionMode'
      } ],
      events : [ {
        targetModule : 'root.interaction',
        listener : 'registerEvent',
        sourceModule : 'root.main',
        type : 'initialized.interaction'
      }, {
        targetModule : 'root.interaction',
        listener : 'highlightedByLegend',
        sourceModule : 'root.legends.legend',
        type : 'highlightedByLegend'
      }, {
        targetModule : 'root.legends.legend',
        listener : 'deselectLegend',
        sourceModule : 'root.interaction',
        type : 'deselectLegend'
      } , {
        targetModule : 'root.main.plot.dataLabel',
        listener : 'showLabel',
        sourceModule : 'root.main.plot.plot',
        type : 'initialized.datalabel'
      }, {
        targetModule : 'root.main.plot.dataLabel',
        listener : 'removeLabel',
        sourceModule : 'root.main.plot.plot',
        type : 'startToInit.datalabel'
      }, {
          targetModule : 'root.interaction',
          listener : 'defaultSelection',
          sourceModule : 'root.main',
          type : 'initialized.defaultSelection'
      } ]
    }
  };

  Manifest.register(multiChart);
});
define('sap/viz/manifests/MultiPieWithDepthChart',['sap/viz/manifests/Viz','sap/viz/data/feed/Constants','sap/viz/modules/manifests/RootContainer',
'sap/viz/manifests/BaseChart','sap/viz/modules/manifests/XYContainer','sap/viz/modules/manifests/TableContainer',
'sap/viz/modules/manifests/Axis','sap/viz/modules/manifests/PieWithDepth',
'sap/viz/manifests/BaseMultipleChart'],
function Setup(Manifest, constants) {
  var multiChart = {
    id : 'viz/multi_pie_with_depth',
    name : 'IDS_MULTIPIEWITHDEPTHCHART',
    base : 'riv/base/multiple',
    modules : {
      root : {
        modules : {
          legends : {
            modules : {
              legend : {
                data : { aa : [ 2 ] }
              }
            }
          },
          
          tooltip : {
            id : 'sap.viz.modules.tooltip',
            configure : {
              propertyCategory : 'tooltip',
              properties : { orientation : 'left' }
            }
          },
          
          interaction : {
            id : 'sap.viz.modules.controller.interaction',
            configure : {
              clientID : 'main',
              propertyCategory : 'interaction',
              properties : {
                selectability: {
                  mode: 'multiple'
                },
                preserveSelectionWhenDragging: true
              }
            }
          },
          
          main : {
            configure : {
              properties : { 
                  'cellPadding' : 5,
                  'mergeDataRange' : ['height'] 
              }
            },

            modules : {
              plot : {
                id : 'sap.viz.modules.xycontainer',
                modules : {
                  plot : {
                    id : 'sap.viz.modules.piewithdepth',
                    configure : {
                      'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                      propertyCategory : 'plotArea',
                      properties : {
                        valign : "center"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    feeds : {
      multiplier : {
        acceptMND : -1,
        max : 2
      },
      pieDepthSize : { 
        max : constants.Constraints.INF 
      },
      pieSectorSize : {
        max : constants.Constraints.INF
      }
    },
    dependencies : {
      attributes : [ {
        targetModule : 'root.main.xAxis2',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'xCategoryScale'
      }, {
        targetModule : 'root.main.yAxis',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'yCategoryScale'
      }, {
        targetModule : 'root.legends.legend',
        target : 'colorPalette',
        sourceModule : 'root.main.plot.plot',
        source : 'colorPalette'
      }, {
        targetModule : 'root.legends.legend',
        target : 'setSelectionMode',
        sourceModule : 'root.interaction',
        source : 'getSelectionMode'
      }, {
          targetModule : 'root.main',
          target : 'heightDataRange',
          sourceModule : 'root.main.plot.plot',
          source : 'heightDataRange'
        },
        {
          targetModule : 'root.main.plot.plot',
          target : 'heightDataRange',
          sourceModule : 'root.main',
          source : 'heightDataRange'
        }],
      events : [ {
        targetModule : 'root.interaction',
        listener : 'registerEvent',
        sourceModule : 'root.main',
        type : 'initialized.interaction'
      }, {
        targetModule : 'root.interaction',
        listener : 'highlightedByLegend',
        sourceModule : 'root.legends.legend',
        type : 'highlightedByLegend'
      }, {
        targetModule : 'root.legends.legend',
        listener : 'deselectLegend',
        sourceModule : 'root.interaction',
        type : 'deselectLegend'
      },{
        targetModule : 'root.tooltip',
        listener : 'showTooltip',
        sourceModule : 'root.main',
        type : 'showTooltip'
      }, {
        targetModule : 'root.tooltip',
        listener : 'hideTooltip',
        sourceModule : 'root.main',
        type : 'hideTooltip'
      }]
    }
  };

  Manifest.register(multiChart);
});
define('sap/viz/manifests/MultiDonutChart',['sap/viz/manifests/Viz','sap/viz/manifests/BaseChart','sap/viz/modules/manifests/RootContainer',
'sap/viz/modules/manifests/XYContainer','sap/viz/modules/manifests/TableContainer',
'sap/viz/modules/manifests/Axis','sap/viz/modules/manifests/Pie','sap/viz/manifests/MultiPieChart'],
function Setup(Manifest) {
  var multiChart = {
    id : 'viz/multi_donut',
    name : 'IDS_MULTIDONUTCHART',
    base : 'viz/multi_pie',
    modules : {
      root : {
        modules : {
          main : {
            modules: {
              plot : {
                id : 'sap.viz.modules.xycontainer',
                modules : {
                  plot : {
                    id : 'sap.viz.modules.pie',
                    configure : {
                    description : 'Settings regarding the chart area and plot area as well as general chart options.',
                      propertyCategory : 'plotArea',
                      properties : { 'isDonut' : true }
                    }
                  },
                  dataLabel : {
                    id : 'sap.viz.modules.datalabel',
                    configure : {
                      propertyCategory : 'dataLabel',
                      properties : { isDonut : true }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  };

  Manifest.register(multiChart);
});
define('sap/viz/manifests/MultiDonutWithDepthChart',['sap/viz/manifests/Viz','sap/viz/data/feed/Constants','sap/viz/modules/manifests/RootContainer',
'sap/viz/manifests/BaseChart','sap/viz/modules/manifests/XYContainer','sap/viz/modules/manifests/TableContainer',
'sap/viz/modules/manifests/Axis','sap/viz/modules/manifests/PieWithDepth',
'sap/viz/manifests/MultiPieWithDepthChart'],
function Setup(Manifest, constants) {
  var multiChart = {
    id : 'viz/multi_donut_with_depth',
    name : 'IDS_MULTIDONUTWITHDEPTHCHART',
    base : 'viz/multi_pie_with_depth',
    modules : {
      root : {
        modules : {
          main : {
            configure : {
              properties : { 'cellPadding' : 5 }
            },

            modules : {
              plot : {
                id : 'sap.viz.modules.xycontainer',
                modules : {
                  plot : {
                    id : 'sap.viz.modules.piewithdepth',
                    configure : {
                      'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                      propertyCategory : 'plotArea',
                      properties : {
                        valign : "center",
                        isDonut : true
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  };

  Manifest.register(multiChart);
});
define('sap/viz/modules/stackedverticalbar',['sap/viz/base/utils/oo', 'sap/viz/modules/Base','sap/viz/base/utils/TypeUtils','sap/viz/base/utils/ObjectUtils','sap/viz/modules/dispatch','sap/viz/modules/util/MNDHandler',
'sap/viz/modules/util/tooltipDataHandler','sap/viz/util/ColorSeriesGenerator',
'sap/viz/util/Scaler','sap/viz/util/NumberUtils','sap/viz/base/utils/Objects',
'sap/viz/lang/langManager','sap/viz/modules/util/BoundUtil','sap/viz/modules/util/defaultSelectionUtil',
'sap/viz/base/UADetector','sap/viz/modules/Constants'],
function Setup(oo, Base,TypeUtils, ObjectUtils, dispatch, MNDHandler, tooltipDataHandler, ColorSeries, Scaler, NumberUtils, Objects, langManager, boundUtil, defaultSelUtil, UADetector,Constants) {
	var CLASSMARKERSELECTED = "v-datapoint-selected",
    CLASSMARKERHOVER = "v-datapoint-hover",
    CLASSDATAPOINT = "v-datapoint",
    CLASSMORPHABLEDATAPOINT = Constants.CSS.CLASS.MORPHABLEDATAPOINT;
	var CLASSDATAPOINTCOMBINED = CLASSDATAPOINT + ' ' + CLASSMORPHABLEDATAPOINT;
	var tooltipDataHandlerObj;
	
	var StackedVerticalBar = function(manifest, ctx) {
		this._svb_data = undefined;
        this._svb_data1 = [[]];
        this._svb_data2 = [[]];
        this._svb_seriesData = [];
        this._svb_tooltipData = [];
        this._svb_primaryAxisTopBoundary = 0;
        this._svb_primaryAxisBottomBoundary = 0;
        this._svb_primaryAxisManualRange = false;
        this._svb_secondaryAxisManualRange = false;
        this._svb_secondaryAxisTopBoundary = 0;
        this._svb_secondaryAxisBottomBoundary = 0;
        this._svb_gWrapper = null;
        
        this._svb_width = undefined;
        this._svb_height = undefined;

        this._svb_isDualAxis = false;
        this._svb_hasMNDonCategoryAxis = false;
        this._svb_colorPalette = [];
        this._svb_axis1ColorPalette = undefined;
        this._svb_axis2ColorPalette = undefined;
        this._svb_MNDInnerOnColor = false;
        this._svb_measureOnAxis1 = 0;
        this._svb_measureOnAxis2 = 0;
        this._svb_shapePalette = ['squareWithRadius'];        
        this._svb_eDispatch = dispatch('selectData', 'deselectData', 'showTooltip', 'hideTooltip', 'initialized','startToInit');
                
        this._svb_effectManager = ctx.effectManager;
        this._svb_styleManager = ctx.styleManager;
        this._svb_valueScales = new Array(2);
        this._svb_xScale = d3.scale.ordinal();
        this._svb_yScale = d3.scale.linear();
        this._svb_yScale2 = d3.scale.linear();
        
        this._svb_decorativeShape = undefined;
        this._svb_lastSelected = [];
        this._svb_tooltipVisible = true;
        this._svb_lastHovered = null;
        
        this._svb_barNumber = undefined;
        this._svb_barGroupNumber = undefined;
        this._svb_barNumberinGroup = undefined;
        this._svb_yPositions = [];
        this._svb_positiveIndexes = [];
        this._svb_negativeIndexes = [];
        this._svb_barWidth = undefined;
      
        this._svb_defsEnter = undefined;
        this._svb_roundCornerDefs = undefined;
        this._svb_suffix = ObjectUtils.guid();
        
        this._svb_enableDataLoadingAnimation = true;
        this._svb_enableDataUpdatingAnimation = true;
        this._svb_enableResizingAnimation = true; // control resizing animation
        this._svb_enableRoundCorner = false;
        this._svb_clipEdge = true;
        this._svb_hasDefaultSelection = false;
        this._svb_isOnlyInitAnimation = false;
        this._svb_afterAttachToDOM = false;
        this._svb_totalIntervalTime = 800;

        this._svb_mode = 'comparison'; //bar display mode
        this._svb_drawingEffect = 'normal';
      
        this._svb_sizeChange = false;
        this._svb_dataStructureChange = false;
        this._svb_dataValueChange = false;
        
        this._svb_totalAnimationCount = undefined;
        this._svb_currentAnimationCount = undefined;
        this._svb_properties = manifest.props(null);
	};
	
	oo.extend(StackedVerticalBar,Base);
	
	StackedVerticalBar.prototype.render = function(selection) {
		var that = this;
		boundUtil.drawBound(selection, this._svb_width, this._svb_height);
        
        tooltipDataHandlerObj = tooltipDataHandler();
        
        //deal with percentage mode
        if(this._svb_mode === 'percentage'){
            this._svbfn_turnToPercentage();
        }
        
        // [19-Oct-2012 Nick] if the size of plot area is too small, there is no value scale created and the whole drawing part is skipped.
        if(!TypeUtils.isExist(this._svb_yScale) && !TypeUtils.isExist(this._svb_yScale2)){
          return;
        }
        
        this._svb_currentAnimationCount = 0;
        this._svb_totalAnimationCount = 0;
        
        this._svb_eDispatch.startToInit();
        
        selection.each(function(){
          
          that._svb_barNumberinGroup = that._svb_seriesData[0][0].length + ((TypeUtils.isExist(that._svb_seriesData[0][1])) ? that._svb_seriesData[0][1].length : 0);
          var barWidthInitial = 8 * (that._svb_xScale.rangeBand()) / (9*that._svb_barNumberinGroup +7 );
          that._svb_barNumber = (TypeUtils.isExist(that._svb_data2)) ? 2 : 1;
          that._svb_barWidth = 8 * (that._svb_xScale.rangeBand()) / (9*that._svb_barNumber +7 );
        
          that._svb_totalAnimationCount = that._svb_seriesData.length * that._svb_barNumberinGroup;
          
          that._svb_gWrapper = d3.select(this);
          
          var svg =  that._svb_gWrapper;
          
          if(that._svb_decorativeShape === undefined){
              that._svb_decorativeShape = svg.append('rect').attr('width', that._svb_xScale.rangeBand() - that._svb_barWidth/2).attr('height', that._svb_height).attr('visibility', 'hidden').attr('fill', that._svb_styleManager.queryDefault('v-hovershadow').fill).attr('class', 'v-hovershadow');
          }else{
              that._svb_decorativeShape.attr('width', that._svb_xScale.rangeBand() - (that._svb_barWidth)/2).attr('height',that._svb_height).attr('visibility', 'hidden');
          }

          if(that._svb_defsEnter === undefined){
              that._svb_defsEnter = svg.append('defs')
              .append('clipPath').attr('id', 'clipPlot_' + that._svb_suffix)
              .append('rect').attr('width', that._svb_width).attr('height', that._svb_height);
          }else{
              that._svb_defsEnter.attr('width', that._svb_width).attr('height', that._svb_height);
          }  
          
          if(that._svb_roundCornerDefs === undefined){      
               that._svb_roundCornerDefs = svg.append('defs');
          }else{
            if( that._svb_dataStructureChange || that._svb_sizeChange || that._svb_dataValueChange || !that._svb_enableRoundCorner ){
                that._svb_roundCornerDefs.selectAll(".v-clippath").remove();
            }
          }
           
          var r = Math.log(that._svb_barWidth)/Math.log(2);
          if( r < 0 ){
            that._svb_enableRoundCorner = false;
          }
        
          var valueScale, tempPos = 0, tempNeg = 0, negativeIndex = 0, postiveIndex = 0;
          var datashapesgroup = svg.selectAll('g.v-datashapesgroup');
          if(!TypeUtils.isExist(datashapesgroup[0][0])){
            datashapesgroup = svg.append('g').attr('class', 'v-datashapesgroup').attr("clip-path", "url(#clipPlot_" + that._svb_suffix + ")").attr("fill", "none");
          }
          var barGroup = datashapesgroup.selectAll('g.v-stackedcolumn').data(that._svb_seriesData);          
          barGroup.enter().append('g');
          barGroup.attr('class','v-stackedcolumn').each(function (perGroupData, i) {
                var axisGroup = d3.select(this).selectAll('g.v-axisGroup').data(perGroupData);     
                axisGroup.enter().append('g');
                axisGroup.attr('class','v-axisGroup').each( function (perAxisData,j) {  
                  // This is for dual axis
                  var valueScale = (j === 0) ? that._svb_yScale : that._svb_yScale2;
                  var startPoint = (j === 0) ? that._svb_barWidth /2 : (that._svb_barWidth /2 + that._svb_barWidth + that._svb_barWidth/8);
                  var initStartPoint = (j === 0) ? that._svb_xScale(i) : (that._svb_xScale(i) + that._svb_barWidth / 2 + that._svb_barWidth) ;
                  var fillingColor =  (j === 0) ? that._svb_axis1ColorPalette : that._svb_axis2ColorPalette;
                  
                  // This is for pos/neg values.
                  var positiveY = 0, negativeY = 0,  positiveStackedValue =  0, negativeStackedValue = 0;
                  var yArray = [], xArray=[];
                  
                  // wrap a datashape g for each rect
                  var barShape = d3.select(this).selectAll('g.v-datashape').data(perAxisData);
                  var barShapeEnter = barShape.enter().append('g').attr('class','v-datashape').append('rect').attr('class', CLASSDATAPOINTCOMBINED);
                      barShape.exit().remove();
                      
                      // [21-Nov-2012 Nick] Keep the original x-position for each g.datashape, it is used when data value changes.
                      if(that._svb_afterAttachToDOM){
                        barShape.each(function(){
                          yArray.push(this.getTransformToElement(this.parentNode).f);
                        });
                      }
                      
                      // [20-Nov-2012 Nick] As g.datashape is considered as a 'shape' concept, all positioning behavior is applied to this element
                      barShape.attr('transform', function (perRectData, m) {
                          var y ;
                          if(perRectData.val >=0 ){
                            positiveStackedValue += perAxisData[m].val;
                            positiveY = valueScale(positiveStackedValue);                          
                            y= positiveY;
                          }else{
                            negativeY = valueScale(negativeStackedValue);
                            negativeStackedValue += perAxisData[m].val;
                            y= negativeY;
                          }
                          var x = that._svb_xScale(i) + startPoint;
                          xArray.push(x);
                          return 'translate('+x+','+y+')';
                      });
                      
                  var bar = barShape.select('rect.v-datapoint');
                  
                  if(that._svb_dataStructureChange || that._svb_dataValueChange){
                    bar.attr('fill', function(d,colorIndex){  
                      d.fillColor = fillingColor[colorIndex % fillingColor.length];
                      var parameter = {
                          drawingEffect:that._svb_drawingEffect,
                          fillColor : d.fillColor,
                          direction : 'horizontal'
                      };
                      return that._svb_effectManager.register(parameter);
                    }).attr('shape-rendering','crispEdges').attr('fill-opacity', 1).attr('stroke','none');
                  }
                      var rcFunction;
                      if(that._svbfn_enableAnimation()){
                    // [04 - Sep - 2012 Nick] DataStructureChange means the structure of data is changed. 
                    // It means the whole DOM nodes needed to be removed (handled by d3) and append new ones.
                    if(that._svb_dataStructureChange){
                      bar.attr('x', function(perRectData, m){
                            var x = initStartPoint - xArray[m] + barWidthInitial * m;
                            x = x + barWidthInitial/8 *(m) + barWidthInitial/2;
                            return x;
                        })
                        .attr('width', barWidthInitial) .attr('height', 0)
                        .attr('y', function (perRectData) {
                          if(perRectData.val > 0){
                            return Math.abs(valueScale(perRectData.val) - valueScale(0));
                          }else{
                            return 0;
                          }
                        });
                        
                      // [04 - Sep - 2012 Nick] Round corner enabled. Do the same transition as the bars do.
                      if(that._svb_enableRoundCorner){
                        rcFunction= function(){
                          bar.attr('clip-path', function(perRectData, indexinGroup){
                              if(indexinGroup === that._svb_negativeIndexes[j][i] || indexinGroup === that._svb_positiveIndexes[j][i]){
                                  var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + that._svb_suffix;
                                  var roundCorner = that._svb_roundCornerDefs.append('clipPath').attr('id', id).attr("class", "v-clippath")
                                            .append('rect').attr('class', 'v-roundCorner-clip')
                                            .attr('rx', r).attr('ry', r).attr('y',  Math.abs(valueScale(perRectData.val) - valueScale(0)) + r)
                                            .attr('height',r).attr('width', barWidthInitial)
                                            .attr('x', this.x.baseVal.value)
                                            .transition().duration(that._svb_totalIntervalTime/2)
                                            .attr('y', function () {
                                              if(indexinGroup === that._svb_negativeIndexes[j][i]){
                                                return 0 - r;
                                              }else{
                                                return 0;
                                              }
                                            })
                                            .attr('height',function(){
                                               return Math.abs(valueScale(perRectData.val) - valueScale(0)) + r ;
                                            })
                                            .transition().delay(that._svb_totalIntervalTime/2).duration(that._svb_totalIntervalTime/2)
                                            .attr('x',0)
                                            .attr('width', that._svb_barWidth);
                                return 'url(#' + id + ')' ;
                              }
                               
                            });
                          };
                     if((UADetector.isSafari() && UADetector.os() === "Windows")||UADetector.isMobile()){
                         window.setTimeout(rcFunction, 0);
                      } else{
                        rcFunction();
                      }
                      }
                      bar.transition().duration(that._svb_totalIntervalTime/2)
                         .attr('height', function(perRectData){
                           return Math.abs(valueScale(perRectData.val) - valueScale(0) ) ;
                         })
                         .attr('y', 0).each('end', function(perRectData, m){
                             this.setAttribute('y', 0);
                             this.setAttribute('height', Math.abs(valueScale(perRectData.val) - valueScale(0)));
                             
                             d3.select(this).transition().duration(that._svb_totalIntervalTime/2)
                             .attr('width', that._svb_barWidth).attr('x',0)
                             .each('end', function(){
                                 this.setAttribute('x', 0);
                                 this.setAttribute('width', that._svb_barWidth);
                              // Fire out event to tell the animation is done.
                                that._svbfn_completeAnimation();
                           });
                         });
                      
                    }else if(that._svb_sizeChange){
                      bar.attr('y',function(d,k){
                          return yArray[k] - this.parentNode.getTransformToElement(this.parentNode.parentNode).f;
                        })
                        .attr('height', function(perRectData,k){
                          var newHeight = Math.abs(valueScale(perRectData.val) - valueScale(0));
                          if(parseFloat(this.height.baseVal.value) > newHeight){
                            return this.height.baseVal.value;
                          }else{
                            return newHeight;
                          }
                        });
                      var sizeChangeTransition = bar.transition();
                      sizeChangeTransition.duration(that._svb_totalIntervalTime/2)
                        .attr('width', that._svb_barWidth)
                        .attr('x', 0)
                        .attr('height', function(perRectData){
                           return Math.abs(valueScale(perRectData.val) - valueScale(0) ) ;
                        })
                        .attr('y',0)
                        .each('end', function(d, m){
                            this.setAttribute('width', that._svb_barWidth);
                            this.setAttribute('x', 0);
                            this.setAttribute('height', Math.abs(valueScale(d.val) - valueScale(0)));
                            this.setAttribute('y', 0);
                           // Fire out event to tell the animation is done.
                             that._svbfn_completeAnimation();
                        });
                      if(that._svb_enableRoundCorner){
                        rcFunction = function(){
                         sizeChangeTransition.attr('clip-path', function(perRectData, indexinGroup){
                             if(indexinGroup === that._svb_negativeIndexes[j][i] || indexinGroup === that._svb_positiveIndexes[j][i]){
                              var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + that._svb_suffix;
                              var  y = parseFloat(this.y.baseVal.value);
                              var roundCorner = that._svb_roundCornerDefs.append('clipPath').attr('id', id).attr("class", "v-clippath")
                                        .append('rect').attr('class', 'v-roundCorner-clip')
                                        .attr('rx', r).attr('ry', r)
                                        .attr('y',  function(){
                                          return y - ((indexinGroup === that._svb_negativeIndexes[j][i]) ? r : 0);
                                        })
                                        .attr('height',this.height.baseVal.value + r).attr('width', this.width.baseVal.value)
                                        .attr('x', this.x.baseVal.value)
                                        .transition().duration(that._svb_totalIntervalTime/2)
                                        .attr('y', function () {
                                          if(indexinGroup === that._svb_negativeIndexes[j][i]){
                                            return 0 - r;
                                          }else{
                                            return 0;
                                          }
                                        })
                                        .attr('height',function(){
                                           return Math.abs(valueScale(perRectData.val) - valueScale(0)) + r ;
                                        })
                                        .attr('x',0)
                                        .attr('width', that._svb_barWidth);
                            return 'url(#' + id + ')' ;
                          }
                           
                        });};
                     if((UADetector.isSafari() && UADetector.os() === "Windows")||UADetector.isMobile()){
                         window.setTimeout(rcFunction, 0);
                      } else{
                        rcFunction();
                      }
                      }
  
                    }else if(that._svb_dataValueChange){
                      bar.attr('y',function(d,k){
                        return yArray[k] - this.parentNode.getTransformToElement(this.parentNode.parentNode).f;
                      });
                      var dataValueChangeTransition = bar.transition();
                      dataValueChangeTransition.duration(that._svb_totalIntervalTime/2)
                         .attr('height', function(perRectData){
                           return Math.abs(valueScale(perRectData.val) - valueScale(0) ) ;
                         })
                         .attr('y', 0)
                         .each('end', function(d, m){
                             this.setAttribute('y', 0);
                             this.setAttribute('height', Math.abs(valueScale(d.val) - valueScale(0)));
                           // Fire out event to tell the animation is done.
                             that._svbfn_completeAnimation();
                        });
                      if(that._svb_enableRoundCorner){
                        rcFunction = function(){
                          dataValueChangeTransition.attr('clip-path', function(perRectData, indexinGroup){
                              if(indexinGroup === that._svb_negativeIndexes[j][i] || indexinGroup === that._svb_positiveIndexes[j][i]){
                                  var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + that._svb_suffix;
                                  var  y = parseFloat(this.y.baseVal.value);
                                  var roundCorner = that._svb_roundCornerDefs.append('clipPath').attr('id', id).attr("class", "v-clippath")
                                            .append('rect').attr('class', 'v-roundCorner-clip')
                                            .attr('rx', r).attr('ry', r)
                                            .attr('y',  function(){
                                              return y - ((indexinGroup === that._svb_negativeIndexes[j][i]) ? r : 0);
                                            })
                                            .attr('height',this.height.baseVal.value + r).attr('width', this.width.baseVal.value)
                                            .attr('x', this.x.baseVal.value)
                                            .transition().duration(that._svb_totalIntervalTime/2)
                                            .attr('y', function () {
                                              if(indexinGroup === that._svb_negativeIndexes[j][i]){
                                                return 0 - r;
                                              }else{
                                                return 0;
                                              }
                                            })
                                            .attr('x', 0)
                                            .attr('height',function(){
                                               return Math.abs(valueScale(perRectData.val) - valueScale(0)) + r ;
                                            });
                                return 'url(#' + id + ')' ;
                              }                           
                            });
                          };
                     if((UADetector.isSafari() && UADetector.os() === "Windows")||UADetector.isMobile()){
                         window.setTimeout(rcFunction, 0);
                      } else{
                        rcFunction();
                      }
                      }
                    }
                    else if (that._svb_enableRoundCorner){
                      rcFunction = function(){
                        bar.attr('clip-path', function(perRectData, indexinGroup){
                            if(indexinGroup === that._svb_negativeIndexes[j][i] || indexinGroup === that._svb_positiveIndexes[j][i]){
                                var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + that._svb_suffix;
                                var roundCorner = that._svb_roundCornerDefs.append('clipPath').attr('id', id).attr("class", "v-clippath")
                                          .append('rect').attr('class', 'v-roundCorner-clip')
                                          .attr('rx', r).attr('ry', r)      
                                          .attr('y', function () {
                                            if(indexinGroup === that._svb_negativeIndexes[j][i]){
                                              return 0 - r;
                                            }else{
                                              return 0;
                                            }
                                          })
                                          .attr('height',function(){
                                             return Math.abs(valueScale(perRectData.val) - valueScale(0)) + r ;
                                          })
                                          
                                          .attr('x',0)
                                          .attr('width', that._svb_barWidth);
                              return 'url(#' + id + ')' ;
                            }
                            that._svbfn_completeAnimation();
                          });
                        };
                     if((UADetector.isSafari() && UADetector.os() === "Windows")||UADetector.isMobile()){
                         window.setTimeout(rcFunction, 0);
                      } else{
                        rcFunction();
                      }

                    }
                  }else{
                    bar.attr('y', 0).attr('x', 0)
                       .attr('width', that._svb_barWidth)
                       .attr('height', function(perRectData){
                         return Math.abs(valueScale(perRectData.val) - valueScale(0) ) ;
                       });
                    if(that._svb_enableRoundCorner){
                      rcFunction = function(){
                        bar.attr('clip-path', function(perRectData, indexinGroup){
                          if(indexinGroup === that._svb_negativeIndexes[j][i] || indexinGroup === that._svb_positiveIndexes[j][i]){
                              var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + that._svb_suffix;
                              var roundCorner = that._svb_roundCornerDefs.append('clipPath').attr('id', id).attr("class", "v-clippath")
                                        .append('rect').attr('class', 'v-roundCorner-clip')
                                        .attr('rx', r).attr('ry', r)      
                                        .attr('y', function () {
                                          if(indexinGroup === that._svb_negativeIndexes[j][i]){
                                            return 0 - r;
                                          }else{
                                            return 0;
                                          }
                                        })
                                        .attr('height',function(){
                                           return Math.abs(valueScale(perRectData.val) - valueScale(0)) + r ;
                                        })                                        
                                        .attr('x',0)
                                        .attr('width', that._svb_barWidth);
                            return 'url(#' + id + ')' ;
                          }
                       });};
                     if((UADetector.isSafari() && UADetector.os() === "Windows")||UADetector.isMobile()){
                         window.setTimeout(rcFunction, 0);
                      } else{
                        rcFunction();
                      }
                     }

                   }
                });       
              });
          barGroup.exit().remove();
        });
        if (! this._svbfn_enableAnimation()){
          this._svb_eDispatch.initialized();
          this._svb_afterAttachToDOM = true;
        }  
        this._svb_sizeChange = false, this._svb_dataValueChange = false, this._svb_dataStructureChange = false;
        this._svb_isOnlyInitAnimation = true;
        return this;
	};
	
	
	/**
     * set/get width
     */
	StackedVerticalBar.prototype.width = function(value){
         if (!arguments.length){
           return this._svb_width;
         }
         this._svb_sizeChange = (this._svb_width === value)&&!this._svb_sizeChange? false:true;
         this._svb_width = value;
     if(TypeUtils.isExist(this._svb_width) && TypeUtils.isExist(this._svb_height)&& TypeUtils.isExist(this._svb_seriesData)){
         this._svbfn_makeScales();
       }  
         return this;
     };
	
     /**
      * set/get height
      */
    StackedVerticalBar.prototype.height = function(value){
        if (!arguments.length){
          return this._svb_height;
         }
        this._svb_sizeChange = (this._svb_height === value)&&!this._svb_sizeChange? false:true;
        this._svb_height = value;
      if(TypeUtils.isExist(this._svb_width) && TypeUtils.isExist(this._svb_height)&& TypeUtils.isExist(this._svb_seriesData)){
          this._svbfn_makeScales();
      }  
         return this;        
      };
     
    StackedVerticalBar.prototype.data = function(value){
          if (!arguments.length){
              return this._svb_data;
          }
          
          this._svb_data = value;
          var obj = MNDHandler(this._svb_data);

            var _data1 = obj["MG1"];
            var _data2 = obj["MG2"];
            this._svb_measureOnAxis1 = obj.MG1Number;
            this._svb_measureOnAxis2 = obj.MG2Number || 0;
            this._svb_MNDInnerOnColor = obj.MNDOnColor && obj.MNDInner;
            this._svb_tooltipData = [];
            
            var i = 0;
            
          if( _data1[0] && _data1[0][0].info && _data1[0][0].info.defaultSelection){
              this._svb_hasDefaultSelection = true;
            }else{
              this._svb_hasDefaultSelection = false;
            }   
            
          if(TypeUtils.isExist(obj.color)){
              this._svb_hasMNDonCategoryAxis = true;
              this._svb_isDualAxis = true;
              var tempData1 = [], tempData2 = [];
              var tempStackedData1 = [], tempStackedData2 = [];
              for(i=0; i<_data1.length; i++){
                tempData1 = [];
                tempData2 = [];
                for(var j=0; j<_data1[i].length; j++){
                  if(obj.color[j] === 0){
                    tempData1.push(_data1[i][j]);
                    tempData2.push({
                    val:null,
                    hasMNDonCategoryAxis : true
                  });
                  }else{

                    tempData1.push({
                    val:null,
                    hasMNDonCategoryAxis : true
                  });
                    tempData2.push(_data1[i][j]);
                  }
                }
                tempStackedData1.push(tempData1);
                tempStackedData2.push(tempData2);
              }
              _data1 = tempStackedData1;
              _data2 = tempStackedData2;

          }else{
            this._svb_hasMNDonCategoryAxis = false;
            if(TypeUtils.isExist(_data2)){
              if(! this._svb_dataStructureChange && (this._svb_data2.length !== _data2.length || this._svb_data2[0].length !== _data2[0].length)){
                      this._svb_dataStructureChange = true;
                   }
              this._svb_isDualAxis = true;
               }else{
                    this._svb_isDualAxis = false;
                }
            }
          
          if(this._svb_data1.length !== _data1.length || this._svb_data1[0].length !== _data1[0].length){
                this._svb_dataStructureChange = true;
              }
          
          var _seriesData = this._svbfn_dataHandler(_data1, _data2);
          this._svb_seriesData = _seriesData;
            this._svb_data1 = _data1;
            this._svb_data2 = _data2;
          
            //judge what changed in dataset
            if(!this._svb_dataStructureChange){
              this._svb_dataValueChange = true;
            }
            
            if(this._svb_hasMNDonCategoryAxis){
              for( i=0; i< this._svb_seriesData.length; i++){
                var temp = this._svb_seriesData[i];
                if(temp[0][0].hasMNDonCategoryAxis){
                  this._svb_tooltipData.push(temp[1]);
                }else{
                  this._svb_tooltipData.push(temp[0]);
                }
              }
            }else{
              this._svb_tooltipData = ObjectUtils.extend(true, {}, this._svb_seriesData); 
            }
            if(TypeUtils.isExist(this._svb_width) && TypeUtils.isExist(this._svb_height)){
                this._svbfn_makeScales();
            }
          
            this._svbfn_parseOptions();
          
          return this;        
        };

        /**
         * set/get properties
        */
    StackedVerticalBar.prototype.properties = function(props){
          if (!arguments.length){
              return this._svb_properties;
           }
          this._svb_properties = Objects.extend(true, this._svb_properties, props);
          this._svbfn_parseOptions();
            
            return this;        
    };
        
    StackedVerticalBar.prototype.destroy = function(){
        if(this._svb_xScale){
           this._svb_xScale.domain([0,1]).range([0,1]);
        }
        if(this._svb_yScale){
            this._svb_yScale.domain([0,1]).range([0,1]);
        }
        if(this._svb_yScale2){
            this._svb_yScale2.domain([0,1]).range([0,1]);
        }
        this._svb_xScale = null;
        this._svb_yScale = null;
        this._svb_yScale2 = null;
        this._svb_seriesData = null;
        this._svb_tooltipData = null;
        
        if(this._svb_effectManager && this._svb_effectManager.destroy){
            this._svb_effectManager.destroy();
            this._svb_effectManager = null;
        }
        if(this._svb_styleManager && this._svb_styleManager.destroy){
            this._svb_styleManager.destroy();
            this._svb_styleManager = null;
        }
        
        
    };    
    
    StackedVerticalBar.prototype.colorPalette = function(Palette){
        if (!arguments.length){
          return this._svb_colorPalette;
       }
        this._svb_colorPalette = Palette;
       return this;        
    };
    
    StackedVerticalBar.prototype.primaryDataRange = function(range){
        if (!arguments.length){
          var maxt, mint;
          if(this._svb_mode === 'percentage'){
            maxt = 1;
            mint = 0;
          }else{
            mint = this._svb_primaryAxisBottomBoundary;
            maxt = this._svb_primaryAxisTopBoundary;
          }
          return {
            min: mint,
            max: maxt
          };
        }
        var tempMax, tempMin;
        if (range !== null) {
            if (!isNaN(range.max)) {
              tempMax = range.max;
            } else {
              tempMax = this._svb_yScale.perfectDomainEnd;
            }
            if (!isNaN(range.min)) {
              tempMin = range.min;
            } else {
              tempMin = this._svb_yScale.perfectDomainBegin;
            }
            if (tempMax > tempMin) {
              this._svb_primaryAxisTopBoundary = tempMax;
              this._svb_primaryAxisBottomBoundary = tempMin;
              if (range.from === 'axis') {
                  this._svb_primaryAxisManualRange = true;
              }
              if(TypeUtils.isExist(this._svb_width) && TypeUtils.isExist(this._svb_height) && TypeUtils.isExist(this._svb_seriesData)){
                  this._svbfn_makeScales();
              }
            }
        } else {
          if (this._svb_primaryAxisManualRange === true) {
            this._svb_primaryAxisTopBoundary = this._svb_yScale.perfectDomainEnd;
            this._svb_primaryAxisBottomBoundary = this._svb_yScale.perfectDomainBegin;
            this._svb_primaryAxisManualRange = false;
            if(TypeUtils.isExist(this._svb_width) && TypeUtils.isExist(this._svb_height) && TypeUtils.isExist(this._svb_seriesData)){
                this._svbfn_makeScales();
            }
          }
        }
        return this;
    };
    
    StackedVerticalBar.prototype.secondDataRange = function(range){
        if (!arguments.length){
          var maxt, mint;
          if(this._svb_mode === 'percentage'){
            maxt = 1;
            mint = 0;
          }else{
            mint = this._svb_secondaryAxisBottomBoundary;
            maxt = this._svb_secondaryAxisTopBoundary;
          }
          return {
            min: mint,
            max: maxt
          };
        }
        var tempMax, tempMin;
        if (range !== null) {
            if (!isNaN(range.max)) {
              tempMax = range.max;
            } else {
              tempMax = this._svb_yScale2.perfectDomainEnd;
            }
            if (!isNaN(range.min)) {
              tempMin = range.min;
            } else {
              tempMin = this._svb_yScale2.perfectDomainBegin;
            }
            if (tempMax > tempMin) {
              this._svb_secondaryAxisTopBoundary = tempMax;
              this._svb_secondaryAxisBottomBoundary = tempMin;
              if (range.from === 'axis') {
                  this._svb_secondaryAxisManualRange = true;
              }
              if(TypeUtils.isExist(this._svb_width) && TypeUtils.isExist(this._svb_height) && TypeUtils.isExist(this._svb_seriesData)){
                  this._svbfn_makeScales();
              }
            }
        } else {
          if (this._svb_secondaryAxisManualRange === true) {
            this._svb_secondaryAxisTopBoundary = this._svb_yScale2.perfectDomainEnd;
            this._svb_secondaryAxisBottomBoundary = this._svb_yScale2.perfectDomainBegin;
            this._svb_secondaryAxisManualRange = false;
            if(TypeUtils.isExist(this._svb_width) && TypeUtils.isExist(this._svb_height) && TypeUtils.isExist(this._svb_seriesData)) {
                this._svbfn_makeScales();
            }
          }
        }
        return this;
      };

    StackedVerticalBar.prototype.categoryScale = function(scale){
          if (!arguments.length){
            return this._svb_xScale;
         }
          this._svb_xScale = scale;
         return this;
    };
    
    StackedVerticalBar.prototype.primaryScale = function(scale){
        if (!arguments.length){
          return this._svb_yScale;
       }
        this._svb_yScale = scale;
        this._svb_valueScales[0] = this._svb_yScale;
       return this;
    };  
    
    StackedVerticalBar.prototype.secondScale = function(scale){
            if (!arguments.length){
                return this._svb_yScale2;
            }
            this._svb_yScale2 = scale;
            this._svb_valueScales[0] = this._svb_yScale2;
            return this;
        };        

    StackedVerticalBar.prototype.primaryAxisColor = function(){
        if(this._svb_isDualAxis && !this._svb_hasMNDonCategoryAxis){
          return this._svb_colorPalette[0];
        }else{
           //Jimmy/Nick/10/18/2012 we are telling axis to draw with default color
          return undefined;
        }
    };
    
    StackedVerticalBar.prototype.secondAxisColor = function(){
        if(TypeUtils.isExist(this._svb_seriesData[0][1]) && !this._svb_hasMNDonCategoryAxis){
          return this._svb_axis2ColorPalette[this._svb_seriesData[0][1].length-1];
        }else{
           //Jimmy/Nick/10/18/2012 we are telling axis to draw with default color
          return undefined;
        }
    };  
    
    /**
     * get preferred size
     * @return {
         'width': NUMBER,
         'height' : NUMBER
       }
     */
    StackedVerticalBar.prototype.getPreferredSize = function(){
       
     };
     
    StackedVerticalBar.prototype.dataLabel = function(_){};
     
    StackedVerticalBar.prototype.dispatch = function(_){
         if(!arguments.length){
             return this._svb_eDispatch;
         }
         this._svb_eDispatch = _;
         return this;
    };
     
    StackedVerticalBar.prototype.primaryAxisTitle = function(_){
        if(!arguments.length){
          var titles =  this._svb_data.getMeasureValuesGroupDataByIdx(0), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join(' & ');
        }
        return this;
      };
      
    StackedVerticalBar.prototype.secondAxisTitle = function(_){
        if(!arguments.length){
          var titles =  this._svb_data.getMeasureValuesGroupDataByIdx(1), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join(' & ');
        }
        return this;
      }; 
    
    StackedVerticalBar.prototype.parent = function(){
          return this._svb_gWrapper;
    };
        
    StackedVerticalBar.prototype.blurOut = function(){
        this._svb_decorativeShape.attr('visibility', 'hidden');
        this._svb_lastHovered = null;
        if (this._svb_tooltipVisible) {
          this._svb_eDispatch.hideTooltip();
        }
    };
      
    StackedVerticalBar.prototype.highlight = function(elems){
        if(elems instanceof Array){
          for(var i = 0, len = elems.length; i < len; i++){
              elems[i].setAttribute('class',CLASSDATAPOINTCOMBINED+ ' ' + CLASSMARKERSELECTED);
            elems[i].setAttribute('fill-opacity', 1);
            if(!this._svb_enableRoundCorner){
                elems[i].setAttribute('stroke', '#333333');
            }
          }
        }else{
          elems.setAttribute('class',CLASSDATAPOINTCOMBINED+ ' ' + CLASSMARKERSELECTED);
          elems.setAttribute('fill-opacity', 1);
          if(!this._svb_enableRoundCorner){
              elems.setAttribute('stroke', '#333333');
          }
        }
        if(this._svb_hasDefaultSelection){
          defaultSelUtil.clearSelectionInfo(this._svb_gWrapper, true, elems);
        }
    };
    
    StackedVerticalBar.prototype.unhighlight = function(elems){
        if(elems instanceof Array){
          for(var i = 0, len = elems.length; i < len; i++){
            elems[i].setAttribute('class',CLASSDATAPOINTCOMBINED);
            elems[i].setAttribute('fill-opacity', 0.4);
            elems[i].setAttribute('stroke','none');
          }
        }else{
          elems.setAttribute('class',CLASSDATAPOINTCOMBINED);
          elems.setAttribute('fill-opacity', 0.4);
          elems.setAttribute('stroke','none');
        }
        if(this._svb_hasDefaultSelection){
          defaultSelUtil.clearSelectionInfo(this._svb_gWrapper, false, elems);
        }
      };
      
    StackedVerticalBar.prototype.clear = function(gray){
        if( gray === null || gray === undefined || gray === false){
          var rects = this._svb_gWrapper.selectAll('.v-datapoint');
              rects.attr('fill-opacity', 1).attr('stroke','none').attr('class',CLASSDATAPOINTCOMBINED);
          if(this._svb_hasDefaultSelection){
            defaultSelUtil.clearSelectionInfo(this._svb_gWrapper, false, rects);
          }
        }else{
          this._svb_gWrapper.selectAll('.v-datapoint').attr('fill-opacity', 0.4).attr('stroke','none').attr('class',CLASSDATAPOINTCOMBINED);
        }
    };

    StackedVerticalBar.prototype.hoverOnPoint = function(point){
        var xOnModule = point.x, yOnModule = point.y;
        // find the closet dimension
        var i = -1;
        while (i < this._svb_seriesData.length) {
          if (Math.abs(xOnModule - this._svb_xScale.rangeBand()*i - 0.5 * this._svb_xScale.rangeBand() ) <= 0.5 * this._svb_xScale.rangeBand()) {
            break;
          }
          i++;
        }

        if (i > (this._svb_seriesData.length - 1) || i < 0) {
          this._svb_decorativeShape.attr('visibility', 'hidden');
          return;
        }

        this._svb_decorativeShape.attr('x',this._svb_xScale.rangeBand() * i + this._svb_barWidth/4)
                       .attr('visibility', 'visible');

        if(this._svb_lastHovered !== i){
          if (this._svb_tooltipVisible){      
            this._svb_lastHovered = i;
            
            //this.parentNode point to plot graphic. it is different from bar chart as in bar chart it should get the yoffset which can get it from mian graphic element
            var transform = this._svb_gWrapper.node().getTransformToElement(this._svb_gWrapper.node().ownerSVGElement);
            var xoffset = transform.e;
            var sumAxis1 = 100, sumAxis2 = 100 , m = 0;
            var tData = tooltipDataHandlerObj.generateTooltipData(this._svb_data, this._svb_tooltipData, i, this._svb_colorPalette, this._svb_shapePalette);
            tData.point = {
              x: this._svb_xScale.rangeBand()*i + 0.5 * this._svb_xScale.rangeBand() + xoffset,
              y: point.y
            };
            tData.plotArea = {
              x : transform.e,
              y : transform.f,
              width : this._svb_width,
              height : this._svb_height
            };
            tData.valueAxis0Count = this._svb_seriesData[0][0].length;
            tData.valueAxis1Count = TypeUtils.isExist(this._svb_seriesData[0][1]) ? this._svb_seriesData[0][1].length:0;
            this._svb_eDispatch.showTooltip(tooltipDataHandler.formatTooltipData(tData));
          }
        }
      };
    
    StackedVerticalBar.prototype._svbfn_dataHandler = function(valueAxis1Data, valueAxis2Data, colorIndexArray){
         var positiveIndex = -1, negativeIndex = -1;
         this._svb_positiveIndexes = [[],[]], this._svb_negativeIndexes = [[],[]];
     
         this._svb_primaryAxisTopBoundary = this._svb_primaryAxisBottomBoundary = 0;
         this._svb_secondaryAxisTopBoundary = this._svb_secondaryAxisBottomBoundary = 0;
       
         var stackedBarGroupsData = [];
       
         // the number of bar in each group
         this._svb_barGroupNumber =  valueAxis1Data[0].length;
         var temp, temp2;
         for(var j=0; j < this._svb_barGroupNumber; j++){
             var tempDataSetAxis1 = [], tempDataSetAxis2 = [];
             var oneGroupDataSet = [];
             temp = 0, temp2 = 0;
             positiveIndex = -1, negativeIndex = -1;
             for(var i=0; i< valueAxis1Data.length; i++){
                 if(NumberUtils.isNoValue(valueAxis1Data[i][j].val)){
                     //Jimmy/1/9/2013, what happens if we use null as the number value
                     //see http://stackoverflow.com/questions/2910495/why-null-0-null-0-but-not-null-0
                     //and http://bclary.com/2004/11/07/#a-11.8.5
                     //checked in chrome/IE9/firefox/javafx, it works fine
                     //the change is to ensure we display 'No Value' in other places related to this data point
                     valueAxis1Data[i][j].val = null;
                     valueAxis1Data[i][j].isNaN = true;
                 }else{
                     if(valueAxis1Data[i][j].val >= 0){
                         temp += valueAxis1Data[i][j].val;
                         positiveIndex = i;
                     }else{
                         temp2 += valueAxis1Data[i][j].val;
                         negativeIndex = i;
                     }
                 }
                 tempDataSetAxis1.push(valueAxis1Data[i][j]);
             }
             this._svb_positiveIndexes[0].push(positiveIndex);
             this._svb_negativeIndexes[0].push(negativeIndex);
       
             if(this._svb_primaryAxisTopBoundary < temp){
                 this._svb_primaryAxisTopBoundary = temp;
             }
             if(this._svb_primaryAxisBottomBoundary > temp2){
                 this._svb_primaryAxisBottomBoundary = temp2;
             }
             oneGroupDataSet.push(tempDataSetAxis1);
       
             if(TypeUtils.isExist(valueAxis2Data)){
                 temp = 0, temp2 = 0;
                 positiveIndex = -1, negativeIndex = -1;
                 for(i=0; i< valueAxis2Data.length; i++){
                     if(NumberUtils.isNoValue(valueAxis2Data[i][j].val)){
                         //Jimmy/1/9/2013, what happens if we use null as the number value
                         //see http://stackoverflow.com/questions/2910495/why-null-0-null-0-but-not-null-0
                         //and http://bclary.com/2004/11/07/#a-11.8.5
                         //checked in chrome/IE9/firefox/javafx, it works fine
                         //the change is to ensure we display 'No Value' in other places related to this data point
                         valueAxis2Data[i][j].val = null;
                         valueAxis2Data[i][j].isNaN = true;
                     }else{             
                         if(valueAxis2Data[i][j].val >= 0){
                             temp += valueAxis2Data[i][j].val;
                             positiveIndex = i;
                         }else{
                             temp2 += valueAxis2Data[i][j].val;
                             negativeIndex = i;
                         }
                     }
                     tempDataSetAxis2.push(valueAxis2Data[i][j]);
                 }
                 this._svb_positiveIndexes[1].push(positiveIndex);
                 this._svb_negativeIndexes[1].push(negativeIndex);
         
                 if(this._svb_secondaryAxisTopBoundary < temp){
                     this._svb_secondaryAxisTopBoundary = temp;
                 }
                 if(this._svb_secondaryAxisBottomBoundary > temp2){
                     this._svb_secondaryAxisBottomBoundary = temp2;
                 }
                 oneGroupDataSet.push(tempDataSetAxis2);
             }
             stackedBarGroupsData.push(oneGroupDataSet);
        }
        return stackedBarGroupsData;
    };
          
    StackedVerticalBar.prototype._svbfn_makeScales = function(){
        var domain = [];
        for (var i=0; i < this._svb_seriesData.length; i++){
            domain.push(i);
          }
          this._svb_xScale.domain(domain).rangeBands([0, this._svb_width]);

          if(this._svb_mode === 'percentage'){
            this._svb_yScale.domain([0,1]).range([this._svb_height, 0]);
            this._svb_yScale2.domain([0,1]).range([this._svb_height, 0]);
            Scaler.perfect(this._svb_yScale);
            Scaler.perfect(this._svb_yScale2);
          }else{
            //when all data is 0 or null, we make the domain from 0 to 1
            if( this._svb_primaryAxisBottomBoundary === 0 && this._svb_primaryAxisTopBoundary === 0 ){
              this._svb_yScale.domain([0,1]).range([this._svb_height, 0]);
            }else{
              this._svb_yScale.domain([this._svb_primaryAxisBottomBoundary,this._svb_primaryAxisTopBoundary]).range([this._svb_height, 0]);
            }

            if(TypeUtils.isExist(this._svb_data2) || this._svb_isDualAxis){
            //when data of second axis is all 0 or null, we make the xScale2 same with xScale .

              if(this._svb_secondaryAxisTopBoundary === 0 && this._svb_secondaryAxisBottomBoundary === 0){
                this._svb_yScale2.domain(this._svb_yScale.domain()).range(this._svb_yScale.range());
              }else{
                this._svb_yScale2.domain([this._svb_secondaryAxisBottomBoundary, this._svb_secondaryAxisTopBoundary]).range([this._svb_height, 0]);
                //when data of first axis is all 0 or null, we make the xScale same with xScale2 .
                if(this._svb_primaryAxisBottomBoundary === 0 && this._svb_primaryAxisTopBoundary === 0){
                  this._svb_yScale.domain(this._svb_yScale2.domain()).range(this._svb_yScale2.range());
                }
              }
                        
              if (!this._svb_primaryAxisManualRange && !this._svb_secondaryAxisManualRange)
              {
                  Scaler.perfectDual(this._svb_yScale, this._svb_yScale2);
              }
              else if(!this._svb_primaryAxisManualRange && this._svb_secondaryAxisManualRange)
              {
                  Scaler.perfect(this._svb_yScale);
                  Scaler.getRoughTickNum(this._svb_yScale2);
              }
              else if(this._svb_primaryAxisManualRange && !this._svb_secondaryAxisManualRange)
              {
                  Scaler.perfect(this._svb_yScale2);
                  Scaler.getRoughTickNum(this._svb_yScale);
              }
              else 
              {
                  Scaler.getRoughTickNum(this._svb_yScale);
                  Scaler.getRoughTickNum(this._svb_yScale2);
              }
            }else{
              if (!this._svb_primaryAxisManualRange) {
                Scaler.perfect(this._svb_yScale);
              } else {
                Scaler.getRoughTickNum(this._svb_yScale);
              }
            }
          }
          if(!TypeUtils.isExist(this._svb_data2)){
              this._svb_yScale2.range([0, 0]);
          }
      };
    
	StackedVerticalBar.prototype._svbfn_completeAnimation = function(){
        if( ++this._svb_currentAnimationCount ===  this._svb_totalAnimationCount){
            this._svb_eDispatch.initialized();
            this._svb_afterAttachToDOM = true;
        }
    };
	
	StackedVerticalBar.prototype._svbfn_enableAnimation = function () {
		var hasAnmation = false;
		if(!this._svb_isOnlyInitAnimation){
			hasAnmation = this._svb_enableDataLoadingAnimation;
		}else if (this._svb_dataStructureChange || this._svb_dataValueChange) {
			hasAnmation = this._svb_enableDataUpdatingAnimation;
		}else if (this._svb_sizeChange) {
			hasAnmation = this._svb_enableResizingAnimation;
		}
		return hasAnmation;
	};
	
	StackedVerticalBar.prototype._svbfn_turnToPercentage = function () {
		for(var i=0, len = this._svb_seriesData.length; i < len; i++){
			for(var j=0 , rowSeriesData = this._svb_seriesData[i], rowTooltipData = this._svb_tooltipData[i]; j < rowSeriesData.length; j++){
				var sum = 0, avaCount = 0, k;
				for(k=0; k < rowSeriesData[j].length; k++){
					sum += Math.abs(rowSeriesData[j][k].val);
                    if(!rowSeriesData[j][k].isNaN) {avaCount++;}
				}
				if(sum === 0) {
					for(k=0; k < rowSeriesData[j].length; k++){
                        rowSeriesData[j][k].value = TypeUtils.isExist(rowSeriesData[j][k].value) ? rowSeriesData[j][k].value : rowSeriesData[j][k].val;
                        rowSeriesData[j][k].val = rowSeriesData[j][k].isNaN? 0:1/avaCount ;
                        if(TypeUtils.isExist(rowTooltipData[j]) &&TypeUtils.isExist(rowTooltipData[j][k]) ){
                          rowTooltipData[j][k].val = rowTooltipData[j][k].isNaN? ' ' : 1/avaCount;
                        }
					}
				}else{
					for( k=0; k < rowSeriesData[j].length; k++){
					if(rowSeriesData[j][k].val < 0){
                        rowSeriesData[j][k].isNegative = true;
					}
					rowSeriesData[j][k].value = TypeUtils.isExist(rowSeriesData[j][k].value) ? rowSeriesData[j][k].value : rowSeriesData[j][k].val;
					rowSeriesData[j][k].val = Math.abs(rowSeriesData[j][k].val/sum);
					if(TypeUtils.isExist(rowTooltipData[j]) &&TypeUtils.isExist(rowTooltipData[j][k]) ){
						rowTooltipData[j][k].val = rowTooltipData[j][k].isNaN? ' ' : rowTooltipData[j][k].val/sum;
					}
				}
				}
			}
		}
	};

	StackedVerticalBar.prototype._svbfn_parseOptions = function (){
		this._svb_enableRoundCorner = this._svb_properties.isRoundCorner;  
		this._svb_mode = this._svb_properties.mode === 'percentage'? 'percentage': 'comparison';
		this._svb_enableDataLoadingAnimation = this._svb_properties.animation.dataLoading; 
		this._svb_enableDataUpdatingAnimation = this._svb_properties.animation.dataUpdating; 
		this._svb_enableResizingAnimation = this._svb_properties.animation.resizing;
		this._svb_tooltipVisible = this._svb_properties.tooltip.enabled;    
		if(this._svb_isDualAxis && ! this._svb_hasMNDonCategoryAxis){
			this._svb_axis1ColorPalette = this._svb_properties.primaryValuesColorPalette;   
            this._svb_axis2ColorPalette = this._svb_properties.secondaryValuesColorPalette;
		}else{
			this._svb_axis2ColorPalette = this._svb_properties.colorPalette;
            this._svb_axis1ColorPalette = this._svb_properties.colorPalette;
		}
		this._svb_drawingEffect = this._svb_properties.drawingEffect;
		this._svb_colorPalette = [];
		
		var flag = 0, flag2 = 0, j = 0, i = 0;
		if(this._svb_MNDInnerOnColor){
			for(i=0 ; i < this._svb_seriesData[0][0].length; i++){
				this._svb_colorPalette.push(this._svb_axis1ColorPalette[i % this._svb_axis1ColorPalette.length]);
                flag++;
                if(flag === this._svb_measureOnAxis1 && this._svb_isDualAxis && TypeUtils.isExist(this._svb_seriesData[0][1])){
                    flag2 = 0;
                    for(; j <= this._svb_seriesData[0][1].length; j++){
                        if(flag2 >= this._svb_measureOnAxis2){
                            flag = 0;
                            break;
                        }
                        this._svb_colorPalette.push(this._svb_axis2ColorPalette[j % this._svb_axis2ColorPalette.length]);  
                        flag2++;
                    }
                }
			}
		}else{
			for(i=0 ; i < this._svb_seriesData[0].length; i++){
                    for(j=0; j < this._svb_seriesData[0][0].length; j++){
                    this._svb_colorPalette.push(this._svb_axis1ColorPalette[j % this._svb_axis1ColorPalette.length]);
                }
                if(this._svb_isDualAxis && TypeUtils.isExist(this._svb_seriesData[0][1])){
                    for(j=0; j < this._svb_seriesData[0][1].length; j++){
                        this._svb_colorPalette.push(this._svb_axis2ColorPalette[j % this._svb_axis2ColorPalette.length]);  
                    }
                 }
             }  
		}
	};
	
	return StackedVerticalBar;
});
define('sap/viz/modules/util/PinchUtil',[],
function Setup() 
{
  var PinchUtil = {

  };
  
  PinchUtil.zoomInfo = function(axis, gestureScale, point, length, type) {
    var scale = gestureScale;
    var range = axis.range(), rangeBand = axis.rangeBand();
    var rangeLength = rangeBand * range.length;
    
    if (gestureScale > 1) {
      if (rangeBand >= length) {
        return null;
      } else if (rangeBand * gestureScale >= length) {
        scale = length /rangeBand;
      }
    } else if (gestureScale < 1 && gestureScale > 0) {
      if (rangeLength <= length) {
        return null;
      } else if (rangeLength * gestureScale <= length) {
        scale = length /rangeLength;
      }
    }
    
    var rangeBandValue;
    if (type === 'bottom' || type === 'top') {
      rangeBandValue = [0, rangeLength * scale];
    } else {
      rangeBandValue = [rangeLength * scale, 0];  
    }
    
    return {
      scale : scale,
      rangeBand : rangeBandValue,
      offset : {
        x : point.x - scale * point.x,
        y : point.y - scale * point.y   
      }
    };
  };
  
  PinchUtil.pinchPointOffset = function(node, axisList, plot) {
    var  transform = node.getTransformToElement(node.parentNode);
    var offset = {};
    var height, width;
    var range = 0;
    if (axisList.xAxis.type === 'value') {
      range = axisList.xAxis.axis.range();  
    } else if (axisList.yAxis.type === 'value') {
      range = axisList.yAxis.axis.range();
    }
    height = Math.abs(range[0] - range[range.length - 1]);
    
    if (axisList.xAxis.type === 'category') {
      width = axisList.xAxis.axis.range().length * axisList.xAxis.axis.rangeBand();   
    } else if (axisList.yAxis.type === 'category') {
      width = axisList.yAxis.axis.range().length * axisList.yAxis.axis.rangeBand();
      
    }
    
    if( transform.e  > 0 ) {
      offset.x = - transform.e;  
    } else if ( transform.e + width < plot.width ) {
      offset.x = plot.width - ( transform.e + width);
    } else {
      offset.x = 0;    
    }
    
    if( transform.f > 0) {
      offset.y = - transform.f;  
    } else if ( transform.f + height < plot.height ){
      offset.y = plot.height - ( transform.f + height); 
    } else {
      offset.y = 0;
    }
    
    return offset;
  };
  
  PinchUtil.convertToLayerPoint = function(point, selection, className) {
    var datashapes = selection.select(className);
    if (datashapes) {
      var node = datashapes.node();
      if (node) {
        var transform = node.getTransformToElement(node.parentNode);
        return {
          x : point.x -transform.e,
          y : point.y -transform.f
        };
      }
    }
  };
  
  return PinchUtil;
});
define('sap/viz/modules/verticalbar',['sap/viz/base/utils/TypeUtils', 'sap/viz/modules/dispatch', 'sap/viz/modules/util/MNDHandler', 'sap/viz/modules/util/tooltipDataHandler', 'sap/viz/util/ColorSeriesGenerator', 'sap/viz/util/Scaler', 'sap/viz/base/utils/ObjectUtils', 'sap/viz/util/NumberUtils', 'sap/viz/base/utils/Objects', 'sap/viz/lang/langManager', 'sap/viz/modules/util/BoundUtil', 'sap/viz/modules/util/defaultSelectionUtil', 'sap/viz/base/UADetector', 'sap/viz/modules/Constants', 'sap/viz/modules/util/PinchUtil', 'sap/viz/modules/util/ClippathUtil', "sap/viz/base/utils/oo", "sap/viz/modules/Base"], function Setup(TypeUtils, dispatch, MNDHandler, tooltipDataHandler, ColorSeries, Scaler, ObjectUtils, NumberUtils, Objects, langManager, boundUtil, defaultSelUtil, UADetector, Constants, PinchUtil, ClippathUtil, oo, Base) {

    var CLASSMARKERSELECTED = "v-datapoint-selected", CLASSMARKERHOVER = "v-datapoint-hover", CLASSDATAPOINT = "v-datapoint", CLASSMORPHABLEDATAPOINT = Constants.CSS.CLASS.MORPHABLEDATAPOINT;
    var CLASSDATAPOINTCOMBINED = CLASSDATAPOINT + ' ' + CLASSMORPHABLEDATAPOINT;
    var CLASSDATASHAPESGROUP = "v-datashapesgroup";

    var vBar = function(manifest, ctx) {

        this._vbar_gapObj = null;

        this._vbar_styleManager = ctx.styleManager;
        this._vbar_tooltipDataHandlerObj = null;
        this._vbar_data1 = null;
        this._vbar_data2 = null;
        this._vbar_data = null;
        this._vbar_seriesData = []; 
        this._vbar_primaryAxisTopBoundary = 0;
        this._vbar_primaryAxisBottomBoundary = 0; 
        this._vbar_primaryAxisManualRange = false; 
        this._vbar_secondaryAxisManualRange = false; 
        this._vbar_secondaryAxisTopBoundary = 0; 
        this._vbar_secondaryAxisBottomBoundary = 0; 
        this._vbar_parent = null; 
        this._vbar_pinchPoint = null;
        this._vbar_hasMNDonCategoryAxis = false;

        this._vbar_width = 0;
        this._vbar_height = 0;
        this._vbar_id = Math.floor(Math.random() * 10000); 
        this._vbar_x = 0; 
        this._vbar_y = 0; 
        this._vbar_isDualAxis = false; 
        this._vbar_colorPalette = []; 
        this._vbar_axis1ColorPalette = []; 
        this._vbar_axis2ColorPalette = []; 
        this._vbar_MNDInnerOnColor = false; 
        this._vbar_measureOnAxis1 = 0; 
        this._vbar_measureOnAxis2 = 0; 
        this._vbar_shapePalette = ['squareWithRadius'];
        // properties,
        this._vbar_dispatch = new dispatch('showTooltip', 'hideTooltip', 'initialized', 'startToInit', 'scale', 'stretch', 'stretchEnd');

        this._vbar_effectManager = ctx.effectManager;

        this._vbar_valueScales = []; 
        this._vbar_xScale = d3.scale.ordinal(); 
        this._vbar_yScale = d3.scale.linear(); 
        this._vbar_yScale2 = d3.scale.linear();

        this._vbar_decorativeShape = null; 
        this._vbar_tooltipVisible = true; 
        this._vbar_lastHovered = null;

        this._vbar_indexforSecondaryAxis = 0; 
        this._vbar_barNumber = 0; 
        this._vbar_barGroupNumber = 0; 
        this._vbar_barWidth = 0; 

        this._vbar_enableDataLoadingAnimation = true; 
        this._vbar_enableDataUpdatingAnimation = true; 
        this._vbar_enableResizingAnimation = true; // control resizing animation
        this._vbar_enableRoundCorner = false; 
        this._vbar_hasDefaultSelection = false;
        this._vbar_totalIntervalTime = 1000; 
        this._vbar_afterAttachToDOM = false; 
        this._vbar_isOnlyInitAnimation = false;

        this._vbar_defsEnter = null; 
        this._vbar_roundCornerDefs = null; 
        this._vbar_suffix = ObjectUtils.guid();
        this._vbar_drawingEffect = 'normal';

        this._vbar_sizeChange = false; 
        this._vbar_dataStructureChange = false; 
        this._vbar_dataValueChange = false;
        this._vbar_properties = manifest.props(null);
        this._vbar_isPinching = false;

        this._vbar_currentAnimationCount = 0;
        this._vbar_totalAnimationCount = 0;

        return this;

    };

    oo.extend(vBar, Base);

    vBar.prototype.render = function(selection) {

        boundUtil.drawBound(selection, this._vbar_width, this._vbar_height);
        if (UADetector.isMobile()) {
            var clippathid = ClippathUtil.drawClippath(selection, this._vbar_width, this._vbar_height);
            selection.attr('clip-path', "url(#" + clippathid + ")");
        }

        this._vbar_tooltipDataHandlerObj = tooltipDataHandler();

        // [19-Oct-2012 Nick] if the size of plot area is too small, there is no value scale created and the whole drawing part is skipped.
        if (this._vbar_valueScales.length === 0) {
            return;
        }

        this._vbar_dispatch.startToInit();

        this._vbar_barNumber = this._vbar_seriesData[0].length;
        this._vbar_barGroupNumber = this._vbar_seriesData.length;
        this._vbar_barWidth = 8 * (this._vbar_xScale.rangeBand()) / (9 * this._vbar_barNumber + 7 );
        this._vbar_currentAnimationCount = 0;
        this._vbar_totalAnimationCount = this._vbar_barGroupNumber * this._vbar_barNumber;
       
        var svg = this._vbar_parent = selection;

        if (!this._vbar_decorativeShape) {
            this._vbar_decorativeShape = svg.append('rect').attr('width', this._vbar_xScale.rangeBand() - this._vbar_barWidth / 2).attr('height', this._vbar_height).attr('visibility', 'hidden').attr('fill', this._vbar_styleManager.queryDefault('v-hovershadow').fill).attr('class', 'v-hovershadow');
        } else {
            this._vbar_decorativeShape.attr('width', this._vbar_xScale.rangeBand() - this._vbar_barWidth / 2).attr('height', this._vbar_height).attr('visibility', 'hidden');
        }

        //vertical bar
        if (!this._vbar_defsEnter) {
            this._vbar_defsEnter = svg.append('defs').append('clipPath').attr('id', 'clipPlot_' + this._vbar_id).append('rect').attr('width', this._vbar_width).attr('height', this._vbar_height);
        } else {
            this._vbar_defsEnter.attr('width', this._vbar_width).attr('height', this._vbar_height);
        }

        if (!this._vbar_roundCornerDefs) {
            this._vbar_roundCornerDefs = svg.append('defs');
        } else {
            if (this._vbar_dataStructureChange || this._vbar_sizeChange || this._vbar_dataValueChange || !this._vbar_enableRoundCorner) {
                this._vbar_roundCornerDefs.selectAll(".v-clippath").remove();
            }
        }

        var datashapesgroup = svg.selectAll('g.v-datashapesgroup');

        if (!TypeUtils.isExist(datashapesgroup[0][0])) {
            datashapesgroup = this._vbar_parent.append('g').attr('class', 'v-datashapesgroup').attr("fill", "none");
            if (!UADetector.isMobile()) {
                datashapesgroup.attr("clip-path", "url(#clipPlot_" + this._vbar_id + ")");
            }
        }

        if (this._vbar_dataStructureChange || this._vbar_dataValueChange || this._vbar_propertiesChange || this._vbar_isPinching) {
            this.draw();
        } else if (this._vbar_sizeChange) {
            this.refresh();
        }

        if (!this._vbarfn_enableAnimation()) {
            this._vbar_dispatch.initialized();
        }

        //reset status
        this._vbar_sizeChange = false, this._vbar_dataStructureChange = false, this._vbar_dataValueChange = false, this._vbar_propertiesChange = false;
        this._vbar_isOnlyInitAnimation = true;

        return this;
    };

    vBar.prototype.draw = function() {

        var r = Math.log(this._vbar_barWidth) / Math.log(2);

        if (r < 0) {
            this._vbar_enableRoundCorner = false;
        }

        var datashapesgroup = this._vbar_parent.selectAll('g.v-datashapesgroup');

        var barGroup = datashapesgroup.selectAll('g.v-column').data(this._vbar_seriesData), lastBarGroupIndex = this._vbar_seriesData.length - 1;
        var that = this, xArray = [];

        var interval = that._vbar_totalIntervalTime / (that._vbar_barNumber * that._vbar_barGroupNumber);

        barGroup.enter().append('g').attr('class', 'v-column');

        var barShape = barGroup.selectAll('g.v-datashape').data(function(d) {
            return d;
        });

        barShape.enter().append('g').attr('class', 'v-datashape').append('rect').classed(CLASSDATAPOINT, true).classed(CLASSDATAPOINTCOMBINED, true);

        // [21-Nov-2012 Nick] Keep the original x-position for each g.datashape, it is used when data value changes.

        barShape.attr('transform', function(perRectData, m, i) {
            var y;
            var valueScale = that._vbar_valueScales[perRectData.valueAxis];
            if (perRectData.val >= 0) {
                y = valueScale(perRectData.val);
            } else {
                y = valueScale(0);
            }
            var x = that._vbar_xScale(i) + that._vbar_barWidth * m;
            x = x + that._vbar_barWidth / 8 * (m) + that._vbar_barWidth / 2;
            xArray.push(x);
            return 'translate(' + x + ',' + y + ')';
        });

        var bar = barShape.select('rect.v-datapoint'), lastBarIndex = that._vbar_seriesData[0].length - 1;

        bar.attr('fill', function(perRectData, i) {
            perRectData.fillColor = that._vbar_colorPalette[i % that._vbar_colorPalette.length];
            var parameter = {
                drawingEffect : that._vbar_drawingEffect,
                fillColor : perRectData.fillColor,
                direction : 'horizontal'
            };
            return that._vbar_effectManager.register(parameter);
        }).attr('shape-rendering', 'crispEdges').attr('fill-opacity', 1).attr('stroke', 'none');

        if (that._vbarfn_enableAnimation()) {
            // [05 - Sep - 2012 Nick] DataStructureChange means the structure of data is changed.
            // It means the whole DOM nodes needed to be removed (handled by d3) and append new ones.
            adjustBarWithDataStructureChangeAnimation(bar, that, xArray, r, interval, lastBarIndex, lastBarGroupIndex);
        }
        // [04 - Sep - 2012 Nick] if the animation is disabled
        else {
            adjustBarWithoutAnimation(bar, that, r, interval);
        }

        barShape.exit().remove();

        barGroup.exit().remove();

    };

    /**
     * Refreshing the chart. Only reset the width, height, x and y. It is supposed that we may do not
     * remove or add any shape when running this function.
     */
    vBar.prototype.refresh = function() {
        var r = Math.log(this._vbar_barWidth) / Math.log(2);

        if (r < 0) {
            this._vbar_enableRoundCorner = false;
        }

        var datashapesgroup = this._vbar_parent.selectAll('g.v-datashapesgroup');

        var barGroup = datashapesgroup.selectAll('g.v-column').data(this._vbar_seriesData), lastBarGroupIndex = this._vbar_seriesData.length - 1;

        var that = this, xArray = [];

        var interval = that._vbar_totalIntervalTime / (that._vbar_barNumber * that._vbar_barGroupNumber);

        var barShape = barGroup.selectAll('g.v-datashape').data(function(d) {
            return d;
        });

        barShape.attr('transform', function(perRectData, m, i) {
            var y;
            var valueScale = that._vbar_valueScales[perRectData.valueAxis];
            if (perRectData.val >= 0) {
                y = valueScale(perRectData.val);
            } else {
                y = valueScale(0);
            }
            var x = that._vbar_xScale(i) + that._vbar_barWidth * m;
            x = x + that._vbar_barWidth / 8 * (m) + that._vbar_barWidth / 2;
            xArray.push(x);
            return 'translate(' + x + ',' + y + ')';
        });

        var bar = barShape.select('rect.v-datapoint'), lastBarIndex = that._vbar_seriesData[0].length - 1;

        if (that._vbarfn_enableAnimation()) {
            // [05 - Sep - 2012 Nick] DataStructureChange means the structure of data is changed.
            // It means the whole DOM nodes needed to be removed (handled by d3) and append new ones.
            adjustBarWithSizeChangeAnimation(bar, that, xArray, r, interval, lastBarIndex, lastBarGroupIndex);
        }
        // [04 - Sep - 2012 Nick] if the animation is disabled
        else {
            adjustBarWithoutAnimation(bar, that, r, interval);
        }

    };

    vBar.prototype.width = function(_) {
        if (!arguments.length) {
            return this._vbar_width;
        }
        this._vbar_sizeChange = (this._vbar_width === _) && !this._vbar_sizeChange ? false : true;
        this._vbar_width = _;
        if (TypeUtils.isExist(this._vbar_width) && TypeUtils.isExist(this._vbar_height) && TypeUtils.isExist(this._vbar_seriesData)) {
            this._vbarfn_makeScales();
        }
        return this;
    };

    vBar.prototype.height = function(_) {
        if (!arguments.length) {
            return this._vbar_width;
        }
        this._vbar_sizeChange = (this._vbar_height === _) && !this._vbar_sizeChange ? false : true;
        this._vbar_height = _;
        if (TypeUtils.isExist(this._vbar_width) && TypeUtils.isExist(this._vbar_height) && TypeUtils.isExist(this._vbar_seriesData)) {
            this._vbarfn_makeScales();
        }
        return this;
    };

    /**
     * set/get data, for some modules like Title, it doesn't need data
     */
    vBar.prototype.data = function(value) {
        if (!arguments.length) {
            return this._vbar_data;
        }
        this._vbar_data = value;

        var obj = MNDHandler(this._vbar_data);

        this._vbar_data1 = obj["MG1"];
        this._vbar_data2 = obj["MG2"];
        this._vbar_measureOnAxis1 = obj.MG1Number;
        this._vbar_measureOnAxis2 = obj.MG2Number || 0;
        this._vbar_MNDInnerOnColor = obj.MNDOnColor && obj.MNDInner;

        if (this._vbar_data1[0] && this._vbar_data1[0][0].info && this._vbar_data1[0][0].info.defaultSelection) {
            this._vbar_hasDefaultSelection = true;
        } else {
            this._vbar_hasDefaultSelection = false;
        }

        if (TypeUtils.isExist(obj.color)) {
            this._vbar_hasMNDonCategoryAxis = true;
            this._vbar_isDualAxis = true;
        } else {
            this._vbar_hasMNDonCategoryAxis = false;
            if (TypeUtils.isExist(this._vbar_data2)) {
                this._vbar_isDualAxis = true;
            } else {
                this._vbar_isDualAxis = false;
            }
        }

        var _seriesData = dataTransform.call(this, this._vbar_data1, this._vbar_data2, obj.color);
        //judge what changed in dataset
        if (this._vbar_seriesData.length !== _seriesData.length || _seriesData[0].length !== this._vbar_seriesData[0].length) {
            this._vbar_dataStructureChange = true;
        } else {
            this._vbar_dataValueChange = true;
        }
        this._vbar_seriesData = _seriesData;
        if (TypeUtils.isExist(this._vbar_width) && TypeUtils.isExist(this._vbar_height)) {
            this._vbarfn_makeScales();
        }

        this._vbarfn_parseOptions();
        return this;
    };

    /**
     * set/get properties
     */
    vBar.prototype.properties = function(props) {
        if (!arguments.length) {
            return this._vbar_properties;
        }
        this._vbar_propertiesChange = true;
        Objects.extend(true, this._vbar_properties, props);
        this._vbarfn_parseOptions();

        return this;
    };

    vBar.prototype.parent = function(_) {
        if (!arguments.length) {
            return this._vbar_parent;
        }
        this._vbar_parent = _;
        return this;
    };

    vBar.prototype.primaryAxisTitle = function(_) {
        if (!arguments.length) {
            var titles = this._vbar_data.getMeasureValuesGroupDataByIdx(0), title = [];
            if (titles) {
                for (var i = 0, len = titles.values.length; i < len; i++) {
                    if (titles.values[i].col !== null && titles.values[i].col !== undefined) {
                        title.push(titles.values[i].col);
                    } else {
                        title.push(langManager.get('IDS_ISNOVALUE'));
                    }
                }
            }
            return title.join(' & ');
        }
        return this;
    };

    vBar.prototype.secondAxisTitle = function(_) {
        if (!arguments.length) {
            var titles = this._vbar_data.getMeasureValuesGroupDataByIdx(1), title = [];
            if (titles) {
                for (var i = 0, len = titles.values.length; i < len; i++) {
                    if (titles.values[i].col !== null && titles.values[i].col !== undefined) {
                        title.push(titles.values[i].col);
                    } else {
                        title.push(langManager.get('IDS_ISNOVALUE'));
                    }
                }
            }
            return title.join(' & ');
        }
        return this;
    };

    vBar.prototype.dispatch = function(_) {
        if (!arguments.length) {
            return this._vbar_dispatch;
        }
        this._vbar_dispatch = _;
        return this;
    };

    vBar.prototype.dataLabel = function(_) {
    };

    vBar.prototype.eventTarget = function(evt) {
        if (evt.type === 'mousemove') {
            return this.hoverOnPoint;
        } else if (evt.type === 'mouseout') {
            return this.blurOut;
        }
    };

    /**
     * get/set your color palette if you support color palette
     */
    vBar.prototype.colorPalette = function(_) {
        if (!arguments.length) {
            return this._vbar_colorPalette;
        }
        this._vbar_colorPalette = _;
        return this;
    };

    /**
     * get/set your shape Palette if you support shape Palette
     */
    vBar.prototype.shapePalette = function(_) {
        if (!arguments.length) {
            return this._vbar_shapePalette;
        }
        this._vbar_shapePalette = _;
        return this;
    };

    /**
     * get preferred size
     * @return {
     'width': NUMBER,
     'height' : NUMBER
     }
     */
    vBar.prototype.getPreferredSize = function() {

    };

    /**
     * TODO: please fill your comments here, or jsdoc will complain.
     */
    vBar.prototype.categoryScale = function(scale) {
        if (!arguments.length) {
            return this._vbar_xScale;
        }
        this._vbar_xScale = scale;
        return this;
    };

    vBar.prototype.self = function() {

        return this;
    };

    vBar.prototype.primaryScale = function(scale) {
        if (!arguments.length) {
            return this._vbar_yScale;
        }
        this._vbar_yScale = scale;
        this._vbar_valueScales[0] = this._vbar_yScale;
        return this;
    };

    vBar.prototype.secondScale = function(scale) {
        if (!arguments.length) {
            return this._vbar_yScale2;
        }
        this._vbar_yScale2 = scale;
        this._vbar_valueScales[1] = this._vbar_yScale2;
        return this;
    };

    vBar.prototype.primaryAxisColor = function() {
        if (this._vbar_isDualAxis && !this._vbar_hasMNDonCategoryAxis) {
            return this._vbar_colorPalette[0];
        } else {
            //Jimmy/Nick/10/18/2012 we are telling axis to draw with default color
            return undefined;
        }
    };

    vBar.prototype.secondAxisColor = function() {
        if (!this._vbar_hasMNDonCategoryAxis) {
            return this._vbar_colorPalette[this._vbar_seriesData[0].length - 1];
        } else {
            //Jimmy/Nick/10/18/2012 we are telling axis to draw with default color
            return undefined;
        }
    };

    vBar.prototype.primaryDataRange = function(range) {
        if (!arguments.length) {
            return {
                min : this._vbar_primaryAxisBottomBoundary,
                max : this._vbar_primaryAxisTopBoundary
            };
        }
        var tempMax, tempMin;
        if (range !== null) {
            if (!isNaN(range.max)) {
                tempMax = range.max;
            } else {
                tempMax = this._vbar_yScale.perfectDomainEnd;
            }
            if (!isNaN(range.min)) {
                tempMin = range.min;
            } else {
                tempMin = this._vbar_yScale.perfectDomainBegin;
            }
            if (tempMax > tempMin) {
                this._vbar_primaryAxisTopBoundary = tempMax;
                this._vbar_primaryAxisBottomBoundary = tempMin;
                if (range.from === 'axis') {
                    this._vbar_primaryAxisManualRange = true;
                }

                if (TypeUtils.isExist(this._vbar_width) && TypeUtils.isExist(this._vbar_height) && TypeUtils.isExist(this._vbar_seriesData)) {
                    this._vbarfn_makeScales();
                }
            }
        } else {
            if (this._vbar_primaryAxisManualRange === true) {
                this._vbar_primaryAxisTopBoundary = this._vbar_yScale.perfectDomainEnd;
                this._vbar_primaryAxisBottomBoundary = this._vbar_yScale.perfectDomainBegin;
                this._vbar_primaryAxisManualRange = false;
                if (TypeUtils.isExist(this._vbar_width) && TypeUtils.isExist(this._vbar_height) && TypeUtils.isExist(this._vbar_seriesData)) {
                    this._vbarfn_makeScales();
                }
            }
        }
        return this;
    };

    vBar.prototype.secondDataRange = function(range) {
        if (!arguments.length) {
            return {
                min : this._vbar_secondaryAxisBottomBoundary,
                max : this._vbar_secondaryAxisTopBoundary
            };
        }
        var tempMax, tempMin;
        if (range !== null) {
            if (!isNaN(range.max)) {
                tempMax = range.max;
            } else {
                tempMax = this._vbar_yScale2.perfectDomainEnd;
            }
            if (!isNaN(range.min)) {
                tempMin = range.min;
            } else {
                tempMin = this._vbar_yScale2.perfectDomainBegin;
            }
            if (tempMax > tempMin) {
                this._vbar_secondaryAxisTopBoundary = tempMax;
                this._vbar_secondaryAxisBottomBoundary = tempMin;
                if (range.from === 'axis') {
                    this._vbar_secondaryAxisManualRange = true;
                }
                if (TypeUtils.isExist(this._vbar_width) && TypeUtils.isExist(this._vbar_height) && TypeUtils.isExist(this._vbar_seriesData)) {
                    this._vbarfn_makeScales();
                }
            }
        } else {
            if (this._vbar_secondaryAxisManualRange === true) {
                this._vbar_secondaryAxisTopBoundary = this._vbar_yScale2.perfectDomainEnd;
                this._vbar_secondaryAxisBottomBoundary = this._vbar_yScale2.perfectDomainBegin;
                this._vbar_secondaryAxisManualRange = false;
                if (TypeUtils.isExist(this._vbar_width) && TypeUtils.isExist(this._vbar_height) && TypeUtils.isExist(this._vbar_seriesData)) {
                    this._vbarfn_makeScales();
                }
            }
        }
        return this;
    };

    vBar.prototype.hoverOnPoint = function(point) {
        var xOnModule = point.x, yOnModule = point.y;
        // find the closet dimension
        var i = -1;
        while (i < this._vbar_seriesData.length) {
            if (Math.abs(xOnModule - this._vbar_xScale.rangeBand() * i - 0.5 * this._vbar_xScale.rangeBand()) <= 0.5 * this._vbar_xScale.rangeBand()) {
                break;
            }
            i++;
        }

        if (i > (this._vbar_seriesData.length - 1)) {
            i = this._vbar_seriesData.length - 1;
        }
        if (i < 0) {
            i = 0;
        }

        var datashapes = this._vbar_parent.select('.' + CLASSDATASHAPESGROUP);
        var strechTransform = datashapes.node().getTransformToElement(datashapes.node().parentNode);
        var yRanges = this._vbar_yScale.range(), yRange = Math.abs(yRanges[0] - yRanges[1]);

        this._vbar_decorativeShape.attr('x', this._vbar_xScale.rangeBand() * i + this._vbar_barWidth / 4 + strechTransform.e).attr('height', yRange).attr('visibility', 'visible');

        if (this._vbar_lastHovered !== i) {
            if (this._vbar_tooltipVisible) {
                this._vbar_lastHovered = i;
                //that.parentNode point to plot graphic. it is different from bar chart as in bar chart it should get the yoffset which can get it from mian graphic element
                var transform = this._vbar_parent[0][0].getTransformToElement(this._vbar_parent[0][0].ownerSVGElement);
                var xoffset = transform.e;
                var tooltipOffset = this._vbar_xScale.rangeBand() * i + 0.5 * this._vbar_xScale.rangeBand() + strechTransform.e;
                if (tooltipOffset > this._vbar_width) {
                    tooltipOffset = this._vbar_width;
                } else if (tooltipOffset < 0) {
                    tooltipOffset = 0;
                }

                var tData = this._vbar_tooltipDataHandlerObj.generateTooltipData(this._vbar_data, this._vbar_seriesData, i, this._vbar_colorPalette, this._vbar_shapePalette);
                tData.point = {
                    x : tooltipOffset + xoffset,
                    y : point.y
                };
                tData.plotArea = {
                    x : transform.e,
                    y : transform.f,
                    width : this._vbar_width,
                    height : this._vbar_height
                };
                this._vbar_dispatch.showTooltip(tooltipDataHandler.formatTooltipData(tData));
            }
        }
    };

    vBar.prototype.self = function() {
        return this;
    };

    vBar.prototype.pinchBegan = function(point) {
        this._vbar_pinchPoint = point;
        this._vbar_isPinching = true;
    };

    vBar.prototype.pinch = function(pinchInfo) {
        // var that = this;

        var layerPoint = PinchUtil.convertToLayerPoint(this._vbar_pinchPoint.point, this._vbar_parent, '.' + CLASSDATASHAPESGROUP);
        var zoomInfo = PinchUtil.zoomInfo(this._vbar_xScale, pinchInfo.scale, layerPoint, this._vbar_width, 'bottom');

        if (zoomInfo) {
            var datashapes = this._vbar_parent.select('.' + CLASSDATASHAPESGROUP), node = datashapes.node();
            var transform = node.getTransformToElement(node.parentNode);
            var scale = zoomInfo.scale, offset = zoomInfo.offset, rangeBand = zoomInfo.rangeBand;
            this._vbar_xScale.rangeBands(rangeBand);

            var yRange = this._vbar_yScale.range();
            this._vbar_yScale.range([yRange[0] * scale, yRange[yRange.length - 1] * scale]);

            this.render(this._vbar_parent);
            this._vbar_dispatch.scale({
                scale : scale
            });

            offset.x += transform.e;
            offset.y += transform.f;
            //chart.dragFromAxis({offset : offset});
            this.dragToOffset({
                offset : offset
            });
            this._vbar_dispatch.stretch({
                offset : offset
            });
        }

    };

    vBar.prototype.dragToOffset = function(offsetInfo) {
        var transformString, transform, datashapes = this._vbar_parent.select('.' + CLASSDATASHAPESGROUP);
        if (offsetInfo.offset) {
            transform = offsetInfo.offset;
        } else {
            transformString = offsetInfo.transform, transform = {
                x : transformString.substring(transformString.indexOf('(') + 1, transformString.indexOf(',')),
                y : transformString.substring(transformString.indexOf(',') + 1, transformString.indexOf(')'))
            };

            var node = datashapes.node(), nodeTransform = node.getTransformToElement(node.parentNode);
            transform.y = nodeTransform.f;
        }

        datashapes.attr('transform', 'translate(' + transform.x + ',' + transform.y + ')');
        drawBound.call(this, this._vbar_parent, {
            'transform' : 'translate(' + transform.x + ',' + transform.y + ')'
        });
        //hide Tooltip
        this.blurOut();
    };

    vBar.prototype.dragFromAxis = function(offsetInfo) {
        var offset = offsetInfo.offset, datashapes = this._vbar_parent.select('.' + CLASSDATASHAPESGROUP), node = datashapes.node();
        var transform = node.getTransformToElement(node.parentNode);
        var yOffset = offset.y + transform.f, xOffset = offset.x + transform.e;
        datashapes.attr('transform', 'translate(' + xOffset + ', ' + yOffset + ')');
        drawBound.call(this, this._vbar_parent, {
            'transform' : 'translate(' + xOffset + ', ' + yOffset + ')'
        });
        //hide Tooltip
        this.blurOut();
    };

    vBar.prototype.pinchEnd = function() {
        this._vbar_isPinching = false;

        var plot = {};
        plot.width = this._vbar_width;
        plot.height = this._vbar_height;

        var axisList = {
            xAxis : {},
            yAxis : {}
        };
        axisList.xAxis.axis = this._vbar_xScale;
        axisList.xAxis.type = 'category';
        axisList.yAxis.axis = this._vbar_yScale;
        axisList.yAxis.type = 'value';

        var xRange = this._vbar_xScale.range().length * this._vbar_xScale.rangeBand();
        var yRanges = this._vbar_yScale.range();
        var yrange = Math.abs(yRanges[0] - yRanges[1]);

        var that = this;

        var datashapes = that._vbar_parent.select('.' + CLASSDATASHAPESGROUP), node = datashapes.node();
        var axisOffset = PinchUtil.pinchPointOffset(node, axisList, plot);
        if (axisOffset.x !== 0) {
            var translate = node.getAttribute('transform'), transfrom = node.getTransformToElement(node.parentNode);
            datashapes.transition().duration(500).tween('transform', function() {
                var xInterPolate, yInterPolate, datashapesInterPloate;
                if (axisOffset.x < 0) {
                    xInterPolate = d3.interpolate(translate, 'translate(0, ' + transfrom.f + ')');
                } else {
                    xInterPolate = d3.interpolate(translate, 'translate(' + (that._vbar_width - xRange) + ', ' + transfrom.f + ')');
                }

                if (axisOffset.y < 0) {
                    yInterPolate = d3.interpolate(translate, 'translate(' + transfrom.e + ', 0)');
                } else {
                    yInterPolate = d3.interpolate(translate, 'translate(' + transfrom.e + ', ' + (that._vbar_height - yrange) + ')');
                }

                if (axisOffset.x < 0 && axisOffset.y < 0) {
                    datashapesInterPloate = d3.interpolate(translate, 'translate(0' + ', 0)');
                } else {
                    datashapesInterPloate = d3.interpolate(translate, 'translate(' + (that._vbar_width - xRange) + ',' + (this._vbar_height - yrange) + ')');
                }

                return function(t) {
                    var xTransform = xInterPolate(t);
                    var yTransform = yInterPolate(t);
                    var datashapesTransform = datashapesInterPloate(t);
                    that._vbar_dispatch.stretch({
                        xTransform : xTransform,
                        yTransform : yTransform
                    });
                    this.setAttribute('transform', datashapesTransform);
                    drawBound.call(that, that._vbar_parent, {
                        'transform' : datashapesTransform
                    });
                };
            }).each('end', function() {
                that._vbar_dispatch.stretchEnd();
            });
        } else {
            that._vbar_dispatch.stretchEnd();
        }
    };

    vBar.prototype.highlight = function(elems) {
        if ( elems instanceof Array) {
            for (var i = 0, len = elems.length; i < len; i++) {
                elems[i].setAttribute('class', CLASSDATAPOINTCOMBINED + ' ' + CLASSMARKERSELECTED);
                elems[i].setAttribute('fill-opacity', 1);
                if (!this._vbar_enableRoundCorner) {
                    elems[i].setAttribute('stroke', '#333333');
                }
            }
        } else {
            elems.setAttribute('class', CLASSDATAPOINTCOMBINED + ' ' + CLASSMARKERSELECTED);
            elems.setAttribute('fill-opacity', 1);
            if (!this._vbar_enableRoundCorner) {
                elems.setAttribute('stroke', '#333333');
            }
        }
        if (this._vbar_hasDefaultSelection) {
            defaultSelUtil.clearSelectionInfo(this._vbar_parent, true, elems);
        }
    };

    vBar.prototype.unhighlight = function(elems) {
        if ( elems instanceof Array) {
            for (var i = 0, len = elems.length; i < len; i++) {
                elems[i].setAttribute('class', CLASSDATAPOINTCOMBINED);
                elems[i].setAttribute('fill-opacity', 0.4);
                elems[i].setAttribute('stroke', 'none');
            }
        } else {
            elems.setAttribute('class', CLASSDATAPOINTCOMBINED);
            elems.setAttribute('fill-opacity', 0.4);
            elems.setAttribute('stroke', 'none');
        }
        if (this._vbar_hasDefaultSelection) {
            defaultSelUtil.clearSelectionInfo(this._vbar_parent, false, elems);
        }
    };

    vBar.prototype.clear = function(gray) {
        if (!gray) {
            var rects = this._vbar_parent.selectAll('.v-datapoint');
            rects.attr('fill-opacity', 1).attr('stroke', 'none').attr('class', CLASSDATAPOINTCOMBINED);
            if (this._vbar_hasDefaultSelection) {
                defaultSelUtil.clearSelectionInfo(this._vbar_parent, false, rects);
            }
        } else {
            this._vbar_parent.selectAll('.v-datapoint').attr('fill-opacity', 0.4).attr('stroke', 'none').attr('class', CLASSDATAPOINTCOMBINED);
        }
    };

    vBar.prototype.blurOut = function() {
        this._vbar_decorativeShape.attr('visibility', 'hidden');
        this._vbar_lastHovered = null;
        if (this._vbar_tooltipVisible) {
            this._vbar_dispatch.hideTooltip();
        }
    };

    vBar.prototype.afterUIComponentAppear = function() {
        this._vbar_dispatch.initialized();
    };

    vBar.prototype.destroy = function() {

        if (this._vbar_xScale) {
            this._vbar_xScale.domain([0,1]).range([0,1]);
        }
        if (this._vbar_yScale) {
            this._vbar_yScale.domain([0,1]).range([0,1]);
        }
        if (this._vbar_yScale2) {
            this._vbar_yScale2.domain([0,1]).range([0,1]);
        }
        this._vbar_xScale = null;
        this._vbar_yScale = null;
        this._vbar_yScale2 = null;
        this._vbar_seriesData = null;
        this._vbar_colorPalette = null;
        this._vbar_parent = null;
        this._vbar_decorativeShape = null;
        this._vbar_data = null;
        this._vbar_data1 = null;
        this._vbar_data2 = null;
        this._vbar_defsEnter = null;
        this._vbar_roundCornerDefs = null;

    };

    //@Alex Su, judge whether we should enable animation

    vBar.prototype._vbarfn_enableAnimation = function() {
        var hasAnmation = false;
        if (!this._vbar_isOnlyInitAnimation) {
            hasAnmation = this._vbar_enableDataLoadingAnimation;
        } else if (this._vbar_dataStructureChange || this._vbar_dataValueChange) {
            hasAnmation = this._vbar_enableDataUpdatingAnimation;
        } else if (this._vbar_sizeChange) {
            hasAnmation = this._vbar_enableResizingAnimation;
        }
        return hasAnmation;
    };

    vBar.prototype._vbarfn_parseOptions = function() {
        this._vbar_enableRoundCorner = this._vbar_properties.isRoundCorner;
        this._vbar_enableDataLoadingAnimation = this._vbar_properties.animation.dataLoading;
        this._vbar_enableDataUpdatingAnimation = this._vbar_properties.animation.dataUpdating;
        this._vbar_enableResizingAnimation = this._vbar_properties.animation.resizing;
        this._vbar_tooltipVisible = this._vbar_properties.tooltip.enabled;
        this._vbar_drawingEffect = this._vbar_properties.drawingEffect;

        if (this._vbar_isDualAxis && !this._vbar_hasMNDonCategoryAxis) {
            this._vbar_axis1ColorPalette = this._vbar_properties.primaryValuesColorPalette;
            this._vbar_axis2ColorPalette = this._vbar_properties.secondaryValuesColorPalette;
        } else {
            this._vbar_axis2ColorPalette = this._vbar_properties.colorPalette;
            this._vbar_axis1ColorPalette = this._vbar_properties.colorPalette;
        }
        var colorIndexes = 0;
        if (!this._vbar_hasMNDonCategoryAxis) {
            this._vbar_indexforSecondaryAxis = this._vbar_data1.length;
            colorIndexes = this._vbar_seriesData[0].length;
        } else {
            colorIndexes = this._vbar_seriesData.length * this._vbar_seriesData[0].length;
        }
        this._vbar_colorPalette = [];
        var i;
        if (this._vbar_MNDInnerOnColor) {
            var flag = 0, flag2 = 0, j = 0;
            for ( i = 0; i < this._vbar_indexforSecondaryAxis; i++) {
                this._vbar_colorPalette.push(this._vbar_axis1ColorPalette[i % this._vbar_axis1ColorPalette.length]);
                flag++;
                if (flag === this._vbar_measureOnAxis1) {
                    flag2 = 0;
                    for (; j <= (colorIndexes - this._vbar_indexforSecondaryAxis); j++) {
                        if (flag2 >= this._vbar_measureOnAxis2) {
                            flag = 0;
                            break;
                        }
                        this._vbar_colorPalette.push(this._vbar_axis2ColorPalette[j % this._vbar_axis2ColorPalette.length]);
                        flag2++;
                    }
                }
            }
        } else {
            for ( i = 0; i < colorIndexes; i++) {
                if (i < this._vbar_indexforSecondaryAxis) {
                    this._vbar_colorPalette.push(this._vbar_axis1ColorPalette[i % this._vbar_axis1ColorPalette.length]);
                } else if (this._vbar_isDualAxis && !this._vbar_hasMNDonCategoryAxis) {
                    this._vbar_colorPalette.push(this._vbar_axis2ColorPalette[(i - this._vbar_indexforSecondaryAxis) % this._vbar_axis2ColorPalette.length]);
                }
            }
        }
    };

    vBar.prototype.setAxisGap = function(_gapObj)
    {
        this._vbar_gapObj = _gapObj;
    };

    /**
     * TODO: add desc
     */
    vBar.prototype._vbarfn_makeScales = function() {
        var domain = [];
        for (var i = 0; i < this._vbar_seriesData.length; i++) {
            domain.push(i);
        }

        this._vbar_valueScales = [];
        //when all data is 0 or null, we make yscale.domain from 0 to 1
        this._vbar_xScale.domain(domain).rangeBands([0, this._vbar_width]);
        if (this._vbar_primaryAxisBottomBoundary === 0 && this._vbar_primaryAxisTopBoundary === 0) {
            this._vbar_yScale.domain([0, 1]).range([this._vbar_height, 0]);

        } else {
            this._vbar_yScale.domain([this._vbar_primaryAxisBottomBoundary, this._vbar_primaryAxisTopBoundary]).range([this._vbar_height, 0]);

        }

        if (TypeUtils.isExist(this._vbar_data2) || this._vbar_isDualAxis) {
            //when data of second axis is all 0 or null, we make the xScale2 same with xScale .

            if (this._vbar_secondaryAxisTopBoundary === 0 && this._vbar_secondaryAxisBottomBoundary === 0) {
                this._vbar_yScale2.domain(this._vbar_yScale.domain()).range(this._vbar_yScale.range());
            } else {
                this._vbar_yScale2.domain([this._vbar_secondaryAxisBottomBoundary, this._vbar_secondaryAxisTopBoundary]).range([this._vbar_height, 0]);
                //when data of first axis is all 0 or null, we make the xScale same with xScale2 .
                if (this._vbar_primaryAxisBottomBoundary === 0 && this._vbar_primaryAxisTopBoundary === 0) {
                    this._vbar_yScale.domain(this._vbar_yScale2.domain()).range(this._vbar_yScale2.range());
                }
            }
            if (!this._vbar_secondaryAxisManualRange && !this._vbar_primaryAxisManualRange) {
                Scaler.perfectDual(this._vbar_yScale, this._vbar_yScale2);
            } else if (!this._vbar_secondaryAxisManualRange && this._vbar_primaryAxisManualRange) {
                Scaler.getRoughTickNum(this._vbar_yScale);
                Scaler.perfect(this._vbar_yScale2);
            } else if (this._vbar_secondaryAxisManualRange && !this._vbar_primaryAxisManualRange) {
                Scaler.perfect(this._vbar_yScale);
                Scaler.getRoughTickNum(this._vbar_yScale2);
            } else {
                Scaler.getRoughTickNum(this._vbar_yScale);
                Scaler.getRoughTickNum(this._vbar_yScale2);
            }
        } else {
            if (!this._vbar_primaryAxisManualRange) {
                Scaler.perfect(this._vbar_yScale);
            } else {
                Scaler.getRoughTickNum(this._vbar_yScale);
            }
            this._vbar_yScale2.range([0, 0]);
        }
                
        var scaleGap = 0;
        if(this._vbar_gapObj && this._vbar_gapObj.startGap)
        {
            scaleGap = this._vbar_gapObj.startGap;
        }
        Scaler.adjustGap(scaleGap, this._vbar_yScale); 
        
        this._vbar_valueScales.push(this._vbar_yScale);
        this._vbar_valueScales.push(this._vbar_yScale2);
    };

    vBar.prototype._vbarfn_x = function(_) {
        if (!arguments.length) {
            return this._vbar_x;
        }
        this._vbar_x = _;
        return this;
    };

    vBar.prototype._vbarfn_y = function(_) {
        if (!arguments.length) {
            return this._vbar_y;
        }
        this._vbar_y = _;
        return this;
    };

    var appendRoundCornerItemWithoutAnimation = function(that, perRectData, m, i, r) {

        var id = 'roundCorner-clip' + '-' + m + i + that._vbar_suffix;
        that._vbar_roundCornerDefs.append('clipPath').attr('id', id).attr("class", "v-clippath").append('rect').attr('rx', r).attr('ry', r).attr('width', that._vbar_barWidth).attr('height', function() {
            var valueScale = that._vbar_valueScales[perRectData.valueAxis];
            // [10 - Sep - 2012 Nick] if the value is invalid number, there is no bar but
            // the space is reserved
            if (perRectData.val !== ' ' && perRectData.val !== 0) {
                var height = Math.abs(valueScale(perRectData.val) - valueScale(0));
                // [10 - Sep - 2012 Nick] if the width of one bar is less than 1px, use 1px.
                return (height + r);
            } else {
                return 0;
            }
        }).attr('y', function() {
            var valueScale = that._vbar_valueScales[perRectData.valueAxis];
            if (perRectData.val >= 0) {
                return 0;
            } else {
                return 0 - r;
            }
        }).attr('x', 0);
        return 'url(#' + id + ')';

    };

    var appendRoundCornerItemWithStructureChangeAnimation = function(that, perRectData, m, i, r, interval) {

        var w = this.getAttribute('width'), h = this.getAttribute('height'), x = this.getAttribute('x'), y = this.getAttribute('y');
        var id = 'roundCorner-clip' + '-' + m + i + that._vbar_suffix;
        that._vbar_roundCornerDefs.append('clipPath').attr('id', id).attr("class", "v-clippath").append('rect').attr('rx', r).attr('ry', r).attr('x', 0).attr('width', that._vbar_barWidth).attr('y', h).transition()
        // .duration(that._vbar_totalIntervalTime)
        .delay(function(d, m) {
            return (m + that._vbar_barNumber * i) * interval;
        }).attr('height', function() {
            var valueScale = that._vbar_valueScales[perRectData.valueAxis];
            // [10 - Sep - 2012 Nick] if the value is invalid number, there is no bar but
            // the space is reserved
            if (perRectData.val !== ' ' && perRectData.val !== 0) {
                var height = Math.abs(valueScale(perRectData.val) - valueScale(0));
                // [10 - Sep - 2012 Nick] if the height of one bar is less than 1px, use 1px.
                return (height + r);
            } else {
                return 0;
            }
        }).attr('y', function() {
            if (perRectData.val > 0) {
                return 0;
            } else {
                return 0 - r;
            }
        });
        return 'url(#' + id + ')';
    };

    var appendRoundCornerItemWithValueChangeAnimation = function(that, perRectData, m, i, r, interval) {
        var w = this.getAttribute('width'), h = this.getAttribute('height'), x = this.getAttribute('x'), y = this.getAttribute('y');
        var id = 'roundCorner-clip' + '-' + m + i + that._vbar_suffix;
        that._vbar_roundCornerDefs.append('clipPath').attr('id', id).attr("class", "v-clippath").append('rect').attr('rx', r).attr('ry', r).attr('width', w).attr('x', x).attr('height', h).attr('y', function() {
            if (perRectData.val > 0) {
                return 0;
            } else {
                return 0 - r;
            }
        }).transition().duration(that._vbar_totalIntervalTime).attr('width', that._vbar_barWidth).attr('height', function() {
            var valueScale = that._vbar_valueScales[perRectData.valueAxis];
            // [10 - Sep - 2012 Nick] if the value is invalid number, there is no bar but
            // the space is reserved
            if (perRectData.val !== ' ' && perRectData.val !== 0) {
                var height = Math.abs(valueScale(perRectData.val) - valueScale(0));
                // [10 - Sep - 2012 Nick] if the width of one bar is less than 1px, use 1px.
                return (height + r);
            } else {
                return 0;
            }
        });
        return 'url(#' + id + ')';
    };

    var adjustBarWithDataStructureChangeAnimation = function(bar, that, xArray, r, interval, lastBarIndex, lastBarGroupIndex) {
        // [05 - Sep - 2012 Nick] DataStructureChange means the structure of data is changed.
        // It means the whole DOM nodes needed to be removed (handled by d3) and append new ones.
        bar.attr('width', that._vbar_barWidth).attr('height', 0).attr('y', function(perRectData) {
            var valueScale = that._vbar_valueScales[perRectData.valueAxis];
            // [10 - Sep - 2012 Nick] if the value is invalid number, there is no bar but
            // the space is reserved
            if (perRectData.val !== ' ' && perRectData.val !== 0 && perRectData.val > 0) {
                var height = Math.abs(valueScale(perRectData.val) - valueScale(0));
                return height;
            } else {
                return 0;
            }
        });

        if (that._vbar_enableRoundCorner) {
            appendRoundCorner.call(this, 'structureChange', bar, that, r, interval);
        }

        bar.transition().delay(function(d, m, i) {
            return (m + that._vbar_barNumber * i) * interval;
        }).attr('height', function(perRectData) {
            var valueScale = that._vbar_valueScales[perRectData.valueAxis];
            // [10 - Sep - 2012 Nick] if the value is invalid number, there is no bar but
            // the space is reserved
            if (perRectData.val !== ' ' && perRectData.val !== 0) {
                var height = Math.abs(valueScale(perRectData.val) - valueScale(0));
                return height;
            } else {
                return 0;
            }
        }).attr('y', 0).attr('x', 0).each('end', function(perRectData, m, i) {
            completeAnimation.call(that);
        });

    };

    var adjustBarWithSizeChangeAnimation = function(bar, that, xArray, r, interval, lastBarIndex, lastBarGroupIndex) {

        if (that._vbar_enableRoundCorner) {
            appendRoundCorner.call(this, 'valueChange', bar, that, r, interval);
        }
        bar.transition().duration(that._vbar_totalIntervalTime).attr('width', that._vbar_barWidth).attr('height', function(perRectData) {
            var valueScale = that._vbar_valueScales[perRectData.valueAxis];
            // [10 - Sep - 2012 Nick] if the value is invalid number, there is no bar but
            // the space is reserved
            if (perRectData.val !== ' ' && perRectData.val !== 0) {
                var height = Math.abs(valueScale(perRectData.val) - valueScale(0));
                return height;
            } else {
                return 0;
            }
        }).attr('y', 0).attr('x', 0).each('end', function(d, m) {
            completeAnimation.call(that);
        });
    };

    var adjustBarWithoutAnimation = function(bar, that, r, interval) {
        bar.attr('width', that._vbar_barWidth).attr('height', function(perRectData) {
            var valueScale = that._vbar_valueScales[perRectData.valueAxis];
            // [10 - Sep - 2012 Nick] if the value is invalid number, there is no bar but
            // the space is reserved
            if (perRectData.val !== ' ' && perRectData.val !== 0) {
                var height = Math.abs(valueScale(perRectData.val) - valueScale(0));
                // [10 - Sep - 2012 Nick] if the width of one bar is less than 1px, use 1px.
                perRectData.height = height;
                return height;
            } else {
                return 0;
            }
        }).attr('y', 0).attr('x', 0);
        if (that._vbar_enableRoundCorner) {
            appendRoundCorner.call(this, 'none', bar, that, r, interval);
        }
    };

    var appendRoundCorner = function(type, bar, that, r, interval) {
        function rcFunc() {
            bar.attr('clip-path', function(perRectData, m, i) {
                switch(type) {
                    case 'none' :
                        return appendRoundCornerItemWithoutAnimation.call(this, that, perRectData, m, i, r);
                    case 'structureChange' :
                        return appendRoundCornerItemWithStructureChangeAnimation.call(this, that, perRectData, m, i, r, interval);
                    case 'valueChange':
                        return appendRoundCornerItemWithValueChangeAnimation.call(this, that, perRectData, m, i, r, interval);
                    default :
                        return appendRoundCornerItemWithValueChangeAnimation.call(this, that, perRectData, m, i, r, interval);
                }
            });
        }

        if ((UADetector.isSafari() && UADetector.os() === "Windows") || UADetector.isMobile()) {
            window.setTimeout(rcFunc, 0);
        } else {
            rcFunc();
        }
    };

    var drawBound = function(selection, option) {
        var xRange = this._vbar_xScale.range().length * this._vbar_xScale.rangeBand();
        var yRanges = this._vbar_yScale.range();
        var yRange = Math.abs(yRanges[0] - yRanges[1]);
        boundUtil.drawBound(selection, xRange, yRange, option);
    };

    var completeAnimation = function() {
        if (++this._vbar_currentAnimationCount === this._vbar_totalAnimationCount) {
            this._vbar_dispatch.initialized();
            this._vbar_afterAttachToDOM = true;
        }
    };

    var changeYPosition = function(d, m) {
        var i = d3.interpolate(this._vbar_height, (m >= this._vbar_indexforSecondaryAxis) ? this._vbar_yScale2(d.val) : this._vbar_yScale(d.val));
        return function(t) {
            return i(t);
        };
    };

    var dataTransform = function(valueAxis1, valueAxis2, colorIndexArray) {
        this._vbar_primaryAxisTopBoundary = this._vbar_primaryAxisBottomBoundary = 0;
        this._vbar_secondaryAxisTopBoundary = this._vbar_secondaryAxisBottomBoundary = 0;
        var barGroups = [];
        // the number of bar in each group
        var barGroupNumber = 0;

        if (valueAxis1[0] && valueAxis1[0].length) {
            barGroupNumber = valueAxis1[0].length;
        } else if (valueAxis2[0] && valueAxis2[0].length) {
            barGroupNumber = valueAxis2[0].length;
        }
        var barGroup = [];
        var temp = 0;
        var temp2 = 0;
        var i, j;
        for ( i = 0; i < valueAxis1.length; i++) {
            if (this._vbar_hasMNDonCategoryAxis) {
                for ( j = 0; j < valueAxis1[i].length; j++) {
                    if (colorIndexArray[j] === 0) {
                        temp = valueAxis1[i][j].val;
                        valueAxis1[i][j].valueAxis = 0;

                        if (this._vbar_primaryAxisTopBoundary < temp) {
                            this._vbar_primaryAxisTopBoundary = temp;
                        }
                        if (this._vbar_primaryAxisBottomBoundary > temp) {
                            this._vbar_primaryAxisBottomBoundary = temp;
                        }
                        this._vbar_indexforSecondaryAxis++;
                    } else {
                        temp2 = valueAxis1[i][j].val;

                        valueAxis1[i][j].valueAxis = 1;
                        if (this._vbar_secondaryAxisTopBoundary < temp2) {
                            this._vbar_secondaryAxisTopBoundary = temp2;
                        }
                        if (this._vbar_secondaryAxisBottomBoundary > temp2) {
                            this._vbar_secondaryAxisBottomBoundary = temp2;
                        }
                    }
                }
            } else {
                temp = d3.max(valueAxis1[i], function(m) {
                    return m.val;
                });
                temp2 = d3.min(valueAxis1[i], function(m) {
                    return m.val;
                });

                if (this._vbar_primaryAxisTopBoundary < temp) {
                    this._vbar_primaryAxisTopBoundary = temp;
                }
                if (this._vbar_primaryAxisBottomBoundary > temp2) {
                    this._vbar_primaryAxisBottomBoundary = temp2;
                }
            }
            barGroup.push(valueAxis1[i]);
        }
        if (valueAxis2 !== undefined) {

            for ( i = 0; i < valueAxis2.length; i++) {
                temp = d3.max(valueAxis2[i], function(m) {
                    return m.val;
                });
                temp2 = d3.min(valueAxis2[i], function(m) {
                    return m.val;
                });

                if (this._vbar_secondaryAxisTopBoundary < temp) {
                    this._vbar_secondaryAxisTopBoundary = temp;
                }
                if (this._vbar_secondaryAxisBottomBoundary > temp2) {
                    this._vbar_secondaryAxisBottomBoundary = temp2;
                }
                barGroup.push(valueAxis2[i]);
            }
        }

        for ( j = 0; j < barGroupNumber; j++) {
            var ds = [];
            for ( i = 0; i < barGroup.length; i++) {
                if (!this._vbar_hasMNDonCategoryAxis) {
                    if (i < valueAxis1.length) {
                        barGroup[i][j].valueAxis = 0;
                    } else {
                        barGroup[i][j].valueAxis = 1;
                    }
                }
                if (NumberUtils.isNoValue(barGroup[i][j].val)) {
                    barGroup[i][j].val = ' ';
                }
                ds.push(barGroup[i][j]);
            }
            if (this._vbar_MNDInnerOnColor) {
                var dSet = [], flag1 = 0, flag2 = 0;
                var n = 0;
                for (var m = 0; m < valueAxis1.length; m++) {
                    dSet.push(ds[m]);
                    flag1++;
                    if (flag1 === this._vbar_measureOnAxis1 && valueAxis2 !== undefined) {
                        flag2 = 0;
                        for (; n < valueAxis2.length; n++) {
                            if (flag2 >= this._vbar_measureOnAxis2) {
                                flag1 = 0;
                                break;
                            }
                            dSet.push(ds[valueAxis1.length + n]);
                            flag2++;
                        }
                    }
                }
                barGroups.push(dSet);
            } else {
                barGroups.push(ds);
            }
        }
        return barGroups;
    };

    return vBar;
});

define('sap/viz/modules/manifests/xy/BaseBar',['sap/viz/modules/manifests/Module','sap/viz/modules/Constants','sap/viz/modules/manifests/xy/Base'],
function Setup(Manifest,Constants) {
  var module = {
    'id' : 'sap.viz.modules.xy.bar.base',
    'name' : 'bar',
    base : "sap.viz.modules.xy.base",
    'abstract' : true,
    'properties' : {
      'tooltip' : {
        'name' : 'tooltip',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'enabled' : {
            'name' : 'enabled',
            'supportedValueType' : 'Boolean',
            'defaultValue' : true,
            'description' : 'Set enabled/disabled tooltip.'
          }
        },
        'isExported' : false,
        'description' : 'Settings for tooltip related properties.'
      },
      'isRoundCorner' : {
        'name' : 'isRoundCorner',
        'supportedValueType' : 'Boolean',
        'defaultValue' : false,
        'description' : 'Set enable/disable round corner of bar.'
      },
      'animation' : {
        'name' : 'animation',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'dataLoading' : {
            'name' : 'dataLoading',
            'supportedValueType' : 'Boolean',
            'defaultValue' : true,
            'description' : 'Set enable/disable data loading animation of plot area.'
          },
          'dataUpdating' : {
            'name' : 'dataUpdating',
            'supportedValueType' : 'Boolean',
            'defaultValue' : true,
            'description' : 'Set enable/disable data updating animation of plot area.'
          },
          'resizing' : {
            'name' : 'resizing',
            'supportedValueType' : 'Boolean',
            'defaultValue' : true,
            'description' : 'Set enable/disable resizing animation of plot area.'
          }
        },
        'description' : 'Settings for animation of plot area.',
        'example': "<a href='"+Constants.DocExample.SnippetUrl+"8535' target='_blank'>"+Constants.DocExample.TryThisValue+"</a>"
      }
    },
    css : {
        '.v-hovershadow' : {
            'description' : 'Define style for hover shadow color.',
              'value' : {
                'fill' : '#cccccc'
              }
        }
    }
  };

  Manifest.register(module);
});
define('sap/viz/modules/manifests/xy/VerticalBar',['sap/viz/modules/manifests/Module','sap/viz/modules/verticalbar','sap/viz/modules/manifests/xy/BaseBar'],
function Setup(Manifest, fn) {
  var module = {
    'id' : 'sap.viz.modules.verticalbar',
    'name' : 'vertical bar',
    base : "sap.viz.modules.xy.bar.base",
    fn : fn
  };

  Manifest.register(module);
});
define('sap/viz/modules/manifests/xy/StackedVerticalBar',['sap/viz/modules/manifests/Module','sap/viz/modules/stackedverticalbar','sap/viz/modules/manifests/xy/VerticalBar'],
function Setup(Manifest, fn) {
    var module = {
      'id' : 'sap.viz.modules.stackedverticalbar',
      'name' : 'stacked vertical bar',
      base : "sap.viz.modules.verticalbar",
      'properties' : {
        'mode' : {
          'name' : 'mode',
          'supportedValueType' : 'String',
          'supportedValues' : [ 'comparison', 'percentage' ],
          'defaultValue' : 'comparison',
          'description' : 'Set dispaly mode of stacked vertical bar.',
            'isExported' : true,
            'updatable': false
        }
      },
      fn : fn
    };

    Manifest.register(module);
});
define('sap/viz/manifests/xy/BaseVerticalChart',['sap/viz/manifests/Viz','sap/viz/modules/manifests/RootContainer','sap/viz/modules/manifests/Title',
'sap/viz/modules/manifests/Legend','sap/viz/modules/manifests/XYContainer', 'sap/viz/modules/manifests/controller/Interaction',
'sap/viz/modules/manifests/Tooltip','sap/viz/modules/manifests/Axis','sap/viz/modules/manifests/Background',
'sap/viz/modules/manifests/DataLabel','sap/viz/modules/manifests/legend/Common',
'sap/viz/modules/manifests/layout/Dock', 'sap/viz/modules/manifests/layout/Stack'],
function Setup ( Manifest ) {
    var chart = {
      id : 'riv/baseverticalchart',
      name : 'IDS_BASEVERTICALCHART',
      'abstract' : true,
      modules : {
        root : {
          id : 'sap.viz.modules.rootContainer',
          configure : {
            propertyCategory : 'general',
            properties : {
              layout : {
                padding : 24,
                vgap : 8,
                hgap : 8
              }
            }
          },
          modules : {
            layout : {
              id : 'sap.viz.modules.layout.dock'
            },
            
            interaction : {
              id : 'sap.viz.modules.controller.interaction',
              configure : {
                clientID : 'main',
                propertyCategory : 'interaction',
                properties : {
                  supportedEventNames: ['mouseup', 'mousedown', 'mousemove', 'mouseover', 'mouseout', 'touchstart'],
                  holdSelection : true
                }
              }
            },          
            title : {
              id : 'sap.viz.modules.title',
              configure : {
                propertyCategory : 'title',
                properties : {
                  layout : {
                    position : 'top',
                    priority : 0
                  }
                }
              }
            },
            
            legends : {
              id : 'sap.viz.modules.legend',
              configure : {
                propertyCategory : 'legendGroup',
                properties : {
                  layout : {
                    position : 'right',
                    priority : 1
                  }
                }
              },
              modules : {
                layout : {
                  id : 'sap.viz.modules.layout.stack'
                },
                legend : {
                  id : 'sap.viz.modules.legend.common',
                  data : {
                      aa : [ 2 ]
                  },
                  configure : {
                    propertyCategory : 'legend',
                    properties : {
                      layout : {
                        order : 0
                      }
                    }
                  }
                }
              }
            },
            
            tooltip : {
              id : 'sap.viz.modules.tooltip',
              configure : {
                propertyCategory : 'tooltip',
                properties : {
                  chartType : 'verticalbar',
                  orientation : 'left'
                }
              }
            },
            main : {
              id : 'sap.viz.modules.xycontainer',
              configure : {
                properties : {
                  layout : {
                    position : 'center',
                    priority : 5
                  }
                }
              },
              modules : {
                dataLabel : {
                  id : 'sap.viz.modules.datalabel',
                  configure : {
                    propertyCategory : 'dataLabel',
                    properties : {
                      paintingMode : 'rectCoordinate',
                      visible : false,
                      orientation : 'vertical',
                      position : 'inside',
                      automaticInOutside : true,
                      showZero : true,
                      isStackMode : false,
                      isPercentMode : false,
                      outsideVisible : true,
                      outsidePosition : 'up'
                    }
                  }
                },
                yAxis : {
                  id : 'sap.viz.modules.axis',
                  configure : {
                  'description': 'Settings for the value axis of an XY chart.',
                   propertyCategory : 'yAxis',
                    properties : {
                      type : 'value',
                      position : 'left'
                    }
                  }
                },
    
                xAxis : {
                  id : 'sap.viz.modules.axis',
                  data : {
                      aa : [ 1 ]
                  },
                  configure : {
                  'description': 'Settings for the category axis of an XY chart.',
                    propertyCategory : 'xAxis',
                    properties : {
                      type : 'category',
                      position : 'bottom',
                      gridline : { visible : false }
                    },
                    propertiesOverride : {
                      gridline : { isExported : false },
                      label : { isExported : false },
                      axisline : { isExported : false },
                      scale : { 
                        fixedRange : {isExported : false},
                        minValue : {isExported : false},
                        maxValue : {isExported : false},
                        isExported : false 
                      }
                    }
                  }
                },
          
                background : {
                  id: 'sap.viz.modules.background',
                  configure : {
                    propertyCategory : 'background',
                    properties : { direction : 'vertical' }
                  }
                },
                plot: {
                  configure: {
                    propertiesOverride:{
                      primaryValuesColorPalette:{ isExported: false },
                      secondaryValuesColorPalette: { isExported: false }
                    }
                  }
                }
              }
            }
          }
        }
      },
      
      dependencies : {
        attributes : [ {
          targetModule : 'root.main.yAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'primaryScale'
        },{
          targetModule : 'root.main.xAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'categoryScale'
        },{
          targetModule : 'root.legends.legend',
          target : 'colorPalette',
          sourceModule : 'root.main.plot',
          source : 'colorPalette'
        } ],
         events : [ {
          targetModule : 'root.tooltip',
          listener : 'showTooltip',
          sourceModule : 'root.main.plot',
          type : 'showTooltip'
        }, {
          targetModule : 'root.tooltip',
          listener : 'hideTooltip',
          sourceModule : 'root.main.plot',
          type : 'hideTooltip'
        } ]
      }
    };
    Manifest.register(chart);
});
define('sap/viz/mvc/PinchGestureDetector',['sap/viz/mvc/GestureDetector','sap/viz/base/Math'],
function Setup(GestureDetector, Math) {
	var ts = GestureDetector.TransitionState;
	/**
	 * This class defines detector for detecting Pinching gesture.
	 * 
	 * @name sap.viz.mvc.PinchGestureDetector
	 * @class
	 * @augments sap.viz.mvc.GestureDetector
	 */
	var PinchGestureDetector = GestureDetector.extend({
		constructor : function() {
			this._origDistance = 1;
			this._currDistance = 1;
			this._startWhen = 0;
			this._stopWhen = 0;
		},

		_distance : function() {
			var points = [];
			for ( var tId in this._grTouchTracker) {
				points.push(this._grTouchTracker[tId].globalXY);
			}
			var dx = points[1].x - points[0].x;
			var dy = points[1].y - points[0].y;
			return Math.sqrt(dx * dx + dy * dy);
		},

		doTouchBegin : function(touchStartEvent) {
			var currentNumOfTouches = this.totalTouches();
			if (this.state === ts.Possible) {
				if (currentNumOfTouches === 2) {
					var twoTouchDistance = this._distance();
					if (twoTouchDistance > 35) {
						this._origDistance = this._currDistance = twoTouchDistance;
						this._startWhen = this._stopWhen = touchStartEvent.timeStamp;
					} else {
						this.state = ts.Failed;
						return;
					}
				}
				// If more than 2 touches began, regard it as a failure
				else if (currentNumOfTouches > 2) {
					this.state = ts.Failed;
					return;
				}
				// If only one touch began, we can wait for another one to come.
			} else if ((this.state === ts.Began || this.state === ts.Changed)) {
				this._stopWhen = touchStartEvent.timeStamp;
				this._currDistance = this._distance();

				this.state = ts.Canceled;
				return;
			}
		},

		doTouchMove : function(touchMoveEvent) {
			switch (this.state) {
			case ts.Possible:
				if (this.totalTouches() === 2) {
					this._stopWhen = touchMoveEvent.timeStamp;
					this._currDistance = this._distance();

					var scale = this.scale();
					if (scale > 1.1 || scale < 0.9) {
						this.state = ts.Began;
					}
				}
				break;
			case ts.Began:
				if (Math.abs(this._origDistance - this._distance()) > 10) {
					this._stopWhen = touchMoveEvent.timeStamp;
					this._currDistance = this._distance();
					this.state = ts.Changed;
				}
				break;
			case ts.Changed:
				this._currDistance = this._distance();
				this._stopWhen = touchMoveEvent.timeStamp;
				this.state = ts.Changed;
				break;
			}
		},

		doTouchEnd : function(touchEndEvent) {
			if (this.state === ts.Began || this.state === ts.Changed) {
				if (this.totalTouches() === 0) {
					this._stopWhen = touchEndEvent.timeStamp;
					this._currDistance = this._distance();
					this.state = ts.Ended;
				} else {
					this._stopWhen = touchEndEvent.timeStamp;
					this._currDistance = this._distance();
					this.state = ts.Canceled;
				}

			} else if (this.state === ts.Possible) {
				this.state = ts.Failed;
			}
		},

		doTouchCancel : function(touchCancelEvent) {
			if (this.state === ts.Began || this.state === ts.Changed) {
				this._stopWhen = touchCancelEvent.timeStamp;
				this._currDistance = this._distance();
				this.state = ts.Canceled;
			} else if (this.state === ts.Possible) {
				this.state = ts.Failed;
			}
		},
		/**
		 * The current scale of the pinching gesture
		 * 
		 * 
		 * @name sap.viz.mvc.PinchGestureDetector#scale
		 * @function
		 * @return {Number}
		 */
		scale : function() {
			return this._currDistance / this._origDistance;
		},
		/**
		 * The current velocity of the pinching gesture
		 * 
		 * 
		 * @name sap.viz.mvc.PinchGestureDetector#velocity
		 * @function
		 * @return {Number}
		 */
		velocity : function() {
			var duration = this._startWhen - this._stopWhen;
			if (duration) {
				return Math.abs((this._currDistance - this._origDistance)) * 1000 / duration;
			} else {
				return 0;
			}
		},
		reset : function() {
			this._super();
			this._origDistance = 1;
			this._currDistance = 1;
			this._startWhen = 0;
			this._stopWhen = 0;
		}
	});
	return PinchGestureDetector;
});
define('sap/viz/modules/controller/pinch',['sap/viz/mvc/PinchGestureDetector', 'sap/viz/mvc/GestureDetector', 'sap/viz/mvc/PanGestureDetector', 'sap/viz/modules/dispatch', 'sap/viz/base/utils/TypeUtils'],
function Setup(PinchGestureDetector, GestureDetector, PanGestureDetector, dispatch, TypeUtils) {
  return function(manifest, ctx) {
    var _pinchGestureDetector;
    var _modules;
    var _targetPlot;
    var _eventManager = ctx.eventManager;
    var _dispatch = dispatch('clear');
    
    var pinch = function() {
      return pinch;
    };
    
    pinch.module = function(modules) {
      if (!arguments.length) {
        return _modules;
      }
      _modules = modules.modules();
      return pinch;
    };
    
    pinch.targetPlot = function(client) {
      if (client) {
        _targetPlot = client;
      }
    };
	
      
    pinch.registerEvent = function() {
      if(!_pinchGestureDetector){
        _pinchGestureDetector = new PinchGestureDetector();
        _pinchGestureDetector.addGestureAction(pinchHandler);
        _pinchGestureDetector.enable(true);
        _eventManager.addGestureDetector(_pinchGestureDetector);
      }      
    };
    
    var pointsCoordinate = function(gesture) {
      var containerBox = gesture.watchedComponent.container.getBoundingClientRect();
      var touchPoints = gesture.involvedTouchePoints();
      var elements = [];
      if (TypeUtils.isArray(touchPoints)) {
        for (var i = 0; i < touchPoints.length; i++) {
          var pointX = touchPoints[i].x + containerBox.left, pointY = touchPoints[i].y + containerBox.top;
          elements.push({x : pointX, y : pointY});
        }
      }
      return elements;
    };
    
    var isInTargetPlotHelper = function(point, targetInfo) {
      var transform = targetInfo.transform;
      var top = transform.f, left = transform.e, right = transform.e + targetInfo.width, bottom = transform.f + targetInfo.height;
      
      if (point.x >= left && point.y >= top && point.x <= right && point.y <= bottom) {
        return true;
      } else {
        return false;
      }
   };
    
    var isInTargetPlot = function(points, targetInfo) {
      if (TypeUtils.isArray(points)) {
        for (var i = 0; i < points.length; i++) {
          var ret = isInTargetPlotHelper (points[i], targetInfo);
          if (!ret) {
            return false;
          }
        }
        return true;
      }
      
      return false;
   };
    
    var convertToLayerPoint = function(point, node) {
      var transform = node.getTransformToElement(node.ownerSVGElement);
      return {
          x : point.x - transform.e,
          y : point.y - transform.f
      };
    };
    
    var hittedModules = [], previousScale;
    var pinchHandler = function(gesture) {
      var points = pointsCoordinate(gesture);
      var centerPoint = gesture.globalLocOfGesture();
      var targetPlotInfo = {};
      targetPlotInfo.width = _targetPlot.width();
      targetPlotInfo.height = _targetPlot.height();
      
      var targetNode = _targetPlot.parent().node();
      targetPlotInfo.transform = targetNode.getTransformToElement(targetNode.ownerSVGElement);
      var currentScale = Math.round(gesture.scale() * 100)/100,  incrementScale;
      if(gesture.state === GestureDetector.TransitionState.Began) {
        for (var module in _modules) {
          if (_modules.hasOwnProperty(module) && _modules[module].parent && _modules[module].parent()) {
            if (_modules[module].pinchBegan && isInTargetPlot(points, targetPlotInfo)) {
              _modules[module].pinchBegan({point : convertToLayerPoint(centerPoint, _modules[module].parent().node())});
              hittedModules.push({module : _modules[module]});
            }
          }
        }
        previousScale = currentScale;
        
      } else if (gesture.state === GestureDetector.TransitionState.Changed) {
        if (hittedModules.length > 0) {
         incrementScale = Math.round(currentScale/previousScale * 100)/100;
         previousScale = incrementScale;
         for (var i = 0; i < hittedModules.length; i++) {
           if (hittedModules[i].module.pinch && isInTargetPlot(points, targetPlotInfo)) {
             hittedModules[i].module.pinch({scale : incrementScale});
           }
         }
       }
      } else {
       if (hittedModules.length > 0) {
         for (var j = 0; j < hittedModules.length; j++) {
           if (hittedModules[j].module.pinchEnd) {
             hittedModules[j].module.pinchEnd();
           }
         }
       }
       
       hittedModules.length = 0;
      }
    };
    
    pinch.properties = function(_) {
    };
    
    pinch.destory = function() {
        
    };
    
    pinch.data = function() {};
    
    
    pinch.dispatch = function(_){
      if ( !arguments.length ) {
        return _dispatch;
      }
      
      _dispatch = _;
      return pinch;
    };
    
    return pinch;
  };
});
define('sap/viz/modules/manifests/controller/Pinch',['sap/viz/modules/manifests/Module','sap/viz/modules/controller/pinch','sap/viz/modules/manifests/controller/Base'],
function Setup(Manifest, fn) {
  var module = {
    'id' : 'sap.viz.modules.controller.pinch',
    'name' : 'selection',
    'base' : "sap.viz.modules.controller.base",
    'description': 'Settings for the drag of the chart.',
    'properties' : {},
    'fn' : fn
  };

  Manifest.register(module);
});
define('sap/viz/manifests/xy/DesktopVerticalBar',['sap/viz/manifests/Viz', 'sap/viz/base/UADetector','sap/viz/manifests/xy/BaseVerticalChart', 'sap/viz/modules/manifests/controller/Pinch'],
function Setup(Manifest, UADetector) {
    var chart = {
      id : 'viz/desktopverticalbar',
      name : 'IDS_VERTICALBARCHART',
      base : 'riv/baseverticalchart',
      'abstract' : true,
      modules : {
        root : {
          modules : {
            main : {
              modules : {
                plot : {
                    id : 'sap.viz.modules.verticalbar',
                    configure : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                        propertyCategory : 'plotArea'
                    }
                }
              }
          }
          }
        }
         
      },
      feeds:{
        secondaryValues:  null
      },
      dependencies : {
        attributes : [ {
          targetModule : 'root.main.plot',
          target : 'primaryDataRange',
          sourceModule : 'root.main.yAxis',
          source : 'range'
        }, {
          targetModule : 'root.main.yAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'primaryScale'
        }, {
          targetModule : 'root.main.yAxis',
          target : 'color',
          sourceModule : 'root.main.plot',
          source : 'primaryAxisColor'
        }, {
          targetModule : 'root.main.xAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'categoryScale'
        },{
      targetModule : 'root.main.yAxis',
       target : 'title',
       sourceModule : 'root.main.plot',
       source : 'primaryAxisTitle'
    },{
          targetModule : 'root.legends.legend',
          target : 'colorPalette',
          sourceModule : 'root.main.plot',
          source : 'colorPalette'
        },{
        targetModule : 'root.legends.legend',
        target : 'setSelectionMode',
        sourceModule : 'root.interaction',
        source : 'getSelectionMode'
        } ],
         events : [ 
         {
          targetModule : 'root.tooltip',
          listener : 'showTooltip',
          sourceModule : 'root.main.plot',
          type : 'showTooltip'
        }, {
          targetModule : 'root.tooltip',
          listener : 'hideTooltip',
          sourceModule : 'root.main.plot',
          type : 'hideTooltip'
        }, {
          targetModule : 'root.interaction',
          listener : 'registerEvent',
          sourceModule : 'root.main.plot',
          type : 'initialized.interaction'
        }, {
          targetModule : 'root.interaction',
          listener : 'highlightedByLegend',
          sourceModule : 'root.legends.legend',
          type : 'highlightedByLegend'
      }, {
            targetModule : 'root.legends.legend',
          listener : 'deselectLegend',
          sourceModule : 'root.interaction',
          type : 'deselectLegend'
      }, {
        targetModule : 'root.main.dataLabel',
        listener : 'showLabel',
        sourceModule : 'root.main.plot',
        type : 'initialized.datalabel'
      }, {
        targetModule : 'root.main.dataLabel',
        listener : 'removeLabel',
        sourceModule : 'root.main.plot',
        type : 'startToInit.datalabel'
      }, {
        targetModule : 'root.interaction',
        listener : 'defaultSelection',
        sourceModule : 'root.main.plot',
        type : 'initialized.defaultSelection'
      }]
      }
    };
    Manifest.register(chart);
});
define('sap/viz/manifests/xy/StackedVerticalBarChart',['sap/viz/manifests/Viz','sap/viz/modules/manifests/RootContainer','sap/viz/modules/manifests/xy/StackedVerticalBar',
'sap/viz/manifests/xy/DesktopVerticalBar'],
function Setup(Manifest) {
    var chart = {
      id : 'viz/stacked_column',
      name : 'IDS_STACKEDVERTICALBARCHART',
      base : 'viz/desktopverticalbar',
      feeds : { secondaryValues: null },
      modules : {
        root : {
          modules : {
            main : {
              modules : {
                plot : {
                  id : 'sap.viz.modules.stackedverticalbar',
                  configure : {
                    description : 'Settings regarding the chart area and plot area as well as general chart options.',
                      propertyCategory : 'plotArea'
                  }
                },
                
                dataLabel : {
                  id : 'sap.viz.modules.datalabel',
                  configure : {
                    properties : {
                      automaticInOutside : false,
                      isStackMode : true,
                      showZero : false
                    },
                    propertiesOverride : {
                      position : {
                        isExported : false
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    };

    Manifest.register(chart);
});
define('sap/viz/manifests/xy/PercentageStackedVerticalBarChart',['sap/viz/manifests/Viz','sap/viz/modules/manifests/xy/StackedVerticalBar','sap/viz/manifests/xy/StackedVerticalBarChart'],
function Setup(Manifest) {
    var chart = {
      id : 'viz/100_stacked_column',
      name : 'IDS_PERCENTAGESTACKEDVERTICALBARCHART',
      base : 'viz/stacked_column',
      modules : {
        root : {
          modules : {
            main : {
              modules : {
                  plot : {
                    id : 'sap.viz.modules.stackedverticalbar',
                    configure : {
                        properties : {
                             mode : 'percentage'
                        }
                    }
                  } ,
                  yAxis : {
                    id : 'sap.viz.modules.axis',
                    configure : {
                    'description': 'Settings for the value axis of an XY chart.',
                      propertyCategory : 'yAxis',
                      properties : {
                        isPercentMode : true
                      },
                      propertiesOverride : {
                        scale : { 
                          fixedRange : {isExported : false},
                          minValue : {isExported : false},
                          maxValue : {isExported : false},
                          isExported : false 
                        }
                      }
                    }
                  },
                  dataLabel : {
                    id : 'sap.viz.modules.datalabel',
                    configure : {
                      propertyCategory : 'dataLabel',
                      properties : {
                        type : 'value',
                        isPercentMode: true,
                        showZero : true
                      }
                    }
                  }
              }
            },
            tooltip : {
              id : 'sap.viz.modules.tooltip',
              configure : {
                propertyCategory : 'tooltip',
                properties : {
                  chartType : '100_stacked_column',
                  orientation : 'bottom',
                  formatString: [["0.00%"],["0.00%"]]
                }
              }
            }
          }
        }
      }
    };

    Manifest.register(chart);
});
define('sap/viz/modules/BaseHorizontalBar',['sap/viz/modules/Constants', 'sap/viz/base/utils/oo',
            'sap/viz/modules/Base', 'sap/viz/modules/dispatch',
            'sap/viz/base/utils/ObjectUtils', 'sap/viz/base/utils/Objects',
            'sap/viz/base/utils/TypeUtils','sap/viz/lang/langManager',
            'sap/viz/modules/util/defaultSelectionUtil'],
function Setup(Constants, oo, Base, dispatch, ObjectUtils, Objects,
        TypeUtils,langManager, defaultSelUtil) {

  var CLASSMARKERSELECTED = Constants.CSS.CLASS.DATAPOINTSELECTED, CLASSDATAPOINT = Constants.CSS.CLASS.DATAPOINT, 
  SEL_CLASSDATAPOINT = '.' + CLASSDATAPOINT;
  
  var BaseHorizontalBar = function(manifest, ctx) {
    BaseHorizontalBar.superclass.constructor.apply(this, arguments);

    /**
     * @protected
     */
    this._dispatch = dispatch('selectData', 'deselectData',
            'showTooltip', 'hideTooltip', 'initialized', 'startToInit');
    this._width = 0, this._height = 0, this._props = manifest
            .props(null), this._parent = null,
            this._shapePalette = ['squareWithRadius'],
            this._colorPalette = [], this._seriesData = [];

    this._valueScale = d3.scale.linear(), this._valueScale2 = d3.scale
            .linear(), this._categoryScale = d3.scale.ordinal(),
            this._valueScales = [];

    this._sizeChange = false, this._dataStructureChange = false,
            this._dataValueChange = false, this._propertiesChange = false;

    this._decorativeShape = null, // the shape to show the effect of
                                  // mouse
    // move
    this._lastHovered = null; // last hovered dimention item index
    this._defsEnter = null, this._roundCornerDefs = null,
            this._suffix = ObjectUtils.guid();

    this._effectManager = ctx.effectManager;
    this._styleManager = ctx.styleManager;

    this._enableDataLoadingAnimation = true,
            this._enableDataUpdatingAnimation = true,
            this._enableResizingAnimation = true,
            this._isOnlyInitAnimation = false;

    this._totalIntervalTime = 1000;
    
    this._enableRoundCorner = false, this._tooltipVisible = true;
    
    this._isDualAxis = false, this._hasMNDonCategoryAxis = false;
    
    this._axis1ColorPalette = null, this._axis2ColorPalette = null, 
    this._drawingEffect = 'normal';
    this._MNDInnerOnColor = false;
    this._measureOnAxis1 = 0;
    this._measureOnAxis2 = 0;
    

    this._data1 = null, this._data2 = null;
    

    this._secondaryAxisBottomBoundary = 0,
    this._secondaryAxisTopBoundary = 0,
    this._primaryAxisBottomBoundary = 0,
    this._primaryAxisTopBoundary = 0;


    this._secondaryAxisManualRange = false,
        this._primaryAxisManualRange = false;
    
    this._hasDefaultSelection = false;
  };

  /**
   * ******************************** public function
   * ***************************
   */
  BaseHorizontalBar.prototype.dispatch = function(_) {
    if (!arguments.length) { return this._dispatch; }
    this._dispatch = _;
    return this;
  };

  BaseHorizontalBar.prototype.data = function(_) {
    if (!arguments.length) { return this._data; }
    this._data = _;
    this.parseData();
    return this;
  };

  BaseHorizontalBar.prototype.width = function(_) {
    if (!arguments.length) { return this._width; }
    this._sizeChange = (this._width === _) && !this._sizeChange  ? false : true;
    this._width = _;
    if (TypeUtils.isExist(this._width) && TypeUtils.isExist(this._height) && TypeUtils.isExist(this._seriesData)) {
      this.makeScales();
    }
    return this;
  };

  BaseHorizontalBar.prototype.height = function(_) {
    if (!arguments.length) { return this._width; }
    this._sizeChange = (this._height === _) && !this._sizeChange ? false : true;
    this._height = _;
    if (TypeUtils.isExist(this._width) && TypeUtils.isExist(this._height) && TypeUtils.isExist(this._seriesData)) {
      this.makeScales();
    }
    return this;
  },
  
  BaseHorizontalBar.prototype.size = function(_) {
    if (!arguments.length) { 
      return {
          width : this._width,
          height : this._height
        };
    }
    this._sizeChange = (this._height === _.height && this._width === _.width) && !this._sizeChange ? false : true;
    this._width = _.width;
    this._height = _.height;
    if (TypeUtils.isExist(this._width) && TypeUtils.isExist(this._height) && TypeUtils.isExist(this._seriesData)) {
      this.makeScales();
    }
    return this;
  },

  BaseHorizontalBar.prototype.properties = function(_) {
    if (!arguments.length) { return this._props; }
    //in resize mode, the function properties will not be called.
    this._propertiesChange = true;
    Objects.extend(true, this._props, _);
    this.parseOptions();

    return this;
  };

  BaseHorizontalBar.prototype.render = function() {

  };
  
  BaseHorizontalBar.prototype.blurOut = function() {
    this._lastHovered = null;
    this._decorativeShape.attr('visibility', 'hidden');
    if (this._tooltipVisible) {
      this._dispatch.hideTooltip();
    }
  };
  
  BaseHorizontalBar.prototype.clear = function(gray) {
    if (gray === undefined || gray === false) {
      var rects = this._parent.selectAll(SEL_CLASSDATAPOINT);
      rects.attr('fill-opacity', 1).attr('stroke', 'none').classed(
          CLASSMARKERSELECTED, false);
      if (this._hasDefaultSelection) {
        defaultSelUtil.clearSelectionInfo(this._parent, false, rects);
      }
    } else {
      this._parent.selectAll(SEL_CLASSDATAPOINT).attr('fill-opacity',
          0.4).attr('stroke', 'none').classed(CLASSMARKERSELECTED,
          false);
    }
  };
  
  BaseHorizontalBar.prototype.highlight = function(elems) {
    var that = this;
    if (!TypeUtils.isArray(elems)) {
      elems = [ elems ];
    }
    d3.selectAll(elems).classed(CLASSMARKERSELECTED, true).attr(
        'fill-opacity', 1).attr('stroke', function() {
      return that._enableRoundCorner ? 'none' : '#333333';
    });
    if (that._hasDefaultSelection) {
      defaultSelUtil.clearSelectionInfo(that._parent, true, elems);
    }
  };

  BaseHorizontalBar.prototype.unhighlight  = function(elems) {
    if (!TypeUtils.isArray(elems)) {
      elems = [ elems ];
    }
    d3.selectAll(elems).classed(CLASSMARKERSELECTED, false).attr(
        'fill-opacity', 0.4).attr('stroke', 'none');
    if (this._hasDefaultSelection) {
      defaultSelUtil.clearSelectionInfo(this._parent, false, elems);
    }
  };
  
  BaseHorizontalBar.prototype.parent = function(_) {
    if (!arguments.length) { return this._parent; }
    this._parent = _;
    return this;
  };

  /**
   * ******************************** dependence function
   * ***************************
   */
  BaseHorizontalBar.prototype.secondAxisTitle = function(_) {
    if (!arguments.length) {
      var titles = this._data.getMeasureValuesGroupDataByIdx(1), title = [];
      if (titles) {
        for ( var i = 0, len = titles.values.length; i < len; i++) {
          if (titles.values[i].col !== null && titles.values[i].col !== undefined) {
            title.push(titles.values[i].col);
          } else {
            title.push(langManager.get('IDS_ISNOVALUE'));
          }
        }
      }
      return title.join(' & ');
    }
    return this;
  };

  BaseHorizontalBar.prototype.primaryAxisTitle = function(_) {
    if (!arguments.length) {
      var titles = this._data.getMeasureValuesGroupDataByIdx(0), title = [];
      if (titles) {
        for ( var i = 0, len = titles.values.length; i < len; i++) {
          if (titles.values[i].col !== null && titles.values[i].col !== undefined) {
            title.push(titles.values[i].col);
          } else {
            title.push(langManager.get('IDS_ISNOVALUE'));
          }
        }
      }
      return title.join(' & ');
    }
    return this;
  };

  BaseHorizontalBar.prototype.shapePalette = function(_) {
    if (!arguments.length) { return this._shapePalette; }
    this._shapePalette = _;
    return this;
  };

  BaseHorizontalBar.prototype.colorPalette =  function(_) {
    if (!arguments.length) { return this._colorPalette; }
    this._colorPalette = _;
    return this;
  };

  BaseHorizontalBar.prototype.secondScale = function(scale) {
    if (!arguments.length) { return this._valueScale2; }
    this._valueScale2 = scale;
    this._valueScales[1] = scale;
    return this;
  };

  BaseHorizontalBar.prototype.primaryScale = function(scale) {
    if (!arguments.length) { return this._valueScale; }
    this._valueScale = scale;
    this._valueScales[0] = scale;
    return this;
  };

  BaseHorizontalBar.prototype.categoryScale = function(scale) {
    if (!arguments.length) { return this._categoryScale; }
    this._categoryScale = scale;
    return this;
  };

  BaseHorizontalBar.prototype.dataLabel = function(_) {

  };

  BaseHorizontalBar.prototype.secondAxisColor = function() {
    if (!this._hasMNDonCategoryAxis) {
      return this._colorPalette[this._seriesData[0].length - 1];
    } else {
      // Jimmy/Nick/10/18/2012 we are telling axis to draw with default
      // color
      return undefined;
    }
  };

  BaseHorizontalBar.prototype.primaryAxisColor = function() {
    if (this._isDualAxis && !this._hasMNDonCategoryAxis) {
      return this._colorPalette[0];
    } else {
      // Jimmy/Nick/10/18/2012 we are telling axis to draw with default
      // color
      return undefined;
    }
  };
  
  /**
   * ******************************** protected function
   * ***************************
   */
  /**
   * @protected
   */
  BaseHorizontalBar.prototype.parseOptions = function() {

  };

  BaseHorizontalBar.prototype.parseData = function() {

  };

  BaseHorizontalBar.prototype.makeScales = function() {

  };

  BaseHorizontalBar.prototype.enableAnimation = function() {
    var hasAnmation = false;
    if (!this._isOnlyInitAnimation) {
      hasAnmation = this._enableDataLoadingAnimation;
    } else if (this._dataStructureChange || this._dataValueChange) {
      hasAnmation = this._enableDataUpdatingAnimation;
    } else if (this._sizeChange) {
      hasAnmation = this._enableResizingAnimation;
    }
    return hasAnmation;
  };
  
  BaseHorizontalBar.prototype.destroy = function() {
    if(this._valueScale){
      this._valueScale.domain([0,1]).range([0,1]);
    }
    if(this._valueScale2){
      this._valueScale2.domain([0,1]).range([0,1]);
    }
    if(this._categoryScale){
      this._categoryScale.domain([0,1]).range([0,1]);
    }
    if(this._effectManager && this._effectManager.destroy){
      this._effectManager.destroy();
    }
    if(this._styleManager && this._styleManager.destroy){
      this._styleManager.destroy();
    }
    this._parent = null;
    this._data = null;
    this._defsEnter = null;
    this._seriesData = null;
    this._decorativeShape = null;
    this._data1 = null;
    this._data2 = null;
    this._roundCornerDefs = null;
  };

  oo.extend(BaseHorizontalBar, Base);

  return BaseHorizontalBar;
});
define('sap/viz/modules/stackedbar',['sap/viz/modules/Constants', 'sap/viz/base/utils/oo',
            'sap/viz/modules/BaseHorizontalBar',
            'sap/viz/modules/util/MNDHandler', 'sap/viz/base/utils/TypeUtils',
            'sap/viz/util/NumberUtils', 'sap/viz/base/utils/ObjectUtils',
            'sap/viz/util/Scaler', 'sap/viz/modules/util/BoundUtil',
            'sap/viz/modules/util/tooltipDataHandler',
            'sap/viz/base/UADetector'],
function(Constants, oo, BaseHorizontalBar, MNDHandler, TypeUtils,
        NumberUtils, ObjectUtils, Scaler, BoundUtil,
        tooltipDataHandler, UADetector) {

  var CLASSDATAPOINT = Constants.CSS.CLASS.DATAPOINT, 
  SEL_CLASSDATAPOINT = '.' + CLASSDATAPOINT, CLASSMORPHABLEDATAPOINT = Constants.CSS.CLASS.MORPHABLEDATAPOINT;

  /************* private function **********/
  
  var dataHandler = function(valueAxis1Data, valueAxis2Data, colorIndexArray){
    
    var positiveIndex = -1, negativeIndex = -1;
    this._stkbar_positiveIndexes = [[],[]], this._stkbar_negativeIndexes = [[],[]];
  
    this._primaryAxisTopBoundary = this._primaryAxisBottomBoundary = 0;
    this._secondaryAxisTopBoundary = this._secondaryAxisBottomBoundary = 0;
    
    var stackedBarGroupsData = [];
    // the number of bar in each group
    this._stkbar_barGroupNumber =  valueAxis1Data[0].length;
    var temp, temp2;
    for(var j=0; j < this._stkbar_barGroupNumber; j++){
      var tempDataSetAxis1 = [], tempDataSetAxis2 = [];
      var oneGroupDataSet = [];
      temp = 0, temp2 = 0;
      positiveIndex = -1, negativeIndex = -1;
      for(var i=0; i< valueAxis1Data.length; i++){
        valueAxis1Data[i][j].valueScale = 0;
        if(NumberUtils.isNoValue(valueAxis1Data[i][j].val)){
          //Jimmy/1/9/2013, what happens if we use null as the number value
          //see http://stackoverflow.com/questions/2910495/why-null-0-null-0-but-not-null-0
          //and http://bclary.com/2004/11/07/#a-11.8.5
          //checked in chrome/IE9/firefox/javafx, it works fine
          //the change is to ensure we display 'No Value' in other places related to this data point
          valueAxis1Data[i][j].val = null;
          valueAxis1Data[i][j].isNaN = true;
        }else{
          
          if(valueAxis1Data[i][j].val >= 0){
            temp += valueAxis1Data[i][j].val;
            positiveIndex = i;
          }else{
            temp2 += valueAxis1Data[i][j].val;
            negativeIndex = i;
          }
        }
      tempDataSetAxis1.push(valueAxis1Data[i][j]);
    }
    this._stkbar_positiveIndexes[0].push(positiveIndex);
    this._stkbar_negativeIndexes[0].push(negativeIndex);
    
    if(this._primaryAxisTopBoundary < temp){
      this._primaryAxisTopBoundary = temp;
    }
    if(this._primaryAxisBottomBoundary > temp2){
      this._primaryAxisBottomBoundary = temp2;
    }
    oneGroupDataSet.push(tempDataSetAxis1);
    
    
    if(TypeUtils.isExist(valueAxis2Data)){
      temp = 0, temp2 = 0;
      positiveIndex = -1, negativeIndex = -1;
      for(i=0; i< valueAxis2Data.length; i++){
        positiveIndex = 0, negativeIndex = -1;
        valueAxis2Data[i][j].valueScale = 1;
        if(NumberUtils.isNoValue(valueAxis2Data[i][j].val)){
          //Jimmy/1/9/2013, what happens if we use null as the number value
          //see http://stackoverflow.com/questions/2910495/why-null-0-null-0-but-not-null-0
          //and http://bclary.com/2004/11/07/#a-11.8.5
          //checked in chrome/IE9/firefox/javafx, it works fine
          //the change is to ensure we display 'No Value' in other places related to this data point
          valueAxis2Data[i][j].val = null;
          valueAxis2Data[i][j].isNaN = true;
        }else{
          
          if(valueAxis2Data[i][j].val >= 0){
            temp += valueAxis2Data[i][j].val;
            positiveIndex = i;
          }else{
            temp2 += valueAxis2Data[i][j].val;
            negativeIndex = i;
          }
        }
        tempDataSetAxis2.push(valueAxis2Data[i][j]);
      }
      this._stkbar_positiveIndexes[1].push(positiveIndex);
      this._stkbar_negativeIndexes[1].push(negativeIndex);
      
      if(this._secondaryAxisTopBoundary < temp){
        this._secondaryAxisTopBoundary = temp;
      }
      if(this._secondaryAxisBottomBoundary > temp2){
        this._secondaryAxisBottomBoundary = temp2;
      }
      oneGroupDataSet.push(tempDataSetAxis2);
    }
    stackedBarGroupsData.push(oneGroupDataSet);
   }
    
    return stackedBarGroupsData;
  };
  
  function turnToPercentage() {
      for ( var i = 0, len = this._seriesData.length; i < len; i++) {
        for ( var j = 0, rowSeriesData =  this._seriesData[i], rowTooltipData = this._stkbar_tooltipData[i]; j < rowSeriesData.length; j++) {
          var sum = 0, avaCount = 0, k;
          for (k = 0; k < rowSeriesData[j].length; k++) {
            sum += Math.abs(rowSeriesData[j][k].val);
            if (!rowSeriesData[j][k].isNaN) {
              avaCount++;
            }
          }
          if (sum === 0) {

            for (k = 0; k < rowSeriesData[j].length; k++) {
              rowSeriesData[j][k].value = TypeUtils
                      .isExist(rowSeriesData[j][k].value) ? rowSeriesData[j][k].value : rowSeriesData[j][k].val;
              rowSeriesData[j][k].val = rowSeriesData[j][k].isNaN ? 0 : 1 / avaCount;
              if (TypeUtils.isExist(rowTooltipData[j]) && TypeUtils.isExist(rowTooltipData[j][k])) {
                rowTooltipData[j][k].val = rowTooltipData[j][k].isNaN  ? ' ' : 1 / avaCount;
              }
            }
          } else {
            for (k = 0; k < rowSeriesData[j].length; k++) {
              if (rowSeriesData[j][k].val < 0) {
                rowSeriesData[j][k].isNegative = true;
              }
              rowSeriesData[j][k].value = TypeUtils
                      .isExist(rowSeriesData[j][k].value) ? rowSeriesData[j][k].value : rowSeriesData[j][k].val;
              rowSeriesData[j][k].val = Math
                      .abs(rowSeriesData[j][k].val / sum);
              if (TypeUtils.isExist(rowTooltipData[j]) && TypeUtils.isExist(rowTooltipData[j][k])) {
                rowTooltipData[j][k].val = rowTooltipData[j][k].isNaN ? ' ' : rowTooltipData[j][k].val / sum;
              }
            }
          }

          }
        }
      }
  
  function completeAnimation(){
    if( ++this._stkbar_currentAnimationCount ===  this._stkbar_totalAnimationCount){
      this._dispatch.initialized();
      this._stkbar_afterAttachToDOM = true;
    }
  }
  
  var StackedBar = function(){
    StackedBar.superclass.constructor.apply(this, arguments);
    
    this._stkbar_mode = 'comparison';
    this._data1 = [[]];
    this._data2 = [[]];
    this._stkbar_tooltipData = null;
    
    this._stkbar_tooltipHandlerObj = null;
    

    this._stkbar_barNumber = 0, this._stkbar_barHeight = 0,
      this._stkbar_barNumberinGroup = 0, this._stkbar_barGroupNumber = 0,
      this._stkbar_currentAnimationCount = 0;
      this._stkbar_totalAnimationCount = 0;
      
   this._stkbar_afterAttachToDOM = false;
   this._stkbar_id = Math.floor(Math.random() * 10000);
   
   this._stkbar_positiveIndexes = [], this._stkbar_negativeIndexes = [];
   
  };
  

  
  /*********** public function ***********/
  
  StackedBar.prototype.refresh = function(){
    var r = Math.log(this._stkbar_barHeight)/Math.log(2);
    if( r < 0 ){
      this._enableRoundCorner = false;
    }
    
    var barGroup = this._parent.selectAll('g.v-datashapesgroup').selectAll('g.v-stackedbar');
    var axisGroups = barGroup.selectAll('g.v-axisGroup');
    var dataShapes = axisGroups.selectAll('g.v-datashape'), bar = dataShapes.select('rect');
    
    var valueScale, originalWidth, newWidth,  that = this;
    var positiveStackedValue =  0, negativeStackedValue = 0;
    var x, y, offsetX, startPoint;
    var itemCount = this._isDualAxis === true ? 2 : 1;
    if (that.enableAnimation()) {
      bar.attr("x" , function(perRectData, indexInGroup, groupIndex){
        /**
         * For animation in stacked bar chart, it should update the x position of data shape, 
         * but keep the old x position of rect. So it means if data shape container move to 
         * left, we also should make rect move to bit right.
         */
        
        /*
         * get the old x position of data shape
         */
        offsetX = this.parentNode.getTransformToElement(this.parentNode.parentNode).e;
        
        if(indexInGroup === 0){
          positiveStackedValue = 0;
          negativeStackedValue = 0;
        }
        
        valueScale = (perRectData.valueScale === 0) ? that._valueScale : that._valueScale2;
        /**
         * if it is binded with value scale 0, the start point is that._stkbar_barHeight /2;
         * if it is binded with value scale 1, the start point is (that._stkbar_barHeight /2 + that._stkbar_barHeight + that._stkbar_barHeight/8), that._stkbar_barHeight * 13 /8 = that._stkbar_barHeight * 1.625;
         */
        startPoint = (perRectData.valueScale === 0) ? that._stkbar_barHeight /2 : that._stkbar_barHeight * 1.625;
        y = that._categoryScale(Math.floor(groupIndex/itemCount)) + startPoint;
        if(perRectData.val >= 0){
          x = valueScale(positiveStackedValue);
          positiveStackedValue += perRectData.val;
        }else{
          negativeStackedValue += perRectData.val;
          x =  valueScale(negativeStackedValue);
        }
        
        this.parentNode.setAttribute('transform' , 'translate(' + x + ',' + y  + ')');
        
        return (offsetX - x);
      }).attr('width', function(perRectData){
        valueScale = ( perRectData.valueScale === 0)? that._valueScale : that._valueScale2;
        originalWidth = parseFloat(this.width.baseVal.value); 
        newWidth = Math.abs(valueScale(perRectData.val) - valueScale(0));
        return  ( originalWidth > newWidth ) ? originalWidth : newWidth; 
      });
      
      adjustBarWithSizeChangeAnimation.call(that, bar, r);
    } else {
      
      dataShapes.attr('transform', function(perRectData, indexInGroup, groupIndex){
        if(indexInGroup === 0){
          positiveStackedValue = 0;
          negativeStackedValue = 0;
        }
        
        valueScale = (perRectData.valueScale === 0) ? that._valueScale : that._valueScale2;
        /**
         * if it is binded with value scale 0, the start point is that._stkbar_barHeight /2;
         * if it is binded with value scale 1, the start point is (that._stkbar_barHeight /2 + that._stkbar_barHeight + that._stkbar_barHeight/8), that._stkbar_barHeight * 13 /8 = that._stkbar_barHeight * 1.625;
         */
        startPoint = (perRectData.valueScale === 0) ? that._stkbar_barHeight /2 : that._stkbar_barHeight * 1.625;
          
        y = that._categoryScale(Math.floor(groupIndex/itemCount)) + startPoint;
        if(perRectData.val >= 0){
          x = valueScale(positiveStackedValue);
          positiveStackedValue += perRectData.val;
        }else{
          negativeStackedValue += perRectData.val;
          x =  valueScale(negativeStackedValue);
        }
        return 'translate('+x+','+y+')';
      });
      
      adjustBarWithoutAnimation.call(that, bar, r);
    }
    
  };
  
  StackedBar.prototype.draw = function(){
    var r = Math.log(this._stkbar_barHeight)/Math.log(2);
    if( r < 0 ){
      this._enableRoundCorner = false;
    }
    var barHeightInitial = 8 * (this._categoryScale.rangeBand()) / (9*this._stkbar_barNumberinGroup +7 );
    var that = this;
    var barGroup = this._parent.selectAll('g.v-datashapesgroup').selectAll('g.v-stackedbar').data(this._seriesData);
    barGroup.enter().append('g').classed('v-stackedbar', true);
    var axisGroups = barGroup.selectAll('g.v-axisGroup').data(function(d) {
      return d;
    });
    
    axisGroups.enter().append('g').classed('v-axisGroup', true);
    
    var dataShapes = axisGroups.selectAll('g.v-datashape').data(function(d){ return d;});
    
    dataShapes.enter().append('g').classed('v-datashape', true).append('rect').classed(CLASSDATAPOINT, true).classed(CLASSMORPHABLEDATAPOINT, true);
    
    dataShapes.exit().remove();
    axisGroups.exit().remove();
    /**
     *  here you should be careful for dual Chart. In Dual chart, the groupIndex is mixed with secondAxis
     */
    
    var valueScale, startPoint;
    var positiveStackedValue =  0, negativeStackedValue = 0;
    var itemCount = this._isDualAxis === true ? 2 : 1;
    var y, x;
    dataShapes.attr('transform', function(perRectData, indexInGroup, groupIndex){
      if(indexInGroup === 0){
        positiveStackedValue = 0;
        negativeStackedValue = 0;
      }
      
      valueScale = (perRectData.valueScale === 0) ? that._valueScale : that._valueScale2;
      /**
       * if it is binded with value scale 0, the start point is that._stkbar_barHeight /2;
       * if it is binded with value scale 1, the start point is (that._stkbar_barHeight /2 + that._stkbar_barHeight + that._stkbar_barHeight/8), that._stkbar_barHeight * 13 /8 = that._stkbar_barHeight * 1.625;
       */
      startPoint = (perRectData.valueScale === 0) ? that._stkbar_barHeight /2 : that._stkbar_barHeight * 1.625;
        
      y = that._categoryScale(Math.floor(groupIndex/itemCount)) + startPoint;
      if(perRectData.val >= 0){
        x = valueScale(positiveStackedValue);
        positiveStackedValue += perRectData.val;
      }else{
        negativeStackedValue += perRectData.val;
        x =  valueScale(negativeStackedValue);
      }
      return 'translate('+x+','+y+')';
    });
    
    var fillingColor;
    var bar = dataShapes.select('rect' + SEL_CLASSDATAPOINT);
    bar.attr('fill', function( perRectData, indexInGroup, groupIndex){
      fillingColor =  (perRectData.valueScale === 0) ? that._axis1ColorPalette : that._axis2ColorPalette;
      perRectData.fillColor = fillingColor[indexInGroup % fillingColor.length];
      var parameter = {
        drawingEffect:that._drawingEffect,
        fillColor : perRectData.fillColor,
        direction : 'vertical'
      };
      return that._effectManager.register(parameter);
    }).attr('shape-rendering','crispEdges').attr('fill-opacity', 1).attr('stroke','none');
    
    if (that.enableAnimation()) {
      adjustBarWithDataChangeAnimation.call(that, bar, r, barHeightInitial);
    } else {
      adjustBarWithoutAnimation.call(that, bar, r);
    }
    
    barGroup.exit().remove();
    
  };
  
  StackedBar.prototype.render = function(selection){

    BoundUtil.drawBound(selection, this._width, this._height);
    
    //deal with percentage mode
    if(this._stkbar_mode === 'percentage'){
      turnToPercentage.call(this);
    }
    
    this._stkbar_tooltipHandlerObj = tooltipDataHandler();
    
    // [19-Oct-2012 Nick] if the size of plot area is too small, there is no value scale created and the whole drawing part is skipped.
    if(!TypeUtils.isExist(this._valueScale) && !TypeUtils.isExist(this._valueScale2)) {
      return;
    }
    this._dispatch.startToInit();
    
    this._stkbar_barNumber = (TypeUtils.isExist(this._data2)) ? 2 : 1;
    this._stkbar_barHeight = 8 * (this._categoryScale.rangeBand()) / (9* this._stkbar_barNumber +7 );
    
    this._stkbar_barNumberinGroup = this._seriesData[0][0].length + ((TypeUtils.isExist(this._seriesData[0][1])) ? this._seriesData[0][1].length : 0);
    var barHeightInitial = 8 * (this._categoryScale.rangeBand()) / (9*this._stkbar_barNumberinGroup +7 );
    
    this._stkbar_currentAnimationCount = 0;
    this._stkbar_totalAnimationCount = this._stkbar_barNumberinGroup * this._seriesData.length;
    
    var svg = this._parent = selection;
    //append decorativeShape
      if(this._decorativeShape === null){
        this._decorativeShape = svg.append('rect').attr('width', this._width).attr('height',
        this._categoryScale.rangeBand() -  this._stkbar_barHeight/2).attr('visibility', 'hidden').attr(
            'fill', this._styleManager.queryDefault('v-hovershadow').fill).attr('class', 'v-hovershadow');
      }else{
        this._decorativeShape.attr('width', this._width).attr('height', this._categoryScale.rangeBand() -  this._stkbar_barHeight/2).attr('visibility', 'hidden');
      }
      
    if(this._defsEnter === null){
      this._defsEnter = svg.append('defs')
        .append('clipPath').attr('id', 'clipPlot_' + this._stkbar_id)
        .append('rect').attr('width', this._width).attr('height', this._height);
    }else{
      this._defsEnter.attr('width', this._width).attr('height', this._height);
    }  
      
    if(this._roundCornerDefs === null){      
      this._roundCornerDefs = svg.append('defs').attr('id', 'round-corner-clip' + this.suffix);
    }else{
      if( this._dataStructureChange || this._sizeChange || this._dataValueChange  || !this._enableRoundCorner){
        this._roundCornerDefs.selectAll(".v-clippath").remove();
      }
    }    
    
    
    var datashapesgroup = svg.selectAll('g.v-datashapesgroup');
    if(!TypeUtils.isExist(datashapesgroup[0][0])){
      datashapesgroup = svg.append('g').attr('class', 'v-datashapesgroup').attr("clip-path", "url(#clipPlot_" + this._stkbar_id + ")");
    }
    
    if( this._dataStructureChange || this._dataValueChange || this._propertiesChange ){
      this.draw();
    } else {
      /* size change*/
      this.refresh();
    }
    
    if (! this.enableAnimation()){
       this._dispatch.initialized();
    }  
    this._sizeChange = false, this._dataValueChange = false, this._dataStructureChange = false, this._propertiesChange = false;
    this._isOnlyInitAnimation = true;
    return this;
  };
  
  function adjustBarWithDataChangeAnimation(bar, r, barHeightInitial){
    var that = this;
    
    var valueScale, y;
    bar.attr('height',barHeightInitial)
       .attr('y', function (perRectData, indexInGroup, groupIndex) {
         if( perRectData.valueScale === 0){
           y = - that._stkbar_barHeight /2  + barHeightInitial * ( indexInGroup * 1.125 + 0.5);
         } else {
           y =  that._stkbar_barHeight/8 + barHeightInitial * ( indexInGroup * 1.125 + 0.5);
         }
         return y;
       }).attr('x', function(perRectData, indexInGroup, groupIndex){
         valueScale =  ( perRectData.valueScale  === 0) ? that._valueScale : that._valueScale2;
         return (perRectData.val > 0) ? 0 : (valueScale(0) - valueScale(perRectData.val));
       }).attr('width', 0);

    // [04 - Sep - 2012 Nick] Round corner enabled. Do the same transition as the bars do.
    if(that._enableRoundCorner){
      appendRoundCorner.call(that, 'dataChange', bar, r, barHeightInitial);
    }
    bar.transition().duration(that._totalIntervalTime/2)
       .attr('width', function(perRectData, indexInGroup, groupIndex){
         valueScale =  ( perRectData.valueScale  === 0) ? that._valueScale : that._valueScale2;
         return Math.abs(valueScale(perRectData.val) - valueScale(0));
       })
       .attr('x', 0).each('end', function(perRectData, m){
           valueScale =  ( perRectData.valueScale  === 0) ? that._valueScale : that._valueScale2;
           //As in large data with animation, transition code will be washed away, we should reset the width of rect in the animation end.
           this.setAttribute('x', 0); 
           this.setAttribute('width', Math.abs(valueScale(perRectData.val) - valueScale(0)) );
           d3.select(this).transition().duration(that._totalIntervalTime/2).attr('height', that._stkbar_barHeight).attr('y', 0).each('end', function(){
               this.setAttribute('height',  that._stkbar_barHeight);
               this.setAttribute('y', 0);
               completeAnimation.call(that);
           });
       });
  }
  
  function adjustBarWithSizeChangeAnimation(bar, r ){
    var that = this;
    
    var valueScale;
    bar.transition().duration(that._totalIntervalTime/2)
       .attr('width', function(perRectData){
         valueScale = ( perRectData.valueScale === 0 ) ? that._valueScale: that._valueScale2;
         return Math.abs(valueScale(perRectData.val) - valueScale(0));
       })
       .attr('x',0)
       .attr('y', 0)
       .attr('height', that._stkbar_barHeight)
       .each('end', function(perRectData){
        valueScale = ( perRectData.valueScale === 0 ) ? that._valueScale: that._valueScale2;
        this.setAttribute('x', 0);
        this.setAttribute('height',  that._stkbar_barHeight);
        this.setAttribute('y', 0);
        this.setAttribute('width', Math.abs(valueScale(perRectData.val) - valueScale(0)));
         // Fire out event to tell the animation is done.
        completeAnimation.call(that);
       });
    
      if(that._enableRoundCorner){
        appendRoundCorner.call(that, 'sizeChange', bar, r);
      }
  
  }
  
  function adjustBarWithoutAnimation( bar, r){
    var that = this;
    var valueScale;
    bar.attr('y',0).attr('x', 0) 
    .attr('width',function(perRectData,k){
      valueScale = (perRectData.valueScale === 0) ? that._valueScale : that._valueScale2;
      return Math.abs(valueScale(perRectData.val) -  valueScale(0));
    })
    .attr('height',that._stkbar_barHeight);
 
   if(that._enableRoundCorner){
     appendRoundCorner.call(that, 'none', bar,  r);
   }
  }
  
  function appendRoundCorner(type, bar, r, barHeightInitial){
    var that = this;
    var rcFunc = function(){
      switch(type){
      case 'none':
        appendRoundCornerItemWithoutAnimation.call(that, bar, r);
        break;
      case 'dataChange':
        appendRoundCornerItemWithDataChange.call(that, bar, r, barHeightInitial);
        break;
      case 'sizeChange' : 
        appendRoundCornerItemWithSizeChange.call(that, bar,  r);
        break;
      default: 
        appendRoundCornerItemWithSizeChange.call(that, bar,  r);
        break;
      }
    };
    
    if((UADetector.isSafari() && UADetector.os() === "Windows")||UADetector.isMobile()){
      window.setTimeout(rcFunc, 0);
   } else{
     rcFunc();
   }
    
  }
  
  function appendRoundCornerItemWithDataChange(bar, r, barHeightInitial){
    var that = this;
    var valueScale, itemCount = this._isDualAxis ? 2 : 1, stackedIndex;
    bar.attr('clip-path', function(perRectData, indexinGroup, groupIndex){
      stackedIndex =  Math.floor(groupIndex / itemCount );
      if(indexinGroup === that._stkbar_negativeIndexes[perRectData.valueScale][stackedIndex] || indexinGroup === that._stkbar_positiveIndexes[perRectData.valueScale][stackedIndex]){
          var id = 'roundCorner-clip' + '-' + groupIndex + indexinGroup + perRectData.valueScale + that._suffix;
          var roundCorner = that._roundCornerDefs.append('clipPath').attr('id', id).attr("class", "v-clippath")
                    .append('rect').attr('class', 'roundCorner-clip')
                    .attr('rx', r).attr('ry', r).attr('y',  this.y.baseVal.value)
                    .attr('height',barHeightInitial).attr('width', 0)
                    .attr('x', this.x.baseVal.value)
                    .transition().duration(that._totalIntervalTime/2)
                    .attr('x',function(){
                      if(indexinGroup ===  that._stkbar_negativeIndexes[perRectData.valueScale][stackedIndex] ){
                        return 0;
                      }else{
                        return 0 - r;
                      }
                    })
                    .attr('width', function(){
                       var valueScale = (perRectData.valueScale === 0) ? that._valueScale : that._valueScale2;
                       return Math.abs(valueScale(perRectData.val) - valueScale(0)) + r;
                    })
                    .transition().delay(that._totalIntervalTime/2).duration(that._totalIntervalTime/2)
                    .attr('height', that._stkbar_barHeight).attr('y', 0);
        return 'url(#' + id + ')' ;
      }
    });
  }
  
  function appendRoundCornerItemWithSizeChange(bar, r){
    var that = this;
    var valueScale, itemCount = this._isDualAxis ? 2 : 1, stackedIndex;
    bar.attr('clip-path', function(perRectData, indexinGroup, groupIndex){
      stackedIndex =  Math.floor(groupIndex / itemCount );
      if(indexinGroup === that._stkbar_negativeIndexes[perRectData.valueScale][stackedIndex] || indexinGroup === that._stkbar_positiveIndexes[perRectData.valueScale][stackedIndex]){
        var id = 'roundCorner-clip' + '-' + groupIndex + indexinGroup + perRectData.valueScale  + that._suffix;
        var x = parseFloat(this.x.baseVal.value) ;
        var roundCorner = that._roundCornerDefs.append('clipPath').attr('id', id).attr("class", "v-clippath")
                    .append('rect').attr('class', 'v-roundCorner-clip')
                    .attr('rx', r).attr('ry', r).attr('y',  this.y.baseVal.value)
                    .attr('height',this.height.baseVal.value).attr('width', this.width.baseVal.value + r)
                    .attr('x', function(){
                      return x - ((indexinGroup === that._stkbar_negativeIndexes[perRectData.valueScale][stackedIndex]) ? 0 : r);
                    })
                    .transition().duration(that._totalIntervalTime/2)
                    .attr('x',function(){
                      if(indexinGroup === that._stkbar_negativeIndexes[perRectData.valueScale][stackedIndex]){
                        return 0;
                      }else{
                        return 0 - r;
                      }
                    })
                    .attr('width', function(){
                      valueScale = (perRectData.valueScale === 0) ? that._valueScale : that._valueScale2;
                       return Math.abs(valueScale(perRectData.val) - valueScale(0)) + r;
                    })
                    .attr('height',that._stkbar_barHeight).attr('y', 0);
        return 'url(#' + id + ')' ;
      }
       
    });
  }
  
  function appendRoundCornerItemWithoutAnimation(bar, r){
    var that = this;
    var valueScale, itemCount = this._isDualAxis ? 2 : 1, stackedIndex;
    bar.attr('clip-path', function(perRectData, indexinGroup, groupIndex){
      stackedIndex =  Math.floor(groupIndex / itemCount );
      if(indexinGroup === that._stkbar_negativeIndexes[perRectData.valueScale][stackedIndex] || indexinGroup === that._stkbar_positiveIndexes[perRectData.valueScale][stackedIndex]){
        var id = 'roundCorner-clip' + '-' + groupIndex + indexinGroup + perRectData.valueScale + that._suffix;
        var roundCorner = that._roundCornerDefs.append('clipPath')
                            .attr('id', id)
                            .attr("class", "v-clippath")
                            .append('rect')
                            .attr('class', 'v-roundCorner-clip')
                            .attr('rx', r)
                            .attr('ry', r)
                            .attr('y', this.y.baseVal.value)
                            .attr('height', that._stkbar_barHeight)
                            .attr('width',function() {
                              valueScale = ( perRectData.valueScale === 0) ? that._valueScale : that._valueScale2;
                              return Math.abs(valueScale(perRectData.val) - valueScale(0)) + r;
                            });
        if(indexinGroup === that._stkbar_negativeIndexes[perRectData.valueScale][stackedIndex]){
          roundCorner.attr('x',0);
        }else{
          roundCorner.attr('x',0 - r);  
        }
        return 'url(#' + id + ')' ;
      }
       
    });
  
  }
  
  StackedBar.prototype.hoverOnPoint = function(point){
    var xOnModule = point.x, yOnModule = point.y;
    // find the closet dimension
    var i = -1;
    while (i < this._seriesData.length) {
      if (Math.abs(yOnModule - this._categoryScale.rangeBand() * i - 0.5 * this._categoryScale.rangeBand()) <= 0.5 * this._categoryScale.rangeBand()) {
        break;
      }
      i++;
    }

    if (i > (this._seriesData.length - 1) || i < 0) {
      this._decorativeShape.attr('visibility', 'hidden');
      return;
    }

    this._decorativeShape.attr('y',
            this._categoryScale.rangeBand() * i + this._stkbar_barHeight / 4).attr(
            'visibility', 'visible');

    if (i !== this._lastHovered) {
      if (this._tooltipVisible) {
        this._lastHovered = i;
        // this.parentNode.parentNode.parentNode point to the main
        // container
        var transform = this._parent[0][0]
                .getTransformToElement(this._parent[0][0].ownerSVGElement);
        var yoffset = transform.f;
        var sumAxis1 = 1, sumAxis2 = 1, m = 0;
        var tData = this._stkbar_tooltipHandlerObj.generateTooltipData(this._data,
                this._stkbar_tooltipData, this._stkbar_barGroupNumber - 1 - i, this._colorPalette,
                this._shapePalette);

        tData.point = {
          x: point.x,
          y: this._categoryScale.rangeBand() * i + 0.5 * this._categoryScale.rangeBand() + yoffset
        };
        tData.plotArea = {
          x: transform.e,
          y: transform.f,
          width: this._width,
          height: this._height
        };
        tData.valueAxis0Count = this._seriesData[0][0].length;
        tData.valueAxis1Count = TypeUtils.isExist(this._seriesData[0][1])  ? this._seriesData[0][1].length : 0;
        this._dispatch.showTooltip(tooltipDataHandler
                .formatTooltipData(tData));
      }
    }
  };
  
  /*********** dependences function ******/
  StackedBar.prototype.primaryDataRange = function(range){
    if (!arguments.length){
      var maxt, mint;
      if(this._stkbar_mode === 'percentage'){
        maxt = 1;
        mint = 0;
      }else{
        mint = this._primaryAxisBottomBoundary;
        maxt = this._primaryAxisTopBoundary;
      }
      return {
        min: mint,
        max: maxt
      };
    }
    var tempMax, tempMin;
    if (range !== null) {
        if (!isNaN(range.max)) {
          tempMax = range.max;
        } else {
          tempMax = this._valueScale.perfectDomainEnd;
        }
        if (!isNaN(range.min)) {
          tempMin = range.min;
        } else {
          tempMin = this._valueScale.perfectDomainBegin;
        }
        if (tempMax > tempMin) {
          this._primaryAxisTopBoundary = tempMax;
          this._primaryAxisBottomBoundary = tempMin;
          if (range.from === 'axis') {
            this._primaryAxisManualRange = true;
          }
          if(TypeUtils.isExist(this._width) && TypeUtils.isExist(this._height)){
            this.makeScales();
          }
        }
    } else {
      if (this._primaryAxisManualRange === true) {
        this._primaryAxisTopBoundary = this._valueScale.perfectDomainEnd;
        this._primaryAxisBottomBoundary = this._valueScale.perfectDomainBegin;
        this._primaryAxisManualRange = false;
        if (TypeUtils.isExist(this._width) && TypeUtils.isExist(this._height)) {
          this.makeScales();
        }
      }
    }
    return this;
  };
  
  StackedBar.prototype.secondDataRange = function(range){
    if (!arguments.length){
      var maxt, mint;
      if(this._stkbar_mode === 'percentage'){
        maxt = 1;
        mint = 0;
      }else{
        mint = this._secondaryAxisBottomBoundary;
        maxt = this._secondaryAxisTopBoundary;
      }
      return {
        min: mint,
        max: maxt
      };
    }
    var tempMax, tempMin;
    if (range !== null) {
        if (!isNaN(range.max)) {
          tempMax = range.max;
        } else {
          tempMax = this._valueScale2.perfectDomainEnd;
        }
        if (!isNaN(range.min)) {
          tempMin = range.min;
        } else {
          tempMin = this._valueScale2.perfectDomainBegin;
        }
        if (tempMax > tempMin) {
          this._secondaryAxisTopBoundary = tempMax;
          this._secondaryAxisBottomBoundary = tempMin;
          if (range.from === 'axis') {
            this._secondaryAxisManualRange = true;
          }
          if(TypeUtils.isExist(this._width) && TypeUtils.isExist(this._height)){
            this.makeScales();
          }
        }
    } else {
      if (this._secondaryAxisManualRange === true) {
        this._secondaryAxisTopBoundary = this._valueScale2.perfectDomainEnd;
        this._secondaryAxisBottomBoundary = this._valueScale2.perfectDomainBegin;
        this._secondaryAxisManualRange = false;
        if (TypeUtils.isExist(this._width) && TypeUtils.isExist(this._height)) {
          this.makeScales();
        }
      }
    }
    return this;
  };
  
  StackedBar.prototype.secondAxisColor = function() {
    if(TypeUtils.isExist(this._seriesData[0][1]) && !this._hasMNDonCategoryAxis){
      return this._axis2ColorPalette[this._seriesData[0][1].length-1];
    }else{
      //Jimmy/Nick/10/18/2012 we are telling axis to draw with default color
      return undefined;
    }
  };
  
  /*********** protected function ********/
  StackedBar.prototype.parseOptions = function(){

    this._enableRoundCorner = this._props.isRoundCorner;
    this._stkbar_mode = this._props.mode === 'percentage'? 'percentage': 'comparison';
    this._enableDataLoadingAnimation =  this._props.animation.dataLoading; 
    this._enableDataUpdatingAnimation =  this._props.animation.dataUpdating; 
    this._enableResizingAnimation = this._props.animation.resizing;
    this._tooltipVisible = this._props.tooltip.enabled;      
    if(this._isDualAxis && !this._hasMNDonCategoryAxis){
      this._axis1ColorPalette = this._props.primaryValuesColorPalette;   
      this._axis2ColorPalette = this._props.secondaryValuesColorPalette;
    }else{
      this._axis2ColorPalette = this._props.colorPalette;
      this._axis1ColorPalette = this._props.colorPalette;
    }

    this._drawingEffect = this._props.drawingEffect;
    
    var indexforSecondaryAxis = this._data1.length;
    this._colorPalette = [];
    var i,j;
    if(this._MNDInnerOnColor){
      var flag = 0, flag2 = 0;
      for(i=0; i < this._seriesData[0][0].length; i++){
        this._colorPalette.push(this._axis1ColorPalette[i % this._axis1ColorPalette.length]);
        flag++;
        if(flag === this._measureOnAxis1 && this._isDualAxis && TypeUtils.isExist(this._seriesData[0][1])){
          flag2 = 0;
          for(j=0; j <= this._seriesData[0][1].length; j++){
            if(flag2 >= this._measureOnAxis2){
              flag = 0;
              break;
            }
          this._colorPalette.push(this._axis2ColorPalette[j % this._axis2ColorPalette.length]);  
          flag2++;
        }
      }
    }
  }else{
      for(i=0 ; i < this._seriesData[0].length; i++){
        for(j=0; j < this._seriesData[0][0].length; j++){
           this._colorPalette.push(this._axis1ColorPalette[j % this._axis1ColorPalette.length]);
        }
        if(this._isDualAxis && TypeUtils.isExist(this._seriesData[0][1])){
          for(j=0; j < this._seriesData[0][1].length; j++){
            this._colorPalette.push(this._axis2ColorPalette[j % this._axis2ColorPalette.length]);  
          }
        }
      }
    }
  
  };
  
  StackedBar.prototype.parseData = function(){

    var obj = MNDHandler(this._data);

    var _data1 = obj["MG1"];
    var _data2 = obj["MG2"];
    this._measureOnAxis1 = obj.MG1Number;
    this._measureOnAxis2 = obj.MG2Number || 0;
    this._MNDInnerOnColor = obj.MNDOnColor && obj.MNDInner;
    this._stkbar_tooltipData = [];
    var i;

    if (_data1[0] && _data1[0][0].info  && _data1[0][0].info.defaultSelection) {
      this._hasDefaultSelection = true;
    } else {
      this._hasDefaultSelection = false;
    }

    if (TypeUtils.isExist(obj.color)) {
      this._hasMNDonCategoryAxis = true;
      this._isDualAxis = true;
      var tempData1 = [], tempData2 = [];
      var tempStackedData1 = [], tempStackedData2 = [];
      for (i = 0; i < _data1.length; i++) {
        tempData1 = [];
        tempData2 = [];
        for ( var j = 0; j < _data1[i].length; j++) {
          if (obj.color[j] === 0) {
            tempData1.push(_data1[i][j]);
            tempData2.push({
              val: null,
              hasMNDonCategoryAxis: true
            });
          } else {
            tempData1.push({
              val: null,
              hasMNDonCategoryAxis: true
            });
            tempData2.push(_data1[i][j]);
          }
        }
        tempStackedData1.push(tempData1);
        tempStackedData2.push(tempData2);
      }
      _data1 = tempStackedData1;
      _data2 = tempStackedData2;

    } else {
      this._hasMNDonCategoryAxis = false;
      if (TypeUtils.isExist(_data2)) {
        if (!this._dataStructureChange  && (this._data2.length !== _data2.length || this._data2[0].length !== _data2[0].length)) {
          this._dataStructureChange = true;
        }
        this._isDualAxis = true;
      } else {
        this._isDualAxis = false;
      }
    }
    if (this._data1.length !== _data1.length || this._data1[0].length !== _data1[0].length) {
      this._dataStructureChange = true;
    }

    var _seriesData = dataHandler.call(this, _data1, _data2, obj.color);

    // judge what changed in dataset
    if (!this._dataStructureChange) {
      this._dataValueChange = true;
    }
    this._seriesData = _seriesData;
    this._data1 = _data1;
    this._data2 = _data2;

    if (this._hasMNDonCategoryAxis) {
      for (i = 0; i < this._seriesData.length; i++) {
        var temp = this._seriesData[i];
        if (temp[0][0].hasMNDonCategoryAxis) {
          this._stkbar_tooltipData.push(temp[1]);
        } else {
          this._stkbar_tooltipData.push(temp[0]);
        }
      }
    } else {
      this._stkbar_tooltipData = ObjectUtils.extend(true, {}, this._seriesData);
    }

    if (TypeUtils.isExist(this._width) && TypeUtils.isExist(this._height)) {
      this.makeScales();
    }
    
    this.parseOptions();
    return this;
  };
  
  StackedBar.prototype.makeScales = function(){

    var domain = [];
    for ( var i = 0; i < this._seriesData.length; i++) {
      domain.push(i);
    }
    this._categoryScale.domain(domain).rangeBands([this._height, 0]);
    if (this._stkbar_mode === 'percentage') {
      this._valueScale.domain([0, 1]).range([0, this._width]);
      this._valueScale2.domain([0, 1]).range([0, this._width]);
      Scaler.perfect(this._valueScale);
      Scaler.perfect(this._valueScale2);
    } else {
      // when all data is 0 or null ,we make the domain from 0 to 1
      if (this._primaryAxisBottomBoundary === 0 && this._primaryAxisTopBoundary === 0) {
        this._valueScale.domain([0, 1]).range([0, this._width]);
      } else {
        this._valueScale.domain(
                        [this._primaryAxisBottomBoundary,
                            this._primaryAxisTopBoundary]).range(
                        [0, this._width]);
      }

      if (TypeUtils.isExist(this._data2) || this._isDualAxis) {
        // when data of second axis is all 0 or null, we make the
        // xScale2 same with xScale .

        if (this._secondaryAxisTopBoundary === 0 && this._secondaryAxisBottomBoundary === 0) {
          this._valueScale2.domain(this._valueScale.domain()).range(this._valueScale.range());
        } else {
          this._valueScale2.domain(
                  [this._secondaryAxisBottomBoundary,
                      this._secondaryAxisTopBoundary]).range([0, this._width]);
          // when data of first axis is all 0 or null, we make the
          // xScale same with xScale2 .
          if (this._primaryAxisBottomBoundary === 0 && this._primaryAxisTopBoundary === 0) {
            this._valueScale.domain(this._valueScale2.domain()).range(this._valueScale2.range());
          }
        }
        if (!this._primaryAxisManualRange && !this._secondaryAxisManualRange) {
          Scaler.perfectDual(this._valueScale, this._valueScale2);
        } else if (!this._primaryAxisManualRange && this._secondaryAxisManualRange) {
          Scaler.perfect(this._valueScale);
          Scaler.getRoughTickNum(this._valueScale2);
        } else if (this._primaryAxisManualRange && !this._secondaryAxisManualRange) {
          Scaler.perfect(this._valueScale2);
          Scaler.getRoughTickNum(this._valueScale);
        } else {
          Scaler.getRoughTickNum(this._valueScale);
          Scaler.getRoughTickNum(this._valueScale2);
        }
      } else {
        if (!this._primaryAxisManualRange) {
          Scaler.perfect(this._valueScale);
        } else {
          Scaler.getRoughTickNum(this._valueScale);
        }
      }
    }

    if (!TypeUtils.isExist(this._data2)) {
      this._valueScale2.range([0, 0]);
    }
  
  };
  
  oo.extend(StackedBar, BaseHorizontalBar);
  return StackedBar;
});
define('sap/viz/modules/util/imageUtil',[], function Setup(){
  var imageUtil = function(){};
  
  var countMagnitude = function(number) {
      var res = 0;
      //0.0234: 0.01
      //0.234: 0.1
      //2.34: 1
      //23.4: 10
      //234:100
      //234:100
      if(number >= 1)
      {
          res = 1;
          for(;;)
          {
              if((number / 10) < 1)
              {
                  break;
              }
              else
              {
                  number /= 10;
                  res *= 10;
              }
          }
      }
      else if(number < 1)
      {
          res = 0.1;
          for(;;)
          {
              if((number * 10) >= 1)
              {
                  break;
              }
              else
              {
                  number *= 10;
                  res /= 10;
              }
          }
      }
      return res;
  };
  
  var bestImageNumberRatio = function(seriesData, valueScale, barHeight)
  {
      var res = 1;
      var imageRatioObjs = [];
      for(var i = 0; i < seriesData.length; i++)
      {
          for(var j = 0; j < seriesData[i].length; j++)
          {
              var ratioItem = {};
              ratioItem.rectWidth = valueScale(seriesData[i][j].val);
              ratioItem.rectHeight = barHeight;

              ratioItem.imageWidth = barHeight;
              ratioItem.val = seriesData[i][j].val;

              imageRatioObjs.push(ratioItem);
          }
      }
      //var points = [40,100,1,5,25,10];
      imageRatioObjs.sort(function(a,b){return b.rectWidth-a.rectWidth;});
      if(imageRatioObjs.length !== 0){
        
          var bestImageNum = imageRatioObjs[0].rectWidth/imageRatioObjs[0].imageWidth;
          var theVal = imageRatioObjs[0].val;

          var baseMagnitude = countMagnitude(bestImageNum/theVal);
          
          var imageNumTest = [];
          
          imageNumTest.push ({"base":1, "gap": Math.abs(baseMagnitude * theVal - bestImageNum)});
          imageNumTest.push ({"base":2, "gap": Math.abs(baseMagnitude * 2 * theVal - bestImageNum)});
          imageNumTest.push ({"base":5, "gap": Math.abs(baseMagnitude * 5 * theVal - bestImageNum)});
          imageNumTest.push ({"base":10, "gap": Math.abs(baseMagnitude * 10 * theVal - bestImageNum)});
          
          var compare = function (a, b){
              return a.gap - b.gap;
          };
          imageNumTest.sort(compare);           
          
          //&& (baseMagnitude * theVal * imageRatioObjs[0].imageWidth) >= imageRatioObjs[0].rectWidth*0.2)
          res = baseMagnitude * imageNumTest[0].base;
      }

      return res;
  };
  
  var getImageURL = function(index)
  {
      var imageURL = "";

      var imageURLNumber = this._props.imagePalette.length;
      if(imageURLNumber > 0)
      {
          imageURL = this._props.imagePalette[index%imageURLNumber];
      }

      return imageURL;
  };
  
  imageUtil.imageFill = function(barShape, bar, barHeight){

    var that = this;
    var defIDFun = function(d, itemIndex, i) {
      return that._suffix + "-defID-" + i + itemIndex;// i is group index
    };

    var urlIDFun = function(d, itemIndex, i) {
      return "url(#" + defIDFun(d, itemIndex, i) + ")";// i is group
      // index
    };

    var rectWidthFun = function(d) {
      var valueScale = that._valueScales[d.valueAxis];
      return valueScale(d.val);
    };

    var rectWidthFunForPattern = function(d) {
      return rectWidthFun(d) + 2;
    };

    var imageNumber = function(perDefData) {

      var val = perDefData.val;
      if (perDefData.val < 0) {
        val = -val;
      }

      var res = {
        number: 0,
        interval: barHeight
      };
      res.number = val * imageNumRatio;

      // to count the interval
      var intNum = Math.floor(res.number);
      var decimalNum = res.number - intNum;

      var rectWidth = rectWidthFun(perDefData);
      var imageWidth = barHeight;
      var lastImageWidth = imageWidth * decimalNum;

      // imageWidth + (intNum-1)*interval + (interval-imageWidth) +
      // lastImageWidth == rectWidth //interval >= imageWidth
      // or imageWidth + (intNum-1)*interval + (lastImageWidth -
      // (imageWidth - interval)) == rectWidth //interval < imageWidth
      // && (lastImageWidth > ( imageWidth - interval) )
      // or imageWidth + (intNum-1)*interval == rectWidth //interval <
      // imageWidth && (lastImageWidth <= ( imageWidth - interval) )
      var intervalTest1;
      if (intNum === 0) {
        intervalTest1 = 0;
      } else {
        if (rectWidth > lastImageWidth) {
          intervalTest1 = (rectWidth - lastImageWidth) / intNum;
        } else {
          intervalTest1 = 0;
        }
      }

      var intervalTest2;
      if (intNum <= 1) {
        intervalTest2 = rectWidth / 2;
      } else {
        if (rectWidth > imageWidth) {
          intervalTest2 = (rectWidth - lastImageWidth) / (intNum);
        } else {
          intervalTest2 = rectWidth / (intNum + 1);
        }
      }

      var intervalTest3;
      if (intNum === 0) {
        intervalTest3 = 0;
      } else if (intNum === 1) {
        intervalTest3 = rectWidth - lastImageWidth;
      } else if (rectWidth > imageWidth)// imageWidth > lastImageWidth
      {
        intervalTest3 = (rectWidth - imageWidth) / (intNum - 1);
      } else {
        intervalTest3 = rectWidth / (intNum + 1);
      }

      if (intervalTest1 >= imageWidth) {
        res.interval = intervalTest1;
      } else if (intervalTest2 < imageWidth && (lastImageWidth > (imageWidth - intervalTest2))) {
        res.interval = intervalTest2;
      } else {
        res.interval = intervalTest3;
      }

      return res;
    };

    var imageRatioObjs = [];

    var imagesFun = function(perDefData, k, i) {
      var pathIDFun = function(d, itemIndex) {
        return that._suffix + "-pathID-" + i + k + itemIndex;
      };

      var urlPathIDFun = function(d, itemIndex) {
        return "url(#" + pathIDFun(d, itemIndex) + ")";
      };

      var lastRectIDFun = function(d, itemIndex) {
        return "L-" + pathIDFun(d, itemIndex);
      };

      var urlLastRectIDFun = function(d, itemIndex) {
        return "url(#" + lastRectIDFun(d, itemIndex) + ")";
      };

      var thisObj = d3.select(this);

      var rectWidth = rectWidthFun(perDefData);
      var rectHeight = barHeight;

      var imageNum = imageNumber(perDefData);

      var intNum = Math.floor(imageNum.number);
      var decimalNum = imageNum.number - intNum;

      thisObj.selectAll("*").remove();

      var iImage = 0;
      for (; iImage < intNum; iImage++) {
        thisObj.append("image").attr("xlink:xlink:href",
                getImageURL.call(that, k)).attr("width", rectHeight).attr(
                "height", rectHeight).attr("x",
                iImage * imageNum.interval);
      }

      if (decimalNum) {
        // we cannot use clip-path, becuase clip-path will change the
        // X of the image.
        var startX = iImage * imageNum.interval;
        var lastImage = thisObj.append("g").attr('transform',
                "translate(" + startX + ",0)");

        lastImage.append("defs").append("pattern").attr("id",
                lastRectIDFun).attr("patternUnits", "userSpaceOnUse")
                .attr("width", rectHeight + 2).attr("height",
                        rectHeight + 2).append("image").attr(
                        "xlink:xlink:href", getImageURL.call(that, k)).attr(
                        "width", rectHeight).attr("height",
                        rectHeight);

        lastImage.append("rect").attr("width",
                rectHeight * decimalNum).attr("height", rectHeight)
                .attr("fill", urlLastRectIDFun);
      }

    };

    // start of the function
    barShape.selectAll("defs").remove();
    var imageDef = barShape.append("defs").append("pattern").attr(
            "id", defIDFun).attr("patternUnits", "userSpaceOnUse")
    // .attr("width",20)//plot width
    // .attr("height",20);//plot height
    .attr("width", rectWidthFunForPattern).attr("height",
            barHeight + 2);

    // we use "each" to access data and index
    // to make the imageNumRatio
    var imageNumRatio = 1;
    imageDef.each(function(d) {
      var valueScale = that._valueScales[d.valueAxis];
      imageNumRatio = bestImageNumberRatio(that._seriesData, valueScale,
              barHeight);
    });

    imageDef.each(imagesFun);
    bar.attr('fill', urlIDFun);

    var debugMode = false;
    if (debugMode) {
      bar.attr("stroke", "#555555");
      bar.attr("stroke-width", "1");
    }
  
  };
  
  return imageUtil;
});
define('sap/viz/modules/bar',[ 'sap/viz/modules/Constants', 'sap/viz/base/utils/oo',
        'sap/viz/modules/BaseHorizontalBar', 'sap/viz/base/utils/TypeUtils',
        'sap/viz/modules/util/MNDHandler', 'sap/viz/util/NumberUtils',
        'sap/viz/util/Scaler', 'sap/viz/modules/util/BoundUtil',
        'sap/viz/base/UADetector', 'sap/viz/modules/util/tooltipDataHandler',
        'sap/viz/modules/util/defaultSelectionUtil', 'sap/viz/modules/util/imageUtil' ],
function Setup(Constants, oo, BaseHorizontalBar, TypeUtils, MNDHandler,
    NumberUtils, Scaler, BoundUtil, UADetector, tooltipDataHandler,
    defaultSelUtil, imageUtil) {

  var CLASSMARKERSELECTED = Constants.CSS.CLASS.DATAPOINTSELECTED, CLASSDATAPOINT = Constants.CSS.CLASS.DATAPOINT, 
  SEL_CLASSDATAPOINT = '.' + CLASSDATAPOINT, CLASSMORPHABLEDATAPOINT = Constants.CSS.CLASS.MORPHABLEDATAPOINT;

  /**
   * *************************** private function
   * ***********************
   */
  var completeAnimation = function() {
    if( ++this._bar_currentAnimationCount ===  this._bar_totalAnimationCount){
      this._dispatch.initialized();
    }
  };

  var dataTransform = function(valueAxis1, valueAxis2, colorIndexArray) {
    this._primaryAxisTopBoundary = this._primaryAxisBottomBoundary = 0;
    this._secondaryAxisTopBoundary = this._secondaryAxisBottomBoundary = 0;
    var barGroups = [];
    // the number of bar in each group
    var barGroupNumber = 0;

    if (valueAxis1[0] && valueAxis1[0].length) {
      barGroupNumber = valueAxis1[0].length;
    } else if (valueAxis2[0] && valueAxis2[0].length) {
      barGroupNumber = valueAxis2[0].length;
    }
    var barGroup = [];
    var temp = 0, temp2 = 0;
    var i = 0, j = 0;
    for (i = 0; i < valueAxis1.length; i++) {
      if (this._hasMNDonCategoryAxis) {
        for (j = 0; j < valueAxis1[i].length; j++) {
          if (colorIndexArray[j] === 0) {
            temp = valueAxis1[i][j].val;
            valueAxis1[i][j].valueAxis = 0;

            if (this._primaryAxisTopBoundary < temp) {
              this._primaryAxisTopBoundary = temp;
            }
            if (this._primaryAxisBottomBoundary > temp) {
              this._primaryAxisBottomBoundary = temp;
            }
            this._bar_indexforSecondaryAxis++;
          } else {
            temp2 = valueAxis1[i][j].val;
            valueAxis1[i][j].valueAxis = 1;

            if (this._secondaryAxisTopBoundary < temp2) {
              this._secondaryAxisTopBoundary = temp2;
            }
            if (this._secondaryAxisBottomBoundary > temp2) {
              this._secondaryAxisBottomBoundary = temp2;
            }
          }
        }
      } else {
        temp = d3.max(valueAxis1[i], function(m) {
          return m.val;
        });
        temp2 = d3.min(valueAxis1[i], function(m) {
          return m.val;
        });

        if (this._primaryAxisTopBoundary < temp) {
          this._primaryAxisTopBoundary = temp;
        }
        if (this._primaryAxisBottomBoundary > temp2) {
          this._primaryAxisBottomBoundary = temp2;
        }
      }
      barGroup.push(valueAxis1[i]);

    }
    if (valueAxis2 !== undefined) {
      for (i = 0; i < valueAxis2.length; i++) {
        temp = d3.max(valueAxis2[i], function(m) {
          return m.val;
        });
        temp2 = d3.min(valueAxis2[i], function(m) {
          return m.val;
        });

        if (this._secondaryAxisTopBoundary < temp) {
          this._secondaryAxisTopBoundary = temp;
        }
        if (this._secondaryAxisBottomBoundary > temp2) {
          this._secondaryAxisBottomBoundary = temp2;
        }
        barGroup.push(valueAxis2[i]);
      }
    }

    for (j = 0; j < barGroupNumber; j++) {
      var ds = [];
      for (i = 0; i < barGroup.length; i++) {
        if (!this._hasMNDonCategoryAxis) {
          if (i < valueAxis1.length) {
            barGroup[i][j].valueAxis = 0;
          } else {
            barGroup[i][j].valueAxis = 1;
          }
        }
        if (NumberUtils.isNoValue(barGroup[i][j].val)) {
          barGroup[i][j].val = ' ';
        }
        ds.push(barGroup[i][j]);
      }
      if (this._MNDInnerOnColor) {
        var dSet = [], flag1 = 0, flag2 = 0;
        var n = 0;
        for ( var m = 0; m < valueAxis1.length; m++) {
          dSet.push(ds[m]);
          flag1++;
          if (flag1 === this._measureOnAxis1 && valueAxis2 !== undefined) {
            flag2 = 0;
            for (; n < valueAxis2.length; n++) {
              if (flag2 >= this._measureOnAxis2) {
                flag1 = 0;
                break;
              }
              dSet.push(ds[valueAxis1.length + n]);
              flag2++;
            }
          }
        }
        barGroups.push(dSet);
      } else {
        barGroups.push(ds);
      }
    }

    return barGroups;
  };

  var imageFillEnabled = function() {
    return (this._props.imageFill && !this._isDualAxis);
  };

  var appendRoundCornerItemWithoutAnimation = function(that, perRectData, m, i, r){
    var id = 'roundCorner-clip' + '-' + m + i + that._suffix;
    that._roundCornerDefs
    .append('clipPath')
    .attr('id', id)
    .attr("class", "v-clippath")
    .append('rect')
    .attr('rx', r)
    .attr('ry', r)
    .attr('width', function() {
         var valueScale = that._valueScales[perRectData.valueAxis];
          if (perRectData.val !== ' ' && perRectData.val !== 0) {
            var width = Math.abs(valueScale(perRectData.val) - valueScale(0));
            return (width + r);
          } else {
            return 0;
          }
        })
    .attr('height', that._bar_barHeight)
    .attr('y', 0)
    .attr('x', function() {
      return perRectData.val < 0 ? 0: -r;
     });
    return 'url(#' + id + ')';
  };
  
  var appendRoundCornerItemWithStructureChangeAnimation = function(that, perRectData, m, i, r, interval){
    var w = this.getAttribute('width'), h = this
        .getAttribute('height'), x = this
        .getAttribute('x'), y = this
        .getAttribute('y');
    var id = 'roundCorner-clip' + '-' + m + i + that._suffix;
    that._roundCornerDefs
        .append('clipPath')
        .attr('id', id)
        .attr("class", "v-clippath")
        .append('rect')
        .attr('rx', r)
        .attr('ry', r)
        .attr('width', w + r)
        .attr('height', that._bar_barHeight)
        .attr('y', 0)
        .attr('x', x)
        .transition()
        .delay(function(d, m) {
              return (m + that._bar_barNumber * i) * interval;
            })
        .attr('x', function() {
              if (perRectData.val < 0) {
                return 0;
              } else {
                return 0 - r;
              }
            })
        .attr('width', function() {
              var valueScale = that._valueScales[perRectData.valueAxis];
              if (perRectData.val !== ' ' && perRectData.val !== 0) {
                var width = Math.abs(valueScale(perRectData.val) - valueScale(0));
                return width + r;
              } else {
                return 0;
              }
            });
    return 'url(#' + id + ')';
  };
  
  var appendRoundCornerItemWithValueChangeAnimation = function(that, perRectData, m, i, r, interval){
    var w = parseFloat(this
        .getAttribute('width')), h = this
        .getAttribute('height'), x = this
        .getAttribute('x'), y = this
        .getAttribute('y');
    var id = 'roundCorner-clip' + '-' + m + i + that._suffix;
    that._roundCornerDefs
        .append('clipPath')
        .attr('id', id)
        .attr("class", "v-clippath")
        .append('rect')
        .attr('rx', r)
        .attr('ry', r)
        //I think it is a bug, when x is smaller than 0, it should be 0
        .attr('x', function() {
          if (perRectData.val < 0) {
            return 0;
          } else {
            return 0 - r;
          }
        })
        .attr('width', w + r)
        .attr('height', h)
        .attr('y', y)
        .transition()
        .duration(that._totalIntervalTime)
        .attr('width', function() {
              var valueScale = that._valueScales[perRectData.valueAxis];
              if (perRectData.val !== ' '  && perRectData.val !== 0) {
                var width = Math.abs(valueScale(perRectData.val) - valueScale(0));
                return (width + r);
              } else {
                return 0;
              }
            }).attr('height', that._bar_barHeight)
        .attr('y', 0);
    return 'url(#' + id + ')';
  };
  
  var appendRoundCorner = function(type, bar, that, r, interval){
    function rcFunc(){
      bar.attr('clip-path', function(perRectData, m, i) {
        switch(type){
        case 'none' :
          return appendRoundCornerItemWithoutAnimation.call(this, that, perRectData, m, i, r);
        case 'structureChange' : 
          return appendRoundCornerItemWithStructureChangeAnimation.call(this, that, perRectData, m, i, r, interval);
        case 'valueChange':
          return appendRoundCornerItemWithValueChangeAnimation.call(this, that, perRectData, m, i, r, interval);
        default :
          return appendRoundCornerItemWithValueChangeAnimation.call(this, that, perRectData, m, i, r, interval);
        }
        });
     }
    
    if ((UADetector.isSafari() && UADetector.os() === "Windows")||UADetector.isMobile()) {
      window.setTimeout(rcFunc, 0);
     } else {
      rcFunc();
     }
  };
  
  var adjustBarWithDataStructureChangeAnimation = function(bar, that, yArray,  r, interval, lastBarIndex, lastBarGroupIndex){
    bar.attr('height', that._bar_barHeight).attr(
            'width', 0).each(function(data, m) {
              d3.select(this).classed('series-' + m, true);
            });

    if (that._enableRoundCorner) {
      appendRoundCorner.call(this, 'structureChange', bar, that, r, interval);
    }
   
    var barTransition = bar.transition();
    barTransition
        .delay(function(d, m, i) {
          return (m + that._bar_barNumber * i) * interval;
        })
        .attr('x', 0)
        .attr('y', 0)
        .attr('width', function(perRectData) {
              var valueScale = that._valueScales[perRectData.valueAxis];
              if (perRectData.val !== ' ' && perRectData.val !== 0) {
                var width = Math.abs(valueScale(perRectData.val) - valueScale(0));
                return width;
              } else {
                return 0;
              }
            }).each('end', function(d, m, i) {
                completeAnimation.call(that);
            });
  };
  
  var adjustBarWithoutAnimation = function(bar, that, r, interval){

    bar.attr('width', function(perRectData) {
          var valueScale = that._valueScales[perRectData.valueAxis];
          if (perRectData.val !== ' '  && perRectData.val !== 0) {
            var width = Math.abs(valueScale(perRectData.val) - valueScale(0));
            return width;
          } else {
            return 0;
          }
        }).attr('x', 0).attr('height',
        that._bar_barHeight).attr('y', 0);
    if (that._enableRoundCorner) {
      appendRoundCorner.call(this, 'none', bar, that, r, interval);
    }
  };
  
  var adjustBarWithSizeChangeAnimation = function(bar, that, yArray,  r, interval, lastBarIndex, lastBarGroupIndex){
    if (!imageFillEnabled.call(that)) {
      if (that._enableRoundCorner) {
        appendRoundCorner.call(this, 'valueChange', bar, that, r, interval);
      }

      var barTransition = bar.transition();
      barTransition
          .duration(that._totalIntervalTime)
          .attr('x', 0)
          .attr('y', 0)
          .attr('width', function(perRectData, m) {
                var valueScale = that._valueScales[perRectData.valueAxis];
                if (perRectData.val !== ' ' && perRectData.val !== 0) {
                  var width = Math.abs(valueScale(perRectData.val)  - valueScale(0));
                  return width;
                } else {
                  return 0;
                }
              }).attr('height', that._bar_barHeight)
          .each('end', function(d, m) {
                  completeAnimation.call(that);
              });
    } else {
      var resizeTime = 500;
      adjustBarWithoutAnimation(bar, that,  r, interval);
      var barG = bar.attr("opacity", 0.3);
      barG = barG.transition();
      barG = barG.delay(0).duration(resizeTime).attr('opacity', 1).each('end',
          function(){
            completeAnimation.call(that);
          });
    }
  };
  
  var Bar = function(manifest, ctx) {
    Bar.superclass.constructor.apply(this, arguments);

    /**
     * ***********************protected attribute
     * *******************************
     */

    /**
     * ***********************private
     * attribute**********************************
     */
    // currently, we do not have actual private. So we only use name
    // conversion to make it private

    this._bar_indexforSecondaryAxis = 0;
    
    this._bar_clipEdge = true;

    this._bar_barNumber = 0, this._bar_barGroupNumber = 0, this._bar_barHeight = 0;
    
    this._bar_tooltipDataHandlerObj = null;
    
    this._bar_currentAnimationCount = 0;
    this._bar_totalAnimationCount = 0;
    this._bar_id = Math.floor(Math.random() * 10000);
    
    return this;
  };

  /**
   * ******************************** public function
   * ********************************
   */
  
  /**
   * Drawing the chart. we will reset all the styles and attributes of each rects.
   */
  Bar.prototype.draw = function(){

      var r = Math.log(this._bar_barHeight) / Math.log(2);
      if (r < 0) {
        this._enableRoundCorner = false;
      }

      var datashapesgroup = this._parent.selectAll('g.v-datashapesgroup');
      var barGroup = datashapesgroup.selectAll('g.v-bar').data(
              this._seriesData), lastBarGroupIndex = this._seriesData.length - 1;
      var that = this, yArray = [];
      var interval = that._totalIntervalTime / (that._bar_barNumber * that._bar_barGroupNumber);
      barGroup.enter().append('g').attr('class', 'v-bar');
      
      var barShape = barGroup.selectAll('g.v-datashape').data(function(d) {
        return d;
      });
      
      barShape.enter().append('g').attr('class', 'v-datashape').append(
              'rect').classed(CLASSDATAPOINT, true).classed(
              CLASSMORPHABLEDATAPOINT, true);
      
      barShape.attr('transform', function(perRectData, m, i) {
        var x, valueScale = that._valueScales[perRectData.valueAxis];
        if (perRectData.val < 0) {
          x = valueScale(perRectData.val);
        } else {
          x = valueScale(0);
        }
        var y = that._categoryScale(i) + that._bar_barHeight * (that._bar_barNumber - m - 1);
        y = y + that._bar_barHeight / 8 * (that._bar_barNumber - m - 1) + that._bar_barHeight / 2;

        yArray.push(y);
        return 'translate(' + x + ',' + y + ')';
      });
         
      var bar = barShape.select('rect.' + CLASSDATAPOINT), lastBarIndex = that._seriesData[0].length - 1;
      
      bar.attr('fill', function(perRectData, t){
        perRectData.fillColor = that._colorPalette[t % that._colorPalette.length];
        var parameter = {
          drawingEffect : that._drawingEffect,
          fillColor : perRectData.fillColor,
          direction : 'vertical'
        };
        return that._effectManager.register(parameter);
      }).attr('shape-rendering', 'crispEdges').attr(
            'fill-opacity', 1).attr('stroke', 'none');

    if (that.enableAnimation()) {
      // [04 - Sep - 2012 Nick] DataStructureChange
      // means the structure of data is changed.
      // It means the whole DOM nodes needed to be
      // removed (handled by d3) and append new ones.
        adjustBarWithDataStructureChangeAnimation(bar, that, yArray,  r, interval, lastBarIndex, lastBarGroupIndex);
    }
    // [04 - Sep - 2012 Nick] if the animation is
    // disabled
    else {
      adjustBarWithoutAnimation(bar, that, r, interval);
    }
    
    // ----------------call image fill
    // functions-----------------------------------------------------
    // barItem: the datashape which has one rect and one defs
    // bar: the bar rect in the barItem
    // i: is group index
    // barHeight: the height of the bar

    if (imageFillEnabled.call(that)) {
      imageUtil.imageFill.call(that, barShape, bar, that._bar_barHeight);
    }
    // ----------------------------------------------------------------------------------------------
    
    
    barShape.exit().remove();
    
    barGroup.exit().remove();
  
  };
  
  /**
   * Refreshing the chart. Only reset the width, height, x and y. It is supposed that we may do not
   * remove or add any shape when running this function.
   */
  Bar.prototype.refresh = function(){
    var r = Math.log(this._bar_barHeight) / Math.log(2);
    if (r < 0) {
      this._enableRoundCorner = false;
    }
    var datashapesgroup = this._parent.selectAll('g.v-datashapesgroup');
    var barGroup = datashapesgroup.selectAll('g.v-bar').data(
            this._seriesData), lastBarGroupIndex = this._seriesData.length - 1;
    var that = this, yArray = [];
    var interval = that._totalIntervalTime / (that._bar_barNumber * that._bar_barGroupNumber);
    var barShape = barGroup.selectAll('g.v-datashape').data(function(d) {
      return d;
    });
    
    barShape.attr('transform', function(perRectData, m, i) {
      var x, valueScale = that._valueScales[perRectData.valueAxis];
      if (perRectData.val < 0) {
        x = valueScale(perRectData.val);
      } else {
        x = valueScale(0);
      }
      var y = that._categoryScale(i) + that._bar_barHeight * (that._bar_barNumber - m - 1);
      y = y + that._bar_barHeight / 8 * (that._bar_barNumber - m - 1) + that._bar_barHeight / 2;

      yArray.push(y);
      return 'translate(' + x + ',' + y + ')';
    });
    
    var bar = barShape.select('rect.' + CLASSDATAPOINT), lastBarIndex = that._seriesData[0].length - 1;
    if (that.enableAnimation()) {
        adjustBarWithSizeChangeAnimation(bar, that, yArray,  r, interval, lastBarIndex, lastBarGroupIndex);
    }
    else {
      adjustBarWithoutAnimation(bar, that, r, interval);
    }
    
    if (imageFillEnabled.call(that)) {
      imageUtil.imageFill.call(that, barShape, bar, that._bar_barHeight);
    }
  };
  
  
  /**
   * Rendering the chart.
   */
  Bar.prototype.render = function(selection) {
    BoundUtil.drawBound(selection, this._width, this._height);
    this._bar_tooltipDataHandlerObj = tooltipDataHandler();
    
    // [19-Oct-2012 Nick] if the size of plot area is too small, there
    // is no value scale created and the whole drawing part is skipped.
    if (this._valueScales.length === 0) {
      return;
    }

    this._dispatch.startToInit();

    this._bar_barNumber = this._seriesData[0].length;
    this._bar_barGroupNumber = this._seriesData.length;
    this._bar_barHeight = 8 * (this._categoryScale.rangeBand()) / (9 * this._bar_barNumber + 7);
    this._bar_currentAnimationCount = 0;
    this._bar_totalAnimationCount =  this._bar_barGroupNumber * this._bar_barNumber;
    var svg = this._parent = selection;

    // append decorativeShape bar
    if (this._decorativeShape === null) {
      this._decorativeShape = svg.append('rect').attr('visibility',
          'hidden').attr('width', this._width).attr('height',
          this._categoryScale.rangeBand() - this._bar_barHeight / 2)
          .attr('fill',
              this._styleManager.queryDefault('v-hovershadow').fill)
          .attr('class', 'v-hovershadow');
    } else {
      this._decorativeShape.attr('width', this._width).attr('height',
          this._categoryScale.rangeBand() - this._bar_barHeight / 2)
          .attr('visibility', 'hidden');
    }

    if (this._defsEnter === null) {
      this._defsEnter = svg
          .append('defs')
          .append('clipPath').attr('id', 'clipPlot_' + this._bar_id)
          .append('rect').attr('width', this._width).attr('height', this._height);
    } else {
      this._defsEnter.attr('width', this._width).attr('height', this._height);
    }

    if (this._roundCornerDefs === null) {
      this._roundCornerDefs = svg.append('defs');
    } else {
      if (this._dataStructureChange || this._sizeChange || this._dataValueChange || !this._enableRoundCorner) {
        this._roundCornerDefs.selectAll(".v-clippath").remove();
      }
    }

    var datashapesgroup = svg.selectAll('g.v-datashapesgroup');
    if (!TypeUtils.isExist(datashapesgroup[0][0])) {
      datashapesgroup = svg.append('g').attr('class', 'v-datashapesgroup').attr("clip-path", "url(#clipPlot_" + this._bar_id + ")");
    }
    
    if( this._dataStructureChange || this._dataValueChange || this._propertiesChange){
      this.draw();
    } else if ( this._sizeChange){
      this.refresh();
    }
    
    
    if (!this.enableAnimation()) {
      this._dispatch.initialized();
    }
    
    //reset status
    this._sizeChange = false, this._dataStructureChange = false,
        this._dataValueChange = false, this._propertiesChange = false;
    this._isOnlyInitAnimation = true;

    return this;
  },
  
  /**
   * Handler mouse move event. If the mouse point is valid, then show the shadow.
   */
  Bar.prototype.hoverOnPoint = function(point) {
    var xOnModule = point.x, yOnModule = point.y;
    // find the closet dimension
    var i = -1;
    while (i < this._seriesData.length) {
      if (Math.abs(yOnModule - this._categoryScale.rangeBand() * i - 0.5 * this._categoryScale.rangeBand()) <= 0.5 * this._categoryScale.rangeBand()) {
        break;
      }
      i++;
    }

    if (i > (this._seriesData.length - 1) || i < 0) {
      this._decorativeShape.attr('visibility', 'hidden');
      return;
    }

    this._decorativeShape.attr('y', this._categoryScale.rangeBand() * i + this._bar_barHeight / 4)
        .attr('visibility', 'visible');

    if (i !== this._lastHovered) {
      if (this._tooltipVisible) {
        this._lastHovered = i;
        // this.parentNode.parentNode.parentNode point to the main
        // container
        var transform = this._parent[0][0]
            .getTransformToElement(this._parent[0][0].ownerSVGElement);
        var yoffset = transform.f;

        var tData = this._bar_tooltipDataHandlerObj.generateTooltipData(this._data,
            this._seriesData, this._bar_barGroupNumber - 1 - i, this._colorPalette,
            this._shapePalette);
        tData.point = {
          x : point.x,
          y : this._categoryScale.rangeBand() * i + 0.5 * this._categoryScale.rangeBand() + yoffset
        };
        tData.plotArea = {
          x : transform.e,
          y : transform.f,
          width : this._width,
          height : this._height
        };
        this._dispatch.showTooltip(tooltipDataHandler
            .formatTooltipData(tData));
      }
    }
  };
  
  /********** dependence function ****************************/
  
  Bar.prototype.secondDataRange = function(range) {
    if (!arguments.length) {
      return {
        min : this._secondaryAxisBottomBoundary,
        max : this._secondaryAxisTopBoundary
      };
    }
    var tempMax, tempMin;
    if (range !== null) {
      if (!isNaN(range.max)) {
        tempMax = range.max;
      } else {
        tempMax = this._valueScale2.perfectDomainEnd;
      }
      if (!isNaN(range.min)) {
        tempMin = range.min;
      } else {
        tempMin = this._valueScale2.perfectDomainBegin;
      }
      if (tempMax > tempMin) {
        this._secondaryAxisTopBoundary = tempMax;
        this._secondaryAxisBottomBoundary = tempMin;
        if (range.from === 'axis') {
          this._secondaryAxisManualRange = true;
        }
        if (TypeUtils.isExist(this._width) && TypeUtils.isExist(this._height)) {
          this.makeScales();
        }
      }
    } else {
      if (this._secondaryAxisManualRange === true) {
        this._secondaryAxisTopBoundary = this._valueScale2.perfectDomainEnd;
        this._secondaryAxisBottomBoundary = this._valueScale2.perfectDomainBegin;
        this._secondaryAxisManualRange = false;
        if (TypeUtils.isExist(this._width) && TypeUtils.isExist(this._height)) {
          this.makeScales();
        }
      }
    }
    return this;
  };
  
  
  Bar.prototype.primaryDataRange = function(range) {
    if (!arguments.length) {
      return {
        min : this._primaryAxisBottomBoundary,
        max : this._primaryAxisTopBoundary
      };
    }
    var tempMax, tempMin;
    if (range !== null) {
      if (!isNaN(range.max)) {
        tempMax = range.max;
      } else {
        tempMax = this._valueScale.perfectDomainEnd;
      }
      if (!isNaN(range.min)) {
        tempMin = range.min;
      } else {
        tempMin = this._valueScale.perfectDomainBegin;
      }
      if (tempMax > tempMin) {
        this._primaryAxisTopBoundary = tempMax;
        this._primaryAxisBottomBoundary = tempMin;
        if (range.from === 'axis') {
          this._primaryAxisManualRange = true;
        }
        if (TypeUtils.isExist(this._width) && TypeUtils.isExist(this._height)) {
          this.makeScales();
        }
      }
    } else {
      if (this._primaryAxisManualRange === true) {
        this._primaryAxisTopBoundary = this._valueScale.perfectDomainEnd;
        this._primaryAxisBottomBoundary = this._valueScale.perfectDomainBegin;
        this._primaryAxisManualRange = false;
        if (TypeUtils.isExist(this._width) && TypeUtils.isExist(this._height)) {
          this.makeScales();
        }
      }
    }
    return this;
  };
  
  Bar.prototype.imageInfo = function() {
      var imageInfo = {
        imageMode: this._props.imageFill,
        imagePalette: this._props.imagePalette,
        radio: 1
      };
      return imageInfo;
  };
  
  /** ************************ protected function *********************** */
  
  /**
   * set domain and set range bands of category scale.
   */
  Bar.prototype.makeCategoryScale = function(){
    var domain = [];
    for ( var i = 0; i < this._seriesData.length; i++) {
      domain.push(i);
    }
    this._categoryScale.domain(domain).rangeBands([ this._height, 0 ]);
  },
  
  /**
   * set domain and set range of value scales
   */
  Bar.prototype.makeValueScales = function(){
    this._valueScales = [];
    // when data is all 0 or null, we make the xScale.domain(0,1)
    if (this._primaryAxisBottomBoundary === 0 && this._primaryAxisTopBoundary === 0) {
      this._valueScale.domain([ 0, 1 ]).range([ 0, this._width ]);
    } else {
      this._valueScale.domain(
          [ this._primaryAxisBottomBoundary,
              this._primaryAxisTopBoundary ]).range(
          [ 0, this._width ]);
    }
    if (TypeUtils.isExist(this._data2) || this._isDualAxis) {
      // when data of second axis is all 0 or null, we make the xScale2
      // same with xScale .

      if (this._secondaryAxisTopBoundary === 0 && this._secondaryAxisBottomBoundary === 0) {
        this._valueScale2.domain(this._valueScale.domain()).range(
            this._valueScale.range());
      } else {
        this._valueScale2.domain(
            [ this._secondaryAxisBottomBoundary,
                this._secondaryAxisTopBoundary ]).range(
            [ 0, this._width ]);
        // when data of first axis is all 0 or null, we make the xScale
        // same with xScale2 .
        if (this._primaryAxisBottomBoundary === 0 && this._primaryAxisTopBoundary === 0) {
          this._valueScale.domain(this._valueScale2.domain()).range(
              this._valueScale2.range());
        }
      }
      if (!this._secondaryAxisManualRange && !this._primaryAxisManualRange) {
        Scaler.perfectDual(this._valueScale, this._valueScale2);
      } else if (!this._secondaryAxisManualRange && this._primaryAxisManualRange) {
        Scaler.perfect(this._valueScale2);
        Scaler.getRoughTickNum(this._valueScale);
      } else if (this._secondaryAxisManualRange && !this._primaryAxisManualRange) {
        Scaler.perfect(this._valueScale);
        Scaler.getRoughTickNum(this._valueScale2);
      } else {
        Scaler.getRoughTickNum(this._valueScale);
        Scaler.getRoughTickNum(this._valueScale2);
      }
    } else {
      if (!this._primaryAxisManualRange) {
        Scaler.perfect(this._valueScale);
      } else {
        Scaler.getRoughTickNum(this._valueScale);
      }
      this._valueScale2.range([ 0, 0 ]);
    }
    this._valueScales.push(this._valueScale);
    this._valueScales.push(this._valueScale2);
  },
  
  Bar.prototype.makeScales = function() {
    this.makeCategoryScale();
    this.makeValueScales();
  },

  Bar.prototype.parseData = function() {
    var obj = MNDHandler(this._data);

    this._data1 = obj["MG1"];
    this._data2 = obj["MG2"];
    this._measureOnAxis1 = obj.MG1Number;
    this._measureOnAxis2 = obj.MG2Number || 0;
    this._MNDInnerOnColor = obj.MNDOnColor && obj.MNDInner;

    if (this._data1[0] && this._data1[0][0].info && this._data1[0][0].info.defaultSelection) {
      this._hasDefaultSelection = true;
    } else {
      this._hasDefaultSelection = false;
    }

    if (TypeUtils.isExist(obj.color)) {
      this._hasMNDonCategoryAxis = true;
      this._isDualAxis = true;
    } else {
      this._hasMNDonCategoryAxis = false;
      if (TypeUtils.isExist(this._data2)) {
        this._isDualAxis = true;
      } else {
        this._isDualAxis = false;
      }
    }

    var _seriesData = dataTransform.call(this, this._data1,
        this._data2, obj.color);
    // judge what changed in dataset
    if (this._seriesData.length !== _seriesData.length || _seriesData[0].length !== this._seriesData[0].length) {
      this._dataStructureChange = true;
    } else {
      this._dataValueChange = true;
    }
    this._seriesData = _seriesData;
    if (TypeUtils.isExist(this._width) && TypeUtils.isExist(this._height)) {
      this.makeScales();
    }
    this.parseOptions();
    return this;
  },

  Bar.prototype.parseOptions = function() {
    this._enableRoundCorner = this._props.isRoundCorner;
    this._enableDataLoadingAnimation = this._props.animation.dataLoading;
    this._enableDataUpdatingAnimation = this._props.animation.dataUpdating;
    this._enableResizingAnimation = this._props.animation.resizing;

    this._tooltipVisible = this._props.tooltip.enabled;

    if (this._isDualAxis && !this._hasMNDonCategoryAxis) {
      this._axis1ColorPalette = this._props.primaryValuesColorPalette;
      this._axis2ColorPalette = this._props.secondaryValuesColorPalette;
    } else {
      this._axis2ColorPalette = this._props.colorPalette;
      this._axis1ColorPalette = this._props.colorPalette;
    }
    this._drawingEffect = this._props.drawingEffect;

    var colorIndexes = 0;
    if (!this._hasMNDonCategoryAxis) {
      this._bar_indexforSecondaryAxis = this._data1.length;
      colorIndexes = this._seriesData[0].length;
    } else {
      colorIndexes = this._seriesData.length * this._seriesData[0].length;
    }
    this._colorPalette = [];
    var i = 0;
    if (this._MNDInnerOnColor) {
      var flag = 0, flag2 = 0, j = 0;
      for (i = 0; i < this._bar_indexforSecondaryAxis; i++) {
        this._colorPalette.push(this._axis1ColorPalette[i % this._axis1ColorPalette.length]);
        flag++;
        if (flag === this._measureOnAxis1) {
          flag2 = 0;
          for (; j <= (colorIndexes - this._bar_indexforSecondaryAxis); j++) {
            if (flag2 >= this._measureOnAxis2) {
              flag = 0;
              break;
            }
            this._colorPalette.push(this._axis2ColorPalette[j  % this._axis2ColorPalette.length]);
            flag2++;
          }
        }
      }
    } else {
      for (i = 0; i < colorIndexes; i++) {
        if (i < this._bar_indexforSecondaryAxis) {
          this._colorPalette.push(this._axis1ColorPalette[i % this._axis1ColorPalette.length]);
        } else if (this._isDualAxis  && !this._hasMNDonCategoryAxis) {
          this._colorPalette
              .push(this._axis2ColorPalette[(i - this._bar_indexforSecondaryAxis)  % this._axis2ColorPalette.length]);
        }
      }
    }
  };

  oo.extend(Bar, BaseHorizontalBar);

  return Bar;
});
define('sap/viz/modules/manifests/xy/Bar',['sap/viz/modules/manifests/Module','sap/viz/modules/bar','sap/viz/modules/manifests/xy/BaseBar'],
function Setup(Manifest, fn) {
  var module = {
    'id' : 'sap.viz.modules.bar',
    'name' : 'bar',
    base : "sap.viz.modules.xy.bar.base",
    'properties' : {
      'imageFill' : {
        'name' : 'imageFill',
        'supportedValueType' : 'Boolean',
        'defaultValue' : false,
        'isExported' : false,
        'description' : 'Set enabled/disabled image fill.'
      },
      'imagePalette' : {
        'name' : 'imagePalette',
        'supportedValueType' : 'StringArray',
        'defaultValue' : [ 'http://www.sap.com/global/ui/images/global/sap-logo.png' ],
        'isExported' : false,
        'description' : 'images to fill the bar',
      } 
    },
    fn : fn
  };

  Manifest.register(module);
});
define('sap/viz/modules/manifests/xy/StackedBar',['sap/viz/modules/manifests/Module','sap/viz/modules/stackedbar','sap/viz/modules/manifests/xy/Bar'],
function Setup(Manifest, fn) {
    var module = {
      'id' : 'sap.viz.modules.stackedbar',
      'name' : 'stacked bar',
      base : "sap.viz.modules.bar",
      'properties' : {
        'mode' : {
          'name' : 'mode',
          'supportedValueType' : 'String',
          'supportedValues' : [ 'comparison', 'percentage' ],
          'defaultValue' : 'comparison',
          'description' : 'Set dispaly mode of stacked bar.',
          'isExported' : true,
          'updatable': false
        }
      },
      fn : fn
    };

    Manifest.register(module);
});
define('sap/viz/manifests/xy/BaseHorizontalChart',['sap/viz/manifests/Viz','sap/viz/modules/manifests/RootContainer','sap/viz/modules/manifests/Title',
'sap/viz/modules/manifests/Legend','sap/viz/modules/manifests/XYContainer',
'sap/viz/modules/manifests/Tooltip','sap/viz/modules/manifests/Axis','sap/viz/modules/manifests/Background',
'sap/viz/modules/manifests/DataLabel','sap/viz/modules/manifests/layout/Dock', 'sap/viz/modules/manifests/layout/Stack', 'sap/viz/modules/manifests/legend/Common'],
function Setup ( Manifest ) {
    var chart = {
      id : 'riv/basehorizontalchart',
      name : 'IDS_BASEHORIZONTALCHART',
     'abstract' : true,
      modules : {
        root : {
          id : 'sap.viz.modules.rootContainer',
          configure : { propertyCategory : 'general' },
          modules : {
            interaction : {
              id : 'sap.viz.modules.controller.interaction',
              configure : {
                clientID : 'main',
                propertyCategory : 'interaction',
                properties : {
                  supportedEventNames: ['mouseup', 'mousedown', 'mousemove', 'mouseover', 'mouseout', 'touchstart'],
                  holdSelection : true
                }
              }
            },
            
            layout : {
              id : 'sap.viz.modules.layout.dock'
            },

            title : {
              id : 'sap.viz.modules.title',
              configure : {
                propertyCategory : 'title',
                properties : {
                  layout : {
                    position : 'top',
                    priority : 0
                  }
                }
              }
            },
            
            legends : {
              id : 'sap.viz.modules.legend',
              configure : {
                propertyCategory : 'legendGroup',
                properties : {
                  layout : {
                    position : 'right',
                    priority : 1
                  }
                }
              },
              
              modules : {
                legend : {
                  id : 'sap.viz.modules.legend.common',
                  data : { aa : [ 2 ] },
                  configure : {
                    propertyCategory : 'legend',
                    properties : {
                      layout : { order : 0 }
                    }
                  }
                },
                
                layout : {
                  id : 'sap.viz.modules.layout.stack'
                }
              }
            },
            
            tooltip : {
              id : 'sap.viz.modules.tooltip',
              configure : {
                propertyCategory : 'tooltip',
                properties : { chartType : 'bar', orientation : 'left' }
              }
            },
            
            main : {
              id : 'sap.viz.modules.xycontainer',
              configure : {
                propertyCategory : 'xyContainer',
                properties : {
                  layout : {
                    position : 'center',
                    priority : 3
                  }
                }
              },
              modules : {
                dataLabel : {
                  id : 'sap.viz.modules.datalabel',
                  configure : {
                    propertyCategory : 'dataLabel',
                    properties : {
                      paintingMode : 'rectCoordinate',
                      visible : false,
                      orientation : 'horizontal',
                      position : 'inside',
                      automaticInOutside : true,
                      showZero : true,
                      isStackMode : false,
                      isPercentMode : false,
                      outsideVisible : true,
                      outsidePosition : 'right'
                    }
                  }
                },
                
                xAxis : {
                  id : 'sap.viz.modules.axis',
                  configure : {
                  'description': 'Settings for the value axis of an XY chart.',
                    propertyCategory : 'xAxis',
                    properties : { type : 'value', position : 'bottom' }
                  }
                },
    
                yAxis : {
                  id : 'sap.viz.modules.axis',
                  data : { aa : [ 1 ] },
                  configure : {
                  'description': 'Settings for the category axis of an XY chart.',
                    propertyCategory : 'yAxis',
                    properties : {
                      type : 'category',
                      position : 'left',
                      gridline : { visible : false }
                    },
                    propertiesOverride : {
                      gridline : { isExported : false },
                      label : { isExported : false },
                      axisline : { isExported : false },
                      scale : { 
                        fixedRange : {isExported : false},
                        minValue : {isExported : false},
                        maxValue : {isExported : false},
                        isExported : false 
                      }
                    }
                  }
                },
          
                background : {
                  id: 'sap.viz.modules.background',
                  configure : {
                    propertyCategory : 'background',
                    properties : { direction : 'horizontal' }
                  }
                },
                plot: {
                  configure: {
                    propertiesOverride:{
                      primaryValuesColorPalette:{ isExported: false },
                      secondaryValuesColorPalette: { isExported: false }
                    }
                  }
                }
              }
            }
          }
        }
      },
      
      dependencies : {
        attributes : [ {
          targetModule : 'root.main.xAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'primaryScale'
        },{
          targetModule : 'root.main.yAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'categoryScale'
        },{
          targetModule : 'root.legends.legend',
          target : 'colorPalette',
          sourceModule : 'root.main.plot',
          source : 'colorPalette'
        } ],
        events : [ {
          targetModule : 'root.tooltip',
          listener : 'showTooltip',
          sourceModule : 'root.main.plot',
          type : 'showTooltip'
        }, {
          targetModule : 'root.tooltip',
          listener : 'hideTooltip',
          sourceModule : 'root.main.plot',
          type : 'hideTooltip'
        } ]
      }
    };

    Manifest.register(chart);
});
define('sap/viz/manifests/xy/BarChart',['sap/viz/manifests/Viz','sap/viz/modules/manifests/xy/Bar','sap/viz/manifests/xy/BaseHorizontalChart',
'sap/viz/modules/manifests/controller/Interaction'],
function Setup(Manifest) {
    var chart = {
      id : 'viz/bar',
      name : 'IDS_BARCHART',
      base : 'riv/basehorizontalchart',
      modules : {
        root : {
          id : 'sap.viz.modules.rootContainer',
          modules : {
            interaction : {
              id : 'sap.viz.modules.controller.interaction',
              configure : {
                clientID : 'main',
                propertyCategory : 'interaction',
                properties : {
                  supportedEventNames: ['mouseup', 'mousedown', 'mousemove', 'mouseover', 'mouseout', 'touchstart'],
                  holdSelection : true
                }
              }
            },
            
            main : {
              modules : {
                plot : {
                  id : 'sap.viz.modules.bar',
                  configure : {
                    description : 'Settings regarding the chart area and plot area as well as general chart options.',
                    propertyCategory : 'plotArea'
                  }
                }
              }
            }
          }
        }
      },
      
      feeds : { secondaryValues:  null },
      
      dependencies : {
        attributes : [ {
          targetModule : 'root.main.plot',
          target : 'primaryDataRange',
          sourceModule : 'root.main.xAxis',
          source : 'range'
        }, {
          targetModule : 'root.main.xAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'primaryScale'
        }, {
          targetModule : 'root.main.xAxis',
          target : 'color',
          sourceModule : 'root.main.plot',
          source : 'primaryAxisColor'
        }, {
          targetModule : 'root.main.yAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'categoryScale'
        },{
          targetModule : 'root.main.xAxis',
          target : 'title',
          sourceModule : 'root.main.plot',
          source : 'primaryAxisTitle'
        },{
          targetModule : 'root.legends.legend',
          target : 'colorPalette',
          sourceModule : 'root.main.plot',
          source : 'colorPalette'
        }, {
        targetModule : 'root.legends.legend',
        target : 'setSelectionMode',
        sourceModule : 'root.interaction',
        source : 'getSelectionMode'
      } ],
        events : [ {
          targetModule : 'root.tooltip',
          listener : 'showTooltip',
          sourceModule : 'root.main.plot',
          type : 'showTooltip'
        }, {
          targetModule : 'root.tooltip',
          listener : 'hideTooltip',
          sourceModule : 'root.main.plot',
          type : 'hideTooltip'
        }, 
        {
          targetModule : 'root.interaction',
          listener : 'registerEvent',
          sourceModule : 'root.main.plot',
          type : 'initialized.interaction'
        },{
          targetModule : 'root.interaction',
          listener : 'highlightedByLegend',
          sourceModule : 'root.legends.legend',
          type : 'highlightedByLegend'
        }, {
          targetModule : 'root.legends.legend',
          listener : 'deselectLegend',
          sourceModule : 'root.interaction',
          type : 'deselectLegend'
        }, {
          targetModule : 'root.main.dataLabel',
          listener : 'showLabel',
          sourceModule : 'root.main.plot',
          type : 'initialized.datalabel'
        }, {
          targetModule : 'root.main.dataLabel',
          listener : 'removeLabel',
          sourceModule : 'root.main.plot',
          type : 'startToInit.datalabel'
        }, {
          targetModule : 'root.interaction',
          listener : 'defaultSelection',
          sourceModule : 'root.main.plot',
          type : 'initialized.defaultSelection'
        }]
      }      
    };

    Manifest.register(chart);
});
define('sap/viz/manifests/xy/StackedBarChart',['sap/viz/manifests/Viz','sap/viz/modules/manifests/RootContainer','sap/viz/modules/manifests/xy/StackedBar',
'sap/viz/manifests/xy/BarChart'],
function Setup(Manifest) {
    var chart = {
      id : 'viz/stacked_bar',
      name : 'IDS_STACKEDBARCHART',
      base : 'viz/bar',
      feeds:{
        secondaryValues: null
      },
      modules : {
        root : {
          modules : {
            main : {
              modules : {
                  plot : {
                    id : 'sap.viz.modules.stackedbar',
                    configure : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                        propertyCategory : 'plotArea'
                    }
                  },
                  dataLabel : {
                    id : 'sap.viz.modules.datalabel',
                    configure : {
                      properties : {
                        automaticInOutside : false,
                        isStackMode : true,
                        showZero : false
                      },
                      propertiesOverride : {
                        position : {
                          isExported : false
                        }
                      }
                    }
                  }
              }
          }
          }
        }
          
      }
    };

    Manifest.register(chart);
});
define('sap/viz/manifests/xy/PercentageStackedBarChart',['sap/viz/manifests/Viz','sap/viz/modules/manifests/RootContainer','sap/viz/modules/manifests/xy/StackedBar',
'sap/viz/manifests/xy/StackedBarChart'],
function Setup(Manifest) {
    var chart = {
      id : 'viz/100_stacked_bar',
      name : 'IDS_PERCENTAGESTACKEDBARCHART',
      base : 'viz/stacked_bar',
      modules : {
        root : {
          modules : {
             main : {
                modules : {
                  plot : {
                    id : 'sap.viz.modules.stackedbar',
                    configure : {
                        properties : {
                             mode : 'percentage'
                        }
                    }
                  },            
                  xAxis : {
                    id : 'sap.viz.modules.axis',
                    configure : {
                    'description': 'Settings for the value axis of an XY chart.',
                      propertyCategory : 'xAxis',
                      properties : {
                        isPercentMode : true
                      },
                      propertiesOverride : {
                        scale : { 
                          fixedRange : {isExported : false},
                          minValue : {isExported : false},
                          maxValue : {isExported : false},
                          isExported : false 
                        }
                      }
                    }
                  },
                  dataLabel : {
                    id : 'sap.viz.modules.datalabel',
                    configure : {
                      propertyCategory : 'dataLabel',
                      properties : {
                        type : 'value',
                        isPercentMode: true,
                        showZero : true
                      }
                    }
                  }
                }
            },
           
            tooltip : {
                id : 'sap.viz.modules.tooltip',
                configure : {
                  propertyCategory : 'tooltip',
                  properties : {
                    chartType : '100_stacked_bar',
                    orientation : 'left',
                    formatString: [["0.00%"],["0.00%"]]
                  }
                }
            }
          }
        }
      }
    };

    Manifest.register(chart);
});
define('sap/viz/manifests/xy/DualStackedBarChart',['sap/viz/manifests/Viz','sap/viz/modules/manifests/RootContainer',
'sap/viz/modules/manifests/xy/StackedBar','sap/viz/manifests/xy/StackedBarChart'],
function Setup(Manifest) {
    var chart = {
      id : 'viz/dual_stacked_bar',
      name : 'IDS_DUALSTACKEDBARCHART',
      base : 'viz/dual_bar',
      modules : {
        root : {
          modules : {
            main : {
            modules : {
              dataLabel : {
                id : 'sap.viz.modules.datalabel',
                configure : {
                  properties : {
                    automaticInOutside : false,
                    isStackMode : true,
                    showZero : false
                  },
                  propertiesOverride:{
                    position : {
                      isExported : false
                    }
                  }
                }
              },
                  plot : {
                    id : 'sap.viz.modules.stackedbar',
                    configure : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                        propertyCategory : 'plotArea'
                    }
                  }
              }
          }
          }
        }
          
      }
    };

    Manifest.register(chart);
});
define('sap/viz/manifests/xy/DualStackedVerticalBarChart',['sap/viz/manifests/Viz','sap/viz/modules/manifests/RootContainer',
'sap/viz/modules/manifests/xy/StackedVerticalBar','sap/viz/manifests/xy/StackedVerticalBarChart'],
function Setup ( Manifest ) {
    var chart = {
      id : 'viz/dual_stacked_column',
      name : 'IDS_DUALSTACKEDVERTICALBARCHART',
      base : 'viz/dual_column',
      modules : {
        root : {
          modules : {
            main : {
            modules : {
              dataLabel : {
                id : 'sap.viz.modules.datalabel',
                configure : {
                  properties : {
                    automaticInOutside : false,
                    isStackMode : true,
                    showZero : false
                  },
                  propertiesOverride:{
                    position : {
                      isExported : false
                    }
                  }
                }
              },
                  plot : {
                    id : 'sap.viz.modules.stackedverticalbar',
                    configure : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                        propertyCategory : 'plotArea'
                    }
                  }
              }
            }
          }
        }
          
      }
    };
    
    Manifest.register(chart);
});
define('sap/viz/manifests/xy/DualPercentageStackedBarChart',['sap/viz/manifests/Viz','sap/viz/modules/manifests/RootContainer',
'sap/viz/modules/manifests/xy/StackedBar','sap/viz/manifests/xy/DualStackedBarChart'],
function Setup(Manifest) {
    var chart = {
      id : 'viz/100_dual_stacked_bar',
      name : 'IDS_DUALPERCENTAGESTACKEDBARCHART',
      base : 'viz/dual_stacked_bar',
      modules : {
        root : {
          modules : {
            main : {
              modules : {
                plot : {
                  id : 'sap.viz.modules.stackedbar',
                  configure : {
                      properties : {
                           mode : 'percentage'
                      }
                  }
                },
                dataLabel : {
                    id : 'sap.viz.modules.datalabel',
                    configure : {
                      propertyCategory : 'dataLabel',
                      properties : {
                        isPercentMode : true,
                        showZero : true
                      }
                    }
                  },
                  xAxis : {
                      id : 'sap.viz.modules.axis',
                      configure : {
                      'description': 'Settings for the value axis of an XY chart.',
                        propertyCategory : 'xAxis',
                        properties : {
                          isPercentMode : true
                        },
                        propertiesOverride : {
                          scale : { 
                            fixedRange : {isExported : false},
                            minValue : {isExported : false},
                            maxValue : {isExported : false},
                            isExported : false 
                          }
                        }
                      }
                    },  
                    xAxis2 : {
                      id : 'sap.viz.modules.axis',
                      configure : {
                      'description': 'Settings for the value axis of an XY chart.',
                        propertyCategory : 'xAxis2',
                        properties : {
                          isPercentMode : true
                        },
                        propertiesOverride : {
                          scale : { 
                            fixedRange : {isExported : false},
                            minValue : {isExported : false},
                            maxValue : {isExported : false},
                            isExported : false 
                          }
                        }
                      }
                    }
                  }
              },
              tooltip : {
                id : 'sap.viz.modules.tooltip',
                configure : {
                  propertyCategory : 'tooltip',
                  properties : {
                    chartType : '100_dual_stacked_bar',
                    orientation : 'left',
                    formatString: [["0.00%"],["0.00%"]]
                  }
                }
              }
          }
        }
      }  
    };

    Manifest.register(chart);
});
define('sap/viz/manifests/xy/DualPercentageStackedVerticalBarChart',['sap/viz/manifests/Viz','sap/viz/modules/manifests/RootContainer',
'sap/viz/modules/manifests/xy/StackedVerticalBar','sap/viz/manifests/xy/DualStackedVerticalBarChart'],
function Setup(Manifest) {
    var chart = {
      id : 'viz/100_dual_stacked_column',
      name : 'IDS_DUALPERCENTAGESTACKEDVERTICALBARCHART',
      base : 'viz/dual_stacked_column',
      modules : {
        root : {
          modules : {
            main : {
              modules : {
                  plot : {
                    id : 'sap.viz.modules.stackedverticalbar',
                    configure : {
                        properties : {
                             mode : 'percentage'
                        }
                    }
                  },
                  dataLabel : {
                      id : 'sap.viz.modules.datalabel',
                      configure : {
                        propertyCategory : 'dataLabel',
                        properties : {
                          isPercentMode : true,
                          showZero : true
                        }
                      }
                    },
                  yAxis : {
                    id : 'sap.viz.modules.axis',
                    configure : {
                    'description': 'Settings for the value axis of an XY chart.',
                      propertyCategory : 'yAxis',
                      properties : {
                        isPercentMode : true
                      },
                      propertiesOverride : {
                        scale : { 
                          fixedRange : {isExported : false},
                          minValue : {isExported : false},
                          maxValue : {isExported : false},
                          isExported : false 
                        }
                      }
                    }
                  },
                  yAxis2 : {
                    id : 'sap.viz.modules.axis',
                    configure : {
                    'description': 'Settings for the value axis of an XY chart.',
                      propertyCategory : 'yAxis2',
                      properties : {
                        isPercentMode : true
                      },
                      propertiesOverride : {
                        scale : { 
                          fixedRange : {isExported : false},
                          minValue : {isExported : false},
                          maxValue : {isExported : false},
                          isExported : false 
                        }
                      }
                    }
                  }
                }
              },
              tooltip : {
                  id : 'sap.viz.modules.tooltip',
                  configure : {
                    propertyCategory : 'tooltip',
                    properties : {
                      chartType : '100_dual_stacked_column',
                      orientation : 'bottom',
                    formatString: [["0.00%"],["0.00%"]]
                  }
                }
              }
          }
        }
      }    
    };

    Manifest.register(chart);
});
define('sap/viz/manifests/xy/DualVerticalBarChart',['sap/viz/manifests/Viz','sap/viz/modules/manifests/RootContainer',
'sap/viz/manifests/xy/DesktopVerticalBar'],
function Setup(Manifest) {
  var chart = {
    id : 'viz/dual_column',
    name : 'IDS_DUALVERTICALBARCHART',
    base : 'viz/desktopverticalbar',
      modules : {
        root : {
          modules : {
            main : {
              modules : {
                plot: {
                  configure: {
                    propertiesOverride:{
                      primaryValuesColorPalette:{
                        isExported: true
                      },
                      secondaryValuesColorPalette: {
                        isExported: true
                      }
                    }
                  }
                },
              yAxis:{
                      id : 'sap.viz.modules.axis',
                  configure:{
                    'description':'Settings for the value axis at left or bottom of an XY chart with 2 value axis.',
                    propertiesOverride:{
                      title:{
                        applyAxislineColor:{
                          isExported: true
                        }
                      }
                    }
                  }
                },
                yAxis2 : {
                    id : 'sap.viz.modules.axis',
                    configure : {
                        'description':'Settings for the value axis at right or top of an XY chart with 2 value axis.',
                        propertyCategory : 'yAxis2',
                        properties : {
                            type : 'value',
                            position : 'right',
                            gridline : { visible : false }
                        },
                        propertiesOverride:{
                          title:{
                            applyAxislineColor:{
                              isExported: true
                            }
                          }
                        }
                    }
                }
              }
            }
          }
        }
          
      },
    feeds:{
      secondaryValues: {
        min : 1,
        max : Number.POSITIVE_INFINITY 
      }
    },
      dependencies : {
        attributes : [ {
          targetModule : 'root.main.plot',
          target : 'primaryDataRange',
          sourceModule : 'root.main.yAxis',
          source : 'range'
        }, {
          targetModule : 'root.main.yAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'primaryScale'
        }, {
          targetModule : 'root.main.plot',
          target : 'secondDataRange',
          sourceModule : 'root.main.yAxis2',
          source : 'range'
        }, {
          targetModule : 'root.main.yAxis2',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'secondScale'
        }, {
          targetModule : 'root.main.yAxis',
          target : 'color',
          sourceModule : 'root.main.plot',
          source : 'primaryAxisColor'
        }, {
          targetModule : 'root.main.yAxis2',
          target : 'color',
          sourceModule : 'root.main.plot',
          source : 'secondAxisColor'
        }, {
          targetModule : 'root.main.xAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'categoryScale'
        }, {
      targetModule : 'root.main.yAxis2',
       target : 'title',
       sourceModule : 'root.main.plot',
       source : 'secondAxisTitle'
    },{
      targetModule : 'root.main.yAxis',
       target : 'title',
       sourceModule : 'root.main.plot',
       source : 'primaryAxisTitle'
    },{
          targetModule : 'root.legends.legend',
          target : 'colorPalette',
          sourceModule : 'root.main.plot',
          source : 'colorPalette'
        },{
        targetModule : 'root.legends.legend',
        target : 'setSelectionMode',
        sourceModule : 'root.interaction',
        source : 'getSelectionMode'
        } ]
    }
  };

  Manifest.register(chart);
});
define('sap/viz/manifests/xy/DualBarChart',['sap/viz/manifests/Viz','sap/viz/modules/manifests/RootContainer',
'sap/viz/manifests/xy/BarChart'],
function Setup(Manifest) {
  var chart = {
    id : 'viz/dual_bar',
    name : 'IDS_DUALBARCHART',
    base : 'viz/bar',
    modules : {
      root : {
        modules : {
          main : {
            modules : {
              plot: {
                configure: {
                  propertiesOverride:{
                    primaryValuesColorPalette:{ isExported: true },
                    secondaryValuesColorPalette: { isExported: true }
                  }
                }
              },
              xAxis:{
                id : 'sap.viz.modules.axis',
                configure:{
                  'description':'Settings for the value axis at left or bottom of an XY chart with 2 value axis.',
                  propertiesOverride:{
                    title:{
                      applyAxislineColor:{
                        isExported: true
                      }
                    }
                  }
                }
              },
              xAxis2 : {
                id : 'sap.viz.modules.axis',
                configure : {
                  'description':'Settings for the value axis at right or top of an XY chart with 2 value axis.',
                  propertyCategory : 'xAxis2',
                  properties : {
                    type : 'value',
                    position : 'top',
                    gridline : { visible : false }
                  },
                  propertiesOverride:{
                    title:{
                      applyAxislineColor:{
                        isExported: true
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    
    feeds : {
      secondaryValues: { min : 1, max : Number.POSITIVE_INFINITY /* or null */  }
    },
    
    dependencies : {
      attributes : [ 
      {
        targetModule : 'root.main.plot',
        target : 'primaryDataRange',
        sourceModule : 'root.main.xAxis',
        source : 'range'
      },       
      {
        targetModule : 'root.main.xAxis',
        target : 'scale',
        sourceModule : 'root.main.plot',
        source : 'primaryScale'
      }, 
      {
        targetModule : 'root.main.plot',
        target : 'secondDataRange',
        sourceModule : 'root.main.xAxis2',
        source : 'range'
      },
      {
        targetModule : 'root.main.xAxis2',
        target : 'scale',
        sourceModule : 'root.main.plot',
        source : 'secondScale'
      }, 
      {
        targetModule : 'root.main.xAxis',
        target : 'color',
        sourceModule : 'root.main.plot',
        source : 'primaryAxisColor'
      }, 
      {
        targetModule : 'root.main.xAxis2',
        target : 'color',
        sourceModule : 'root.main.plot',
        source : 'secondAxisColor'
      }, 
      {
        targetModule : 'root.main.yAxis',
        target : 'scale',
        sourceModule : 'root.main.plot',
        source : 'categoryScale'
      },
      {
      targetModule : 'root.main.xAxis',
       target : 'title',
       sourceModule : 'root.main.plot',
       source : 'primaryAxisTitle'
      }, 
      {
        targetModule : 'root.main.xAxis2',
        target : 'title',
        sourceModule : 'root.main.plot',
        source : 'secondAxisTitle'
      },
      {
        targetModule : 'root.legends.legend',
        target : 'colorPalette',
        sourceModule : 'root.main.plot',
        source : 'colorPalette'
      }, 
      {
        targetModule : 'root.legends.legend',
        target : 'setSelectionMode',
        sourceModule : 'root.interaction',
        source : 'getSelectionMode'
      } ]
    }
  };

  Manifest.register(chart);
});
define('sap/viz/manifests/xy/VerticalBarChart',['sap/viz/manifests/Viz', 'sap/viz/base/UADetector', 'sap/viz/modules/manifests/xy/VerticalBar','sap/viz/manifests/xy/BaseVerticalChart', 'sap/viz/modules/manifests/controller/Pinch'],
function Setup(Manifest, UADetector) {
    var chart = {
      id : 'viz/column',
      name : 'IDS_VERTICALBARCHART',
      base : 'riv/baseverticalchart',
      modules : {
        root : {
          id : 'sap.viz.modules.rootContainer',
          modules : {
            interaction : {
              id : 'sap.viz.modules.controller.interaction',
              configure : {
                clientID : 'main',
                propertyCategory : 'interaction',
                properties : {
                  supportedEventNames: ['mouseup', 'mousedown', 'mousemove', 'mouseover', 'mouseout', 'touchstart'],
                  holdSelection : true
                }
              }
            },
            main : {
              modules : {
                plot : {
                    id : 'sap.viz.modules.verticalbar',
                    configure : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                        propertyCategory : 'plotArea'
                    }
                }
              }
          }
          }
        }
         
      },
      feeds:{
        secondaryValues:  null
      },
      dependencies : {
        attributes : [ {
          targetModule : 'root.main.plot',
          target : 'primaryDataRange',
          sourceModule : 'root.main.yAxis',
          source : 'range'
        }, {
          targetModule : 'root.main.yAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'primaryScale'
        }, {
          targetModule : 'root.main.yAxis',
          target : 'color',
          sourceModule : 'root.main.plot',
          source : 'primaryAxisColor'
        }, {
          targetModule : 'root.main.xAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'categoryScale'
        },{
      targetModule : 'root.main.yAxis',
       target : 'title',
       sourceModule : 'root.main.plot',
       source : 'primaryAxisTitle'
    },{
          targetModule : 'root.legends.legend',
          target : 'colorPalette',
          sourceModule : 'root.main.plot',
          source : 'colorPalette'
        },{
        targetModule : 'root.legends.legend',
        target : 'setSelectionMode',
        sourceModule : 'root.interaction',
        source : 'getSelectionMode'
        } ],
         events : [ 
         {
          targetModule : 'root.tooltip',
          listener : 'showTooltip',
          sourceModule : 'root.main.plot',
          type : 'showTooltip'
        }, {
          targetModule : 'root.tooltip',
          listener : 'hideTooltip',
          sourceModule : 'root.main.plot',
          type : 'hideTooltip'
        }, {
          targetModule : 'root.interaction',
          listener : 'registerEvent',
          sourceModule : 'root.main.plot',
          type : 'initialized.interaction'
        }, {
          targetModule : 'root.interaction',
          listener : 'highlightedByLegend',
          sourceModule : 'root.legends.legend',
          type : 'highlightedByLegend'
      }, {
            targetModule : 'root.legends.legend',
          listener : 'deselectLegend',
          sourceModule : 'root.interaction',
          type : 'deselectLegend'
      }, {
        targetModule : 'root.main.dataLabel',
        listener : 'showLabel',
        sourceModule : 'root.main.plot',
        type : 'initialized.datalabel'
      }, {
        targetModule : 'root.main.dataLabel',
        listener : 'removeLabel',
        sourceModule : 'root.main.plot',
        type : 'startToInit.datalabel'
      }, {
        targetModule : 'root.interaction',
        listener : 'defaultSelection',
        sourceModule : 'root.main.plot',
        type : 'initialized.defaultSelection'
      }]
      }
    };
   
    Manifest.register(chart);
});

define('sap/viz/manifests/xy/ImageBarChart',['sap/viz/manifests/Viz','sap/viz/modules/manifests/RootContainer',
'sap/viz/manifests/xy/BarChart'],
function Setup(Manifest) {
  var chart = {
    id : 'viz/image_bar',
    name : 'IDS_IMAGEBARCHART',
    base : 'viz/bar',
    'isExported':false,
    modules : {
      root : {
        modules : {
          main : {
            modules : {
              dataLabel: {
                configure: {
                  properties : {
                    visible: true,
                    position: "outside"
                  }
                }
              },
              plot: {
                configure: {
                  properties : {
                    imageFill: true
                  },                
                  propertiesOverride:{
                    imagePalette: { isExported: true }
                  }
                }
              }
            }
          }
        }
      }
    },
      dependencies : {
        attributes : [ undefined, undefined, undefined,undefined,undefined, undefined, 
        {
          targetModule : 'root.legends.legend',
          target : 'imageInfo',
          sourceModule : 'root.main.plot',
          source : 'imageInfo'
        }, {
          targetModule : 'root.tooltip',
          target : 'imageInfo',
          sourceModule : 'root.main.plot',
          source : 'imageInfo'
        } ]
      }         

  };

  Manifest.register(chart);
});
define('sap/viz/modules/stackedwaterfall',['sap/viz/base/utils/TypeUtils','sap/viz/modules/dispatch','sap/viz/modules/util/MNDHandler',
'sap/viz/lang/langManager','sap/viz/util/NumberUtils','sap/viz/util/Scaler','sap/viz/util/ColorSeriesGenerator',
'sap/viz/base/utils/Objects','sap/viz/modules/util/tooltipDataHandler',
'sap/viz/modules/util/BoundUtil','sap/viz/base/utils/ObjectUtils','sap/viz/modules/util/defaultSelectionUtil','sap/viz/modules/Constants'],
function Setup(TypeUtils, dispatch, MNDHandler, langManager, NumberUtils, Scaler, ColorSeries, Objects, TooltipDataHandler, boundUtil, Objects2, defaultSelUtil,Constants) {
  var stackedwaterfall = function(manifest, ctx) {
    var CLASSMARKERSELECTED = "v-datapoint-selected",
        CLASSMARKERHOVER = "v-datapoint-hover",
        CLASSDATAPOINT = "v-datapoint",
        CLASSMORPHABLEDATAPOINT = Constants.CSS.CLASS.MORPHABLEDATAPOINT;
    var CLASSDATAPOINTCOMBINED = CLASSDATAPOINT + ' ' + CLASSMORPHABLEDATAPOINT;
    var CSSCLASS_HOVERLINE = 'v-hovershadow';

    var options, width, height, originData, chartData, tooltipData, primaryAxisMinValue, primaryAxisMaxValue, categoryLen, measureLength,
        primaryAxisManualRange = false, 
        tooltipVisible, decorativeShape, barInfo, isDataSchemaChanged = false, isDataLoading = true, isSizeChanged = false, isDatasetChanged = false,
        lastHovered = null, dimensionData, measureData, isShowTotal, isShowSubtotal, hasDefaultSelection = false,
        eDispatch = new dispatch('selectData', 'deselectData', 'showTooltip', 'hideTooltip', 'initialized', 'startToInit');
    var defaultString = langManager.get('IDS_ISNOVALUE'),
        colorPalette = ColorSeries.sap32().range(), 
        shapePalette = ['squareWithRadius'],
        totalIntervalTime = 1200, sWrapper;
    var style = {};
    var _TooltipDataHandler;

    var effectManager = ctx.effectManager, drawingEffect = 'normal';
    
    var categoryScale = d3.scale.ordinal(), primaryScale = d3.scale.linear();

    var defsEnter ,
        id = Math.floor(Math.random() * 10000);

    var chart = function(selection) {
      boundUtil.drawBound(selection, width, height);
      
      _TooltipDataHandler = TooltipDataHandler();
      
      if(!TypeUtils.isExist(primaryScale)){
        return;
      }
      eDispatch.startToInit();
      
      selection.each(function(){
        //calculate information
        barInfo = _getBarInfo();
        var barSize = barInfo.barSize;
        //TODO start from zero. Do we support start from certain position? 
        var intialValue = 0;
        var interval = totalIntervalTime / categoryLen;
        
        sWrapper = d3.select(this);
        var svg = sWrapper;
        
        // append decorativeShape bar
        if (decorativeShape === undefined) {
          decorativeShape = sWrapper.append('rect').attr('visibility', 'hidden').attr('fill', style.hoverline.fill).attr('class', CSSCLASS_HOVERLINE);
          //set decorative shape info.
          if(options.isHorizontal === false){
            decorativeShape.attr('width', categoryScale.rangeBand() - barInfo.barGap).attr('height', height);
          }else{
            decorativeShape.attr('height', categoryScale.rangeBand() - barInfo.barGap).attr('width', width);
          }
        } else {
          //set decorative shape info.
          if(options.isHorizontal === false){
            decorativeShape.attr('width', categoryScale.rangeBand() - barInfo.barGap).attr('height', height).attr('visibility', 'hidden');
          }else{
            decorativeShape.attr('height', categoryScale.rangeBand() - barInfo.barGap).attr('width', width).attr('visibility', 'hidden');
          }
        }
        
        if(!TypeUtils.isExist(defsEnter)){
          defsEnter = svg
            .append('defs')
            .append('clipPath').attr('id', 'clipPlot_' + id)
            .append('rect').attr('width', width).attr('height', height);
        }else{
          defsEnter.attr('width', width).attr('height', height);
        }

       
        if(isDataSchemaChanged === true){
          //Data structure changed. reset. 
          sWrapper.selectAll('g.v-waterfallgroup').remove();
          sWrapper.selectAll('g.v-datashapesgroup').remove();
        }
        //create stacked waterfall group
        var mainShapesWrapper = sWrapper.selectAll('g.v-datashapesgroup');
        if(mainShapesWrapper.empty()){
          mainShapesWrapper = sWrapper.append('g').attr('class', 'v-datashapesgroup').attr("clip-path", "url(#clipPlot_" + id + ")");
        }
        var wrap = mainShapesWrapper.selectAll('g.v-waterfallgroup').data(chartData);
        wrap.enter().append('g').attr('class', 'v-waterfallgroup');
        wrap.exit().remove();
        
        var hasAnmation = false;
        if(isDataLoading){
          hasAnmation = options.animation.dataLoading;
        }else if(isDatasetChanged){
          hasAnmation = options.animation.dataUpdating;
        }else if(isSizeChanged){
          hasAnmation = options.animation.resizing;
        }
        
        var dataShape = wrap.selectAll('g.v-datashape').data(function(d,i){
          return d.items;
        });
        var dataShapeEnter = dataShape.enter().append('g').attr('class','v-datashape');
        dataShapeEnter.append('rect').attr('class', CLASSDATAPOINTCOMBINED);
        
        if(!hasAnmation){
          dataShape.exit().remove();
          if(options.isHorizontal === false){
            //vertical
            wrap.attr('transform', function(d, i){
              var categoryPos = categoryScale(i) + barInfo.barGap;
              return 'translate('+categoryPos+','+0+')';
            });
            
            dataShape.attr('transform', function(d){
              var y=(d.val > 0) ? primaryScale(intialValue + d.after) : primaryScale(intialValue + d.before);
              return 'translate('+0+','+y+')';
            });
            
            dataShape.select('rect').attr('fill',function(d){
                  var parameters = {
                  drawingEffect : drawingEffect,
                  fillColor : colorPalette[d.index % colorPalette.length],
                  direction : 'horizontal'
                };
                return effectManager.register(parameters);
              })
              .attr('width', barSize)
              .attr('height', function(d){
                return Math.abs(primaryScale(d.after)-primaryScale(d.before));
              }).attr('fill-opacity', 1).attr('stroke','none');
          }else{
            //horizontal
            wrap.attr('transform', function(d, i){
              var categoryPos = categoryScale(i) + barInfo.barGap;
              return 'translate('+0+','+categoryPos+')';
            });
            
            dataShape.attr('transform', function(d, i){
              var x= (d.val > 0) ? primaryScale(intialValue + d.before) : primaryScale(intialValue + d.after);
              return 'translate('+x+','+0+')';
            });
            
            dataShape.select('rect').attr('fill',function(d, i){
                  var parameters = {
                  drawingEffect : drawingEffect,
                  fillColor : colorPalette[d.index % colorPalette.length],
                  direction : 'vertical'
                };
                return effectManager.register(parameters);
              })
              .attr('height', barSize)
              .attr('width', function(d, i){
                return Math.abs(primaryScale(d.after)-primaryScale(d.before));
              }).attr('fill-opacity', 1).attr('stroke','none');
          }
          eDispatch.initialized();
        }else{
          //remove data shape
          dataShape.exit().transition().duration(interval)
            .attr('height', 0)
            .attr('width', 0)
            .remove();
          var ds, m, mLen;
          if(options.isHorizontal === false){
            //Vertical
            dataShapeEnter.selectAll('rect').attr('height', 0);
            dataShapeEnter.attr('transform', function(d){
              var y = primaryScale(intialValue + d.before); 
              return 'translate('+0+','+y+')';
            });
            
            wrap.attr('transform', function(d, i){
              var categoryPos = categoryScale(i) + barInfo.barGap;
              return 'translate('+categoryPos+','+0+')';
            });
            
            for(m = 0, mLen = dataShape.length; m<mLen; m++){
              ds = d3.selectAll(dataShape[m]);
              ds.transition()
                .duration(interval)
                .delay(function(d, i){
                  return m*interval;
                })
                .attr('transform', function(d){
                  if(primaryScale){
                    var y = (d.val > 0) ? primaryScale(intialValue + d.after) : primaryScale(intialValue + d.before);
                    return 'translate('+0+','+y+')';
                  }else{
                    return 0;
                  }
                  
                });
              ds.select('rect').attr('fill',function(d){
                var parameters = {
                    drawingEffect : drawingEffect,
                    fillColor : colorPalette[d.index % colorPalette.length],
                    direction : 'horizontal'
                  };
                  return effectManager.register(parameters);
                })
                .attr('width', barSize).attr('fill-opacity', 1).attr('stroke','none')
                .transition()
                  .duration(interval)
                  .delay(function(){
                    return m*interval;
                  })
                  .attr('height', function(d){
                    if(primaryScale){
                      return Math.abs(primaryScale(d.after)-primaryScale(d.before));
                    }else{
                      return 0;
                    }
                    
                  })
                  .each('end', function(d, i){
                    if(d.isLastItem !== undefined && d.isLastItem === true){
                      eDispatch.initialized();
                    }
                  });
            }
          }else{
            dataShapeEnter.selectAll('rect').attr('width', 0);
            dataShapeEnter.attr('transform', function(d){
              var x = primaryScale(intialValue + d.before);
              return 'translate('+x+','+0+')';
            });
            
            wrap.attr('transform', function(d, i){
              var categoryPos = categoryScale(i) + barInfo.barGap;
              return 'translate('+0+','+categoryPos+')';
            });
            
            for(m = 0, mLen = dataShape.length; m<mLen; m++){
              ds = d3.selectAll(dataShape[m]);
              ds.transition()
              .duration(interval)
              .delay(function(){
                return m*interval;
              })
              .attr('transform', function(d){
                if(primaryScale){
                  var x = (d.val > 0) ? primaryScale(intialValue + d.before) : primaryScale(intialValue + d.after);
                  return 'translate('+x+','+0+')';
                }else{
                  return 0;
                }                
              });
              ds.select('rect').attr('fill',function(d){
                var parameters = {
                    drawingEffect : drawingEffect,
                    fillColor : colorPalette[d.index % colorPalette.length],
                    direction : 'vertical'
                  };
                  return effectManager.register(parameters);
              })
                .attr('height', barSize).attr('fill-opacity', 1).attr('stroke','none')
                .transition()
                  .duration(interval)
                  .delay(function(){
                    return m*interval;
                  })
                  .attr('width', function(d){
                    if(primaryScale){
                      return Math.abs(primaryScale(d.after)-primaryScale(d.before));
                    }else{
                      return 0;
                    }
                    
                  })
                  .each('end', function(d, i){
                    if(d.isLastItem !== undefined && d.isLastItem === true){
                      eDispatch.initialized();
                    }
                  });
            }
          }
        }
        //reset flags
        isDataLoading = false;
        isSizeChanged = false;
        isDatasetChanged = false;
      });
    };

    chart.afterUIComponentAppear = function(){
      eDispatch.initialized(); 
    };
    
    chart.hoverOnPoint = function(point) {
      var xOnModule = point.x, yOnModule = point.y;
      var posModule;
      if(options.isHorizontal === false){
        //vertical stacked waterfall bar chart
        posModule = xOnModule;
      }else{
        //horizontal stacked waterfall bar chart
        posModule = yOnModule;
      }
      // find the closet dimension
      var i = -1;
      var groupCount = chartData.length;
      while (i < groupCount) {
        if (Math.abs(posModule - categoryScale.rangeBand() * i - 0.5 * categoryScale.rangeBand()) <= 0.5 * categoryScale.rangeBand()) {
          break;
        }
        i++;
      }

      if (i > (groupCount - 1) || i < 0) {
        decorativeShape.style('visibility', 'hidden');
        return;
      }
      if(options.isHorizontal === false){
        decorativeShape.attr('x', categoryScale.rangeBand() * i + barInfo.barGap / 2);
      }else{
        decorativeShape.attr('y', categoryScale.rangeBand() * i + barInfo.barGap / 2 );
      }
      decorativeShape.style('visibility', 'visible');
      
      if (lastHovered !== i) {
        if (tooltipVisible) {
          lastHovered = i;
          // this.parentNode point to plot graphic. it is different from bar
          // chart as in bar chart it should get the yoffset which can get it
          // from mian graphic element
          var transform = sWrapper.node().getTransformToElement(sWrapper.node().ownerSVGElement);
          var tData = _TooltipDataHandler.generateTooltipData(originData, tooltipData, i, colorPalette, shapePalette);
          if (options.isHorizontal === false) {
            // vertical stacked waterfall bar chart
            tData.point = {
              x : categoryScale.rangeBand() * i + 0.5 * categoryScale.rangeBand() + transform.e,
              y : point.y
            };
          } else {
            // horizontal stacked waterfall bar chart
            tData.point = {
              x : point.x,
              y : categoryScale.rangeBand() * i + 0.5 * categoryScale.rangeBand() + transform.f
            };
          }
          
          eDispatch.showTooltip(TooltipDataHandler.formatTooltipData(tData));
        }
      }

    };

    chart.blurOut = function() {
      decorativeShape.style('visibility', 'hidden');
      lastHovered = null;
      if (tooltipVisible) {
        eDispatch.hideTooltip();
      }
    };
  
    chart.highlight = function(elems) {        
     if (elems instanceof Array) {
           for ( var i = 0, len = elems.length; i < len; i++) {
                elems[i].setAttribute('class',CLASSDATAPOINTCOMBINED+ ' ' + CLASSMARKERSELECTED);
                elems[i].setAttribute('fill-opacity', 1);
                elems[i].setAttribute('stroke', '#333333');
            }
        } else {
            elems.setAttribute('class',CLASSDATAPOINTCOMBINED+ ' ' + CLASSMARKERSELECTED);
            elems.setAttribute('fill-opacity', 1);
            elems.setAttribute('stroke', '#333333');      
       }
       if(hasDefaultSelection){
          defaultSelUtil.clearSelectionInfo(sWrapper, true, elems);
       }
    };

    chart.unhighlight = function(elems) {
       if (elems instanceof Array) {
            for ( var i = 0, len = elems.length; i < len; i++) {
                elems[i].setAttribute('class',CLASSDATAPOINTCOMBINED);
                elems[i].setAttribute('fill-opacity', 0.4);
                elems[i].setAttribute('stroke', 'none');
            }
        } else {
            elems.setAttribute('class',CLASSDATAPOINTCOMBINED);
            elems.setAttribute('fill-opacity', 0.4);
            elems.setAttribute('stroke', 'none');
        }
        if (hasDefaultSelection) {
            defaultSelUtil.clearSelectionInfo(sWrapper, false, elems);
        }
    };

    chart.clear = function(gray) {
      if (gray === null || gray === false || gray === undefined) {
        var rects = sWrapper.selectAll('.v-datapoint');
        rects.attr('fill-opacity', 1).attr('stroke', 'none');
        if (hasDefaultSelection) {
          defaultSelUtil.clearSelectionInfo(sWrapper, false, rects);
        }
      } else {
        sWrapper.selectAll('.v-datapoint').attr('fill-opacity', 0.4).attr('stroke', 'none');
      }
    };

    chart.parent = function() {
      return sWrapper;
    };
    
    chart.data = function(_) {
      if (!arguments.length) {
        return originData;
      }
      originData = _;
      _parseOriginData(_);
      
      if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
        _makeScale();
      }
      return chart;
    };

    chart.properties = function(props) {
      if (!arguments.length) {
        return options;
      }
      
      Objects.extend(true, options, props);
      colorPalette = options.colorPalette;
      drawingEffect = options.drawingEffect;
      tooltipVisible = options.tooltip.enabled;
      
      if(isShowTotal !== options.isShowTotal || isShowSubtotal !== options.subtotal.visible){
        //isShowTotal is changed, update dataset.
        isShowTotal = options.isShowTotal;
        isShowSubtotal = options.subtotal.visible;
        _parseOriginData(originData);
      }
      return chart;
    };

    chart.width = function(_) {
      if (!arguments.length) {
        return width;
      }
      isSizeChanged = (!isSizeChanged && (_ === width)) ? false : true;
      width = _;
      if(TypeUtils.isExist(originData) && TypeUtils.isExist(width) && TypeUtils.isExist(height)){
        _makeScale();
      }
      return chart;
    };

    chart.height = function(_) {
      if (!arguments.length) {
        return height;
      }
      isSizeChanged = (!isSizeChanged && (_ === height)) ? false : true;
      height = _;
      if(TypeUtils.isExist(originData) && TypeUtils.isExist(width) && TypeUtils.isExist(height)){
        _makeScale();
      }
      return chart;
    };

    chart.primaryAxisTitle = function(_) {
      if(!arguments.length){
        var titles =  originData.getMeasureValuesGroupDataByIdx(0), title = [];
        if(titles){
          for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
          }
        }
        return title.join(' & ');
      }
      return chart;
    };

    chart.secondAxisTitle = function(_) {
      if(!arguments.length){
        var titles =  originData.getMeasureValuesGroupDataByIdx(1), title = [];
        if(titles){
          for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
          }
        }
        return title.join(' & ');
      }
      return chart;
    };

    chart.categoryScale = function(scale) {
      if (!arguments.length) {
        return categoryScale;
      }
      categoryScale = scale;
      return chart;
    };

    chart.primaryScale = function(scale) {
      if (!arguments.length) {
        return primaryScale;
      }
      primaryScale = scale;
      return chart;
    };
    
    chart.colorPalette = function(_){
      if(!arguments.length){
        return colorPalette;
      }
      colorPalette = _;
      return this;
    };

    chart.dispatch = function(_) {
      if (!arguments.length){
        return eDispatch;
      }
      eDispatch = _;
      return chart;
    };

    chart.dataLabel = function(_) {
      return chart;
    };
    
    chart.dimensionData = function(_){
      if (!arguments.length) {
        return [dimensionData];
      }
      dimensionData = _;
    };
    
    chart.primaryDataRange = function(range) {
      if (!arguments.length) {
        return {
          min : primaryAxisMinValue,
          max : primaryAxisMaxValue
        };
      }
      var tempMax, tempMin;
      if (range !== null) {
        if (!isNaN(range.max)) {
          tempMax = range.max;
        } else {
          tempMax = primaryScale.perfectDomainEnd;
        }
        if (!isNaN(range.min)) {
          tempMin = range.min;
        } else {
          tempMin = primaryScale.perfectDomainBegin;
        }
        if (tempMax > tempMin) {
          primaryAxisMaxValue = tempMax;
          primaryAxisMinValue = tempMin;
          if (range.from === 'axis') {
            primaryAxisManualRange = true;
          }
          if (TypeUtils.isExist(width) && TypeUtils.isExist(height)) {
            _makeScale();
          }
        }
      } else {
        if (primaryAxisManualRange === true) {
          primaryAxisMaxValue = primaryScale.perfectDomainEnd;
          primaryAxisMinValue = primaryScale.perfectDomainBegin;
          primaryAxisManualRange = false;
          if (TypeUtils.isExist(width) && TypeUtils.isExist(height)) {
            _makeScale();
          }
        }
      }
      return this;
    };

    var _getBarInfo = function(){
      //Calculate bar size and bar gap.
      var defaultBarSize = 2 * (categoryScale.rangeBand()) / 3;
      var defaultBarGap = defaultBarSize / 2;
      var customizeBarGap = options.barGap;
      var barGap = defaultBarGap, barSize = defaultBarSize;
      
      if(customizeBarGap !== undefined){
        var customizeBarSize = categoryScale.rangeBand() - customizeBarGap;
        if(!(customizeBarGap < 5 || customizeBarSize < 0)){
          barSize = customizeBarSize;
          barGap = customizeBarGap;
        }
      }
      
      //bar gap = single side gap width
      return {
        'barSize': barSize,
        'barGap' : barGap/2
      };
    };
      
    var _makeScale = function(){
      var domain = [];
      for (var i=0; i < categoryLen; i++){
           domain.push(i);
      }
      //when all data is 0 or null, we make primaryScale.domain from 0 to 1
      if(options.isHorizontal === true){
        categoryScale.domain(domain).rangeBands([0, height]);
        if( primaryAxisMinValue === 0 && primaryAxisMaxValue === 0){
          primaryScale.domain([0, 1]).range([0, width]);
        }else{
          primaryScale.domain([primaryAxisMinValue, primaryAxisMaxValue]).range([0, width]);
        }
      }else{
        categoryScale.domain(domain).rangeBands([0, width]);
        if( primaryAxisMinValue === 0 && primaryAxisMaxValue === 0){
          primaryScale.domain([0, 1]).range([height, 0]);
        }else{
          primaryScale.domain([primaryAxisMinValue, primaryAxisMaxValue]).range([height, 0]);
        }
        
      }
      if (!primaryAxisManualRange) {
        Scaler.perfect(primaryScale);
      } else {
        Scaler.getRoughTickNum(primaryScale);
      }
    };
    
    var _parseOriginData = function(data){
      //set dimension data for category axis
      dimensionData = {};
      measureData = {};
      if((isShowTotal === true) || (options.subtotal.visible === true)){
        Objects2.extend(true, dimensionData, data.getAnalysisAxisDataByIdx(0));
        Objects2.extend(true, measureData, data.getMeasureValuesGroupDataByIdx(0));
      }else{
        dimensionData = data.getAnalysisAxisDataByIdx(0);
        measureData = data.getMeasureValuesGroupDataByIdx(0);
      }
      
      var obj = MNDHandler(data);
      
      //Init tooltip data
      tooltipData = TooltipDataHandler.dataTransform(obj);
      
      var mgData = obj["MG1"], start = options.initialValue;  //default start position is 0
      isDataSchemaChanged = false;
      
      if( mgData[0] && mgData[0][0].info && mgData[0][0].info.defaultSelection){
        hasDefaultSelection = true;
      }else{
        hasDefaultSelection = false;
      }
      
      //Check update type: update dataset, data schema or data loading
      if(categoryLen===undefined && measureLength===undefined){
        //Data loading
        isDataLoading = true;
      }else{
        isDatasetChanged = true;
      }
      //Check new dataset structure. 
      if((categoryLen!==undefined && measureLength!==undefined) && (categoryLen !== mgData[0].length || measureLength !== mgData.length)){
        isDataSchemaChanged = true;
      }
      
      var positive_start, negative_start, subStart, totals = [], subTotals = [], totalValue = 0, eachValueItem = {}, items = [], itemValue, isTotal, before, after, sum = 0, subGroupIndex, subGroupValidIndex = 0; //total is for each bar group, sum means total value of all value 
      var infos, totalSum = 0, hasTotal = false;
      positive_start = negative_start = start;
      chartData = [], primaryAxisMinValue = primaryAxisMaxValue = options.initialValue;
      
      categoryLen = mgData[0].length;
      measureLength = mgData.length;
      
      //check sub-group and add sub-total value
      var subIndex, tmpCategoryLen, subGroups;
      if(options.subtotal.visible === true){
        subIndex = 0;
        tmpCategoryLen = categoryLen;
        subGroups = options.subtotal.subGroups;
      }
      
      for ( var i = 0; i < categoryLen; i++) {
        //positive and negative start from the same position.
        positive_start = negative_start = start;
        //reset
        items = [], totalValue = totalSum = 0, isTotal = false;
        
        if(subStart === undefined) {
          subStart = start;
        }

        for ( var j = 0; j < measureLength; j++) {
          //Handle each value
          itemValue = _handleNullValue(mgData[j][i].val);
          infos = mgData[j][i].info;
          if(infos){
            isTotal = (infos.valueinfo === undefined) ? false : infos.valueinfo.isTotal;
            if(isTotal && (j === 0)){
              positive_start = negative_start = 0;
              hasTotal = true;
            }
          }
          
          if(itemValue !== defaultString){
            if(isTotal){
              if(itemValue > 0){
                before = positive_start;
                after = positive_start + itemValue;
                positive_start = after;
              } else {
                before = negative_start;
                after = negative_start + itemValue;
                negative_start = after;
              }
              totalSum = totalSum + itemValue;
            }else{
              subTotals[j] = (subTotals[j] ? subTotals[j] + itemValue : itemValue);
              
              //except Null value
              totalValue = totalValue + itemValue;
              
              //adjust before and after value
              if(itemValue > 0){
                before = positive_start;
                after = positive_start + itemValue;
                positive_start = after;
              } else {
                before = negative_start;
                after = negative_start + itemValue;
                negative_start = after;
              }
              totals[j] = (totals[j] ? totals[j] + itemValue : itemValue);
            }
            //Set primaryAxisMinValue, primaryAxisMaxValue
            if(after > primaryAxisMaxValue){
              primaryAxisMaxValue = after;
            }
            if(after < primaryAxisMinValue){
              primaryAxisMinValue = after;
            }
            
            eachValueItem = {
                "index" : j,
                "val": mgData[j][i].val,
                "info": mgData[j][i].info,
                "before": before,
                "after": after,
                "ctx": mgData[j][i].ctx
            };
            items.push(eachValueItem);
          }
        }
        if(isTotal){
          chartData.push({
            "total": totalSum,
            "start": 0,
            "items": items
          });
        }else{
          chartData.push({
            "total": totalValue,
            "start": start,
            "items": items
          });
        }
        
        //reset sum
        sum = sum + totalValue;
        
        if(options.subtotal.visible === true){
          //Add sub-total value
          subGroupIndex = subGroups[subIndex];
          while((subIndex < subGroups.length) && (subGroupIndex < 0 || subGroupIndex > categoryLen - 1 )){
            subIndex++;
            subGroupIndex = subGroups[subIndex];
          }
          if(i === subGroupIndex){
            //last category bar in this bar group. And add sub-total
            if(options.subtotal.isSubgroupTotal){
              _addTotalItemToChartData(i+subGroupValidIndex+1, start, subTotals, "Sub-Total-"+subGroupValidIndex);
            }else{
              _addTotalItemToChartData(i+subGroupValidIndex+1, 0, totals, "Sub-Total-"+subGroupValidIndex);
            }
            subStart = undefined;
            subTotals = [];
            subIndex++;
            subGroupValidIndex ++;
            tmpCategoryLen++;
          }
        }
        //reset start position.
        start = start + totalValue;
      }
      
      if(hasTotal){
        //Re-check axis max and min value
        if(primaryAxisMinValue > 0){
          primaryAxisMinValue = 0;
        }else if(primaryAxisMaxValue < 0){
          primaryAxisMaxValue = 0;
        }
      }
      
      if(tmpCategoryLen !== undefined){
        categoryLen = tmpCategoryLen;
      }
      
      if(isShowTotal){
        _addTotalItemToChartData(categoryLen, 0, totals, "Total");
        categoryLen++;
      }
      //Add last item flag to send initialized
      if(categoryLen > 0){
        var lastItems = chartData[categoryLen - 1].items;
        if(lastItems.length > 0){
          lastItems[lastItems.length - 1].isLastItem = true;
        }
      }
    };

    var _addTotalItemToChartData = function(index, start, sumArr, dimensionName){
      var positive_start, negative_start, before, after, eachValueItem, items = [], sum = 0, itemValue;
      positive_start = negative_start = start;
      
      for(var i = 0, iLen = sumArr.length; i < iLen; i++){
        itemValue = sumArr[i];
        sum = sum + itemValue;
        if(itemValue > 0){
          before = positive_start;
          after = positive_start + itemValue;
          positive_start = after;
        } else {
          before = negative_start;
          after = negative_start + itemValue;
          negative_start = after;
        }
        eachValueItem = {
            "index" : i,
            "val": itemValue,
            "before": before,
            "after": after,
            "ctx": {
              "path" : {
                "mg" : itemValue,
                "mi" : i
              }
            }
        };
        items.push(eachValueItem);
        measureData.values[0].rows[i].splice(index, 0, {val: sumArr[i]});
      }
      chartData.push({
        "total": sum,
        "start": start,
        "items": items
      });
      
      dimensionData.values[0].rows.splice(index, 0, {val: dimensionName});
      if (dimensionData.values.length > 1) {
        var len;
        for (i = 1, len = dimensionData.values.length; i < len; i++) {
          dimensionData.values[i].rows.splice(index, 0, {
            val : ""
          });
        }
      }
    };
    
    chart.destroy = function(){
        if(categoryScale){
          categoryScale.domain([0,1]).range([0,1]);
        }
        if(primaryScale){
          primaryScale.domain([0,1]).range([0,1]);
        }        
        categoryScale = null;
        dimensionData = null;
        tooltipData = null;
        decorativeShape = null;
        defsEnter = null;
        chartData = null;
        primaryAxisManualRange = null;
        primaryAxisMaxValue = null;
        primaryAxisMinValue = null;
        primaryScale = null;
        sWrapper = null;
        
          
        //destroy ctx
        if(ctx){
          ctx.destroy();
          ctx = null;
        }
    };
    var _handleNullValue = function(value){
      return (value === null || value === undefined) ? defaultString : value;
    };

    function getCSSStyle() {
      style.hoverline = ctx.styleManager.queryDefault(CSSCLASS_HOVERLINE);
    }

    getCSSStyle();
    options = manifest.props(null);
    return chart;
  };
  return stackedwaterfall;
});

define('sap/viz/modules/manifests/xy/StackedWaterfall',['sap/viz/modules/manifests/Module','sap/viz/modules/stackedwaterfall',
'sap/viz/modules/manifests/xy/BaseBar'],
function Setup(Manifest, fn) {
    var module = {
      'id' : 'sap.viz.modules.stackedwaterfall',
      'name' : 'stackedwaterfall',
      base : "sap.viz.modules.xy.bar.base",
      'properties' : {
        'isRoundCorner' : null,
        'primaryValuesColorPalette' : { 'isExported' : false },
        'secondaryValuesColorPalette' : { 'isExported' : false },
        'isHorizontal' : {
          'name' : 'isHorizontal',
          'supportedValueType' : 'Boolean',
          'defaultValue' : false,
          'description' : 'Set stacked waterfall orientaion.',
          'isExported' : false
        },
        'isShowTotal' : {
          'name' : 'isShowTotal',
          'supportedValueType' : 'Boolean',
          'defaultValue' : false,
          'description' : 'Set stacked waterfall show/hide total value.',
          'isExported' : false
        },
        'subtotal' : {
          'name' : 'subtotal',
          'supportedValueType' : 'Object',
          'supportedValues' : {
            'visible' : {
              'name' : 'visible',
              'supportedValueType' : 'Boolean',
              'defaultValue' : false,
              'description' : 'Set visibility of subtotal.'
            }, 
            'isSubgroupTotal' : {
              'name' : 'isSubgroupTotal',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set isRuntimeTotal of subtotal.'
            },
            'subGroups' : {
              'name' : 'subGroups',
              'supportedValueType' : 'StringArray',
              'defaultValue' : [],
              'description' : 'Set bar groups.',
                'isExported' : false
            }
          },
          'isExported' : false,
          'description' : 'Settings for subtotal related properties.'
        },
        'barGap': {
          'name' : 'barGap',
          'supportedValueType' : 'PositiveInt',
          'defaultValue' : undefined,
          'min' : '5',
          'description': "Set the distance between bars. Default value is the same as bar size.",
          'isExported' : true
        },
        'initialValue': {
          'name' : 'initialValue',
          'supportedValueType' : 'PositiveInt',
          'defaultValue' : 0,
          'description': "Set initial value of waterfall.",
          'isExported' : true
        }
      },
      fn : fn,
      'feeds' : {
        configure : {
          'secondaryValues' : null,
          'regionColor': {
            acceptMND : -1,
            min : 1,
            max : 1
          },
          'axisLabels' : {
            max : 1,
            acceptMND : -1
          },
          'primaryValues' : {
            max : 1
          }
        }
      }
    };

    Manifest.register(module);
});
define('sap/viz/manifests/xy/HorizontalWaterfallChart',['sap/viz/manifests/Viz','sap/viz/modules/manifests/RootContainer','sap/viz/modules/manifests/xy/StackedWaterfall',
'sap/viz/manifests/xy/BaseHorizontalChart'],
function Setup(Manifest) {
    var chart = {
      id : 'viz/horizontal_waterfall',
      name : 'IDS_HORIZONTALWATERFALLCHART',
      base : 'riv/basehorizontalchart',
      modules : {
        root : {
          modules : {
            interaction : {
              id : 'sap.viz.modules.controller.interaction',
              configure : {
                clientID : 'main',
                propertyCategory : 'interaction',
                properties : {
                  supportedEventNames: ['mouseup', 'mousemove', 'touchstart']
                }
              }
            },
            legends : null,
            main : {
                modules : {
                  dataLabel : {
                    id : 'sap.viz.modules.datalabel',
                    configure : {
                      properties : {
                        automaticInOutside : false,
                        showZero : false,
                        outsideVisible : false
                      },
                      propertiesOverride : {
                        position : {
                          isExported : false
                        }
                      }
                    }
                  },
                  yAxis : {
                    id : 'sap.viz.modules.axis',
                    configure : {
                      properties : {
                        isIndependentMode : true
                      }
                    }
                  }, 
                  plot : {
                      id : 'sap.viz.modules.stackedwaterfall',
                      configure : {
                          'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                          propertyCategory : 'plotArea',
                          properties : {
                            'isHorizontal' : true
                          },
                          propertiesOverride : {
                            isShowTotal : {
                              isExported : false
                            }
                          }
                      }
                  }
                }
             }
          }
        }
        
      },
      feeds:{
        'regionColor' : null
      },
      dependencies : {
          attributes : [ {
            targetModule : 'root.main.plot',
            target : 'primaryDataRange',
            sourceModule : 'root.main.xAxis',
            source : 'range'
          }, {
            targetModule : 'root.main.xAxis',
            target : 'scale',
            sourceModule : 'root.main.plot',
            source : 'primaryScale'
          },{
            targetModule : 'root.main.yAxis',
            target : 'scale',
            sourceModule : 'root.main.plot',
            source : 'categoryScale'
          },null,{
        targetModule : 'root.main.xAxis',
            target : 'title',
            sourceModule : 'root.main.plot',
            source : 'primaryAxisTitle'
      },{
        targetModule : 'root.main.yAxis',
        target : 'independentData',
        sourceModule : 'root.main.plot',
        source : 'dimensionData'
      }],
          events : [ {
            targetModule : 'root.tooltip',
            listener : 'showTooltip',
            sourceModule : 'root.main.plot',
            type : 'showTooltip'
          }, {
            targetModule : 'root.tooltip',
            listener : 'hideTooltip',
            sourceModule : 'root.main.plot',
            type : 'hideTooltip'
          }, {
              targetModule : 'root.interaction',
              listener : 'registerEvent',
              sourceModule : 'root.main.plot',
              type : 'initialized.interaction'
           }, {
             targetModule : 'root.main.dataLabel',
             listener : 'showLabel',
             sourceModule : 'root.main.plot',
             type : 'initialized.datalabel'
           }, {
             targetModule : 'root.main.dataLabel',
             listener : 'removeLabel',
             sourceModule : 'root.main.plot',
             type : 'startToInit.datalabel'
           }, {
             targetModule : 'root.main.dataLabel',
             listener : 'removeLabel',
             sourceModule : 'root.main.plot',
             type : 'startToInit.datalabel'
           } ]
        }
    };

    Manifest.register(chart);
});
define('sap/viz/manifests/xy/WaterfallChart',['sap/viz/manifests/Viz','sap/viz/modules/manifests/RootContainer','sap/viz/modules/manifests/xy/StackedWaterfall',
'sap/viz/manifests/xy/BaseVerticalChart'],
function Setup(Manifest) {
    var chart = {
      id : 'viz/waterfall',
      name : 'IDS_WATERFALLCHART',
      base : 'riv/baseverticalchart',
      modules : {
        root : {
          modules : {
            interaction : {
              id : 'sap.viz.modules.controller.interaction',
              configure : {
                clientID : 'main',
                propertyCategory : 'interaction',
                properties : {
                  supportedEventNames: ['mouseup', 'mousemove', 'touchstart']
                }
              }
            },
            legends : null,
            main : {
              modules : {
                dataLabel : {
                  id : 'sap.viz.modules.datalabel',
                  configure : {
                    properties : {
                      automaticInOutside : false,
                      showZero : false,
                      outsideVisible : false
                    },
                    propertiesOverride : {
                      position : {
                        isExported : false
                      }
                    }
                  }
                },
                xAxis : {
                  id : 'sap.viz.modules.axis',
                  configure : {
                    properties : {
                      isIndependentMode : true
                    }
                  }
                }, 
                plot : {
                    id : 'sap.viz.modules.stackedwaterfall',
                    configure : {
                        'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                        propertyCategory : 'plotArea',
                        propertiesOverride : {
                          isShowTotal : {
                            isExported : false
                          }
                        }
                    }
                }
              }
          }
          }
        }

      },
      feeds:{
        'regionColor' : null
      },
      dependencies : {
          attributes : [ {
            targetModule : 'root.main.plot',
            target : 'primaryDataRange',
            sourceModule : 'root.main.yAxis',
            source : 'range'
          }, {
            targetModule : 'root.main.yAxis',
            target : 'scale',
            sourceModule : 'root.main.plot',
            source : 'primaryScale'
          },{
            targetModule : 'root.main.xAxis',
            target : 'scale',
            sourceModule : 'root.main.plot',
            source : 'categoryScale'
          },null,{
      targetModule : 'root.main.yAxis',
            target : 'title',
            sourceModule : 'root.main.plot',
            source : 'primaryAxisTitle'
      },{
        targetModule : 'root.main.xAxis',
        target : 'independentData',
        sourceModule : 'root.main.plot',
        source : 'dimensionData'
      }],
           events : [ {
            targetModule : 'root.tooltip',
            listener : 'showTooltip',
            sourceModule : 'root.main.plot',
            type : 'showTooltip'
          }, {
            targetModule : 'root.tooltip',
            listener : 'hideTooltip',
            sourceModule : 'root.main.plot',
            type : 'hideTooltip'
          }, {
            targetModule : 'root.interaction',
            listener : 'registerEvent',
            sourceModule : 'root.main.plot',
            type : 'initialized.interaction'
          }, {
            targetModule : 'root.main.dataLabel',
            listener : 'showLabel',
            sourceModule : 'root.main.plot',
            type : 'initialized.datalabel'
          },{
            targetModule : 'root.main.dataLabel',
            listener : 'removeLabel',
            sourceModule : 'root.main.plot',
            type : 'startToInit.datalabel'
          }, {
            targetModule : 'root.main.dataLabel',
            listener : 'removeLabel',
            sourceModule : 'root.main.plot',
            type : 'startToInit.datalabel'
          }, {
            targetModule : 'root.interaction',
            listener : 'defaultSelection',
            sourceModule : 'root.main.plot',
            type : 'initialized.defaultSelection'
          } ]
        }
    };

    Manifest.register(chart);
});
define('sap/viz/manifests/xy/StackedWaterfallChart',['sap/viz/manifests/Viz','sap/viz/data/feed/Constants','sap/viz/modules/manifests/RootContainer',
'sap/viz/modules/manifests/xy/StackedWaterfall','sap/viz/manifests/xy/BaseVerticalChart',
'sap/viz/modules/manifests/controller/Interaction'],
function Setup(Manifest, constants) {
    var chart = {
      id : 'viz/stacked_waterfall',
      name : 'IDS_STACKEDWATERFALLCHART',
      base : 'riv/baseverticalchart',
      modules : {
        root : {
          modules : {
            interaction : {
              id : 'sap.viz.modules.controller.interaction',
              configure : {
                clientID : 'main',
                propertyCategory : 'interaction',
                properties : {
                  supportedEventNames: ['mouseup', 'mousemove', 'touchstart']
                }
              }
            },
             main : {
              modules : {
                plot : {
                  id : 'sap.viz.modules.stackedwaterfall',
                  configure : {
                      'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                      propertyCategory : 'plotArea'
                  }
                },
                xAxis : {
                  id : 'sap.viz.modules.axis',
                  configure : {
                    properties : {
                      isIndependentMode : true
                    }
                  }
                },
                dataLabel : {
                  id : 'sap.viz.modules.datalabel',
                  configure : {
                    properties : {
                      automaticInOutside : false,
                      isStackMode : true,
                      showZero : false
                    },
                    propertiesOverride : {
                      position : {
                        isExported : false
                      }
                    }
                  }
                }
              }
            }
          }
        }
       
      },
      feeds:{
        primaryValues : {
          'max' : constants.Constraints.INF
        },
        regionColor : {
          'acceptMND' : 1,
          'max' : 2
        },
        axisLabels : {
          max : 1,
          acceptMND : 0,
          maxStackedDims : 1
        }
      },
      dependencies : {
        attributes : [ {
          targetModule : 'root.main.plot',
          target : 'primaryDataRange',
          sourceModule : 'root.main.yAxis',
          source : 'range'
        }, {
          targetModule : 'root.main.yAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'primaryScale'
        }, {
          targetModule : 'root.main.xAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'categoryScale'
        }, {
          targetModule : 'root.legends.legend',
          target : 'colorPalette',
          sourceModule : 'root.main.plot',
          source : 'colorPalette'
        }, {
          targetModule : 'root.main.yAxis',
          target : 'title',
          sourceModule : 'root.main.plot',
          source : 'primaryAxisTitle'
        }, {
          targetModule : 'root.main.xAxis',
          target : 'independentData',
          sourceModule : 'root.main.plot',
          source : 'dimensionData'
        } ],
       events : [ {
          targetModule : 'root.tooltip',
          listener : 'showTooltip',
          sourceModule : 'root.main.plot',
          type : 'showTooltip'
        }, {
          targetModule : 'root.tooltip',
          listener : 'hideTooltip',
          sourceModule : 'root.main.plot',
          type : 'hideTooltip'
        }, {
          targetModule : 'root.interaction',
          listener : 'registerEvent',
          sourceModule : 'root.main.plot',
          type : 'initialized.interaction'
        }, {
          targetModule : 'root.interaction',
          listener : 'highlightedByLegend',
          sourceModule : 'root.legends.legend',
          type : 'highlightedByLegend'
        }, {
          targetModule : 'root.legends.legend',
          listener : 'deselectLegend',
          sourceModule : 'root.interaction',
          type : 'deselectLegend'
        }, {
          targetModule : 'root.main.dataLabel',
          listener : 'showLabel',
          sourceModule : 'root.main.plot',
          type : 'initialized.datalabel'
        }, {
          targetModule : 'root.main.dataLabel',
          listener : 'removeLabel',
          sourceModule : 'root.main.plot',
          type : 'startToInit.datalabel'
        }, {
          targetModule : 'root.interaction',
          listener : 'defaultSelection',
          sourceModule : 'root.main.plot',
          type : 'initialized.defaultSelection'
        } ]
      }
    };

    Manifest.register(chart);
});

define('sap/viz/manifests/xy/HorizontalStackedWaterfallChart',['sap/viz/manifests/Viz','sap/viz/modules/manifests/RootContainer','sap/viz/modules/manifests/Axis',
'sap/viz/modules/manifests/xy/StackedWaterfall','sap/viz/manifests/xy/StackedWaterfallChart',
'sap/viz/modules/manifests/Tooltip','sap/viz/modules/manifests/Background'],
function Setup(Manifest) {
  var chart = {
    id : 'viz/horizontal_stacked_waterfall',
    name : 'IDS_HORIZONTALSTACKEDWATERFALL',
    base : "viz/stacked_waterfall",
    modules : {
      root : {
        modules : {
          tooltip : {
            id : 'sap.viz.modules.tooltip',
            configure : {
              propertyCategory : 'tooltip',
              properties : {
                chartType : 'bar'
              }
            }
          },
          main : {
            modules : {
              plot : {
                id : 'sap.viz.modules.stackedwaterfall',
                configure : {
                  propertyCategory : 'plotArea',
                  properties : {
                    'isHorizontal' : true
                  }
                }
              },
              xAxis : {
                id : 'sap.viz.modules.axis',
                configure : {
                  'description' : 'Settings for the value axis of an XY chart.',
                  propertyCategory : 'xAxis',
                  properties : {
                    type : 'value',
                    position : 'bottom',
                    gridline : {
                      visible : true
                    }
                  },
                  propertiesOverride : {
                    scale : { 
                      fixedRange : {isExported : true},
                      minValue : {isExported : true},
                      maxValue : {isExported : true},
                      isExported : true 
                    }
                  }
                }
              },
    
              yAxis : {
                id : 'sap.viz.modules.axis',
                data : {
                  aa : [ 1 ]
                },
                configure : {
                  'description' : 'Settings for the category axis of an XY chart.',
                  propertyCategory : 'yAxis',
                  properties : {
                    type : 'category',
                    position : 'left',
                    gridline : {
                      visible : false
                    },
                    isIndependentMode : true
                  },
                  propertiesOverride : {
                    gridline : {
                      isExported : false
                    },
                    label : {
                      isExported : false
                    },
                    axisline : {
                      isExported : false
                    },
                    scale : { 
                      fixedRange : {isExported : false},
                      minValue : {isExported : false},
                      maxValue : {isExported : false},
                      isExported : false 
                    }
                  }
                }
              },
              background : {
                id: 'sap.viz.modules.background',
                configure : {
                  propertyCategory : 'background',
                  properties : {
                    direction : 'horizontal'
                  }
                }
              },
              dataLabel : {
                id : 'sap.viz.modules.datalabel',
                configure : {
                  properties : {
                    automaticInOutside : false,
                    isStackMode : true,
                    showZero : false,
                    orientation : 'horizontal'
                  },
                  propertiesOverride : {
                    position : {
                      isExported : false
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    feeds : {
      axisLabels : {
        maxStackedDims : 1
      }
    },
    dependencies : {
      attributes : [ {
        targetModule : 'root.main.plot',
        target : 'primaryDataRange',
        sourceModule : 'root.main.xAxis',
        source : 'range'
      }, {
        targetModule : 'root.main.xAxis',
        target : 'scale',
        sourceModule : 'root.main.plot',
        source : 'primaryScale'
      }, {
        targetModule : 'root.main.yAxis',
        target : 'scale',
        sourceModule : 'root.main.plot',
        source : 'categoryScale'
      }, {
          targetModule : 'root.legends.legend',
          target : 'colorPalette',
          sourceModule : 'root.main.plot',
          source : 'colorPalette'
      }, {
        targetModule : 'root.main.xAxis',
        target : 'title',
        sourceModule : 'root.main.plot',
        source : 'primaryAxisTitle'
      }, {
        targetModule : 'root.main.yAxis',
        target : 'independentData',
        sourceModule : 'root.main.plot',
        source : 'dimensionData'
      } ]
    }
  };
  Manifest.register(chart);
});

define('sap/viz/manifests/xy/HorizontalLineChart',['sap/viz/manifests/Viz','sap/viz/modules/manifests/xy/HorizontalLine','sap/viz/manifests/xy/BaseHorizontalChart'],
function Setup(Manifest) {
  var chart = {
    id : 'viz/horizontal_line',
    name : 'IDS_HORIZONTALLINECHART',
    base : 'riv/basehorizontalchart',
    modules : {
      root : {
        modules : {
          tooltip : {
            configure : {
              properties : {
                chartType : 'horizontalline',
                orientation : 'left'
              }
            }
          },

          'main' : {
            'modules' : {
              dataLabel : {
                id : 'sap.viz.modules.datalabel',
                configure : {
                  propertyCategory : 'dataLabel',
                  properties : {
                    position : 'outside',
                    automaticInOutside : false,
                    positionPreference : true
                  }
                }
              },
              'plot' : {
                'id' : 'sap.viz.modules.horizontalline',
                'configure' : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                  'propertyCategory' : 'plotArea'
                }
              }
            }
          }
        }
      }
 
    },
    feeds:{
      secondaryValues: null
    },
    /**
     * the dependencies will be resolved globally to allow modules inside
     * container depend on modules outside, so the keys should be globally
     * unique
     */
    dependencies : {
      attributes : [ {
        targetModule : 'root.main.yAxis',
        target : 'scale',
        sourceModule : 'root.main.plot',
        source : 'categoryScale'
      }, {
        targetModule : 'root.legends.legend',
        target : 'colorPalette',
        sourceModule : 'root.main.plot',
        source : 'getColorPalette'
      }, {
        targetModule : 'root.main.plot',
        target : 'primaryDataRange',
        sourceModule : 'root.main.xAxis',
        source : 'range'
      }, {
        targetModule : 'root.main.xAxis',
        target : 'scale',
        sourceModule : 'root.main.plot',
        source : 'primaryScale'
      }, {
        targetModule : 'root.main.xAxis',
        target : 'title',
        sourceModule : 'root.main.plot',
        source : 'primaryAxisTitle'
      }, {
        targetModule : 'root.legends.legend',
        target : 'shapes',
        sourceModule : 'root.main.plot',
        source : 'shapePalette'
      } , {
        targetModule : 'root.legends.legend',
        target : 'setSelectionMode',
        sourceModule : 'root.interaction',
        source : 'getSelectionMode'
      }],
      events : [ {
        targetModule : 'root.tooltip',
        listener : 'showTooltip',
        sourceModule : 'root.main.plot',
        type : 'showTooltip'
      }, {
        targetModule : 'root.tooltip',
        listener : 'hideTooltip',
        sourceModule : 'root.main.plot',
        type : 'hideTooltip'
      }, {
            targetModule : 'root.interaction',
            listener : 'registerEvent',
            sourceModule : 'root.main.plot',
            type : 'initialized.interaction'
      }  , {
            targetModule : 'root.interaction',
          listener : 'highlightedByLegend',
          sourceModule : 'root.legends.legend',
          type : 'highlightedByLegend'
        }, {
            targetModule : 'root.legends.legend',
          listener : 'deselectLegend',
          sourceModule : 'root.interaction',
          type : 'deselectLegend'
          }, {
            targetModule : 'root.main.dataLabel',
            listener : 'showLabel',
            sourceModule : 'root.main.plot',
            type : 'initialized.datalabel'
          }, {
            targetModule : 'root.main.dataLabel',
            listener : 'removeLabel',
            sourceModule : 'root.main.plot',
            type : 'startToInit.datalabel'
          }, {
            targetModule : 'root.interaction',
            listener : 'defaultSelection',
            sourceModule : 'root.main.plot',
            type : 'initialized.defaultSelection'
          }]
    }
  };
  Manifest.register(chart);
});
define('sap/viz/manifests/xy/DualHorizontalLineChart',['sap/viz/manifests/Viz','sap/viz/modules/manifests/RootContainer',
'sap/viz/modules/manifests/xy/HorizontalLine','sap/viz/manifests/xy/HorizontalLineChart'],
function Setup(Manifest) {
  var chart = {
    'id' : 'viz/dual_horizontal_line',
    'name' : 'IDS_DUALHORIZONTALLINECHART',
    'base' : 'viz/horizontal_line',
     'modules' : {
       root : {
        modules : {
          'main' : {
            'id' : 'sap.viz.modules.xycontainer',
            'modules' : {
              plot : {
                 configure : {
                  propertiesOverride : {
                    primaryValuesColorPalette:{ isExported: true },
                    secondaryValuesColorPalette: { isExported: true }
                  }
                }
              },
              xAxis : {
                id : 'sap.viz.modules.axis',
                configure:{
                  'description':'Settings for the value axis at left or bottom of an XY chart with 2 value axis.',
                  propertiesOverride:{
                    title:{
                      applyAxislineColor:{
                        isExported: true
                      }
                    }
                  }
                }
              },
              'xAxis2' : {
                'id' : 'sap.viz.modules.axis',
                'configure' : {
                  'description':'Settings for the value axis at right or top of an XY chart with 2 value axis.',
                  propertiesOverride:{
                    title:{
                      applyAxislineColor:{
                        isExported: true
                      }
                    }
                  },
                  'propertyCategory' : 'xAxis2',
                  'properties' : {
                    'type' : 'value',
                    'position' : 'top',
                    'gridline' : { 'visible' : false }
                  }
                }
              }
            }
          }
        }
      }
    },
    
    feeds : {
      secondaryValues : { min : 1, max : Number.POSITIVE_INFINITY },
      axisLabels : { acceptMND : -1, max: 1 },
      regionColor : { acceptMND: 0 }
    },
    /**
     * the dependencies will be resolved globally to allow modules inside
     * container depend on modules outside, so the keys should be globally
     * unique
     */
    dependencies : {
      attributes : 
      [ 
        {
          targetModule : 'root.main.yAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'categoryScale'
        },
        {
          targetModule : 'root.legends.legend',
          target : 'colorPalette',
          sourceModule : 'root.main.plot',
          source : 'getColorPalette'
        }, 
        {
          targetModule : 'root.main.plot',
          target : 'primaryDataRange',
          sourceModule : 'root.main.xAxis',
          source : 'range'
        },
        {
          targetModule : 'root.main.xAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'primaryScale'
        }, 
        {
          targetModule : 'root.main.plot',
          target : 'secondDataRange',
          sourceModule : 'root.main.xAxis2',
          source : 'range'
        }, 
        {
          targetModule : 'root.main.xAxis2',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'secondaryScale'
        }, 
        {
          targetModule : 'root.main.xAxis',
          target : 'title',
          sourceModule : 'root.main.plot',
          source : 'primaryAxisTitle'
        }, 
        {
          targetModule : 'root.main.xAxis2',
          target : 'title',
          sourceModule : 'root.main.plot',
          source : 'secondAxisTitle'
        }, 
        {
          targetModule : 'root.main.xAxis',
          target : 'color',
          sourceModule : 'root.main.plot',
          source : 'primaryAxisColor'
        }, 
        {
          targetModule : 'root.main.xAxis2',
          target : 'color',
          sourceModule : 'root.main.plot',
          source : 'secondAxisColor'
        },
        {
          targetModule : 'root.legends.legend',
          target : 'shapes',
          sourceModule : 'root.main.plot',
          source : 'shapePalette'
        } 
      ]
    }
  };
  Manifest.register(chart);
});
define('sap/viz/manifests/xy/LineChart',['sap/viz/manifests/Viz','sap/viz/modules/manifests/xy/Line','sap/viz/modules/manifests/RootContainer',
'sap/viz/manifests/xy/BaseVerticalChart','sap/viz/modules/manifests/controller/Interaction'],
function Setup ( Manifest ) {
  var chart = {
    id : 'viz/line',
    name : 'IDS_LINECHART',
    base: 'riv/baseverticalchart',
    
    modules : {
      root : {
        modules : {
          tooltip : {
          configure : {
            properties : {
              chartType : 'line',
              orientation : 'left'
            }
          }
        },

      main : {
        'modules' : {
          dataLabel : {
            id : 'sap.viz.modules.datalabel',
            configure : {
              propertyCategory : 'dataLabel',
              properties : {
                position : 'outside',
                automaticInOutside : false,
                positionPreference : true
              }
            }
          },
          plot : {
            id : 'sap.viz.modules.line',
            configure : {
              'description': 'Settings regarding the chart area and plot area as well as general chart options.',
              propertyCategory : 'plotArea'
            }
          }
        }
      }
        }
      }

     
    },
    feeds:{
      secondaryValues: null
    },
    dependencies : {
      attributes : [ {
        targetModule : 'root.main.xAxis',
        target : 'scale',
        sourceModule : 'root.main.plot',
        source : 'categoryScale'
      }, {
        targetModule : 'root.legends.legend',
        target : 'colorPalette',
        sourceModule : 'root.main.plot',
        source : 'getColorPalette'
      }, {
        targetModule : 'root.main.plot',
        target : 'primaryDataRange',
        sourceModule : 'root.main.yAxis',
        source : 'range'
      }, {
        targetModule : 'root.main.yAxis',
        target : 'scale',
        sourceModule : 'root.main.plot',
        source : 'primaryScale'
      }, {
      targetModule : 'root.main.yAxis',
      target : 'title',
      sourceModule : 'root.main.plot',
      source : 'primaryAxisTitle'
    }, {
        targetModule : 'root.legends.legend',
        target : 'shapes',
        sourceModule : 'root.main.plot',
        source : 'shapePalette'
      }, {
        targetModule : 'root.legends.legend',
        target : 'setSelectionMode',
        sourceModule : 'root.interaction',
        source : 'getSelectionMode'
      } ],
      events : [ {
        targetModule : 'root.tooltip',
        listener : 'showTooltip',
        sourceModule : 'root.main.plot',
        type : 'showTooltip'
      }, {
        targetModule : 'root.tooltip',
        listener : 'hideTooltip',
        sourceModule : 'root.main.plot',
        type : 'hideTooltip'
      }, {
            targetModule : 'root.interaction',
            listener : 'registerEvent',
            sourceModule : 'root.main.plot',
            type : 'initialized.interaction'
            }, {
          targetModule : 'root.interaction',
          listener : 'highlightedByLegend',
          sourceModule : 'root.legends.legend',
          type : 'highlightedByLegend'
        }, {
            targetModule : 'root.legends.legend',
          listener : 'deselectLegend',
          sourceModule : 'root.interaction',
          type : 'deselectLegend'
          }, {
            targetModule : 'root.main.dataLabel',
            listener : 'showLabel',
            sourceModule : 'root.main.plot',
            type : 'initialized.datalabel'
          }, {
            targetModule : 'root.main.dataLabel',
            listener : 'removeLabel',
            sourceModule : 'root.main.plot',
            type : 'startToInit.datalabel'
          }, {
            targetModule : 'root.interaction',
            listener : 'defaultSelection',
            sourceModule : 'root.main.plot',
            type : 'initialized.defaultSelection'
          } ]
    }
  };
  Manifest.register(chart);
});
define('sap/viz/manifests/xy/DualLineChart',['sap/viz/manifests/Viz','sap/viz/modules/manifests/RootContainer',
'sap/viz/modules/manifests/xy/Line','sap/viz/manifests/xy/LineChart','sap/viz/modules/manifests/controller/Interaction'],
function Setup(Manifest) {
  var chart = {
    id : 'viz/dual_line',
    name : 'IDS_DIUALLINECHART',
    base: 'viz/line',
    'modules' : {
      root : {
        modules : {
          interaction : {
            id : 'sap.viz.modules.controller.interaction',
            configure : {
              clientID : "main",
              propertyCategory : 'interaction'
            }
          },
           main : {
            modules : {
              plot : {
                configure : {
                  propertiesOverride : {
                    primaryValuesColorPalette : { isExported: true },
                    secondaryValuesColorPalette : { isExported: true }
                  }
                }
              },
              yAxis:{
                id : 'sap.viz.modules.axis',
                configure:{
                  'description':'Settings for the value axis at left or bottom of an XY chart with 2 value axis.',
                  propertiesOverride:{
                    title:{
                      applyAxislineColor:{
                        isExported: true
                      }
                    }
                  }
                }
              },
              yAxis2 : {
                id : 'sap.viz.modules.axis',
                configure : {
                  'description':'Settings for the value axis at right or top of an XY chart with 2 value axis.',
                  propertyCategory : 'yAxis2',
                  properties : {
                    type : 'value',
                    position : 'right',
                    gridline : { visible : false }
                  },
                  propertiesOverride:{
                    title:{
                      applyAxislineColor:{
                        isExported: true
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    
    feeds : {
      secondaryValues : { min : 1, max : Number.POSITIVE_INFINITY },
       axisLabels : { acceptMND : -1, max: 1 },
       regionColor : { acceptMND : 0 }
    },
    /**
     * the dependencies will be resolved globally to allow modules inside
     * container depend on modules outside, so the keys should be globally
     * unique
     */
    dependencies : {
      attributes : 
      [ 
        {
          targetModule : 'root.main.xAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'categoryScale'
        }, 
        {
          targetModule : 'root.legends.legend',
          target : 'colorPalette',
          sourceModule : 'root.main.plot',
          source : 'getColorPalette'
        }, 
        {
          targetModule : 'root.main.plot',
          target : 'primaryDataRange',
          sourceModule : 'root.main.yAxis',
          source : 'range'
        }, 
        {
          targetModule : 'root.main.yAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'primaryScale'
        }, 
        {
          targetModule : 'root.main.plot',
          target : 'secondDataRange',
          sourceModule : 'root.main.yAxis2',
          source : 'range'
        }, 
        {
          targetModule : 'root.main.yAxis2',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'secondaryScale'
        }, 
        {
          targetModule : 'root.main.yAxis',
          target : 'title',
          sourceModule : 'root.main.plot',
          source : 'primaryAxisTitle'
        }, 
        {
          targetModule : 'root.main.yAxis2',
          target : 'title',
          sourceModule : 'root.main.plot',
          source : 'secondAxisTitle'
        },
        {
          targetModule : 'root.main.yAxis',
          target : 'color',
          sourceModule : 'root.main.plot',
          source : 'primaryAxisColor'
        }, 
        {
          targetModule : 'root.main.yAxis2',
          target : 'color',
          sourceModule : 'root.main.plot',
          source : 'secondAxisColor'
        },
        {
          targetModule : 'root.legends.legend',
          target : 'shapes',
          sourceModule : 'root.main.plot',
          source : 'shapePalette'
        } 
      ]
    }
  };
  Manifest.register(chart);
});
define('sap/viz/modules/combination',['sap/viz/modules/dispatch','sap/viz/modules/manifests/Module','sap/viz/util/ColorSeriesGenerator',
'sap/viz/modules/util/MNDHandler','sap/viz/base/utils/TypeUtils','sap/viz/base/utils/ObjectUtils',
'sap/viz/data/MultiAxesDataAdapter','sap/viz/modules/util/tooltipDataHandler',
'sap/viz/util/Scaler','sap/viz/util/NumberUtils','sap/viz/base/utils/Objects',
'sap/viz/lang/langManager','sap/viz/modules/util/BoundUtil','sap/viz/modules/util/dataUtil'],
function Setup(dispatch, ModuleManifest, ColorSeries, MNDHandler, TypeUtils, ObjUtils, MultiAxesDataAdapter, TooltipDataHandler, Scaler, NumberUtils, Objects, langManager, BoundUtil, dataUtil) {
  var combination = function(manifest, ctx) {
    var hasAnimationEnd;
    function module(selection) {
      BoundUtil.drawBound(selection, _width, _height);
      _tooltipDataHandler = TooltipDataHandler();
      selection.each(

        function(inputData) {
          if (inputData !== undefined) {
            prepareData(inputData);
          }
          _d3root = d3.select(this);
          
          redraw();
        }
      );//each
      isDataSchemaChanged = false, isDataLoading = false, isSizeChanged = false, isDatasetChanged = false;
      return module;
    }

    module.afterUIComponentAppear = function(){
      _eDispatch.initialized(); 
    };
    
    
    /**
     * set/get width
     */
    module.width = function(_) {
      if (!arguments.length) {
        return _width;
      }
      isSizeChanged = (!isSizeChanged && (_ === _width)) ? false : true;
      _width =  _ ;
      if(TypeUtils.isExist(_width) && TypeUtils.isExist(_height)&& TypeUtils.isExist(_rawdata)) {
        computeScales();
      }
      return module;
    };
    /**
     * set/get height
     */
    module.height = function(_) {
      if (!arguments.length) {
        return _height;
      }
      isSizeChanged = (!isSizeChanged && (_ === _height)) ? false : true;
      _height =  _ ;
      if(TypeUtils.isExist(_width) && TypeUtils.isExist(_height)&& TypeUtils.isExist(_rawdata)) {
        computeScales();
      }
      return module;
    };
    /**
     * set/get size
     * 
     * @param {Object}
     *            {'width':Num, 'height':Num}
     */
    module.size = function(_) {
      if (!arguments.length) {
        return {
          width : _width,
          height: _height
        };
      }
      _width = _.width;
      _height = _.height;
      if(TypeUtils.isExist(_width) && TypeUtils.isExist(_height)&& TypeUtils.isExist(_rawdata)) {
        computeScales();
      }
      return module;
    };

    /**
     * set/get properties
     */
    module.properties = function(_) {
      if (!arguments.length) {
        return getProperty();
      }
      setProperty(Objects.extend(true, getProperty(), _));
      prepareData(_rawdata, true);
      return module;
    };
    
    module.dataLabel = function(_){};
    /**
     * set/get data
     */
    module.data = function(_) {
      if (!arguments.length) {
        return _rawdata;
      }
      isDatasetChanged = true;
      isDataSchemaChanged = false;
      if (! dataUtil().hasSameSchema(_rawdata, _)){
        isDataSchemaChanged = true;
      }
      prepareData(_);
      return module;
    };

    module.primaryAxisTitle = function(_){
        if(!arguments.length) {
          var titles =  _rawdata.getMeasureValuesGroupDataByIdx(0), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join(' & ');
        }
        return this;
      };
      
      module.secondAxisTitle = function(_){
        if(!arguments.length){
          var titles =  _rawdata.getMeasureValuesGroupDataByIdx(1), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join(' & ');
        }
        return this;
      };
     
      module.dispatch = function(_){
        if(!arguments.length) {
          return _eDispatch;
        }
        _eDispatch = _;
        return module;
      };

      module.primaryScale = function(scale)
      {
        if(!arguments.length) {
          return _valueAxis1.scale;
        }
        _valueAxis1.scale = scale;
        return module;
      };
      
      module.secondaryScale = function(scale)
      {
        if(!arguments.length) {
          return _valueAxis2.scale;
        }
        _valueAxis2.scale = scale;
        return module;
      };
      
      module.categoryScale = function(scale)
      {
        if(!arguments.length) {
          return _xScale;
        }
        _xScale = scale;
        return module;
      };

    module.primaryDataRange = function(range){
      if (!arguments.length){
        return {
          min: _valueAxis1.bottomValue,
          max: _valueAxis1.topValue
        };
      }
      var tempMax, tempMin;
      if (range !== null) {
          if (!isNaN(range.max)) {
            tempMax = range.max;
          } else {
            tempMax = _valueAxis1.scale.perfectDomainEnd;
          }
          if (!isNaN(range.min)) {
            tempMin = range.min;
          } else {
            tempMin = _valueAxis1.scale.perfectDomainBegin;
          }
          if (tempMax > tempMin) {
            _valueAxis1.topValue = tempMax;
            _valueAxis1.bottomValue = tempMin;
            if (range.from === 'axis') {
              _valueAxis1.manualRange = true;
            }
            if(TypeUtils.isExist(_width) && TypeUtils.isExist(_height)){
              calculateScale(_valueAxis1, _valueAxis1.scale);
            }
          }
      } else {
        if (_valueAxis1.manualRange === true) {
          _valueAxis1.topValue = _valueAxis1.scale.perfectDomainEnd;
          _valueAxis1.bottomValue = _valueAxis1.scale.perfectDomainBegin;
          _valueAxis1.manualRange = false;
          if(TypeUtils.isExist(_width) && TypeUtils.isExist(_height)) {
            calculateScale(_valueAxis1, _valueAxis1.scale);
          }
        }
      }
      return module;
    };

    module.secondDataRange = function(range){
      if (!arguments.length){
        return {
          min: _valueAxis2.bottomValue,
          max: _valueAxis2.topValue
        };
      }
      var tempMax, tempMin;
      if (range !== null) {
          if (!isNaN(range.max)) {
            tempMax = range.max;
          } else {
            tempMax = _valueAxis2.scale.perfectDomainEnd;
          }
          if (!isNaN(range.min)) {
            tempMin = range.min;
          } else {
            tempMin = _valueAxis2.scale.perfectDomainBegin;
          }
          if (tempMax > tempMin) {
            _valueAxis2.topValue = tempMax;
            _valueAxis2.bottomValue = tempMin;
          if (range.from === 'axis') {
            _valueAxis2.manualRange = true;
          }
          if(TypeUtils.isExist(_width) && TypeUtils.isExist(_height)){
            calculateScale(_valueAxis2, _valueAxis2.scale);
            }
          }
      } else {
        if (_valueAxis2.manualRange === true) {
          _valueAxis2.topValue = _valueAxis2.scale.perfectDomainEnd;
          _valueAxis2.bottomValue = _valueAxis2.scale.perfectDomainBegin;
          _valueAxis2.manualRange = false;
          if(TypeUtils.isExist(_width) && TypeUtils.isExist(_height)) {
            calculateScale(_valueAxis2, _valueAxis2.scale);
          }
        }
      }
      return module;
    };

    module.primaryAxisColor = function() 
    {
      if (!_props.MNDOnCategory) {
        return _props.primaryValuesColorPalette[0];
      } else {
        return null;
      }
    };
    
    module.secondAxisColor = function() 
    {
      if (!_props.MNDOnCategory) {
        return _props.secondaryValuesColorPalette[0];
      } else {
        return null;
      }
    };

      module.colorPalette = function(Palette){
        if (!arguments.length){
          return _colorPalette;
         }
         return module;
      };

      module.shapePalette = function(Palette){
        if (!arguments.length){
          return _shapePalette;
         }
         return module;
      };

    module.parent = function () {
      return _d3root;
    };
    
    module.clear = function (gray) {
      for (var i in _module)
      {
        if (gray === undefined || gray === false) {
          _module[i].module.clear();
        } else {
          _module[i].module.clear('grayall');
        }
      }
    };

    module.highlight = function (elements) {
      var i, j;
      var elementArray;
      if (elements instanceof Array) {
        elementArray = elements;
      } else {
        elementArray = [];
        elementArray.push(elements);
      }
      
      if (elementArray.length === 0) {
        return;
      }
      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
          _module[i].highlightArray = [];
        }
      }

      for (i=0; i<elementArray.length; i++) {
        var element = elementArray[i];
        for (j in _module) {
          if (_module.hasOwnProperty(j)) {
              var dpa = _module[j].dataPointElements;
              if (isExist(dpa, element)) {
                _module[j].highlightArray.push(element);
                break;
              }
          }
        }
      }

      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
          _module[i].module.highlight(_module[i].highlightArray);
        }
      }
    };

    module.unhighlight = function (elements) {
      var i, j;
      var elementArray;
      if (elements instanceof Array) {
        elementArray = elements;
      } else {
        elementArray = [];
        elementArray.push(elements);
      }    
      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
          _module[i].unhighlightArray = [];
        }
      }

      for (i=0; i<elementArray.length; i++) {
        var element = elementArray[i];
        for (j in _module) {
          if (_module.hasOwnProperty(j)) {
              var dpa = _module[j].dataPointElements;
              if (isExist(dpa, element)) {
                _module[j].unhighlightArray.push(element);
                break;
              }
          }
        }
      }

      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
          _module[i].module.unhighlight(_module[i].unhighlightArray);
        }
      }
    };
    
    module.hoverOnPoint = function( point ) {
      var i;
      if (_props.tooltip.enabled) {
        var point0= point.x, point1 = point.y;
  
        if(point0 < 0 || point0 > _width) {
          return;
        }
        var xIndex = getCategoryIndex(point0);
        if(_preMouseMoveXIndex === xIndex) {
          return;
        }
        _preMouseMoveXIndex = xIndex;

        var tData = _tooltipDataHandler.generateTooltipData(_rawdata, 
                                   _tooltipdata, 
                                   xIndex, 
                                   _colorPalette, 
                                   _shapePalette);
        var matrix = _d3root.node().getTransformToElement(_d3root.node().ownerSVGElement);                                   
        tData.point = {
            x: _xScale.rangeBand()*(xIndex + 0.5) + matrix.e,
            y: _height / 4 + matrix.f
        };
        _eDispatch.showTooltip(TooltipDataHandler.formatTooltipData(tData));
      }
      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
          _module[i].module.hoverOnPoint(point);
        }
      }
      return true;
    };

    module.blurOut = function( ) {
      var i;
      if (_props.tooltip.enabled) {
        _eDispatch.hideTooltip();
        _preMouseMoveXIndex = -1;
      }
      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
          _module[i].module.blurOut();
        }
      }      
      return true;
    };  
    
    module.destroy = function(){
     if(_xScale){
       _xScale.domain([0,1]).range([0,1]);
     }
     if(_valueAxis1.scale){
       _valueAxis1.scale.domain([0,1]).range([0,1]);
     }
     if(_valueAxis2.scale){
       _valueAxis2.scale.domain([0,1]).range([0,1]);
     }
     _valueAxis1.data = null;
     _valueAxis1.manualRange = null;
     _valueAxis1.topValue = null;
     _valueAxis1.bottomValue = null;
     _valueAxis2.data = null;
     _valueAxis2.manualRange = null;
     _valueAxis2.topValue = null;
     _valueAxis2.bottomValue = null;
     
     _xScale = null;
     _valueAxis1 = null;
     _valueAxis2 = null;
     
     _effectManager = null;
     _d3root = null;
     
     //destroy ctx
     if(ctx){
       ctx.destroy();
       ctx = null;
     }
    };

      var _xScale = d3.scale.ordinal(),
          _valueAxis1 = {
            scale: d3.scale.linear()
          },
          _valueAxis2 = {
            scale: d3.scale.linear()
          };

    
    //private field
    var CLASSNAME_MODULE = 'v-module';

    var _tooltipDataHandler;
    var _eDispatch = new dispatch('showTooltip', 'hideTooltip', 'initialized', 'startToInit');
    //property
    var _width, _height;
    var _props = {
      priorityMap : {
        'bar' : 5,
        'line' : 0
      },
      defaultShape : 'line',
      MNDOnCategory : false,
      MNDInner : false
    };
    var _effectManager = ctx.effectManager;
    
    var isDataSchemaChanged = false, isDataLoading = true, isSizeChanged = false, isDatasetChanged = false;

    //data
    var _rawdata, _tooltipdata;
    var _d3root;
    var _colorPalette, _shapePalette;
    
    //module
    var _module;

    var _preMouseMoveXIndex = -1;

    var dummyDispatch = function (_) {
      this.mtype = _;
    };
    dummyDispatch.prototype.initialized = function() {
      _dummyDispatchHelper.initialized(this.mtype);
    };
    dummyDispatch.prototype.startToInit = function() {
      _eDispatch.startToInit();
    };
    var _dummyDispatchHelper = {
      initialized : function(mtype) {
        var i;
        if (_module[mtype]) {
          _module[mtype].isCompleteAnimation = true;
        }
        for (i in _module) {
          if (!_module[i].isCompleteAnimation) {
            return true;
          }
        }
        hasAnimationEnd = true;
        return true;
      }
    };

    function init() {
      //TODO: should destroy useless module here(stop animation of useless module)
      _module = {};
    }
    function prepareData ( rawdata , isMandatory ) {
      var i, j, mtype, tm;
      if ((rawdata === null) || (rawdata === undefined) || (!isMandatory && (_rawdata === rawdata))) {
        return;
      }

      init();
      _rawdata = rawdata;

       var obj = MNDHandler(_rawdata );
      _props.MNDInner = obj.MNDInner;
      _valueAxis1.data = obj['MG1'];
      _valueAxis2.data = obj['MG2'];
      _tooltipdata = TooltipDataHandler.dataTransform(obj);

      if (obj.color) {
        var tempData = obj['MG1'];
        var data0 = [];
        var data1 = [];
        for (i=0; i<tempData.length; i++) {
          var temp0 = [];
          var temp1 = [];
          var temp = tempData[i];
          for (j=0; j<temp.length; j++) {
            if (obj.color[j] === 0) {
              temp0.push(temp[j]);
            } else if (obj.color[j] === 1) {
              temp1.push(temp[j]);
            }
          }
          data0.push(temp0);
          data1.push(temp1);
        }
        _valueAxis1.data = data0;
        _valueAxis2.data = data1;
      }
      if(TypeUtils.isExist(_width) && TypeUtils.isExist(_height)&& TypeUtils.isExist(_rawdata)) {
        computeScales();
      }
      if (obj.hasMND && !obj.MNDOnColor) {
        mtype = _props.dataShape.primaryAxis[0];
        if (mtype === undefined || mtype === null) {
          mtype = _props.defaultShape;
        }
        if (_module[mtype] === undefined) {
          _module[mtype] = {};
        }
        _module[mtype].data = _rawdata;
        _props.MNDOnCategory = true;
      } else {
        _props.MNDOnCategory = false;
        var daa1 = _rawdata.getAnalysisAxisDataByIdx(0);
        var daa2 = _rawdata.getAnalysisAxisDataByIdx(1);
        var dva1 = _rawdata.getMeasureValuesGroupDataByIdx(0);
        var dva2 = _rawdata.getMeasureValuesGroupDataByIdx(1);
        for (i=0; i<dva1.values.length; i++) {
          mtype = _props.dataShape.primaryAxis[i];
          if (mtype === undefined || mtype === null) {
            mtype = _props.defaultShape;
          }
          if (_module[mtype] === undefined) {
            _module[mtype] = {m1Num:0, m2Num:0};
          }
          tm = _module[mtype];
          tm.m1Num ++;
          if (tm.data === undefined) {
            tm.data = new MultiAxesDataAdapter();
            tm.data.addAnalysisAxis(daa1);
            tm.data.addAnalysisAxis(daa2);
            tm.data.addMeasureValuesGroup({
              index: dva1.index,
              values: []
            });
            if (dva2) {
              tm.data.addMeasureValuesGroup({
                index: dva2.index,
                values: []
              });
            }
          }
          var tva1 = tm.data.getMeasureValuesGroupDataByIdx(0);
          tva1.values.push(dva1.values[i]);
        }
        
        if (dva2) {
          for (i=0; i<dva2.values.length; i++) {
            mtype = _props.dataShape.secondAxis[i];
            if (mtype === undefined || mtype === null) {
              mtype = _props.defaultShape;
            }
            if (_module[mtype] === undefined) {
              _module[mtype] = {m1Num:0, m2Num:0};
            }
            tm = _module[mtype];
            tm.m2Num ++;
            if (tm.data === undefined) {
              tm.data = new MultiAxesDataAdapter();
              tm.data.addAnalysisAxis(daa1);
              tm.data.addAnalysisAxis(daa2);
              tm.data.addMeasureValuesGroup({
                index: dva1.index,
                values: []
              });
              if (dva2) {
                tm.data.addMeasureValuesGroup({
                  index: dva2.index,
                  values: []
                });
              }
            }
            var tva2 = tm.data.getMeasureValuesGroupDataByIdx(1);
            tva2.values.push(dva2.values[i]);
          }
        }
      }
      prepareColor();
    }
    
    function prepareColor() {
      var i, j, color, mtype, tm;
      if (_rawdata === undefined) { return; }
      
      var dva1 = _rawdata.getMeasureValuesGroupDataByIdx(0);
      var dva2 = _rawdata.getMeasureValuesGroupDataByIdx(1);
      var valueAxis1ColorPalette;
      var valueAxis2ColorPalette;

      if (dva2 && !_props.MNDOnCategory) {
        valueAxis1ColorPalette = _props.primaryValuesColorPalette;  
      }else{
        valueAxis1ColorPalette = _props.colorPalette;
      }
      
      valueAxis2ColorPalette = _props.secondaryValuesColorPalette;
      
      _colorPalette = [];
      _shapePalette = [];
      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
            _module[i].colorPaletteY1 = [];
            _module[i].currentM1Index = -1;
            if (dva2) {
              _module[i].colorPaletteY2 = [];
              _module[i].currentM2Index = -1;
            }
        }
      }
      
      if (_props.MNDOnCategory) {
        mtype = _props.dataShape.primaryAxis[0];
        var rowslength = dva1.values[0].rows.length;
        for (j=0; j<rowslength; j++) {
          _module[mtype].colorPaletteY1.push(valueAxis1ColorPalette[(j) % valueAxis1ColorPalette.length]);
          _shapePalette.push(getShape(mtype));
          _colorPalette.push(valueAxis1ColorPalette[(j) % valueAxis1ColorPalette.length]);
        }
      } else {
        var measure1Num = dva1.values.length;
        var measure2Num = 0;
        if (dva2) {
          measure2Num = dva2.values.length;
        }
        var measureNum = measure1Num + measure2Num;
        var colorAxisDataNum = dva1.values[0].rows.length;
        for (i=0; i<measure1Num; i++) {
          mtype = _props.dataShape.primaryAxis[i];
          if (mtype === undefined || mtype === null) {
            mtype = _props.defaultShape;
          }
          tm = _module[mtype];
          tm.currentM1Index ++;
          for (j=0; j<colorAxisDataNum; j++) {
            if (_props.MNDInner) {
              color = valueAxis1ColorPalette[(i+j*measure1Num ) % valueAxis1ColorPalette.length];
              tm.colorPaletteY1[tm.currentM1Index+j*tm.m1Num] = color;
              _shapePalette[i+j*measureNum] = getShape(mtype);
              _colorPalette[i+j*measureNum] = color;
            } else {
              color = valueAxis1ColorPalette[(i*colorAxisDataNum+j) % valueAxis1ColorPalette.length];
              _module[mtype].colorPaletteY1.push(color);
              _shapePalette.push(getShape(mtype));
              _colorPalette.push(color);
            }
          }
        }

        if (dva2) {
          for (i=0; i<measure2Num; i++) {
            mtype = _props.dataShape.secondAxis[i];
            if (mtype === undefined || mtype === null) {
              mtype = _props.defaultShape;
            }
            tm = _module[mtype];
            tm.currentM2Index ++;
            for (j=0; j<colorAxisDataNum; j++) {
              if (_props.MNDInner) {
                color = valueAxis2ColorPalette[(i+j*measure2Num ) % valueAxis2ColorPalette.length];
                tm.colorPaletteY2[tm.currentM2Index+j*tm.m2Num] = color;
                _shapePalette[measure1Num+i+j*measureNum] = getShape(mtype);
                _colorPalette[measure1Num+i+j*measureNum] = color;
              } else {
                color = valueAxis2ColorPalette[(i*colorAxisDataNum+j) % valueAxis2ColorPalette.length];
                _module[mtype].colorPaletteY2.push(color);
                _shapePalette.push(getShape(mtype));
                _colorPalette.push(color);
              }
            }
          }
        }
      } // _props.MNDOnCategory
    }
    function moduleSortHelp(a, b) {
      return (_props.priorityMap[b] - _props.priorityMap[a]);
    }
    function prepareModule() {
      var tempA = [],i;
      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
          tempA.push(i);
        }
      }
      tempA.sort(moduleSortHelp);

      _d3root.selectAll('.' + CLASSNAME_MODULE).remove(); //TODO: should not always remove all
      var d3modules = _d3root.selectAll('.' + CLASSNAME_MODULE).data(tempA);
      d3modules.enter().append('svg:g').attr('class', CLASSNAME_MODULE);
      d3modules.exit().remove();
      
      d3modules.each(function(d) {
        _module[d].d3root = d3.select(this);
      });
      
      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
            _module[i].module = getModule(i); //TODO: should not always new module instance
            var hasAnimation = false;
            if(isDataLoading){
              hasAnimation = _props.animation.dataLoading;
            }else if(isDatasetChanged){
              hasAnimation = _props.animation.dataUpdating;
            }else if(isSizeChanged){
              hasAnimation = _props.animation.resizing;
            }
            var props = {
              colorPalette: _module[i].colorPaletteY1,
              primaryValuesColorPalette : _module[i].colorPaletteY1,
              tooltip : {enabled : false},
              animation : {
                dataLoading: hasAnimation
              },
              drawingEffect: _props.drawingEffect
            };
            if (_module[i].colorPaletteY2) {
              props.secondaryValuesColorPalette = _module[i].colorPaletteY2;
            }
            switch (i) {
            case 'line' :
              props.hoverline = { visible : false };
              ObjUtils.extend(props, _props.line);
              break;
            case 'bar' :
              ObjUtils.extend(props, _props.bar);
              break;
            default :
              break;
            }
            _module[i].props = props;
            _module[i].module.dispatch(new dummyDispatch(i));
        }
      }
    }

    function redraw() {
      hasAnimationEnd = false;
      var i;
      prepareModule();

      if (_module.hasOwnProperty('bar')) {
        dataUtil().addMetaInfo2Data(_module, 'bar', {chart: 'combination', element: 'bar'});
      }
      
      if (_module.hasOwnProperty('line')) {
        dataUtil().addMetaInfo2Data(_module, 'line', {chart: 'combination', element: 'line'});
      }
      
      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
            var m = _module[i];
            m.module.width(_width).height(_height).data(m.data)
                .properties(m.props).primaryScale(_valueAxis1.scale)
                .categoryScale(_xScale);
            var dva2 = _rawdata.getMeasureValuesGroupDataByIdx(1);
            if (dva2) {
              switch(i) {
              case 'bar' :
                m.module.secondScale(_valueAxis2.scale); break;
              case 'line' :
                m.module.secondaryScale(_valueAxis2.scale); break;
              default:
                break;
              }
            }
            m.d3root.call(m.module);
            m.dataPointElements = [];
            m.d3root.selectAll('.v-datapoint').each(function(){m.dataPointElements.push(this);});
        }
      }
 
      if(hasAnimationEnd)
      {
          _eDispatch.initialized();
      }
      else
      {
        var timeInterval = 20;
        var totalTime = 0;
        var maxTime = 5000;

        var func = setInterval(function(){
          if(hasAnimationEnd || totalTime > maxTime)
          {
            clearInterval(func);
            _eDispatch.initialized();
          }
          else
          {
            totalTime += timeInterval;
          }
        },
        timeInterval);
      }
    }

    function getCategoryIndex(val)
    {
      var index = val / _xScale.rangeBand();
      index = Math.floor(index);
      var categoryNum = 0;
      if (_valueAxis1.data.length !== 0) {
        categoryNum = _valueAxis1.data[0].length;
      } else {
        categoryNum = _valueAxis2.data[0].length;
      }
      if(index > categoryNum - 1) {index = categoryNum - 1;}
      if(index < 0) { index = 0;}
      return index;
    }

      function computeScales() {
          var domain = [];
          var categoryNum = 0;
          if (_props.MNDOnCategory) {
            if (_valueAxis1.data && _valueAxis1.data.length > 0) {
              categoryNum += _valueAxis1.data[0].length;
            }
            if (_valueAxis2.data && _valueAxis2.data.length > 0) {
              categoryNum += _valueAxis2.data[0].length;
            }        
          } else {
            if (_valueAxis1.data && _valueAxis1.data.length > 0) {
              categoryNum = _valueAxis1.data[0].length;
            } else {
              categoryNum = _valueAxis2.data[0].length;  
            }
          }
          for (var i=0; i < categoryNum; i++) {
             domain.push(i);
          }      
          _xScale.domain(domain).rangeBands([0, _width]);

          calculateScale(_valueAxis1, _valueAxis1.scale);
          calculateScale(_valueAxis2, _valueAxis2.scale);

        if (_valueAxis1.data && _valueAxis1.data.length > 0 &&
            _valueAxis2.data && _valueAxis2.data.length > 0 ) {
          if(_valueAxis1.scale.domain().length === 0 && _valueAxis2.scale.domain().length === 0){
            _valueAxis1.scale.domain([0, 1]).range ([_height, 0]); 
            _valueAxis2.scale.domain([0, 1]).range ([_height, 0]); 
          } else if(_valueAxis1.scale.domain().length === 0 && _valueAxis2.scale.domain().length !== 0){
            _valueAxis1.scale.domain(_valueAxis2.scale.domain()).range(_valueAxis2.scale.range());
          } else if(_valueAxis1.scale.domain().length !== 0 && _valueAxis2.scale.domain().length === 0){
            _valueAxis2.scale.domain(_valueAxis1.scale.domain()).range(_valueAxis1.scale.range());
          }

          if (!_valueAxis1.manualRange && !_valueAxis2.manualRange) {
              Scaler.perfectDual(_valueAxis1.scale, _valueAxis2.scale);
          } else if (!_valueAxis1.manualRange) {
              Scaler.perfect(_valueAxis1.scale);
              Scaler.getRoughTickNum(_valueAxis2.scale);
          } else if (!_valueAxis2.manualRange) {
              Scaler.perfect(_valueAxis2.scale);
              Scaler.getRoughTickNum(_valueAxis1.scale);
          } else {
            Scaler.getRoughTickNum(_valueAxis1.scale);
            Scaler.getRoughTickNum(_valueAxis2.scale);
          }
        } else if (_valueAxis1.data && _valueAxis1.data.length > 0) {
          if(_valueAxis1.scale.domain().length === 0){
            _valueAxis1.scale.domain([0, 1]).range ([_height, 0]);
          }
          if (!_valueAxis1.manualRange) {
            Scaler.perfect(_valueAxis1.scale);
          } else {
            Scaler.getRoughTickNum(_valueAxis1.scale);
          }
        } else if (_valueAxis2.data && _valueAxis2.data.length > 0) {
          if(_valueAxis2.scale.domain().length === 0){
            _valueAxis2.scale.domain([0, 1]).range ([_height, 0]);
          }
          if (!_valueAxis2.manualRange) {
            Scaler.perfect(_valueAxis2.scale);
          } else {
            Scaler.getRoughTickNum(_valueAxis2.scale);
          }
        }
      }

    function calculateScale(axisValue, scale) {
        if(axisValue.data && axisValue.data.length > 0) {
            if(axisValue.topValue === undefined) {
              var minMax = calculateMinMax(axisValue);
              if(!minMax||(minMax.min === 0 && minMax.max === 0)) {
                scale.domain([]).range ([]);             
              }else{
                scale.domain([minMax.min, minMax.max]).range ([_height, 0]);                
              }
            } else {
              scale.domain([axisValue.bottomValue, axisValue.topValue]).range ([_height, 0]);
            }
        } else {
          scale.domain([0,0]).range(0,0);
        }
      }

    function getProperty() {
      var temp = {};
      temp.tooltip = {enabled:  _props.tooltip.enabled};
      temp.primaryValuesColorPalette = _props.primaryValuesColorPalette;
      temp.secondaryValuesColorPalette = _props.secondaryValuesColorPalette;
      temp.colorPalette = _props.colorPalette;
      temp.drawingEffect = _props.drawingEffect;
      temp.animation = {};
      ObjUtils.extend(true, temp.animation, _props.animation);
      temp.dataShape = {};
      ObjUtils.extend(true, temp.dataShape, _props.dataShape);
      temp.bar = {};
      ObjUtils.extend(true, temp.bar, _props.bar);
      temp.line = {};
      ObjUtils.extend(true, temp.line, _props.line);
  
      return temp;
    }

    function setProperty (props) {
      _props.tooltip = {enabled: props.tooltip.enabled};
      _props.primaryValuesColorPalette = props.primaryValuesColorPalette;
      _props.secondaryValuesColorPalette = props.secondaryValuesColorPalette;
      _props.drawingEffect = props.drawingEffect;
      _props.colorPalette = props.colorPalette;
      _props.animation = {};
      ObjUtils.extend(true, _props.animation, props.animation);
      _props.dataShape = {};
      ObjUtils.extend(true, _props.dataShape, props.dataShape);
      _props.bar = {};
      ObjUtils.extend(true, _props.bar, props.bar);
      _props.line = {};
      ObjUtils.extend(true, _props.line, props.line);

      return _props;
    }
    function getModule(mtype) {
      var result;
      switch (mtype) {
      case 'bar':
        result = ModuleManifest.get("sap.viz.modules.verticalbar"); break;
      case 'line':
        result = ModuleManifest.get("sap.viz.modules.line"); break;
      default:
        break;
      }
      return result.execute(ctx);
    }
    
    function getShape(mtype) {
      var result;
      switch (mtype) {
      case 'line':
        result = _props.line.marker.shape;
        break;
      case 'bar':
        result = 'squareWithRadius'; break;
      default:
        break;
      }
      return result;
    }

    function isExist(ao, element) {
      for (var n=0; n<ao.length; n++) {
        if (ao[n] === element) {
          return true;
        }
      }
      return false;
    }

    function calculateMinMax(axisValue)
    {
      if(!axisValue.data || axisValue.data.length === 0) {
        return null;
      }
      var minMax = {
          min: null,
          max: null
      };
      minMax.max = d3.max(axisValue.data, function(d){
        return d3.max(d, function(_){ return _.val;});
      });
      minMax.min = d3.min(axisValue.data, function(d){
        return d3.min(d, function(_){ return _.val;});
      });
      if(NumberUtils.isNoValue(minMax.max )) { 
        return null;
       }
      if(minMax.min >= 0) {
        minMax.min = 0;
        minMax.max += minMax.max * 5 / _height ;
      } else if(minMax.max <= 0) {
        minMax.max = 0;
        minMax.min +=  minMax.min * 5/ _height;
      } else {
        var temp = (minMax.max - minMax.min) * 5 / _height;
        minMax.min -= temp;
        minMax.max += temp;
      }
      
      return minMax;
    }
    setProperty(manifest.props(null));
    return module;
  };
  return combination;
});
define('sap/viz/modules/manifests/xy/Combination',['sap/viz/modules/manifests/Module','sap/viz/modules/Constants','sap/viz/modules/combination','sap/viz/modules/manifests/xy/Base'],
function Setup(Manifest,Constants,fn) {

  var module = {
    base : "sap.viz.modules.xy.base",
    'id' : 'sap.viz.modules.combination',
    'name' : 'combination',
    'properties' : {
      'tooltip' : {
        'name' : 'tooltip',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'enabled' : {
            'name' : 'enabled',
            'supportedValueType' : 'Boolean',
            'defaultValue' : true,
            'description' : 'Set enabled/disabled tooltip.'
          }
        },
        'isExported' : false,
        'description' : 'Settings for tooltip related properties.'
      },
      'animation' : {
          'name' : 'animation',
          'supportedValueType' : 'Object',
          'supportedValues' : {
            'dataLoading' : {
              'name' : 'dataLoading',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enable/disable data loading animation of plot area.'
            },
            'dataUpdating' : {
              'name' : 'dataUpdating',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enable/disable data updating animation of plot area.'
            },
            'resizing' : {
              'name' : 'resizing',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enable/disable resizing animation of plot area.'
            }
          },
          'description' : 'Settings for animation of plot area.',
          'example': "<a href='"+Constants.DocExample.SnippetUrl+"8535' target='_blank'>"+Constants.DocExample.TryThisValue+"</a>"
      },
      'dataShape' : {
          'name' : 'dataShape',
          'supportedValueType' : 'Object',
          'supportedValues' : {
            'primaryAxis' : {
              'name' : 'primaryAxis',
              'supportedValueType' : 'StringArray',
              'supportedValues' : [ 'bar', 'line' ],
              'defaultValue' : [ 'bar', 'line', 'line'],
              'description' : 'Set shape of measure index1 data.'
            },
            'secondAxis' : {
              'name' : 'secondAxis',
              'supportedValueType' : 'StringArray',
              'supportedValues' : [ 'line', 'line' ],
              'defaultValue' : [ 'line', 'line', 'line'],
              'description' : 'Set shape of measure index2 data.',
                'isExported': true
            }
          },
          'description' : 'Set shape of measure data.'
      },
      'bar' : {
          'name' : 'bar',
          'supportedValueType' : 'Object',
          'supportedValues' : {
            'isRoundCorner' : {
            'name' : 'isRoundCorner',
            'supportedValueType' : 'Boolean',
            'defaultValue' : false,
            'description' : 'Set enable/disable round corner of bar.'
          }
          },
          'description' : 'Settings for bar properties.'     
      }, //bar
      'line' : {
          'name' : 'line',
          'supportedValueType' : 'Object',
          'supportedValues' : {
            'width' : {
            'name' : 'width',
            'supportedValueType' : 'PositiveInt',
            'defaultValue' : 2,
            'description' : 'Set width of line, range[1,7]. When beyond the range, the line width is default size 2.'
            },
            'marker' : {
                'name' : 'marker',
                'description' : 'Set marker/data point graphics settings.',
                'supportedValueType' : 'Object',
                'supportedValues' : {
                    'visible' : {
                      'name' : 'visible',
                      'supportedValueType' : 'Boolean',
                      'defaultValue' : false,
                      'description' : 'Set to show marker or not.'
                    },
                    'shape' : {
                      'name' : 'shape',
                      'supportedValueType' : 'StringArray',
                      'supportedValues' : ['circle', 'diamond', 'triangleUp', 'triangleDown', 'triangleLeft', 'triangleRight', 'cross', 'intersection'],
                      'defaultValue' : 'circle',
                      'description' : 'Set marker shapes for chart.'
                    },
                    'size' : {
                      'name' : 'size',
                      'supportedValueType' : 'PositiveInt',
                      'defaultValue' : "6",
                      'min' : '4',
                      'max' : '32',
                      'description' : 'Set marker size of data point, range[4,32]. When beyond the range, the marker size is default size 6.'
                    }
                }
            }
          },
          'description' : 'Settings for line properties.'
      } //line
    }, 
    css : {
        '.v-hovershadow' : {
            'description' : 'Define style for hover shadow color.',
              'value' : {
                'fill' : '#cccccc'
              }
        }
    },
    fn : fn
  
  };

  Manifest.register(module);
});
define('sap/viz/manifests/xy/CombinationChart',['sap/viz/manifests/Viz','sap/viz/modules/manifests/RootContainer','sap/viz/modules/manifests/Title',
'sap/viz/modules/manifests/Legend','sap/viz/modules/manifests/XYContainer',
'sap/viz/modules/manifests/Tooltip','sap/viz/modules/manifests/Axis','sap/viz/modules/manifests/xy/Combination',
'sap/viz/modules/manifests/xy/Line','sap/viz/modules/manifests/xy/VerticalBar',
'sap/viz/modules/manifests/controller/Interaction','sap/viz/manifests/xy/BaseVerticalChart'],
function Setup (Manifest) {
  var chart={
    base : 'riv/baseverticalchart',
    id:'viz/combination',
    name:'IDS_COMBINATIONCHART',
    modules:{
      root : {
        modules : {
          tooltip : {
            configure : {
              properties : { chartType : 'line', orientation : 'left' }
            }
          },
          main:{    
            modules:{
              plot:{
                id:'sap.viz.modules.combination',
                configure:{
                      'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory:'plotArea',
                  propertiesOverride : {
                    dataShape:{
                      secondAxis : { isExported: false }
                    }
                  }
                }
              },
              dataLabel : {
                id : 'sap.viz.modules.datalabel',
                configure : {
                  propertyCategory : 'dataLabel',
                  properties : { position : 'inside' }
                }
              }
            }
          }
        }
      }
    },
    
    feeds : { secondaryValues: null },
    
    dependencies:{
      attributes:[
        {
          targetModule : 'root.main.plot',
          target : 'primaryDataRange',
          sourceModule : 'root.main.yAxis',
          source : 'range'
        },{
          targetModule : 'root.main.yAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'primaryScale'
        },{
          targetModule : 'root.main.xAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'categoryScale'
        },{
          targetModule : 'root.main.yAxis',
          target : 'title',
          sourceModule : 'root.main.plot',
          source : 'primaryAxisTitle'
        },{
          targetModule : 'root.legends.legend',
          target : 'colorPalette',
          sourceModule : 'root.main.plot',
          source : 'colorPalette'
        },{
          targetModule:'root.legends.legend',
          target:'shapes',
          sourceModule:'root.main.plot',
          source:'shapePalette'
        },{
            targetModule : 'root.legends.legend',
            target : 'setSelectionMode',
            sourceModule : 'root.interaction',
            source : 'getSelectionMode'
        }
      ],
      events : [ 
        {
          targetModule : 'root.tooltip',
          listener : 'showTooltip',
          sourceModule : 'root.main.plot',
          type : 'showTooltip'
        }, {
          targetModule : 'root.tooltip',
          listener : 'hideTooltip',
          sourceModule : 'root.main.plot',
          type : 'hideTooltip'
        }, {
          targetModule : 'root.interaction',
          listener : 'registerEvent',
          sourceModule : 'root.main.plot',
          type : 'initialized.interaction'
        }, {
            targetModule : 'root.interaction',
            listener : 'highlightedByLegend',
            sourceModule : 'root.legends.legend',
            type : 'highlightedByLegend'
        }, {
                targetModule : 'root.legends.legend',
              listener : 'deselectLegend',
              sourceModule : 'root.interaction',
              type : 'deselectLegend'
        },{
          targetModule : 'root.main.dataLabel',
          listener : 'showLabel',
          sourceModule : 'root.main.plot',
          type : 'initialized.datalabel'
        }, {
          targetModule : 'root.main.dataLabel',
          listener : 'removeLabel',
          sourceModule : 'root.main.plot',
          type : 'startToInit.datalabel'
        }, {
          targetModule : 'root.interaction',
          listener : 'defaultSelection',
          sourceModule : 'root.main.plot',
          type : 'initialized.defaultSelection'
        }
      ]      
    }
  };

  Manifest.register(chart);
});
define('sap/viz/manifests/xy/DualCombinationChart',['sap/viz/manifests/Viz','sap/viz/modules/manifests/RootContainer',
'sap/viz/manifests/xy/CombinationChart','sap/viz/modules/manifests/xy/Combination'],
 function Setup (Manifest) {
  var chart={
    id:'viz/dual_combination',
    name:'IDS_DUALCOMBINATIONCHART',
    base : 'viz/combination',
    modules:{
      root : {
        modules : {
          main : {
            modules :{
              plot : {
                configure : {
                  propertiesOverride : {
                    primaryValuesColorPalette:{ isExported: true },
                    secondaryValuesColorPalette: { isExported: true },
                    dataShape:{
                      secondAxis : { isExported: true }
                    }
                  }
                }
              },
              yAxis : {
                id : 'sap.viz.modules.axis',
                configure:{
                  'description':'Settings for the value axis at left or bottom of an XY chart with 2 value axis.',
                  propertiesOverride:{
                    title:{
                      applyAxislineColor:{
                        isExported: true
                      }
                    }
                  }
                }
              },
              yAxis2 : {
                id : 'sap.viz.modules.axis',
                configure : {
                  'description':'Settings for the value axis at right or top of an XY chart with 2 value axis.',
                  propertyCategory : 'yAxis2',
                  properties : {
                    type : 'value',
                    position : 'right',
                    gridline : { visible : false }
                  },
                  propertiesOverride:{
                    title:{
                      applyAxislineColor:{
                        isExported: true
                      }
                    }
                  }
                }
              }    
            }
          }
        }
      }
    },
    
    feeds : {
      secondaryValues: { min: 1, max: Number.POSITIVE_INFINITY }
    },
    
    dependencies:{
      attributes:[
        {
          targetModule : 'root.main.plot',
          target : 'primaryDataRange',
          sourceModule : 'root.main.yAxis',
          source : 'range'
        },
        {
          targetModule : 'root.main.yAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'primaryScale'
        },
        {
          targetModule : 'root.main.plot',
          target : 'secondDataRange',
          sourceModule : 'root.main.yAxis2',
          source : 'range'
        },
        {
          targetModule : 'root.main.yAxis2',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'secondaryScale'
        },
        {
          targetModule : 'root.main.xAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'categoryScale'
        },
        {
          targetModule : 'root.main.yAxis',
          target : 'title',
          sourceModule : 'root.main.plot',
          source : 'primaryAxisTitle'
        }, 
        {
          targetModule : 'root.main.yAxis2',
          target : 'title',
          sourceModule : 'root.main.plot',
          source : 'secondAxisTitle'
        },
        {
          targetModule : 'root.main.yAxis',
          target : 'color',
          sourceModule : 'root.main.plot',
          source : 'primaryAxisColor'
        },
        {
          targetModule : 'root.main.yAxis2',
          target : 'color',
          sourceModule : 'root.main.plot',
          source : 'secondAxisColor'
        },
        {
          targetModule : 'root.legends.legend',
          target : 'colorPalette',
          sourceModule : 'root.main.plot',
          source : 'colorPalette'
        },
        {
          targetModule:'root.legends.legend',
          target:'shapes',
          sourceModule:'root.main.plot',
          source:'shapePalette'
        }
      ]
    }
  };

  Manifest.register(chart);
});
define('sap/viz/modules/horizontalcombination',['sap/viz/modules/dispatch','sap/viz/manifest','sap/viz/util/ColorSeriesGenerator','sap/viz/modules/util/MNDHandler',
'sap/viz/base/utils/TypeUtils','sap/viz/base/utils/ObjectUtils',
'sap/viz/data/MultiAxesDataAdapter','sap/viz/modules/util/tooltipDataHandler','sap/viz/util/Scaler',
'sap/viz/util/NumberUtils','sap/viz/base/utils/Objects','sap/viz/lang/langManager',
'sap/viz/modules/util/BoundUtil','sap/viz/modules/util/dataUtil'],
function Setup(dispatch, Manifest, ColorSeries, MNDHandler, TypeUtils, ObjUtils, MultiAxesDataAdapter, TooltipDataHandler, Scaler, NumberUtils, Objects, langManager, BoundUtil, dataUtil) {
  var combination = function(manifest, ctx) {
    var hasAnimationEnd;
    function module(selection) {
      _tooltipDataHandler = TooltipDataHandler();
      BoundUtil.drawBound(selection, _width, _height);
      selection.each(
        function(inputData) {
          if (inputData !== undefined) {
            prepareData(inputData);
          }
          _d3root = d3.select(this);
          
          redraw();
        }
      );//each
      isDataSchemaChanged = false, isDataLoading = false, isSizeChanged = false, isDatasetChanged = false;
      return module;
    }

    /**
     * set/get width
     */
    module.width = function(_) {
      if (!arguments.length) {
        return _width;
      }
      isSizeChanged = (!isSizeChanged && (_ === _width)) ? false : true;
      _width =  _ ;
      if(TypeUtils.isExist(_width) && TypeUtils.isExist(_height)&& TypeUtils.isExist(_rawdata)) {
        computeScales();
      }
      return module;
    };
    /**
     * set/get height
     */
    module.height = function(_) {
      if (!arguments.length) {
        return _height;
      }
      isSizeChanged = (!isSizeChanged && (_ === _height)) ? false : true;
      _height =  _ ;
      if(TypeUtils.isExist(_width) && TypeUtils.isExist(_height)&& TypeUtils.isExist(_rawdata)) {
        computeScales();
      }
      return module;
    };
    
    module.afterUIComponentAppear = function(){
      _eDispatch.initialized(); 
    };
    /**
     * set/get size
     * 
     * @param {Object}
     *            {'width':Num, 'height':Num}
     */
    module.size = function(_) {
      if (!arguments.length) {
        return {
          width : _width,
          height: _height
        };
      }
      _width = _.width;
      _height = _.height;
      if(TypeUtils.isExist(_width) && TypeUtils.isExist(_height)&& TypeUtils.isExist(_rawdata)) {
        computeScales();
      }
      return module;
    };

    /**
     * set/get properties
     */
    module.properties = function(_) {
      if (!arguments.length) {
        return getProperty();
      }
      setProperty(Objects.extend(true, getProperty(), _));
      prepareData(_rawdata, true);
      return module;
    };
    
    module.dataLabel = function(_){};
    /**
     * set/get data
     */
    module.data = function(_) {
      if (!arguments.length) {
        return _rawdata;
      }
      isDatasetChanged = true;
      isDataSchemaChanged = false;
      if (! dataUtil().hasSameSchema(_rawdata, _)){
        isDataSchemaChanged = true;
      }
      prepareData(_);
      return module;
    };

    module.primaryAxisTitle = function(_){
        if(!arguments.length) {
          var titles =  _rawdata.getMeasureValuesGroupDataByIdx(0), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join(' & ');
        }
        return this;
      };
      
      module.secondAxisTitle = function(_){
        if(!arguments.length){
          var titles =  _rawdata.getMeasureValuesGroupDataByIdx(1), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join(' & ');
        }
        return this;
      };
     
      module.dispatch = function(_){
        if(!arguments.length) {
          return _eDispatch;
        }
        _eDispatch = _;
        return module;
      };

      module.primaryScale = function(scale)
      {
        if(!arguments.length) {
          return _valueAxis1.scale;
        }
        _valueAxis1.scale = scale;
        return module;
      };
      
      module.secondaryScale = function(scale)
      {
        if(!arguments.length) {
          return _valueAxis2.scale;
        }
        _valueAxis2.scale = scale;
        return module;
      };
      
      module.categoryScale = function(scale)
      {
        if(!arguments.length) {
          return _xScale;
        }
        _xScale = scale;
        return module;
      };

    module.primaryDataRange = function(range){
      if (!arguments.length){
        return {
          min: _valueAxis1.bottomValue,
          max: _valueAxis1.topValue
        };
      }
      var tempMax, tempMin;
      if (range !== null) {
          if (!isNaN(range.max)) {
            tempMax = range.max;
          } else {
            tempMax = _valueAxis1.scale.perfectDomainEnd;
          }
          if (!isNaN(range.min)) {
            tempMin = range.min;
          } else {
            tempMin = _valueAxis1.scale.perfectDomainBegin;
          }
          if (tempMax > tempMin) {
            _valueAxis1.topValue = tempMax;
            _valueAxis1.bottomValue = tempMin;
          if (range.from === 'axis') {
            _valueAxis1.manualRange = true;
          }
          if(TypeUtils.isExist(_width) && TypeUtils.isExist(_height)){
            calculateScale(_valueAxis1, _valueAxis1.scale);
            }
          }
      } else {
        if (_valueAxis1.manualRange === true) {
          _valueAxis1.topValue = _valueAxis1.scale.perfectDomainEnd;
          _valueAxis1.bottomValue = _valueAxis1.scale.perfectDomainBegin;
          _valueAxis1.manualRange = false;
          if(TypeUtils.isExist(_width) && TypeUtils.isExist(_height)) {
            calculateScale(_valueAxis1, _valueAxis1.scale);
          }
        }
      }
      return module;
    };

    module.secondDataRange = function(range){
      if (!arguments.length){
        return {
          min: _valueAxis2.bottomValue,
          max: _valueAxis2.topValue
        };
      }
      var tempMax, tempMin;
      if (range !== null) {
          if (!isNaN(range.max)) {
            tempMax = range.max;
          } else {
            tempMax = _valueAxis2.scale.perfectDomainEnd;
          }
          if (!isNaN(range.min)) {
            tempMin = range.min;
          } else {
            tempMin = _valueAxis2.scale.perfectDomainBegin;
          }
          if (tempMax > tempMin) {
            _valueAxis2.topValue = tempMax;
            _valueAxis2.bottomValue = tempMin;
          if (range.from === 'axis') {
            _valueAxis2.manualRange = true;
          }
          if(TypeUtils.isExist(_width) && TypeUtils.isExist(_height)){
            calculateScale(_valueAxis2, _valueAxis2.scale);
            }
          }
      } else {
        if (_valueAxis2.manualRange === true) {
          _valueAxis2.topValue = _valueAxis2.scale.perfectDomainEnd;
          _valueAxis2.bottomValue = _valueAxis2.scale.perfectDomainBegin;
          _valueAxis2.manualRange = false;
          if(TypeUtils.isExist(_width) && TypeUtils.isExist(_height)) {
            calculateScale(_valueAxis2, _valueAxis2.scale);
          }
        }
      }
      return module;
    };

    module.primaryAxisColor = function() 
    {
      if (!_props.MNDOnCategory) {
        return _props.primaryValuesColorPalette[0];
      } else {
        return null;
      }
    };
    
    module.secondAxisColor = function() 
    {
      if (!_props.MNDOnCategory) {
        return _props.secondaryValuesColorPalette[0];
      } else {
        return null;
      }
    };

      module.colorPalette = function(Palette){
        if (!arguments.length){
          return _colorPalette;
         }
         return module;
      };

      module.shapePalette = function(Palette){
        if (!arguments.length){
          return _shapePalette;
         }
         return module;
      };

    module.parent = function () {
      return _d3root;
    };
    
    module.clear = function (gray) {
      for (var i in _module)
      {
        if (gray === undefined) {
          _module[i].module.clear();
        } else {
          _module[i].module.clear('grayall');
        }
      }
    };

    module.highlight = function (elements) {
      var i, j;
      var elementArray;
      if (elements instanceof Array) {
        elementArray = elements;
      } else {
        elementArray = [];
        elementArray.push(elements);
      }
      
      if (elementArray.length === 0) {
        return;
      }
      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
          _module[i].highlightArray = [];
        }
      }

      for (i=0; i<elementArray.length; i++) {
        var element = elementArray[i];
        for (j in _module) {
          if (_module.hasOwnProperty(j)) {
              var dpa = _module[j].dataPointElements;
              if (isExist(dpa, element)) {
                _module[j].highlightArray.push(element);
                break;
              }
          }
        }
      }

      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
          _module[i].module.highlight(_module[i].highlightArray);
        }
      }
    };

    module.unhighlight = function (elements) {
      var i, j;
      var elementArray;
      if (elements instanceof Array) {
        elementArray = elements;
      } else {
        elementArray = [];
        elementArray.push(elements);
      }    
      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
          _module[i].unhighlightArray = [];
        }
      }

      for (i=0; i<elementArray.length; i++) {
        var element = elementArray[i];
        for (j in _module) {
          if (_module.hasOwnProperty(j)) {
              var dpa = _module[j].dataPointElements;
              if (isExist(dpa, element)) {
                _module[j].unhighlightArray.push(element);
                break;
              }
          }
        }
      }

      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
          _module[i].module.unhighlight(_module[i].unhighlightArray);
        }
      }
    };
    
    module.hoverOnPoint = function( point ) {
      var i;
      if (_props.tooltip.enabled) {
        var point0= point.x, point1 = point.y;
  
        if(point1 < 0 || point1 > _height) {
          return;
        }
        var xIndex = getCategoryIndex(point1);
        if(_preMouseMoveXIndex === xIndex) {
          return;
        }
        _preMouseMoveXIndex = xIndex;

        var tData = _tooltipDataHandler.generateTooltipData(_rawdata, 
                                   _tooltipdata, 
                                   xIndex, 
                                   _colorPalette, 
                                   _shapePalette);
        var matrix = _d3root.node().getTransformToElement(_d3root.node().ownerSVGElement);
        tData.point = {
            y: (_height - _xScale.rangeBand()*(xIndex + 0.5)) + matrix.f,
            x: _width*3/4 + matrix.e
        };
        _eDispatch.showTooltip(TooltipDataHandler.formatTooltipData(tData));
      }
      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
          _module[i].module.hoverOnPoint(point);
        }
      }
      return true;
    };

    module.blurOut = function( ) {
      var i;
      if (_props.tooltip.enabled) {
        _eDispatch.hideTooltip();
        _preMouseMoveXIndex = -1;
      }
      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
          _module[i].module.blurOut();
        }
      }      
      return true;
    };  
    
    module.destroy = function(){
      if(_xScale){
        _xScale.domain([0,1]).range([0,1]);
      }
      if(_valueAxis1.scale){
        _valueAxis1.scale.domain([0,1]).range([0,1]);
      }
      if(_valueAxis2.scale){
        _valueAxis2.scale.domain([0,1]).range([0,1]);
      }
      
      _valueAxis1.data = null;
      _valueAxis1.manualRange = null;
      _valueAxis1.topValue = null;
      _valueAxis1.bottomValue = null;
      _valueAxis2.data = null;
      _valueAxis2.manualRange = null;
      _valueAxis2.topValue = null;
      _valueAxis2.bottomValue = null;
      
      _xScale = null;
      _valueAxis1 = null;
      _valueAxis2 = null;
      
      _effectManager = null;
      _d3root = null;
      
      //destroy ctx
      if(ctx){
        ctx.destroy();
        ctx = null;
      }
     };

      var _xScale = d3.scale.ordinal(),
        _valueAxis1 = {
        scale: d3.scale.linear()
      },
      _valueAxis2 = {
        scale: d3.scale.linear()
      };

    
    //private field
    var _tooltipDataHandler;
    var _eDispatch = new dispatch('showTooltip', 'hideTooltip', 'initialized', 'startToInit');
    //property
    var _width, _height;
    var _props = {
      priorityMap : {
        'bar' : 5,
        'line' : 0
      },
      defaultShape : 'line',
      MNDOnCategory : false,
      MNDInner : false
    };
    
    var _effectManager = ctx.effectManager;
    
    var isDataSchemaChanged = false, isDataLoading = true, isSizeChanged = false, isDatasetChanged = false;

    //data
    var _rawdata, _tooltipdata;
    var _d3root;
    var _colorPalette, _shapePalette;
    
    //module
    var _module;

    var _preMouseMoveXIndex = -1;

    var dummyDispatch = function (_) {
      this.mtype = _;
    };
    dummyDispatch.prototype.initialized = function() {
      _dummyDispatchHelper.initialized(this.mtype);
    };
    dummyDispatch.prototype.startToInit = function() {
      _eDispatch.startToInit();
    };

    var _dummyDispatchHelper = {
      initialized : function(mtype) {
        var i;
        if (_module[mtype]) {
          _module[mtype].isCompleteAnimation = true;
        }
        for (i in _module) {
          if (!_module[i].isCompleteAnimation) {
            return true;
          }
        }
        hasAnimationEnd = true;
        return true;
      }
    };

    function init() {
      //TODO: should destroy useless module here(stop animation of useless module)
      _module = {};
    }
    function prepareData ( rawdata , isMandatory ) {
      var i, j, mtype, tm;
      if ((rawdata === null) || (rawdata === undefined) || (!isMandatory && (_rawdata === rawdata))) {
        return;
      }

      init();
      _rawdata = rawdata;

       var obj = MNDHandler(_rawdata );
      _props.MNDInner = obj.MNDInner;
      _valueAxis1.data = obj['MG1'];
      _valueAxis2.data = obj['MG2'];
      _tooltipdata = TooltipDataHandler.dataTransform(obj);

      if (obj.color) {
        var tempData = obj['MG1'];
        var data0 = [];
        var data1 = [];
        for (i=0; i<tempData.length; i++) {
          var temp0 = [];
          var temp1 = [];
          var temp = tempData[i];
          for (j=0; j<temp.length; j++) {
            if (obj.color[j] === 0) {
              temp0.push(temp[j]);
            } else if (obj.color[j] === 1) {
              temp1.push(temp[j]);
            }
          }
          data0.push(temp0);
          data1.push(temp1);
        }
        _valueAxis1.data = data0;
        _valueAxis2.data = data1;
      }
      if(TypeUtils.isExist(_width) && TypeUtils.isExist(_height)&& TypeUtils.isExist(_rawdata)) {
        computeScales();
      }
      if (obj.hasMND && !obj.MNDOnColor) {
        mtype = _props.dataShape.primaryAxis[0];
        if (mtype === undefined || mtype === null) {
          mtype = _props.defaultShape;
        }
        if (_module[mtype] === undefined) {
          _module[mtype] = {};
        }
        _module[mtype].data = _rawdata;
        _props.MNDOnCategory = true;
      } else {
        _props.MNDOnCategory = false;
        var daa1 = _rawdata.getAnalysisAxisDataByIdx(0);
        var daa2 = _rawdata.getAnalysisAxisDataByIdx(1);
        var dva1 = _rawdata.getMeasureValuesGroupDataByIdx(0);
        var dva2 = _rawdata.getMeasureValuesGroupDataByIdx(1);
        for (i=0; i<dva1.values.length; i++) {
          mtype = _props.dataShape.primaryAxis[i];
          if (mtype === undefined || mtype === null) {
            mtype = _props.defaultShape;
          }
          if (_module[mtype] === undefined) {
            _module[mtype] = {m1Num:0, m2Num:0};
          }
          tm = _module[mtype];
          tm.m1Num ++;
          if (tm.data === undefined) {
            tm.data = new MultiAxesDataAdapter();
            tm.data.addAnalysisAxis(daa1);
            tm.data.addAnalysisAxis(daa2);
            tm.data.addMeasureValuesGroup({
              index: dva1.index,
              values: []
            });
            if (dva2) {
              tm.data.addMeasureValuesGroup({
                index: dva2.index,
                values: []
              });
            }
          }
          var tva1 = tm.data.getMeasureValuesGroupDataByIdx(0);
          tva1.values.push(dva1.values[i]);
        }
        
        if (dva2) {
          for (i=0; i<dva2.values.length; i++) {
            mtype = _props.dataShape.secondAxis[i];
            if (mtype === undefined || mtype === null) {
              mtype = _props.defaultShape;
            }
            if (_module[mtype] === undefined) {
              _module[mtype] = {m1Num:0, m2Num:0};
            }
            tm = _module[mtype];
            tm.m2Num ++;
            if (tm.data === undefined) {
              tm.data = new MultiAxesDataAdapter();
              tm.data.addAnalysisAxis(daa1);
              tm.data.addAnalysisAxis(daa2);
              tm.data.addMeasureValuesGroup({
                index: dva1.index,
                values: []
              });
              if (dva2) {
                tm.data.addMeasureValuesGroup({
                  index: dva2.index,
                  values: []
                });
              }
            }
            var tva2 = tm.data.getMeasureValuesGroupDataByIdx(1);
            tva2.values.push(dva2.values[i]);
          }
        }
      }
      prepareColor();
    }
    
    function prepareColor() {
      var i, j, color, mtype, tm;
      if (_rawdata === undefined) { return; }
      
      var dva1 = _rawdata.getMeasureValuesGroupDataByIdx(0);
      var dva2 = _rawdata.getMeasureValuesGroupDataByIdx(1);
      var valueAxis1ColorPalette;
      var valueAxis2ColorPalette;

      if (dva2 && !_props.MNDOnCategory) {
        valueAxis1ColorPalette = _props.primaryValuesColorPalette;  
      }else{
        valueAxis1ColorPalette = _props.colorPalette;
      }
      
      valueAxis2ColorPalette = _props.secondaryValuesColorPalette;
      
      _colorPalette = [];
      _shapePalette = [];
      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
            _module[i].colorPaletteY1 = [];
            _module[i].currentM1Index = -1;
            if (dva2) {
              _module[i].colorPaletteY2 = [];
              _module[i].currentM2Index = -1;
            }
        }
      }
      
      if (_props.MNDOnCategory) {
        mtype = _props.dataShape.primaryAxis[0];
        var rowslength = dva1.values[0].rows.length;
        for (j=0; j<rowslength; j++) {
          _module[mtype].colorPaletteY1.push(valueAxis1ColorPalette[(j) % valueAxis1ColorPalette.length]);
          _shapePalette.push(getShape(mtype));
          _colorPalette.push(valueAxis1ColorPalette[(j) % valueAxis1ColorPalette.length]);
        }
      } else {
        var measure1Num = dva1.values.length;
        var measure2Num = 0;
        if (dva2) {
          measure2Num = dva2.values.length;
        }
        var measureNum = measure1Num + measure2Num;
        var colorAxisDataNum = dva1.values[0].rows.length;
        for (i=0; i<measure1Num; i++) {
          mtype = _props.dataShape.primaryAxis[i];
          if (mtype === undefined || mtype === null) {
            mtype = _props.defaultShape;
          }
          tm = _module[mtype];
          tm.currentM1Index ++;
          for (j=0; j<colorAxisDataNum; j++) {
            if (_props.MNDInner) {
              color = valueAxis1ColorPalette[(i+j*measure1Num ) % valueAxis1ColorPalette.length];
              tm.colorPaletteY1[tm.currentM1Index+j*tm.m1Num] = color;
              _shapePalette[i+j*measureNum] = getShape(mtype);
              _colorPalette[i+j*measureNum] = color;
            } else {
              color = valueAxis1ColorPalette[(i*colorAxisDataNum+j) % valueAxis1ColorPalette.length];
              _module[mtype].colorPaletteY1.push(color);
              _shapePalette.push(getShape(mtype));
              _colorPalette.push(color);
            }
          }
        }

        if (dva2) {
          for (i=0; i<measure2Num; i++) {
            mtype = _props.dataShape.secondAxis[i];
            if (mtype === undefined || mtype === null) {
              mtype = _props.defaultShape;
            }
            tm = _module[mtype];
            tm.currentM2Index ++;
            for (j=0; j<colorAxisDataNum; j++) {
              if (_props.MNDInner) {
                color = valueAxis2ColorPalette[(i+j*measure2Num ) % valueAxis2ColorPalette.length];
                tm.colorPaletteY2[tm.currentM2Index+j*tm.m2Num] = color;
                _shapePalette[measure1Num+i+j*measureNum] = getShape(mtype);
                _colorPalette[measure1Num+i+j*measureNum] = color;
              } else {
                color = valueAxis2ColorPalette[(i*colorAxisDataNum+j) % valueAxis2ColorPalette.length];
                _module[mtype].colorPaletteY2.push(color);
                _shapePalette.push(getShape(mtype));
                _colorPalette.push(color);
              }
            }
          }
        }
      } // _props.MNDOnCategory
    }
    function moduleSortHelp(a, b) {
      return (_props.priorityMap[b] - _props.priorityMap[a]);
    }
    function prepareModule() {
      var tempA = [],i;
      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
          tempA.push(i);
        }
      }
      tempA.sort(moduleSortHelp);
      
      _d3root.selectAll('.module').remove(); //TODO: should not always remove all
      var d3modules = _d3root.selectAll('.module').data(tempA);
      d3modules.enter().append('svg:g').attr('class', 'module');
      d3modules.exit().remove();
      
      d3modules.each(function(d) {
        _module[d].d3root = d3.select(this);
      });
      
      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
            _module[i].module = getModule(i); //TODO: should not always new module instance
            var hasAnimation = false;
            if(isDataLoading){
              hasAnimation = _props.animation.dataLoading;
            }else if(isDatasetChanged){
              hasAnimation = _props.animation.dataUpdating;
            }else if(isSizeChanged){
              hasAnimation = _props.animation.resizing;
            }
            var props = {
              colorPalette : _module[i].colorPaletteY1,
              primaryValuesColorPalette : _module[i].colorPaletteY1,
              tooltip : {enabled : false},
              animation : {
                dataLoading: hasAnimation
              },
              drawingEffect: _props.drawingEffect
            };
            if (_module[i].colorPaletteY2) {
              props.secondaryValuesColorPalette = _module[i].colorPaletteY2;
            }
            switch (i) {
            case 'line' :
              props.hoverline = { visible : false };
              ObjUtils.extend(props, _props.line);
              break;
            case 'bar' :
              ObjUtils.extend(props, _props.bar);
              break;
            default :
              break;
            }
            _module[i].props = props;
            _module[i].module.dispatch(new dummyDispatch(i));
        }
      }
    }

    function redraw() {
      hasAnimationEnd = false;
      var i;
      prepareModule();

      if (_module.hasOwnProperty('bar')) {
        dataUtil().addMetaInfo2Data(_module, 'bar', {chart: 'combination', element: 'bar'});
      }
      
      if (_module.hasOwnProperty('line')) {
        dataUtil().addMetaInfo2Data(_module, 'line', {chart: 'combination', element: 'line'});
      }
      
      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
            var m = _module[i];
            m.module.width(_width).height(_height).data(m.data)
                .properties(m.props).primaryScale(_valueAxis1.scale)
                .categoryScale(_xScale);
            var dva2 = _rawdata.getMeasureValuesGroupDataByIdx(1);
            if (dva2) {
              switch(i) {
              case 'bar' :
                m.module.secondScale(_valueAxis2.scale); break;
              case 'line' :
                m.module.secondaryScale(_valueAxis2.scale); break;
              default:
                break;
              }
            }
            
            m.d3root.call(m.module);
            m.dataPointElements = [];
            m.d3root.selectAll('.v-datapoint').each(function(){m.dataPointElements.push(this);});
        }
      }

      if(hasAnimationEnd)
      {
          _eDispatch.initialized();
      }
      else
      {
        var timeInterval = 20;
        var totalTime = 0;
        var maxTime = 5000;

        var func = setInterval(function(){
          if(hasAnimationEnd || totalTime > maxTime)
          {
            clearInterval(func);
            _eDispatch.initialized();
          }
          else
          {
            totalTime += timeInterval;
          }
        },
        timeInterval);
      }
    }

    function getCategoryIndex(val)
    {
      var categoryNum = _xScale.domain().length;
      var index = val / _xScale.rangeBand();
        index = Math.floor(index);
       
      return categoryNum - 1 - index;
    }

      function computeScales() {
          var domain = [];
          var categoryNum = 0;
          if (_props.MNDOnCategory) {
            if (_valueAxis1.data && _valueAxis1.data.length > 0) {
              categoryNum += _valueAxis1.data[0].length;
            }
            if (_valueAxis2.data && _valueAxis2.data.length > 0) {
              categoryNum += _valueAxis2.data[0].length;
            }        
          } else {
            if (_valueAxis1.data && _valueAxis1.data.length > 0) {
              categoryNum = _valueAxis1.data[0].length;
            } else {
              categoryNum = _valueAxis2.data[0].length;  
            }
          }
          for (var i=0; i < categoryNum; i++) {
             domain.push(i);
          }      
          _xScale.domain(domain).rangeBands([_height, 0]);

          calculateScale(_valueAxis1, _valueAxis1.scale);
          calculateScale(_valueAxis2, _valueAxis2.scale);

          if (_valueAxis1.data && _valueAxis1.data.length > 0 &&
              _valueAxis2.data && _valueAxis2.data.length > 0 ) {
          if(_valueAxis1.scale.domain().length === 0 && _valueAxis2.scale.domain().length === 0){
            _valueAxis1.scale.domain([0, 1]).range ([0,_width]); 
            _valueAxis2.scale.domain([0, 1]).range ([0,_width]); 
          } else if(_valueAxis1.scale.domain().length === 0 && _valueAxis2.scale.domain().length !== 0){
            _valueAxis1.scale.domain(_valueAxis2.scale.domain()).range(_valueAxis2.scale.range());
          } else if(_valueAxis1.scale.domain().length !== 0 && _valueAxis2.scale.domain().length === 0){
            _valueAxis2.scale.domain(_valueAxis1.scale.domain()).range(_valueAxis1.scale.range());
          }

          if (!_valueAxis1.manualRange && !_valueAxis2.manualRange) {
              Scaler.perfectDual(_valueAxis1.scale, _valueAxis2.scale);
          } else if (!_valueAxis1.manualRange) {
              Scaler.perfect(_valueAxis1.scale);
              Scaler.getRoughTickNum(_valueAxis2.scale);
          } else if (!_valueAxis2.manualRange) {
              Scaler.perfect(_valueAxis2.scale);
              Scaler.getRoughTickNum(_valueAxis1.scale);
          } else {
            Scaler.getRoughTickNum(_valueAxis1.scale);
            Scaler.getRoughTickNum(_valueAxis2.scale);
          }
        } else if (_valueAxis1.data && _valueAxis1.data.length > 0) {
          if(_valueAxis1.scale.domain().length === 0){
            _valueAxis1.scale.domain([0, 1]).range ([0,_width]);
          }
          if (!_valueAxis1.manualRange) {
            Scaler.perfect(_valueAxis1.scale);
          } else {
            Scaler.getRoughTickNum(_valueAxis1.scale);
          }
        } else if (_valueAxis2.data && _valueAxis2.data.length > 0) {
          if(_valueAxis2.scale.domain().length === 0){
            _valueAxis2.scale.domain([0, 1]).range ([0,_width]);
          }
          if (!_valueAxis2.manualRange) {
            Scaler.perfect(_valueAxis2.scale);
          } else {
            Scaler.getRoughTickNum(_valueAxis2.scale);
          }
        }
      }

    function calculateScale(axisValue, scale) {
        if(axisValue.data && axisValue.data.length > 0) {
            if(axisValue.topValue === undefined) {
              var minMax = calculateMinMax(axisValue);
              if(!minMax || ( minMax.min === 0 && minMax.max === 0)) {
                scale.domain([]).range ([]); 
              } else {
                scale.domain([minMax.min, minMax.max]).range ([0, _width]);
              }
            } else {
              scale.domain([axisValue.bottomValue, axisValue.topValue]).range ([0, _width]);
            }
        } else {
          scale.domain([0,0]).range(0,0);
        }
      }

    function getProperty() {
      var temp = {};
      temp.tooltip = {enabled: _props.tooltip.enabled};
      temp.primaryValuesColorPalette = _props.primaryValuesColorPalette;
      temp.secondaryValuesColorPalette = _props.secondaryValuesColorPalette;
      temp.colorPalette = _props.colorPalette;
      temp.drawingEffect = _props.drawingEffect;
      temp.animation = {};
      ObjUtils.extend(true, temp.animation, _props.animation);
      temp.dataShape = {};
      ObjUtils.extend(true, temp.dataShape, _props.dataShape);
      temp.bar = {};
      ObjUtils.extend(true, temp.bar, _props.bar);
      temp.line = {};
      ObjUtils.extend(true, temp.line, _props.line);
  
      return temp;
    }

    function setProperty (props) {
      _props.tooltip = {enabled: props.tooltip.enabled};
      _props.primaryValuesColorPalette = props.primaryValuesColorPalette;
      _props.secondaryValuesColorPalette = props.secondaryValuesColorPalette;
      _props.drawingEffect = props.drawingEffect;
      _props.colorPalette = props.colorPalette;
      _props.animation = {};
      ObjUtils.extend(true, _props.animation, props.animation);
      _props.dataShape = {};
      ObjUtils.extend(true, _props.dataShape, props.dataShape);
      _props.bar = {};
      ObjUtils.extend(true, _props.bar, props.bar);
      _props.line = {};
      ObjUtils.extend(true, _props.line, props.line);

      return _props;
    }

    function getModule(mtype) {
      var result;
      switch (mtype) {
      case 'bar':
        result = Manifest.module.get("sap.viz.modules.bar"); break;
      case 'line':
        result = Manifest.module.get("sap.viz.modules.horizontalline"); break;
      default:
        break;
      }
    //TODO, Ian, temporary switch between old and new style, remove it when all modules have been migrated
      if(result.fn.prototype.__new_style__){
          var target =  new result.fn(result, ctx);
          var ret = function(selection){
            return target.render(selection);
          };
         for(var i in target){
           //if(target.hasOwnProperty(i)){
           if(typeof(target[i]) === 'function'){
             var targetFn = target[i];
             ret[i] = function(tFn){
               return function(){
                 return tFn.apply(target, arguments);  
               };
             }(targetFn);
           }
         }
       return ret;
        
      }else {
        return result.fn(result, ctx);
      }
    }
    
    function getShape(mtype) {
      var result;
      switch (mtype) {
      case 'line':
        result = _props.line.marker.shape;
        break;
      case 'bar':
        result = 'squareWithRadius'; break;
      default:
        break;
      }
      return result;
    }

    function isExist(ao, element) {
      for (var n=0; n<ao.length; n++) {
        if (ao[n] === element) {
          return true;
        }
      }
      return false;
    }

    function calculateMinMax(axisValue)
    {
      if(!axisValue.data || axisValue.data.length === 0) {
        return null;
      }
      var minMax = {
          min: null,
          max: null
      };
      minMax.max = d3.max(axisValue.data, function(d){
        return d3.max(d, function(_){ return _.val;});
      });
      minMax.min = d3.min(axisValue.data, function(d){
        return d3.min(d, function(_){ return _.val;});
      });
      if(NumberUtils.isNoValue(minMax.max )) {
        return null;
      }
      if(minMax.min >= 0) {
        minMax.min = 0;
        minMax.max += minMax.max * 5 / _width;
      } else if(minMax.max <= 0) {
        minMax.max = 0;
        minMax.min +=  minMax.min * 5/ _width;
      } else {
        var temp = (minMax.max - minMax.min) * 5 / _width;
        minMax.min -= temp;
        minMax.max += temp;
      }
      
      return minMax;
    }
    setProperty(manifest.props(null));
    return module;
  };
  return combination;
});
define('sap/viz/modules/manifests/xy/HorizontalCombination',['sap/viz/modules/manifests/Module','sap/viz/modules/horizontalcombination','sap/viz/modules/manifests/xy/Combination'],
function Setup(Manifest, fn) {

  var module = {
    base : "sap.viz.modules.combination",
    'id' : 'sap.viz.modules.horizontalcombination',
    'name' : 'horizontalcombination',
    fn : fn
  };

  Manifest.register(module);
});
define('sap/viz/manifests/xy/HorizontalCombinationChart',['sap/viz/manifests/Viz','sap/viz/modules/manifests/RootContainer','sap/viz/modules/manifests/Title',
'sap/viz/modules/manifests/Legend','sap/viz/modules/manifests/XYContainer',
'sap/viz/modules/manifests/Tooltip','sap/viz/modules/manifests/Axis','sap/viz/modules/manifests/xy/HorizontalCombination',
'sap/viz/modules/manifests/xy/HorizontalLine',
'sap/viz/modules/manifests/xy/Bar','sap/viz/modules/manifests/controller/Interaction',
'sap/viz/manifests/xy/BaseHorizontalChart'],
function Setup (Manifest) {
  var chart={
    base : 'riv/basehorizontalchart',
    id:'viz/horizontal_combination',
    name:'IDS_HORIZONTALCOMBINATIONCHART',
    modules:{
      root : {
        modules : {
          tooltip : {
            configure : {
            properties : {
              chartType : 'horizontalline',
              orientation : 'left'
            }
            }
          },
          main : {
            modules : {
              plot : {
                id : 'sap.viz.modules.horizontalcombination',
                configure:{
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory:'plotArea',
                  propertiesOverride : {
                    dataShape:{
                      secondAxis : { isExported: false }
                    }
                  }
                }
              },
              
              dataLabel : {
                id : 'sap.viz.modules.datalabel',
                configure : {
                  propertyCategory : 'dataLabel',
                  properties : { position : 'inside' }
                }
              }
            }
          }
        }
      }
    },
    feeds : {
        secondaryValues: null
    },
    dependencies:{
      attributes:[
        {
          targetModule : 'root.main.yAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'categoryScale'
        },{
          targetModule : 'root.main.plot',
          target : 'primaryDataRange',
          sourceModule : 'root.main.xAxis',
          source : 'range'
        },{
          targetModule : 'root.main.xAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'primaryScale'
        },{
          targetModule : 'root.main.xAxis',
          target : 'title',
          sourceModule : 'root.main.plot',
          source : 'primaryAxisTitle'
        },{
          targetModule : 'root.legends.legend',
          target : 'colorPalette',
          sourceModule : 'root.main.plot',
          source : 'colorPalette'
        },{
          targetModule:'root.legends.legend',
          target:'shapes',
          sourceModule:'root.main.plot',
          source:'shapePalette'
        },{
            targetModule : 'root.legends.legend',
            target : 'setSelectionMode',
            sourceModule : 'root.interaction',
            source : 'getSelectionMode'
        }
      ],
      events : [ 
        {
          targetModule : 'root.tooltip',
          listener : 'showTooltip',
          sourceModule : 'root.main.plot',
          type : 'showTooltip'
        }, {
          targetModule : 'root.tooltip',
          listener : 'hideTooltip',
          sourceModule : 'root.main.plot',
          type : 'hideTooltip'
        }, {
          targetModule : 'root.interaction',
          listener : 'registerEvent',
          sourceModule : 'root.main.plot',
          type : 'initialized.interaction'
        }, {
            targetModule : 'root.interaction',
            listener : 'highlightedByLegend',
            sourceModule : 'root.legends.legend',
            type : 'highlightedByLegend'
        }, {
                targetModule : 'root.legends.legend',
              listener : 'deselectLegend',
              sourceModule : 'root.interaction',
              type : 'deselectLegend'
        } , {
          targetModule : 'root.main.dataLabel',
          listener : 'showLabel',
          sourceModule : 'root.main.plot',
          type : 'initialized.datalabel'
        }, {
          targetModule : 'root.main.dataLabel',
          listener : 'removeLabel',
          sourceModule : 'root.main.plot',
          type : 'startToInit.datalabel'
        }, {
          targetModule : 'root.interaction',
          listener : 'defaultSelection',
          sourceModule : 'root.main.plot',
          type : 'initialized.defaultSelection'
        }
      ]      
    }
  };

  Manifest.register(chart);
});
define('sap/viz/manifests/xy/DualHorizontalCombinationChart',['sap/viz/manifests/Viz','sap/viz/modules/manifests/RootContainer',
'sap/viz/manifests/xy/HorizontalCombinationChart','sap/viz/modules/manifests/xy/HorizontalCombination'],
 function Setup (Manifest) {
  var chart={
    id:'viz/dual_horizontal_combination',
    name:'IDS_DUALHORIZONTALCOMBINATIONCHART',
    base : 'viz/horizontal_combination',
    modules:{
      root : {
        modules : {
          main : {
            modules : {
              plot : {
                configure : {
                  propertiesOverride : {
                    primaryValuesColorPalette : { isExported: true },
                    secondaryValuesColorPalette : { isExported: true },
                    dataShape : {
                      secondAxis : { isExported: true }
                    }
                  }
                }
              },
              xAxis:{
                id : 'sap.viz.modules.axis',
                configure:{
                  'description':'Settings for the value axis at left or bottom of an XY chart with 2 value axis.',
                  propertiesOverride:{
                    title:{
                      applyAxislineColor:{
                        isExported: true
                      }
                    }
                  }
                }
              },
              'xAxis2' : {
                'id' : 'sap.viz.modules.axis',
                'configure' : {
                  'description':'Settings for the value axis at right or top of an XY chart with 2 value axis.',
                'propertyCategory' : 'xAxis2',
                'properties' : {
                  'type' : 'value',
                  'position' : 'top',
                  'gridline' : { 'visible' : false }
                },
                propertiesOverride:{
                  title:{
                    applyAxislineColor:{
                      isExported: true
                    }
                  }
                }
                }
              }
            }
          }
        }
      }
    },
    
    feeds : {
      secondaryValues: { min: 1, max: Number.POSITIVE_INFINITY  }
    },
    
    dependencies:{
      attributes:[
        {
          targetModule : 'root.main.yAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'categoryScale'
        },
        {
          targetModule : 'root.main.plot',
          target : 'secondDataRange',
          sourceModule : 'root.main.xAxis2',
          source : 'range'
        },
        {
          targetModule : 'root.main.xAxis2',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'secondaryScale'
        },
        {
          targetModule : 'root.main.plot',
          target : 'primaryDataRange',
          sourceModule : 'root.main.xAxis',
          source : 'range'
        },
        {
          targetModule : 'root.main.xAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'primaryScale'
        },
        {
          targetModule : 'root.main.xAxis',
          target : 'color',
          sourceModule : 'root.main.plot',
          source : 'primaryAxisColor'
        },
        {
          targetModule : 'root.main.xAxis2',
          target : 'color',
          sourceModule : 'root.main.plot',
          source : 'secondAxisColor'
        },
        {
          targetModule : 'root.main.xAxis',
          target : 'title',
          sourceModule : 'root.main.plot',
          source : 'primaryAxisTitle'
        },
        {
          targetModule : 'root.main.xAxis2',
          target : 'title',
          sourceModule : 'root.main.plot',
          source : 'secondAxisTitle'
        },
        {
          targetModule : 'root.legends.legend',
          target : 'colorPalette',
          sourceModule : 'root.main.plot',
          source : 'colorPalette'
        },
        {
          targetModule:'root.legends.legend',
          target:'shapes',
          sourceModule:'root.main.plot',
          source:'shapePalette'
        }
      ]
    }
  };

  Manifest.register(chart);
});
define('sap/viz/modules/verticalboxplot',['sap/viz/base/utils/TypeUtils','sap/viz/modules/dispatch','sap/viz/modules/util/MNDHandler',
'sap/viz/util/ColorSeriesGenerator','sap/viz/util/Scaler','sap/viz/util/NumberUtils',
'sap/viz/lang/langManager','sap/viz/modules/util/tooltipDataHandler','sap/viz/base/utils/Objects',
'sap/viz/modules/util/BoundUtil','sap/viz/modules/util/defaultSelectionUtil'],
function Setup(TypeUtils, dispatch, MNDHandler, ColorSeries, Scaler, NumberUtils, langManager,tooltipDataHandler, Objects, boundUtil, defaultSelUtil) {
  var boxplot = function(manifest, ctx) {
    var CSSCLASS_HOVERLINE = 'v-hovershadow';
    var sWrapper = null, 
      dimensionGroup = [], 
      dimensionDomain = [], 
      seriesData = [], 
      legendData = [], 
      regionData = [], 
      dimensionData = [], 
      boxplotData = [],
      colorPalette = [],
      boxColorPalette = [],
      _data = null; 
    var  dimensions = {
        'sap.viz.modules.verticalboxplot.dimension' : {
                'key' : 'sap.viz.modules.verticalboxplot.dimension',
                'values' : null
        }
      };

    var width, 
      height, 
      xScale = d3.scale.ordinal(), 
      yScale = d3.scale.linear(), 
      xDimensionScale = d3.scale.ordinal(),
      decorativeShape,
      boxWidth,
      lastHovered = null,
      tooltipVisible = true,
      hasDefaultSelection = false,
      scaleMinMax = {
          min: 0,
          max: 0
      },
      scaleManualRange = false,
      effectManager = ctx.effectManager,
      drawingEffect = 'normal',
      defaultString = langManager.get('IDS_ISNOVALUE');
    
    var _properties = {}, eDispatch = new dispatch('showTooltip', 'hideTooltip', 'initialized');
    var style = {};
    var outLierLayout = {
      width : '1',
      color : '#000000'
    };

    var quartileLayout = {
      width: '0',
      midLineColor: '#000000'
    };
    
    var lowOutLiersObj = [], highOutLiersObj = [], whiskersObj = [], lowWhiskerObj = [], highWhiskerObj = [], quartilesObj = [], outLiersObj = [];
    var keysArray = ['Maximum:', '3rd Quartile:', 'Median:', '1st Quartile:', 'Minimum:'], noValueStr = 'No value';

    var defsEnter = null,
        id = Math.floor(Math.random() * 10000);
    
    var makeScales = function() {
      var domain = [];
      for ( var i = 0; i < seriesData.length; i++) {
        domain.push(i);
      }
      xScale.domain(domain).rangeBands([0, width]);
      xDimensionScale.domain(dimensionDomain).rangeBands([0, width]);

      //when all data is 0 or null ,we should make yScale.domain from 0 to 1
      if(!scaleMinMax || (scaleMinMax.min === 0 && scaleMinMax.max === 0)){
        yScale.domain([ 0, 1 ]).range([ height, 0 ]);
      } else{
        yScale.domain([ scaleMinMax.min, scaleMinMax.max ]).range([ height, 0 ]);
      }
      if (!scaleManualRange) {
        Scaler.perfect(yScale);
      } else {
        Scaler.getRoughTickNum(yScale);
      }
    };
    
    chart.dimensionData = function(_)
    {
      if (!arguments.length){
        return dimensions;
      }
      dimensions = _;
      return chart;    
    };
    
    function locateBoundary(data) {
      
      if (TypeUtils.isExist(data)) {
        length = data.length;
        var firstLoop = false;
        for (var i = 0; i < length; i++) {
          
          if (data[i].length > 0) {
            if (!firstLoop) {
              scaleMinMax = findMinMax(data[i]);
              firstLoop = true;
            } else {
              var tmp = findMinMax(data[i]);
              if (tmp) {
                if (tmp.min < scaleMinMax.min) {
                  scaleMinMax.min = tmp.min;
                }
                if (tmp.max > scaleMinMax.max) {
                  scaleMinMax.max = tmp.max;
                }
              }
              
            }
          }
        }
      }
      
    }
    
    function findMinMax(range) {
      var minMax = {min:0, max:0};
      if (TypeUtils.isExist(range)) {
        range.sort( function(aObj, bObj) { return aObj.val - bObj.val; });
        
        minMax = {min: range[0].val, max: range[range.length - 1].val};
      }
      return minMax;
    }

    function clearBoxData() {
      lowOutLiersObj = [];
      highOutLiersObj = [];
      whiskersObj = [];
      lowWhiskerObj = [];
      highWhiskerObj = [];
      quartilesObj = [];
      outLiersObj = [];
    }
    
    function clearGlobalData() {
      dimensionGroup = []; 
      dimensionDomain = []; 
      seriesData = []; 
      legendData = []; 
      regionData = []; 
      dimensionData = []; 
      boxplotData = []; 
    }

    function even(n) {
      return (n & 1) == 0;
    }

    function median(distribution, start, end) {
      var n = end - start + 1;
      if (n <= 0)
        return -1;

      var ret;
      var ctxValue = distribution[start + Math.floor((n + 1) / 2) - 1].ctx;
      var infoValue = distribution[start + Math.floor((n + 1) / 2) - 1].info;

      if (even(n)) {
        ret = (distribution[start + Math.floor((n + 1) / 2) - 1].val + distribution[start
            + Math.floor((n + 1) / 2)].val) / 2;
      } else {
        ret = distribution[start + Math.floor((n + 1) / 2) - 1].val;
      }
      return {
        'ctx' : ctxValue,
        'info' : infoValue,
        'val' : ret
      };
    }

    function setDistribution(distribution) {

      if (distribution && distribution.length > 0) {
        var n = distribution.length,
          box = {
            'Maximum:': null,
            '3rd Quartile:': null,
            'Median:': null,
            '1st Quartile:': null,
            'Minimum:': null  
          };
        
        midLine = median(distribution,  0,  n - 1);
        box['Median:'] = midLine;
        
        //Q1 is the median of the first half of the set; we add the median to
        // it if the whole set length is even
        var bak = distribution[Math.floor(n / 2)];
        distribution[Math.floor(n / 2)] = midLine;
        var boxBottom = median(distribution, 0, Math.floor(n / 2));
        distribution[Math.floor(n / 2)] = bak;
        
        // Q3 is the median of the second half of the set; we add the median to
        // it if the whole set length is even
        bak = distribution[Math.floor((n - 1) / 2)];
        distribution[Math.floor((n - 1) / 2)] = midLine;
        var boxTop  = median(distribution, Math.floor((n - 1) / 2), n - 1);
        distribution[Math.floor((n - 1) / 2)] = bak;
        box['3rd Quartile:'] = boxTop;
        box['1st Quartile:'] = boxBottom;
          
        // inter-quartile range
        var iqr = boxTop.val - boxBottom.val;
        // lower adjacent limit
        var lal = boxBottom.val - 1.5 * iqr;
        // upper adjacent limit
        var ual = boxTop.val + 1.5 * iqr;

        // search for the lowest non outlier
        var i = 0;
        while (distribution[i].val < lal)
          i++;
        lowWhisker = distribution[i];
        box['Minimum:'] = lowWhisker;

        if (lowWhisker) {
          if (boxBottom) {
            if (boxBottom.val != lowWhisker.val) {
              lowWhiskerObj.push({
                'pair' : [boxBottom, lowWhisker],
                'ctx' : [lowWhisker.ctx],
                'val' : [lowWhisker.val], //[boxBottom.val, lowWhisker.val],
                'info' : [lowWhisker.info],
              });
            }
          }
        }

        // low outliers are all the values lower than lowest non outlier
        for ( var k = 0; k < i; k++)
          outLiersObj.push(distribution[k]);

        // search for the largest non outlier
        var j = n - 1;
        while (distribution[j].val > ual)
          j--;
        highWhisker = distribution[j];
        box['Maximum:'] = highWhisker;

        for ( var k = 0; k < n - j - 1; k++)
          outLiersObj.push(distribution[j + 1 + k]);

        if (outLiersObj.length > 0) {
          box['outLiers(s)'] = outLiersObj.length;
        }

        if (highWhisker) {
          if (boxTop) {
            if (boxTop.val != highWhisker.val) {
              highWhiskerObj.push({
                'pair' : [highWhisker, boxTop],
                'ctx' : [highWhisker.ctx],
                'val' : [highWhisker.val], //highWhisker.val, boxTop.val
                'info' : [highWhisker.info]
              });
            }
          }
        }

        if (boxBottom && boxTop && midLine) {
          if (boxBottom.val == boxTop.val) {
            quartilesObj.push({
              'pair' : [boxBottom, boxBottom],
              'midLine': null,
              'ctx' : [boxBottom.ctx],
              'val' : [boxBottom.val],
              'info' : [boxBottom.info]
            });
          } else if (midLine.val == boxTop.val) {
            quartilesObj.push({
              'pair' : [boxTop, boxBottom],
              'midLine': null,
              'ctx' : [boxTop.ctx],
              'val' : [boxTop.val],//, boxBottom.val
              'info' : [boxTop.info, boxBottom.info]
            });
          } else if (midLine.val == boxBottom.val) {
            quartilesObj.push({
              'pair' : [boxTop, boxBottom],
              'midLine': null,
              'ctx' : [boxBottom.ctx],
              'val' : [boxBottom.val],//boxTop.val, 
              'info' : [boxTop.info, boxBottom.info]
            });
          } else {
            quartilesObj.push({
              'pair' : [boxTop, midLine],
              'midLine': midLine,
              'ctx' : [boxTop.ctx],
              'val' : [boxTop.val],
              'info' : [boxTop.info]
            });
            quartilesObj.push({
              'pair' : [midLine, boxBottom],
              'midLine': midLine,
              'ctx' : [boxBottom.ctx],
              'val' : [boxBottom.val],
              'info' : [boxBottom.info]
            });
          }
        }
        boxplotData.push(box);
      }
    }
      
    function chart(selection) { 
      
      selection.each(function() {
        
        boundUtil.drawBound(selection, width, height);
          
        boxNumber = 1, boxGroupNumber = seriesData.length, boxWidth = 8 * (xScale.rangeBand()) / (9 * boxNumber + 7);
  
          var svg = sWrapper = d3.select(this);
          svg.selectAll('g.v-box').remove();
          
          if(decorativeShape == null){
            decorativeShape = svg.append('rect').attr('width', xScale.rangeBand() - boxWidth/2).attr('height', height).attr('visibility', 'hidden').attr('fill', style.hoverline.fill).attr('class', CSSCLASS_HOVERLINE);
          }else{
            decorativeShape.attr('width', xScale.rangeBand() - boxWidth/2).attr('height',height).attr('visibility', 'hidden');
          }

          if(defsEnter === null){
            defsEnter = svg
              .append('defs')
              .append('clipPath').attr('id', 'clipPlot_' + id)
              .append('rect').attr('width', width).attr('height', height);
          }else{
            defsEnter.attr('width', width).attr('height', height);
          }

          var datashapesgroup = svg.selectAll('g.v-datashapesgroup');
          if(!TypeUtils.isExist(datashapesgroup[0][0])){
            datashapesgroup = svg.append('g').attr('class', 'v-datashapesgroup').attr("clip-path", "url(#clipPlot_" + id + ")").attr("fill", "none");
          }

          var boxGroup = datashapesgroup.selectAll('g.v-box').data(seriesData);

          boxGroup.enter().append('g');
          boxGroup.attr('class', 'v-box').each( function(boxData, outerIndex) {
              
            if (boxData.length == 0) {
              boxplotData.push({});
              return;
            }
            
            boxData = boxData.sort(function(aObj, bObj) { return aObj.val - bObj.val; });
    
                var arrLength = boxData.length, min = boxData[0], max = boxData[arrLength - 1];
    
                setDistribution(boxData);
    
                var outLiersSelector = d3.select(this).selectAll('circle.outliers').data(outLiersObj);
                outLiersSelector.enter().append('circle');
                outLiersSelector.attr('cx', function(outLier) {
                  var x = xScale(outerIndex) + boxWidth;
                  return x;
                })
                .attr('cy', function(outLier, num) {
                  var y = yScale(outLier.val);
                  return y;
                })
                .attr('r', '2')
                //.attr('shape-rendering', 'crispEdges')
                .attr('stroke', effectManager.register(
                                                    {
                                                  drawingEffect : 'normal',
                                                  fillColor : outLierLayout.color
                                                }
                                                      )
             )
                .attr('stroke-width', outLierLayout.width)
                .attr('fill', 'none')
                .attr('class', 'v-datapoint v-morphable-datapoint v-outliers');
                
                outLiersSelector.exit().remove();

                var quartileSelector = d3.select(this).selectAll('rect.quartile').data(quartilesObj);
                quartileSelector.enter().append('rect');
                quartileSelector.attr('x', function(quartile) {
                  var x = xScale(outerIndex) + boxWidth / 2;
                  return x;
                })
                .attr('y', function(quartile, num) {
                  var y = yScale(quartile.pair[0].val);
                  return y;
  
                })
                .attr('width', boxWidth)
                .attr('height', function(quartile, num) {
                  var height = 0;
                  var pairDiff = quartile.pair[1].val - quartile.pair[0].val;
                  if (pairDiff == 0) {
                    height = 1;
                  } else {
                    height = yScale(quartile.pair[1].val) - yScale(quartile.pair[0].val);
                  }
  
                  return height;
                })
                .attr('shape-rendering', 'crispEdges')
                .attr( 'fill', function(d){
                  var parameter = {
                      drawingEffect : drawingEffect,
                      fillColor : boxColorPalette[outerIndex % boxColorPalette.length],
                      direction : 'horizontal'
                    };
            return effectManager.register(parameter);   
                })
                .attr('stroke-width', quartileLayout.width)
                //.attr('stroke', '#000000')
                .attr('class', 'v-datapoint v-morphable-datapoint v-quartile');
                
                if (quartilesObj.length == 2) {
                  var midLineXStart = xScale(outerIndex) + boxWidth / 2;
                  var midLineXEnd = midLineXStart + boxWidth;
                  var midLineYStart = midLineYEnd = yScale(quartilesObj[0].midLine.val);
                  var lineSelector = d3.select(this);
                    lineSelector.append('line')
                    .attr('x1', midLineXStart)
                    .attr('y1', midLineYStart)
                    .attr('x2', midLineXEnd)
                    .attr('y2', midLineYEnd)
                    .attr('stroke', '#ffffff')
                    .attr('stroke-width', 1)
                    .attr('shape-rendering', 'crispEdges')
                    .attr('class', 'v-midline');
                }
                
                quartileSelector.exit().remove();
    
                var verticalLineXStart = 0, verticalLineYStart = 0, verticalLineXEnd = 0, verticalLineYEnd = 0;
                var horizontalLineXStart = 0, horizontalLineYStart = 0, horizontalLineXEnd = 0, horizontalLineYEnd = 0;
                var whiskerSelector = d3.select(this).selectAll('rect.v-rectlowwhisker').data(lowWhiskerObj);
                whiskerSelector.enter().append('rect');
                whiskerSelector.attr('x', function(whisker) {
                  var x = xScale(outerIndex) + boxWidth / 2;
                  horizontalLineXStart = x;
                  horizontalLineXEnd = x + boxWidth;
                  verticalLineXStart = verticalLineXEnd = x + boxWidth / 2;
                  return x;
                  })
                  .attr('y', function(whisker) {
                    var tmpPair = whisker.pair;
                    var y = yScale(tmpPair[0].val);
                    verticalLineYStart = y;
                    horizontalLineYStart = horizontalLineYEnd = yScale(tmpPair[1].val);
                    return y;
                  })
                  .attr('width', boxWidth)
                  .attr('height', function(whisker) {
                    var height = yScale(whisker.pair[1].val) - yScale(whisker.pair[0].val);
                    verticalLineYEnd = yScale(whisker.pair[1].val);
                    var lineSelector = d3.select(this.parentNode);
                    lineSelector.append('line')
                    .attr('x1', verticalLineXStart)
                    .attr('y1', verticalLineYStart)
                    .attr('x2', verticalLineXEnd)
                    .attr('y2', verticalLineYEnd)
                    .attr('stroke', effectManager.register(
                                      {
                                        drawingEffect : 'normal',
                                        fillColor : '#000000'
                                      }
                                    )
                                 )
                    .attr('stroke-width', 1)
                    .attr('shape-rendering', 'crispEdges')
                    .attr('class', 'v-lineverticallowwhisker v-innerwhisker');
                    
                    var lineSelector = d3.select(this.parentNode);
                    lineSelector.append('line')
                    .attr('x1', horizontalLineXStart)
                    .attr('y1', horizontalLineYStart)
                    .attr('x2', horizontalLineXEnd)
                    .attr('y2', horizontalLineYEnd)
                    .attr('stroke', function(d){
                          var parameter = {
                         drawingEffect : 'normal',
                         fillColor : boxColorPalette[outerIndex % boxColorPalette.length]
                        };
                                   return effectManager.register(parameter);  
                                }
                         )
                    .attr('stroke-width', 1)
                    .attr('shape-rendering', 'crispEdges')
                    .attr('class', 'v-linehorizontallowwhisker');
                    return height;
                    })
                  .attr('shape-rendering', 'crispEdges')
                  .attr('fill-opacity', '0')
                  .attr('stroke-width', '0')
                  .attr('class', 'v-datapoint v-morphable-datapoint v-rectlowwhisker');
                
                whiskerSelector.exit().remove();
    
                var verticalLineXStart = 0, verticalLineYStart = 0, verticalLineXEnd = 0, verticalLineYEnd = 0;
                var horizontalLineXStart = 0, horizontalLineYStart = 0, horizontalLineXEnd = 0, horizontalLineYEnd = 0;
                var whiskerSelector = d3.select(this).selectAll('rect.v-recthighwhisker').data(highWhiskerObj);
                whiskerSelector.enter().append('rect');
                whiskerSelector
                    .attr('x', function(whisker) {
                      var x = xScale(outerIndex) + boxWidth / 2;
                      horizontalLineXStart = x;
                      horizontalLineXEnd = x + boxWidth;
                      verticalLineXStart = verticalLineXEnd = x + boxWidth / 2;
                      return x;
                      })
                    .attr('y', function(whisker, num) {
                      var tmpPair = whisker.pair;
                      var y = yScale(tmpPair[0].val);
                      verticalLineYStart = y;
                      horizontalLineYStart = horizontalLineYEnd = yScale(tmpPair[0].val);
                      return y;
                      })
                    .attr('width', boxWidth)
                    .attr('height', function(whiskersObj, num) {
                      var height = yScale(whiskersObj.pair[1].val) - yScale(whiskersObj.pair[0].val);
                      verticalLineYEnd = verticalLineYStart + height;
                      var lineSelector = d3.select(this.parentNode);
                      lineSelector.append('line')
                      .attr('x1', verticalLineXStart)
                      .attr('y1', verticalLineYStart)
                      .attr('x2', verticalLineXEnd)
                      .attr('y2', verticalLineYEnd)
                      .attr('stroke', effectManager.register(
                                      {
                                        drawingEffect : 'normal',
                                        fillColor : '#000000'
                                      }
                                    )
                                 )
                      .attr('stroke-width', 1)
                      .attr('shape-rendering', 'crispEdges')
                      .attr('class', 'v-lineverticalhighwhisker v-innerwhisker');
  
                      var lineSelector = d3.select(this.parentNode);
                      lineSelector.append('line')
                      .attr('x1', horizontalLineXStart)
                      .attr('y1', horizontalLineYStart)
                      .attr('x2', horizontalLineXEnd)
                      .attr('y2', horizontalLineYEnd)
                      .attr('stroke', function(d){
                            var parameter = {
                         drawingEffect : 'normal',
                         fillColor : boxColorPalette[outerIndex % boxColorPalette.length]
                        };
                                   return effectManager.register(parameter);  
                                }
                           )
                      .attr('stroke-width', 1)
                      .attr('shape-rendering', 'crispEdges')
                      .attr('class', 'v-linehorizontalhighwhisker');
                       
                      return height;
                      })
                    .attr('shape-rendering', 'crispEdges')
                    .attr('fill-opacity', '0')
                    .attr('stroke-width', '0')
                    .attr('class', 'v-datapoint v-morphable-datapoint v-recthighwhisker');
                
                whiskerSelector.exit().remove();      
                clearBoxData();
          });
          eDispatch.initialized();
          boxGroup.exit().remove();
      });
    return chart;
    };
  
    chart.width = function(value) {
      if (!arguments.length) {
        return width;
      }
      
      width = value;
      if (TypeUtils.isExist(width) && TypeUtils.isExist(height) && TypeUtils.isExist(seriesData)) {
        makeScales();
      }
      return chart;
    };
      
    chart.height = function(value) {
      if (!arguments.length) {
        return height;
      }

      height = value;
      if (TypeUtils.isExist(width) && TypeUtils.isExist(height) && TypeUtils.isExist(seriesData)) {
        makeScales();
      }
      return chart;
    }; 
    
    var handleNull = function(_) {
      if (_ === null || _ === undefined) {
        return defaultString;
      } else {
        return _;
      }
    };

    function getTooltipData(index) {
      
      var tooltipData =  {
          'body': [],
          'footer': []
        },
        internalIndex = 0;
      
      if (regionData) {

        var body = {
          'name': null,
          'val': []
        };
        
        internalIndex = index % regionData.length;
        body.name = regionData[internalIndex].name;
  
        if (regionData[internalIndex].label != null && regionData[internalIndex].shape != null && boxColorPalette[internalIndex] != null) {
          var item = {
              'shape': null,
              'color': null,
              'label': null,
              'value': null
            };
          
          item.shape = regionData[internalIndex].shape;
          item.color = boxColorPalette[internalIndex];
          item.label = regionData[internalIndex].label;
          body.val.push(item);
        }
        
        if (boxplotData) {
          
          if (boxplotData[index]) {
            var hasData = false;
            for (var i in boxplotData[index]) {
              var item = {
                  'shape': null,
                  'color': null,
                  'label': null,
                  'value': null
                };
              hasData = true;
              item.label = i;
              if (boxplotData[index][i]) {
                if (i == 'outLiers(s)') {
                  item.value = boxplotData[index][i];
                } else {
                  item.value = boxplotData[index][i].val;
                }
              }
              body.val.push(item);
            }
            
            if (!hasData) {
              for (var j = 0; j < keysArray.length; j++) {
                var item = {};
                item.label = keysArray[j];
                item.value = noValueStr;
                item.color = null;
                item.shape = null;
                body.val.push(item);
              }
            }
          }
        }
        
        tooltipData.body.push(body);
      }
      
      if (dimensionData) {
        internalIndex = Math.floor(index / regionData.length);
        for (var i = 0; i < dimensionData.length; i++) {
          
          if (dimensionData[i].rows.length > 0) {
            var footer = {
                'label': null,
                'value': null
              };
            footer.label = dimensionData[i].col;
            footer.value = dimensionData[i].rows[internalIndex];
            
            tooltipData.footer.push(footer);
          }
        }
      }
    
      return tooltipData;
    }
    
    function generateTooltipData() {
      
      if (dimensions) {
        for (var i in dimensions) {
          dimensionData = dimensions[i].values;
        }
      }
      
      if (legendData) {
        var legendList = legendData.values;
        if (legendList.length > 1) {
          if (legendList[0].type == 'MND') {
            //mnd scan
            for (var mndIndex = 0; mndIndex < legendList[0].rows.length; mndIndex++) {

              //vertical scan
              for (var m = 0; m < legendList[1].rows.length; m++) {
                var legendObj = {
                    'name': null,
                    'shape': null,
                    'color': null,
                    'label': null
                  };
                legendObj.name = legendList[0].rows[mndIndex];
                var label = [];
                
                //horizontal scan
                for (var n = 1; n < legendList.length; n++) {
                  label.push(legendList[n].rows[m]);
                }
                legendObj.label = label;
                regionData.push(legendObj);
              }    

            }
          } else if (legendList[legendList.length - 1].type == 'MND') {

            for (var m = 0; m < legendList[0].rows.length; m++) {

              var label = [];
              for (var n = 0; n < legendList.length - 1; n++) {
                label.push(legendList[n].rows[m]);              
              }
              

              for (var mndIndex = 0; mndIndex < legendList[legendList.length - 1].rows.length; mndIndex++) {
                var legendObj = {
                    'name': null,
                    'shape': null,
                    'color': null,
                    'label': null
                  };
                legendObj.label = label;
                legendObj.name = legendList[legendList.length - 1].rows[mndIndex];
                regionData.push(legendObj);
              }
            }
          } 
        } else {
          for (var m = 0; m < legendList[0].rows.length; m++) {
            var legendObj = {
                'name': null,
                'shape': null,
                'color': null,
                'label': null
              };
            legendObj.name = legendList[0].rows[m];
            regionData.push(legendObj);
          }
        }
      }
      
      for (var k = 0; k < regionData.length; k++) {
        //regionData[k].color = boxColorPalette[k % boxColorPalette.length];
        regionData[k].shape = 'squareWithRadius';
      }
    }

    function setElementAttribute(element, attribute, value) {
      if (element) {
        var className = element.getAttribute('class');
        if(className.indexOf('v-recthighwhisker') == -1 && className.indexOf('v-rectlowwhisker') == -1
           && className.indexOf('v-linehorizontalhighwhisker') == -1 && className.indexOf('v-lineverticalhighwhisker') == -1
           && className.indexOf('v-linehorizontallowwhisker') == -1 && className.indexOf('v-lineverticallowwhisker') == -1) {
          element.setAttribute(attribute, value);
        }else if (className.indexOf('v-recthighwhisker') != -1) {
          var nodeList = element.parentNode.querySelectorAll('line');
          if (nodeList) {
            for (var j = 0, nodeListLen = nodeList.length; j < nodeListLen; j++) {
              var nodeClassName = nodeList[j].getAttribute('class');
              if (nodeClassName.indexOf('v-linehorizontalhighwhisker') != -1 || nodeClassName.indexOf('v-lineverticalhighwhisker') != -1) {
                nodeList[j].setAttribute(attribute, value);
              }
            }
          }
        } else if(className.indexOf('v-rectlowwhisker') != -1) {
          var nodeList = element.parentNode.querySelectorAll('line');
          if (nodeList) {
            for (var j = 0, nodeListLen = nodeList.length; j < nodeListLen; j++) {
              var nodeClassName = nodeList[j].getAttribute('class');
              if (nodeClassName.indexOf('v-linehorizontallowwhisker') != -1 || nodeClassName.indexOf('v-lineverticallowwhisker') != -1) {
                nodeList[j].setAttribute(attribute, value);
              }
            }
          }        
        }      
      }
    }
    
      chart.parent = function(){
        return sWrapper;
      };
      
      chart.highlight = function(elems){
        if(elems instanceof Array){
          for(var i = 0, elemsLen = elems.length; i < elemsLen; i++) {
          var item = elems[i];
          setElementAttribute(item, 'opacity', 1);
          }
        }else{
        setElementAttribute(elems, 'opacity', 1);
        }
        if(hasDefaultSelection){
          defaultSelUtil.clearSelectionInfo(sWrapper, true, elems);
        }
      };
      
      chart.unhighlight = function(elems){
        if(elems instanceof Array){
          for(var i = 0, len = elems.length; i < len; i++){
          var item = elems[i];
          setElementAttribute(item, 'opacity', 0.4);
          }
        }else{
        setElementAttribute(elems, 'opacity', 0.4);
        }
        if(hasDefaultSelection){
          defaultSelUtil.clearSelectionInfo(sWrapper, false, elems);
        }
      };
      
      chart.clear = function(gray){
        if( gray == null || gray == false){
          sWrapper.selectAll('.v-datapoint').attr('opacity', 1);
          sWrapper.selectAll('.v-lineverticallowwhisker').attr('opacity', 1);
          sWrapper.selectAll('.v-lineverticalhighwhisker').attr('opacity', 1);
          sWrapper.selectAll('.v-linehorizontallowwhisker').attr('opacity', 1);
          sWrapper.selectAll('.v-linehorizontalhighwhisker').attr('opacity', 1);
          
          if(hasDefaultSelection){
            defaultSelUtil.clearSelectionInfo(sWrapper, false, sWrapper.selectAll('.v-datapoint'));
          }
          
        }else{
          sWrapper.selectAll('.v-datapoint').attr('opacity', 0.4);
          sWrapper.selectAll('.v-lineverticallowwhisker').attr('opacity', 0.4);
          sWrapper.selectAll('.v-lineverticalhighwhisker').attr('opacity', 0.4);
          sWrapper.selectAll('.v-linehorizontallowwhisker').attr('opacity', 0.4);
          sWrapper.selectAll('.v-linehorizontalhighwhisker').attr('opacity', 0.4);
        }
        
        sWrapper.selectAll('.v-recthighwhisker').attr('opacity', 0);
        sWrapper.selectAll('.v-rectlowwhisker').attr('opacity', 0);
      };
  
      chart.hoverOnPoint = function(point){
        var xOnModule = point.x, yOnModule = point.y;
      // find the closet dimension
      var i = -1;
      while (i < seriesData.length) {
        if (Math.abs(xOnModule - xScale.rangeBand()*i - 0.5 * xScale.rangeBand() ) <= 0.5 * xScale.rangeBand()) {
          break;
        }
        i++;
      }

      if (i > (seriesData.length - 1)
          || i < 0) {
        decorativeShape.attr(
            'visibility', 'hidden');
        return;
      }
      
      decorativeShape.attr(
          'x',
          xScale.rangeBand() * i + boxWidth/4).attr(
          'visibility', 'visible');
      
      if(lastHovered !== i){
        if (tooltipVisible) {
          lastHovered = i;
          //this.parentNode point to plot graphic. it is different from bar chart as in bar chart it should get the yoffset which can get it from mian graphic element.
          var transform = sWrapper[0][0].getTransformToElement(sWrapper[0][0].ownerSVGElement);
          var xoffset = transform.e;

          var tooltipData = getTooltipData(i);
          
          tooltipData.point = {
              x: xScale.rangeBand()*i + 0.5 * xScale.rangeBand() + xoffset,
              y: point.y
              };
          tooltipData.plotArea = {
                        x : transform.e,
                        y : transform.f,
                        width : width,
                        height : height
                    };
          eDispatch.showTooltip(tooltipDataHandler.formatTooltipData(tooltipData));
        }
      }
      
      };
  
      chart.blurOut = function(){
        decorativeShape.attr('visibility', 'hidden');
        lastHovered = null;
      if (tooltipVisible) {
          eDispatch.hideTooltip();
      }
      };
      
      function makeSubGroup(row, start, end, groups, parentGroupIndex) {
      if (row && start <= end && end < row.length) {
        var subStart = subEnd = pos = start;
        while (pos <= end) {
          var contexts = []; 
          while (((pos+1) <= end) && (row[pos + 1].val == row[pos].val)) {
            contexts.push(row[subEnd].ctx);
            subEnd++;
            pos++;
          }
          if(subEnd < row.length)
          {
            contexts.push(row[subEnd].ctx);
          }
          row[subStart].contexts = contexts;
          groups.push({
            'val': row[subStart],
            'parentGroupIndex': parentGroupIndex,
            'start': subStart,
            'end': subEnd
          });
          pos++;
          subStart = subEnd = pos;
        }          
      }
    }

    
    function generateGroup(row) {
      var curGroups = [];
      if (row) {
        var mapLen = dimensionGroup.length;
        var preGroups = mapLen > 0?dimensionGroup[mapLen - 1].val : null;
        if (preGroups) {
          for (var i = 0, len = preGroups.length; i < len; i++) {
            var preGroup = preGroups[i];
            var start = preGroup.start;
            var end = preGroup.end;
            makeSubGroup(row, start, end, curGroups, i );
          }
        } else {
          makeSubGroup(row, 0, row.length - 1, curGroups, null);
        }
      }
      return curGroups;
    }

    function dataTransform(originalData) {
      if (originalData) {
        var originalDimension = originalData.getAnalysisAxisDataByIdx(0);
        legendData = originalData.getAnalysisAxisDataByIdx(1);
        if (originalDimension) {
          var len = originalDimension.values.length;
          if (len == 1) {
            dimensionGroup.push({'col': originalDimension.values[0].col.val, 'val': []});
          } else {
            for (var i = 0; i < len - 1; i++) {
              var row = originalDimension.values[i].rows;
              dimensionGroup.push({'col': originalDimension.values[i].col.val, 'val': generateGroup(row)});
            }
          }
        }
      }
    }
    
    function caculateLeavesNum(start, end) {
      
      var len = dimensionGroup.length, num = 0, index = 0, leavesGroups = dimensionGroup[len - 1].val;
      while (leavesGroups[index].start != start) {
        index++;
      }      
      while (leavesGroups[index].end != end) {
        num++;
        index++;
      }
      num++;
      return num;
    }

    function generateDimensions() {
      if (dimensionGroup) {
        var len = dimensionGroup.length, groups = null;
        
        groups = dimensionGroup[len - 1].val;
        if (groups.length == 0) {
          dimensionDomain.push(0);
          dimensionDomain.push(1);
        } else {
          for (var i = 0, lenScale = groups.length; i < lenScale; i++) {
            dimensionDomain.push(i);
          }
        }
        
        if (groups.length == 0) {
          dimensions['sap.viz.modules.verticalboxplot.dimension'].values = [{'col': {'val': dimensionGroup[len - 1].col}, 'rows': []}];
        } else {
          
          var scaleValues = [];
          for (var j = 0; j < len; j++) {
            var obj = {
              'col': {'val': ''},
              'rows': []
            };
            obj.col.val = dimensionGroup[j].col;
            var rowGroups = dimensionGroup[j].val;
            for (var k = 0,  lenRowGroups =  rowGroups.length; k < lenRowGroups; k++) {
              var start = rowGroups[k].start, end = rowGroups[k].end, num = caculateLeavesNum(start, end);
              for (var m = 0; m < num; m++) {
                obj.rows.push({
                  'val': handleNull(rowGroups[k].val.val),
                  'info' : rowGroups[k].val.info,
                  'contexts' : rowGroups[k].val.contexts
                });
              }
            }
            
            scaleValues.push(obj);
          }
              
          dimensions['sap.viz.modules.verticalboxplot.dimension'].values = scaleValues;
        }        
      }      
    }
    
    function createColorPalette(length) {
      boxColorPalette = [];
      if (colorPalette.length > 0) {
        for( var i = 0; i < length; ++i) {
          boxColorPalette.push(colorPalette[i % colorPalette.length]);
        }
      }
    }
    
      function parseOptions(){  
      tooltipVisible = _properties.tooltip.enabled;
        colorPalette = _properties.colorPalette;
        drawingEffect = _properties.drawingEffect;
      }
      
    chart.data = function(value) {
      if (!arguments.length) {
        return _data;
      }
      
      clearGlobalData();
      parseOptions();
      
      _data = value;
        var obj = MNDHandler(_data);
        dataTransform(_data);
        dataMG1 = obj["MG1"];
        
        if( dataMG1[0] && dataMG1[0][0].info && dataMG1[0][0].info.defaultSelection){
          hasDefaultSelection = true;
        }else{
          hasDefaultSelection = false;
        }   
      var len = dataMG1.length;
      var groups = dimensionGroup[dimensionGroup.length - 1].val;
      if (groups.length != 0) {
        for (var i = 0, groupsLen = groups.length; i < groupsLen; i++) {
          var start = groups[i].start, end = groups[i].end;
          for (var j = 0; j < len; j++) {
            var row = [], left = start, right = end;
            for (;left <= right; left++) {
              if (!NumberUtils.isNoValue(dataMG1[j][left].val))
                row.push(dataMG1[j][left]);
            }
            seriesData.push(row);
          }
        }
      } else {
        for (var j = 0; j < len; j++) {
          var row = [];
          for (var m = 0; m < dataMG1[j].length; m++) {
            if (!NumberUtils.isNoValue(dataMG1[j][m].val)) {
              row.push(dataMG1[j][m]);
            } 
          }
          seriesData.push(row);
        }
      }
        
      locateBoundary(seriesData);
      generateDimensions();
      
      if (TypeUtils.isExist(width) && TypeUtils.isExist(height)) {
        makeScales();
      }
      
      generateTooltipData();
            createColorPalette(regionData.length);
      
      return chart;
    };
    
    chart.primaryAxisTitle = function(_){
        if(!arguments.length){
          var titles =  _data.getMeasureValuesGroupDataByIdx(0), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join(' & ');
        }
        return this;
      };
      
      chart.secondAxisTitle = function(_){
        if(!arguments.length){
          var titles =  _data.getMeasureValuesGroupDataByIdx(1), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join(' & ');
        }
        return this;
      };
      
    chart.properties = function(props){

        if (!arguments.length){
          return _properties;
         }
      
      Objects.extend(true, _properties, props);
            parseOptions();
            createColorPalette(regionData.length);
            
         return chart;        
      };
    
    chart.categoryScale = function(scale){
      if (!arguments.length){
        return xDimensionScale;
      }
      xDimensionScale = scale;
      return chart;
     };
     
    chart.primaryScale = function(scale){
      if (!arguments.length){
        return yScale;
      }
      yScale = scale;
      return chart;
    };

    chart.primaryDataRange = function(range){
      if (!arguments.length){
        return {
          min: scaleMinMax.min,
          max: scaleMinMax.max
        };
      }
      var tempMax, tempMin;
      if (range !== null) {
          if (!isNaN(range.max)) {
            tempMax = range.max;
          } else {
            tempMax = yScale.perfectDomainEnd;
          }
          if (!isNaN(range.min)) {
            tempMin = range.min;
          } else {
            tempMin = yScale.perfectDomainBegin;
          }
          if (tempMax > tempMin) {
            scaleMinMax.max = tempMax;
            scaleMinMax.min = tempMin;
            if (range.from === 'axis') {
                scaleManualRange = true;
            }
            if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
              makeScales();
            }
          }
      } else {
        if (scaleManualRange === true) {
            scaleMinMax.max = yScale.perfectDomainEnd;
            scaleMinMax.min = yScale.perfectDomainBegin;
            scaleManualRange = false;
            if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
              makeScales();
            }
        }
      }
      return chart;
    };

    chart.colorPalette = function(Palette){
      if (!arguments.length){
        return colorPalette;
      }
      colorPalette = Palette;
      return chart;
     };
  
     chart.dispatch = function(_){
        if(!arguments.length)
          return eDispatch;
        eDispatch = _;
        return this;
      };
      
    chart.destroy = function(){
        if(xScale){
          xScale.domain([0,1]).range([0,1]);
        }
        if(yScale){
          yScale.domain([0,1]).range([0,1]);
        }
        if(xDimensionScale){
          xDimensionScale.domain([0,1]).range([0,1]);
        }
        xDimensionScale = null;
        xScale = null;
        yScale = null;
        
        decorativeShape = null;
        defsEnter = null;
        sWrapper = null;
        lastHovered = null;
        dimensionGroup = null; 
        dimensionDomain = null; 
        seriesData = null;
        legendData = null; 
        regionData = null; 
        dimensionData = null; 
        boxplotData = null;
        colorPalette = null;
        boxColorPalette = null;
        dimensions['sap.viz.modules.verticalboxplot.dimension'].values = null;
        dimensions = null;
        _data = null;
       
          
        //destroy ctx
        if(ctx){
          ctx.destroy();
          ctx = null;
        }
      };

    function getCSSStyle() {
      style.hoverline = ctx.styleManager.queryDefault(CSSCLASS_HOVERLINE);
    }

    getCSSStyle();
    _properties = manifest.props(null);
    return chart;
  };

  return boxplot;
});
define('sap/viz/modules/manifests/xy/VerticalBoxplot',['sap/viz/modules/manifests/Module','sap/viz/modules/verticalboxplot','sap/viz/modules/manifests/xy/Base'],
function Setup(Manifest, fn) {
  var module = {
    'id' : 'sap.viz.modules.verticalboxplot',
    'name' : 'vertical boxplot',
    base : "sap.viz.modules.xy.base",
    'properties' : { 
          'primaryValuesColorPalette' : { 'isExported' : false },
          'secondaryValuesColorPalette' : { 'isExported' : false },
          'tooltip' : {
            'name' : 'tooltip',
            'supportedValueType' : 'Object',
            'supportedValues' : {
              'enabled' : {
                'name' : 'enabled',
                'supportedValueType' : 'Boolean',
                'defaultValue' : true,
                'description' : 'Set enabled/disabled tooltip.'
              }
            },
            'isExported' : false,
            'description' : 'Settings for tooltip related properties.'
          }
    },
    'feeds' : {
      configure : {
          secondaryValues:null,
          axisLabels:{
          acceptMND: -1,
          min : 1,
          max : 1
        }
      }
    },
    'css' : {
        '.v-hovershadow' : {
            'description' : 'Define style for hover shadow color.',
            'value' : {
                'fill' : '#cccccc',
            }
        }
    },
    fn : fn
  };

  Manifest.register(module);
});
define('sap/viz/manifests/xy/VerticalBoxplotChart',['sap/viz/manifests/Viz','sap/viz/modules/manifests/RootContainer','sap/viz/modules/manifests/xy/VerticalBoxplot',
'sap/viz/manifests/xy/BaseVerticalChart','sap/viz/modules/manifests/controller/Interaction'],
function Setup(Manifest) {
    var chart = {
      id : 'viz/boxplot',
      name : 'IDS_VERTICALBOXPLOTCHART',
      base : 'riv/baseverticalchart',
      modules : {
        root : {
          modules : {
             tooltip : {
              id : 'sap.viz.modules.tooltip',
              configure : {
                propertyCategory : 'tooltip',
                properties : {
                  chartType : 'verticalboxplot',
                  orientation : 'left'
                }
              }
          },
          'interaction' : {
            id : 'sap.viz.modules.controller.interaction',
            configure : { clientID : 'main', propertyCategory : 'interaction' }
          },
          main : {
              modules : {
                dataLabel:null,
                xAxis : {
                  id : 'sap.viz.modules.axis',
                  configure : {
                    properties : {
                      isIndependentMode : true
                    }
                  }
                },
                plot : {
                    id : 'sap.viz.modules.verticalboxplot',
                    configure : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                        propertyCategory : 'plotArea'
                    }
                }
              }
            }
          }
        }
         
      },

     dependencies : {
       attributes : [ {
            targetModule : 'root.main.plot',
            target : 'primaryDataRange',
            sourceModule : 'root.main.yAxis',
            source : 'range'
          }, {
             targetModule : 'root.main.yAxis',
             target : 'scale',
             sourceModule : 'root.main.plot',
             source : 'primaryScale'
          },{
             targetModule : 'root.main.yAxis',
             target : 'title',
             sourceModule : 'root.main.plot',
             source : 'primaryAxisTitle'
          },{
            targetModule : 'root.main.xAxis',
            target : 'scale',
            sourceModule : 'root.main.plot',
            source : 'categoryScale'
          },{
            targetModule : 'root.main.xAxis',
            target : 'independentData',
            sourceModule : 'root.main.plot',
            source : 'dimensionData'
          },{
            targetModule : 'root.legends.legend',
            target : 'colorPalette',
            sourceModule : 'root.main.plot',
            source : 'colorPalette'
          },{
            targetModule : 'root.legends.legend',
            target : 'setSelectionMode',
            sourceModule : 'root.interaction',
            source : 'getSelectionMode'
          } ],
           events : [ {
            targetModule : 'root.tooltip',
            listener : 'showTooltip',
            sourceModule : 'root.main.plot',
            type : 'showTooltip'
          }, {
            targetModule : 'root.tooltip',
            listener : 'hideTooltip',
            sourceModule : 'root.main.plot',
            type : 'hideTooltip'
          }, {
            targetModule : 'root.interaction',
            listener : 'registerEvent',
            sourceModule : 'root.main.plot',
            type : 'initialized.interaction'
          }, {
            targetModule : 'root.interaction',
            listener : 'highlightedByLegend',
            sourceModule : 'root.legends.legend',
            type : 'highlightedByLegend'
          }, {
            targetModule : 'root.legends.legend',
            listener : 'deselectLegend',
            sourceModule : 'root.interaction',
            type : 'deselectLegend'
          }, {
            targetModule : 'root.interaction',
            listener : 'defaultSelection',
            sourceModule : 'root.main.plot',
            type : 'initialized.defaultSelection'
          }
          ]
        }
    };
    Manifest.register(chart);
});
define('sap/viz/modules/horizontalboxplot',['sap/viz/base/utils/TypeUtils','sap/viz/modules/dispatch','sap/viz/modules/util/MNDHandler',
'sap/viz/util/ColorSeriesGenerator','sap/viz/util/Scaler','sap/viz/util/NumberUtils',
'sap/viz/modules/util/tooltipDataHandler','sap/viz/base/utils/Objects','sap/viz/lang/langManager',
'sap/viz/modules/util/BoundUtil','sap/viz/modules/util/defaultSelectionUtil','sap/viz/modules/Constants'],
function Setup(TypeUtils, dispatch, MNDHandler, ColorSeries, Scaler, NumberUtils,tooltipDataHandler,Objects, langManager, BoundUtil, defaultSelUtil,Constants) {
  var boxplot = function(manifest, ctx) {
    var CLASSDATAPOINT=Constants.CSS.CLASS.DATAPOINT,
        CLASSMORPHABLEDATAPOINT = Constants.CSS.CLASS.MORPHABLEDATAPOINT,
        SEL_CLASSDATAPOINT='.'+CLASSDATAPOINT;
    
    var CLASSDATAPOINTCOMBINED = CLASSDATAPOINT + ' ' + CLASSMORPHABLEDATAPOINT;
    
    var CSSCLASS_HOVERLINE = 'v-hovershadow';
    var sWrapper = null, 
      dimensionGroup = [], 
      dimensionDomain = [], 
      seriesData = [], 
      legendData = [], 
      regionData = [], 
      dimensionData = [], 
      boxplotData = [],
      colorPalette = [],
      boxColorPalette = [],
      _data = null; 
    var  dimensions = {
        'sap.viz.modules.horizontalboxplot.dimension' : {
                'key' : 'sap.viz.modules.horizontalboxplot.dimension',
                'values' : null
        }
      };

    var width,
      height, 
      yScale = d3.scale.ordinal(),
      xScale = d3.scale.linear(),
      yDimensionScale = d3.scale.ordinal(),
      decorativeShape,
      boxWidth,
      boxHeight,
      lastHovered = null,
      tooltipVisible = true,
      hasDefaultSelection = false,
      scaleMinMax = {
          min: 0,
          max: 0
      },
      scaleManualRange = false,
      effectManager = ctx.effectManager,
      drawingEffect = 'normal';
    
    var _properties = {}, eDispatch = new dispatch('showTooltip', 'hideTooltip', 'initialized');
    var style = {};
    var outLierLayout = {
      width : '1',
      color : '#000000'
    };

    var quartileLayout = {
      width: '0',
      midLineColor: '#000000'
    };
    
    var lowOutLiersObj = [], highOutLiersObj = [], whiskersObj = [], lowWhiskerObj = [], highWhiskerObj = [], quartilesObj = [], outLiersObj = [];
    var keysArray = ['Maximum:', '3rd Quartile:', 'Median:', '1st Quartile:', 'Minimum:'], noValueStr = 'No value';

    var defsEnter = null,
        id = Math.floor(Math.random() * 10000);

    var makeScales = function() {
      var domain = [];
      for ( var i = 0; i < seriesData.length; i++) {
        domain.push(i);
      }
      yScale.domain(domain).rangeBands([0, height]);
      yDimensionScale.domain(dimensionDomain).rangeBands([0, height]); 

      //when all data is 0 or null, we make xScale.domain(0,1)
      if(!scaleMinMax || ( scaleMinMax.min === 0 && scaleMinMax.max === 0)){
        xScale.domain([ 0, 1 ]).range([ 0, width]);
      }else{
        xScale.domain([ scaleMinMax.min, scaleMinMax.max ]).range([ 0, width]);
      }
      if (!scaleManualRange) {
        Scaler.perfect(xScale);
      } else {
        Scaler.getRoughTickNum(xScale);
      }
    };

    chart.dimensionData = function(_)
    {
      if (!arguments.length){
        return dimensions;
      }
      dimensions = _;
      return chart;    
    };
    
    function locateBoundary(data) {
      
      if (TypeUtils.isExist(data)) {
        length = data.length;
        var firstLoop = false;
        for (var i = 0; i < length; i++) {
          
          if (data[i].length > 0) {
            if (!firstLoop) {
              scaleMinMax = findMinMax(data[i]);
              firstLoop = true;
            } else {
              var tmp = findMinMax(data[i]);
              if (tmp) {
                if (tmp.min < scaleMinMax.min) {
                  scaleMinMax.min = tmp.min;
                }
                if (tmp.max > scaleMinMax.max) {
                  scaleMinMax.max = tmp.max;
                }
              }
              
            }
          }
        }
      }
      
    }
    
    function findMinMax(range) {
      var minMax = {min:0, max:0};
      if (TypeUtils.isExist(range)) {
        range.sort( function(aObj, bObj) { return aObj.val - bObj.val; });
        
        minMax = {min: range[0].val, max: range[range.length - 1].val};
      }
      return minMax;
    }

    function clearBoxData() {
      lowOutLiersObj = [];
      highOutLiersObj = [];
      whiskersObj = [];
      lowWhiskerObj = [];
      highWhiskerObj = [];
      quartilesObj = [];
      outLiersObj = [];
    }
    
    function clearGlobalData() {
      dimensionGroup = []; 
      dimensionDomain = []; 
      seriesData = []; 
      legendData = []; 
      regionData = []; 
      dimensionData = []; 
      boxplotData = []; 
    }

    function even(n) {
      return (n & 1) == 0;
    }

    function median(distribution, start, end) {
      var n = end - start + 1;
      if (n <= 0)
        return -1;

      var ret;
      var ctxValue = distribution[start + Math.floor((n + 1) / 2) - 1].ctx;
      var infoValue = distribution[start + Math.floor((n + 1) / 2) - 1].info;

      if (even(n)) {
        ret = (distribution[start + Math.floor((n + 1) / 2) - 1].val + distribution[start
            + Math.floor((n + 1) / 2)].val) / 2;
      } else {
        ret = distribution[start + Math.floor((n + 1) / 2) - 1].val;
      }
      return {
        'ctx' : ctxValue,
        'info': infoValue,
        'val' : ret
      };
    }

    function setDistribution(distribution) {

      if (distribution && distribution.length > 0) {
        var n = distribution.length,
          box = {
            'Maximum:': null,
            '3rd Quartile:': null,
            'Median:': null,
            '1st Quartile:': null,
            'Minimum:': null  
          };
        
        var midLine = median(distribution,  0,  n - 1);
        box['Median:'] = midLine;
          
        //Q1 is the median of the first half of the set; we add the median to
        // it if the whole set length is even
        var bak = distribution[Math.floor(n / 2)];
        distribution[Math.floor(n / 2)] = midLine;
        var boxBottom = median(distribution, 0, Math.floor(n / 2));
        distribution[Math.floor(n / 2)] = bak;
        
        // Q3 is the median of the second half of the set; we add the median to
        // it if the whole set length is even
        bak = distribution[Math.floor((n - 1) / 2)];
        distribution[Math.floor((n - 1) / 2)] = midLine;
        var boxTop  = median(distribution, Math.floor((n - 1) / 2), n - 1);
        distribution[Math.floor((n - 1) / 2)] = bak;
        box['3rd Quartile:'] = boxTop;
        box['1st Quartile:'] = boxBottom;
          
        // inter-quartile range
        var iqr = boxTop.val - boxBottom.val;
        // lower adjacent limit
        var lal = boxBottom.val - 1.5 * iqr;
        // upper adjacent limit
        var ual = boxTop.val + 1.5 * iqr;

        // search for the lowest non outlier
        var i = 0;
        while (distribution[i].val < lal)
          i++;
        lowWhisker = distribution[i];
        box['Minimum:'] = lowWhisker;

        if (lowWhisker) {
          if (boxBottom) {
            if (boxBottom.val != lowWhisker.val) {
              lowWhiskerObj.push({
                'pair' : [boxBottom, lowWhisker],
                'ctx' : [lowWhisker.ctx],
                'val' : [lowWhisker.val], //[boxBottom.val, lowWhisker.val],
                'info' : [lowWhisker.info],
              });
            }
          }
        }

        // low outliers are all the values lower than lowest non outlier
        for ( var k = 0; k < i; k++)
          outLiersObj.push(distribution[k]);

        // search for the largest non outlier
        var j = n - 1;
        while (distribution[j].val > ual)
          j--;
        var highWhisker = distribution[j];
        box['Maximum:'] = highWhisker;

        for ( var k = 0; k < n - j - 1; k++)
          outLiersObj.push(distribution[j + 1 + k]);

        if (outLiersObj.length > 0) {
          box['outLiers(s)'] = outLiersObj.length;
        }

        if (highWhisker) {
          if (boxTop) {
            if (boxTop.val != highWhisker.val) {
              highWhiskerObj.push({
                'pair' : [highWhisker, boxTop],
                'ctx' : [highWhisker.ctx],
                'val' : [highWhisker.val], //highWhisker.val, boxTop.val
                'info' : [highWhisker.info]
              });
            }
          }
        }

        if (boxBottom && boxTop && midLine) {
          if (boxBottom.val == boxTop.val) {
            quartilesObj.push({
              'pair' : [boxBottom, boxBottom],
              'midLine': null,
              'ctx' : [boxBottom.ctx],
              'val' : [boxBottom.val],
              'info' : [boxBottom.info]
            });
          } else if (midLine.val == boxTop.val) {
            quartilesObj.push({
              'pair' : [boxTop, boxBottom],
              'midLine': null,
              'ctx' : [boxTop.ctx],
              'val' : [boxTop.val],//, boxBottom.val
              'info' : [boxBottom.info]
            });
          } else if (midLine.val == boxBottom.val) {
            quartilesObj.push({
              'pair' : [boxTop, boxBottom],
              'midLine': null,
              'ctx' : [boxBottom.ctx],
              'val' : [boxBottom.val],//boxTop.val, 
              'info' : [boxBottom.info]
            });
          } else {
            quartilesObj.push({
              'pair' : [boxTop, midLine],
              'midLine': midLine,
              'ctx' : [boxTop.ctx],
              'val' : [boxTop.val],
              'info' : [boxTop.info]
            });
            quartilesObj.push({
              'pair' : [midLine, boxBottom],
              'midLine': midLine,
              'ctx' : [boxBottom.ctx],
              'val' : [boxBottom.val],
              'info' : [boxBottom.info]
            });
          }
        }
        boxplotData.push(box);
      }
    }
      
    function chart(selection) { 
      BoundUtil.drawBound(selection, width, height);
      selection.each(function() {
          
        boxNumber = 1, boxGroupNumber = seriesData.length, boxHeight = 8 * (yScale.rangeBand()) / (9 * boxNumber + 7);
  
          var svg = sWrapper = d3.select(this);
          svg.selectAll('g.v-box').remove();
          
          if(decorativeShape == null){
            decorativeShape = svg.append('rect').attr('width', width).attr('height', yScale.rangeBand() - boxHeight/2).attr('visibility', 'hidden').attr('fill', style.hoverline.fill).attr('class', CSSCLASS_HOVERLINE);
          }else{
            decorativeShape.attr('width', width).attr('height', yScale.rangeBand() - boxHeight/2).attr('visibility', 'hidden');
          }

          if(defsEnter === null){
            defsEnter = svg
              .append('defs')
              .append('clipPath').attr('id', 'clipPlot_' + id)
              .append('rect').attr('width', width).attr('height', height);
          }else{
            defsEnter.attr('width', width).attr('height', height);
          }

          var datashapesgroup = svg.selectAll('g.v-datashapesgroup');
          if(!TypeUtils.isExist(datashapesgroup[0][0])){
            datashapesgroup = svg.append('g').attr('class', 'v-datashapesgroup').attr("clip-path", "url(#clipPlot_" + id + ")").attr("fill", "none");
          }

          var boxGroup = datashapesgroup.selectAll('g.v-box').data(seriesData);

          boxGroup.enter().append('g');
          boxGroup.attr('class', 'v-box').each( function(boxData, outerIndex) {
              
            if (boxData.length == 0) {
              boxplotData.push({});
              return;
            }
            
            boxData = boxData.sort(function(aObj, bObj) { return aObj.val - bObj.val; });
    
                var arrLength = boxData.length, min = boxData[0], max = boxData[arrLength - 1];
    
                setDistribution(boxData);
    
                var outLiersSelector = d3.select(this).selectAll('circle.outliers').data(outLiersObj);
                outLiersSelector.enter().append('circle');
                outLiersSelector.attr('cy', function(outLier) {
                  var y = yScale(outerIndex) + boxHeight;
                  return y;
                })
                .attr('cx', function(outLier, num) {
                  var x = xScale(outLier.val);
                  return x;
                })
                .attr('r', '2')
                //.attr('shape-rendering', 'crispEdges')
                .attr('stroke', effectManager.register(
                                                    {
                                                  drawingEffect : 'normal',
                                                  fillColor : outLierLayout.color
                                                  }
                                                      )
             )
                .attr('stroke-width', outLierLayout.width)
                .attr('fill', 'none')
                .attr('class', CLASSDATAPOINTCOMBINED+' v-outliers');
                
                outLiersSelector.exit().remove();
    
                var quartileSelector = d3.select(this).selectAll('rect.quartile').data(quartilesObj);
                quartileSelector.enter().append('rect');
                quartileSelector.attr('y', function(quartile) {
                  var y = yScale(outerIndex) + boxHeight / 2;
                  return y;
                })
                .attr('x', function(quartile, num) {
                  var x = xScale(quartile.pair[1].val);
                  return x;
                })
                .attr('height', boxHeight)
                .attr('width', function(quartile, num) {
                  var width = 0;
                  var pairDiff = quartile.pair[0].val - quartile.pair[1].val;
                  if (pairDiff == 0) {
                    width = 1;
                  } else {
                    width = xScale(quartile.pair[0].val) - xScale(quartile.pair[1].val);
                  }
  
                  return width;
                })
                .attr('shape-rendering', 'crispEdges')
                .attr( 'fill', function(d){
                  var parameter = {
                      drawingEffect : drawingEffect,
                      fillColor : boxColorPalette[outerIndex % boxColorPalette.length],
                      direction : 'vertical'
                    };
            return effectManager.register(parameter);                
                })
                .attr('stroke-width', quartileLayout.width)
                //.attr('stroke', '#000000')
                .attr('class', CLASSDATAPOINTCOMBINED+' v-quartile');
                
                if (quartilesObj.length == 2) {
                  var midLineYStart = yScale(outerIndex) + boxHeight / 2;
                  var midLineYEnd = midLineYStart + boxHeight;
                  var midLineXStart = midLineXEnd = xScale(quartilesObj[0].midLine.val);
                  var lineSelector = d3.select(this);
                  lineSelector.append('line')
                  .attr('x1', midLineXStart)
                  .attr('y1', midLineYStart)
                  .attr('x2', midLineXEnd)
                  .attr('y2', midLineYEnd)
                  .attr('stroke', '#ffffff')
                  .attr('stroke-width', 1)
                  .attr('shape-rendering', 'crispEdges')
                  .attr('class', 'v-midline');
                }
                
                quartileSelector.exit().remove();
    
                var verticalLineXStart = 0, verticalLineYStart = 0, verticalLineXEnd = 0, verticalLineYEnd = 0;
                var horizontalLineXStart = 0, horizontalLineYStart = 0, horizontalLineXEnd = 0, horizontalLineYEnd = 0;
                var whiskerSelector = d3.select(this).selectAll('rect.v-rectlowwhisker').data(lowWhiskerObj);
                whiskerSelector.enter().append('rect');
                whiskerSelector.attr('y', function(whisker) {
                  var y = yScale(outerIndex) + boxHeight / 2;
                  horizontalLineYStart = horizontalLineYEnd = y + boxHeight / 2 ;
                  verticalLineYStart = y;
                  verticalLineYEnd = y + boxHeight;
                  return y;
                  })
                  .attr('x', function(whisker) {
                    var x = xScale(whisker.pair[1].val);
                    horizontalLineXStart = x;
                    verticalLineXStart = verticalLineXEnd = x;
                    return x;
                   })
                  .attr('height', boxHeight)
                    .attr('width', function(whisker) {
                      var width = xScale(whisker.pair[0].val) - xScale(whisker.pair[1].val);
                      horizontalLineXEnd = xScale(whisker.pair[1].val) + width;
                      var lineSelector = d3.select(this.parentNode);
                      lineSelector.append('line')
                      .attr('x1', verticalLineXStart)
                      .attr('y1', verticalLineYStart)
                      .attr('x2', verticalLineXEnd)
                      .attr('y2', verticalLineYEnd)
                      .attr('stroke', function(d){
                           var parameter = {
                                 drawingEffect : 'normal',
                                 fillColor : boxColorPalette[outerIndex % boxColorPalette.length]
                                };
                         return effectManager.register(parameter);  
                             }
                           )
                      .attr('stroke-width', 1)
                      .attr('shape-rendering', 'crispEdges')
                      .attr('class', 'v-lineverticallowwhisker');
                    
                    var lineSelector = d3.select(this.parentNode);
                    lineSelector.append('line')
                    .attr('x1', horizontalLineXStart)
                    .attr('y1', horizontalLineYStart)
              .attr('x2', horizontalLineXEnd)
                    .attr('y2', horizontalLineYEnd)
                    .attr('stroke', effectManager.register(
                                            {
                                              drawingEffect : 'normal',
                                              fillColor : '#000000'
                                            }
                                          )
                               )
                    .attr('stroke-width', 1)
                    .attr('shape-rendering', 'crispEdges')
                    .attr('class', 'v-linehorizontallowwhisker v-innerwhisker');
                    return width;
                    })
                .attr('shape-rendering', 'crispEdges')
                .attr('fill-opacity', '0')
                .attr('stroke-width', '0')
                .attr('class', CLASSDATAPOINTCOMBINED+' v-rectlowwhisker');
                
                whiskerSelector.exit().remove();
                
                var verticalLineXStart = 0, verticalLineYStart = 0, verticalLineXEnd = 0, verticalLineYEnd = 0;
                var horizontalLineXStart = 0, horizontalLineYStart = 0, horizontalLineXEnd = 0, horizontalLineYEnd = 0;
                var whiskerSelector = d3.select(this).selectAll('rect.v-recthighwhisker').data(highWhiskerObj);
                whiskerSelector.enter().append('rect');
                whiskerSelector
                    .attr('y', function(whisker) {
                      var y = yScale(outerIndex) + boxHeight / 2;
              horizontalLineYStart = horizontalLineYEnd = y + boxHeight / 2;
              verticalLineYStart = y;
              verticalLineYEnd = y + boxHeight;
                      return y;
                      })
                    .attr('x', function(whisker, num) {
                      var x = xScale(whisker.pair[1].val);
                    horizontalLineXStart = x;
                    verticalLineXStart = verticalLineXEnd = xScale(whisker.pair[0].val);
                      return x;
                      })
                    .attr('height', boxHeight)
                    .attr('width', function(whisker, num) {
                      var width = xScale(whisker.pair[0].val) - xScale(whisker.pair[1].val);
                      horizontalLineXEnd = xScale(whisker.pair[1].val) + width;
                      var lineSelector = d3.select(this.parentNode);
                      lineSelector.append('line')
                      .attr('x1', verticalLineXStart)
                      .attr('y1', verticalLineYStart)
                      .attr('x2', verticalLineXEnd)
                      .attr('y2', verticalLineYEnd)
                      .attr('stroke',  function(d){
                              var parameter = {
                           drawingEffect : 'normal',
                           fillColor : boxColorPalette[outerIndex % boxColorPalette.length]
                          };
                              
                                    return effectManager.register(parameter);  
                                }
                           )
                      .attr('stroke-width', 1)
                      .attr('shape-rendering', 'crispEdges')
                      .attr('class', 'v-lineverticalhighwhisker');
  
                      var lineSelector = d3.select(this.parentNode);
                      lineSelector.append('line')
                      .attr('x1', horizontalLineXStart)
                      .attr('y1', horizontalLineYStart)
                      .attr('x2', horizontalLineXEnd)
                      .attr('y2', horizontalLineYEnd)
                      .attr('stroke', effectManager.register(
                                      {
                                        drawingEffect : 'normal',
                                        fillColor : '#000000'
                                      }
                                    )
                                 )
                      .attr('stroke-width', 1)
                      .attr('shape-rendering', 'crispEdges')
                      .attr('class', 'v-linehorizontalhighwhisker v-innerwhisker');
                       
                      return width;
                      })
                      .attr('shape-rendering', 'crispEdges')
                      .attr('fill-opacity', '0')
                      .attr('stroke-width', '0')
                      .attr('class', CLASSDATAPOINTCOMBINED+' v-recthighwhisker');
                
                whiskerSelector.exit().remove();               
                clearBoxData();   
          });
          eDispatch.initialized();
          boxGroup.exit().remove();
      });
    return chart;
    };
  
    chart.width = function(value) {
      if (!arguments.length) {
        return width;
      }
      
      width = value;
      if (TypeUtils.isExist(width) && TypeUtils.isExist(height) && TypeUtils.isExist(seriesData)) {
        makeScales();
      }
      return chart;
    };
      
    chart.height = function(value) {
      if (!arguments.length) {
        return height;
      }

      height = value;
      if (TypeUtils.isExist(width) && TypeUtils.isExist(height) && TypeUtils.isExist(seriesData)) {
        makeScales();
      }
      return chart;
    };  
    
    var handleNull = function(_) {
      if (_ === null || _ === undefined) {
        return defaultString;
      } else {
        return _;
      }
    };
  
    function getTooltipData(index) {
      
      var tooltipData =  {
          'body': [],
          'footer': []
        },
        internalIndex = 0;
      
      if (regionData) {

        var body = {
          'name': null,
          'val': []
        };
        
        internalIndex = index % regionData.length;
        body.name = regionData[internalIndex].name;
  
        if (regionData[internalIndex].label != null && regionData[internalIndex].shape != null && boxColorPalette[internalIndex] != null) {
          var item = {
              'shape': null,
              'color': null,
              'label': null,
              'value': null
            };
          
          item.shape = regionData[internalIndex].shape;
          item.color = boxColorPalette[internalIndex];
          item.label = regionData[internalIndex].label;
          body.val.push(item);
        }
        
        if (boxplotData) {
          
          if (boxplotData[index]) {
            var hasData = false;
            for (var i in boxplotData[index]) {
              var item = {
                  'shape': null,
                  'color': null,
                  'label': null,
                  'value': null
                };
              hasData = true;
              item.label = i;
              if (boxplotData[index][i]) {
                if (i == 'outLiers(s)') {
                  item.value = boxplotData[index][i];
                } else {
                  item.value = boxplotData[index][i].val;
                }
              }
              body.val.push(item);
            }
            
            if (!hasData) {
              for (var j = 0; j < keysArray.length; j++) {
                var item = {};
                item.label = keysArray[j];
                item.value = noValueStr;
                item.color = null;
                item.shape = null;
                body.val.push(item);
              }
            }
          }
        }
        
        tooltipData.body.push(body);
      }
      
      if (dimensionData) {
        internalIndex = Math.floor(index / regionData.length);
        for (var i = 0; i < dimensionData.length; i++) {
          
          if (dimensionData[i].rows.length > 0) {
            var footer = {
                'label': null,
                'value': null
              };
            footer.label = dimensionData[i].col;
            footer.value = dimensionData[i].rows[internalIndex];
            
            tooltipData.footer.push(footer);
          }
        }
      }
      
      return tooltipData;
    }
    
    function generateTooltipData() {
      
      if (dimensions) {
        for (var i in dimensions) {
          dimensionData = dimensions[i].values;
        }
      }
      
      if (legendData) {
        var legendList = legendData.values;
        if (legendList.length > 1) {
          if (legendList[0].type == 'MND') {
            //mnd scan
            for (var mndIndex = 0; mndIndex < legendList[0].rows.length; mndIndex++) {

              //vertical scan
              for (var m = 0; m < legendList[1].rows.length; m++) {
                var legendObj = {
                    'name': null,
                    'shape': null,
                    'color': null,
                    'label': null
                  };
                legendObj.name = legendList[0].rows[mndIndex];
                var label = [];
                
                //horizontal scan
                for (var n = 1; n < legendList.length; n++) {
                  label.push(legendList[n].rows[m]);
                }
                legendObj.label = label;
                regionData.push(legendObj);
              }    

            }
          } else if (legendList[legendList.length - 1].type == 'MND') {

            for (var m = 0; m < legendList[0].rows.length; m++) {

              var label = [];
              for (var n = 0; n < legendList.length - 1; n++) {
                label.push(legendList[n].rows[m]);              
              }
              

              for (var mndIndex = 0; mndIndex < legendList[legendList.length - 1].rows.length; mndIndex++) {
                var legendObj = {
                    'name': null,
                    'shape': null,
                    'color': null,
                    'label': null
                  };
                legendObj.label = label;
                legendObj.name = legendList[legendList.length - 1].rows[mndIndex];
                regionData.push(legendObj);
              }
            }
          } 
        } else {
          for (var m = 0; m < legendList[0].rows.length; m++) {
            var legendObj = {
                'name': null,
                'shape': null,
                'color': null,
                'label': null
              };
            legendObj.name = legendList[0].rows[m];
            regionData.push(legendObj);
          }
        }
      }
      
      for (var k = 0; k < regionData.length; k++) {
        //regionData[k].color = boxColorPalette[k % boxColorPalette.length];
        regionData[k].shape = 'squareWithRadius';
      }
    }

    function setElementAttribute(element, attribute, value) {
      if (element) {
        var className = element.getAttribute('class');
        if(className.indexOf('v-recthighwhisker') == -1 && className.indexOf('v-rectlowwhisker') == -1
           && className.indexOf('v-linehorizontalhighwhisker') == -1 && className.indexOf('v-lineverticalhighwhisker') == -1
           && className.indexOf('v-linehorizontallowwhisker') == -1 && className.indexOf('v-lineverticallowwhisker') == -1) {
          element.setAttribute(attribute, value);
        }else if (className.indexOf('v-recthighwhisker') != -1) {
          var nodeList = element.parentNode.querySelectorAll('line');
          if (nodeList) {
            for (var j = 0, nodeListLen = nodeList.length; j < nodeListLen; j++) {
              var nodeClassName = nodeList[j].getAttribute('class');
              if (nodeClassName.indexOf('v-linehorizontalhighwhisker') != -1 || nodeClassName.indexOf('v-lineverticalhighwhisker') != -1) {
                nodeList[j].setAttribute(attribute, value);
              }
            }
          }
        } else if(className.indexOf('v-rectlowwhisker') != -1) {
          var nodeList = element.parentNode.querySelectorAll('line');
          if (nodeList) {
            for (var j = 0, nodeListLen = nodeList.length; j < nodeListLen; j++) {
              var nodeClassName = nodeList[j].getAttribute('class');
              if (nodeClassName.indexOf('v-linehorizontallowwhisker') != -1 || nodeClassName.indexOf('v-lineverticallowwhisker') != -1) {
                nodeList[j].setAttribute(attribute, value);
              }
            }
          }        
        }      
      }
    }
    
      chart.parent = function(){
        return sWrapper;
      };
      
      chart.highlight = function(elems){
        if(elems instanceof Array){
          for(var i = 0, elemsLen = elems.length; i < elemsLen; i++) {
          var item = elems[i];
          setElementAttribute(item, 'opacity', 1);
          }
        }else{
        setElementAttribute(elems, 'opacity', 1);
        }
        if(hasDefaultSelection){
          defaultSelUtil.clearSelectionInfo(sWrapper, true, elems);
        }
      };
      
      chart.unhighlight = function(elems){
        if(elems instanceof Array){
          for(var i = 0, len = elems.length; i < len; i++){
          var item = elems[i];
          setElementAttribute(item, 'opacity', 0.4);
          }
        }else{
        setElementAttribute(elems, 'opacity', 0.4);
        }
        if(hasDefaultSelection){
          defaultSelUtil.clearSelectionInfo(sWrapper, false, elems);
        }
      };
      
      chart.clear = function(gray){
        if( gray == null || gray == false){
          sWrapper.selectAll(SEL_CLASSDATAPOINT).attr('opacity', 1);
          sWrapper.selectAll('.v-lineverticallowwhisker').attr('opacity', 1);
          sWrapper.selectAll('.v-lineverticalhighwhisker').attr('opacity', 1);
          sWrapper.selectAll('.v-linehorizontallowwhisker').attr('opacity', 1);
          sWrapper.selectAll('.v-linehorizontalhighwhisker').attr('opacity', 1);
          if(hasDefaultSelection){
            defaultSelUtil.clearSelectionInfo(sWrapper, false, sWrapper.selectAll(SEL_CLASSDATAPOINT));
          }
          
        }else{
          sWrapper.selectAll(SEL_CLASSDATAPOINT).attr('opacity', 0.4);
          sWrapper.selectAll('.v-lineverticallowwhisker').attr('opacity', 0.4);
          sWrapper.selectAll('.v-lineverticalhighwhisker').attr('opacity', 0.4);
          sWrapper.selectAll('.v-linehorizontallowwhisker').attr('opacity', 0.4);
          sWrapper.selectAll('.v-linehorizontalhighwhisker').attr('opacity', 0.4);
        }
        
        sWrapper.selectAll('.v-recthighwhisker').attr('opacity', 0);
        sWrapper.selectAll('.v-rectlowwhisker').attr('opacity', 0);
      };
  
      chart.hoverOnPoint = function(point){
        var xOnModule = point.x, yOnModule = point.y;
      // find the closet dimension
      var i = -1;
      while (i < seriesData.length) {
        if (Math.abs(yOnModule - yScale.rangeBand()*i - 0.5 * yScale.rangeBand() ) <= 0.5 * yScale.rangeBand()) {
          break;
        }
        i++;
      }

      if (i > (seriesData.length - 1)
          || i < 0) {
        decorativeShape.attr(
            'visibility', 'hidden');
        return;
      }
      
      decorativeShape.attr(
          'y',
          yScale.rangeBand() * i + boxHeight/4).attr(
          'visibility', 'visible');
      
      if(lastHovered !== i){
        if (tooltipVisible) {
          lastHovered = i;
          //this.parentNode point to plot graphic. it is different from bar chart as in bar chart it should get the yoffset which can get it from mian graphic element.
          var transform = sWrapper[0][0].getTransformToElement(sWrapper[0][0].ownerSVGElement);
          var yoffset = transform.f;
          
          var tooltipData = getTooltipData(i);
          
          tooltipData.point = {
              x: point.x,
              y: yScale.rangeBand()*i + 0.5 * yScale.rangeBand() + yoffset
          };
          tooltipData.plotArea = {
                        x : transform.e,
                        y : transform.f,
                        width : width,
                        height : height
                    };
          eDispatch.showTooltip(tooltipDataHandler.formatTooltipData(tooltipData));
        }
      }
      
      };
  
      chart.blurOut = function(){
        decorativeShape.attr('visibility', 'hidden');
        lastHovered = null;
      if (tooltipVisible) {
          eDispatch.hideTooltip();
      }
      };
      
      function makeSubGroup(row, start, end, groups, parentGroupIndex) {
      if (row && start <= end && end < row.length) {
        var subStart = subEnd = pos = start;
        while (pos <= end) {
          var contexts = []; 
          while (((pos+1) <= end) && (row[pos + 1].val == row[pos].val)) {
            contexts.push(row[subEnd].ctx);
            subEnd++;
            pos++;
          }
          if(subEnd < row.length)
          {
            contexts.push(row[subEnd].ctx);
          }
          row[subStart].contexts = contexts;
          groups.push({
            'val': row[subStart],
            'parentGroupIndex': parentGroupIndex,
            'start': subStart,
            'end': subEnd
          });
          pos++;
          subStart = subEnd = pos;
        }          
      }
    }

    
    function generateGroup(row) {
      var curGroups = [];
      if (row) {
        var mapLen = dimensionGroup.length;
        var preGroups = mapLen > 0?dimensionGroup[mapLen - 1].val : null;
        if (preGroups) {
          for (var i = 0, len = preGroups.length; i < len; i++) {
            var preGroup = preGroups[i];
            var start = preGroup.start;
            var end = preGroup.end;
            makeSubGroup(row, start, end, curGroups, i );
          }
        } else {
          makeSubGroup(row, 0, row.length - 1, curGroups, null);
        }
      }
      return curGroups;
    }

    function dataTransform(originalData) {
      if (originalData) {
        var originalDimension = originalData.getAnalysisAxisDataByIdx(0);
        legendData = originalData.getAnalysisAxisDataByIdx(1);
        if (originalDimension) {
          var len = originalDimension.values.length;
          if (len == 1) {
            dimensionGroup.push({'col': originalDimension.values[0].col.val, 'val': []});
          } else {
            for (var i = 0; i < len - 1; i++) {
              var row = originalDimension.values[i].rows;
              dimensionGroup.push({'col': originalDimension.values[i].col.val, 'val': generateGroup(row)});
            }
          }
        }
      }
    }
    
    function caculateLeavesNum(start, end) {
      
      var len = dimensionGroup.length, num = 0, index = 0, leavesGroups = dimensionGroup[len - 1].val;
      while (leavesGroups[index].start != start) {
        index++;
      }      
      while (leavesGroups[index].end != end) {
        num++;
        index++;
      }
      num++;
      return num;
    }

    function generateDimensions() {
      if (dimensionGroup) {
        var len = dimensionGroup.length, groups = null;
        
        groups = dimensionGroup[len - 1].val;
        if (groups.length == 0) {
          dimensionDomain.push(0);
          dimensionDomain.push(1);
        } else {
          for (var i = 0, lenScale = groups.length; i < lenScale; i++) {
            dimensionDomain.push(i);
          }
        }
        
        if (groups.length == 0) {
          dimensions['sap.viz.modules.horizontalboxplot.dimension'].values = [{'col': {'val': dimensionGroup[len - 1].col}, 'rows': []}];
        } else {
          
          var scaleValues = [];
          for (var j = 0; j < len; j++) {
            var obj = {
              'col': {'val': ''},
              'rows': []
            };
            obj.col.val = dimensionGroup[j].col;
            var rowGroups = dimensionGroup[j].val;
            for (var k = 0,  lenRowGroups =  rowGroups.length; k < lenRowGroups; k++) {
              var start = rowGroups[k].start, end = rowGroups[k].end, num = caculateLeavesNum(start, end);
              for (var m = 0; m < num; m++) {
                obj.rows.push({
                  'val': handleNull(rowGroups[k].val.val),
                  'info' : rowGroups[k].val.info,
                  'contexts' : rowGroups[k].val.contexts
                });
              }
            }
            
            scaleValues.push(obj);
          }
              
          dimensions['sap.viz.modules.horizontalboxplot.dimension'].values = scaleValues;
        }        
      }      
    }
  
    function createColorPalette(length) {
      boxColorPalette = [];
      if (colorPalette.length > 0) {
        for( var i = 0; i < length; ++i) {
          boxColorPalette.push(colorPalette[i % colorPalette.length]);
        }
      }
    }
      function parseOptions(){
      tooltipVisible = _properties.tooltip.enabled ;
        colorPalette = _properties.colorPalette;
        drawingEffect = _properties.drawingEffect;
      }
      
    chart.data = function(value) {
      if (!arguments.length) {
        return _data;
      }
      
      clearGlobalData();
      parseOptions();
      
      _data = value;
        var obj = MNDHandler(_data);
        dataTransform(_data);
        var dataMG1 = obj["MG1"];
        
        if( dataMG1[0] && dataMG1[0][0].info && dataMG1[0][0].info.defaultSelection){
          hasDefaultSelection = true;
        }else{
          hasDefaultSelection = false;
        } 
        
      var len = dataMG1.length;
      var groups = dimensionGroup[dimensionGroup.length - 1].val;
      if (groups.length != 0) {
        for (var i = 0, groupsLen = groups.length; i < groupsLen; i++) {
          var start = groups[i].start, end = groups[i].end;
          for (var j = 0; j < len; j++) {
            var row = [], left = start, right = end;
            for (;left <= right; left++) {
              if (!NumberUtils.isNoValue(dataMG1[j][left].val))
                row.push(dataMG1[j][left]);
            }
            seriesData.push(row);
          }
        }
      } else {
        for (var j = 0; j < len; j++) {
          var row = [];
          for (var m = 0; m < dataMG1[j].length; m++) {
            if (!NumberUtils.isNoValue(dataMG1[j][m].val)) {
              row.push(dataMG1[j][m]);
            } 
          }
          seriesData.push(row);
        }
      }
        
      locateBoundary(seriesData);
      generateDimensions();
      
      if (TypeUtils.isExist(width) && TypeUtils.isExist(height)) {
        makeScales();
      }
      
      generateTooltipData();
            createColorPalette(regionData.length);
      
      return chart;
    };
    
    chart.primaryAxisTitle = function(_){
        if(!arguments.length){
          var titles =  _data.getMeasureValuesGroupDataByIdx(0), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join(' & ');
        }
        return this;
      };
      
      chart.secondAxisTitle = function(_){
        if(!arguments.length){
          var titles =  _data.getMeasureValuesGroupDataByIdx(1), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join(' & ');
        }
        return this;
      };
      
    chart.properties = function(props){

        if (!arguments.length){
          return _properties;
         }
      
      Objects.extend(true, _properties, props);
            parseOptions();
            createColorPalette(regionData.length);
            
         return chart;        
      };
    
    chart.categoryScale = function(scale){
      if (!arguments.length){
        return yDimensionScale;
      }
      yDimensionScale = scale;
      return chart;
     };
     
    chart.primaryScale = function(scale){
      if (!arguments.length){
        return xScale;
      }
      xScale = scale;
      return chart;
    };

    chart.primaryDataRange = function(range){
      if (!arguments.length){
        return {
          min: scaleMinMax.min,
          max: scaleMinMax.max
        };
      }
      var tempMax, tempMin;
      if (range !== null) {
          if (!isNaN(range.max)) {
            tempMax = range.max;
          } else {
            tempMax = xScale.perfectDomainEnd;
          }
          if (!isNaN(range.min)) {
            tempMin = range.min;
          } else {
            tempMin = xScale.perfectDomainBegin;
          }
          if (tempMax > tempMin) {
            scaleMinMax.max = tempMax;
            scaleMinMax.min = tempMin;
            if (range.from === 'axis') {
                scaleManualRange = true;
            }
            if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
              makeScales();
            }
          }
      } else {
        if (scaleManualRange === true) {
            scaleMinMax.max = xScale.perfectDomainEnd;
            scaleMinMax.min = xScale.perfectDomainBegin;
            scaleManualRange = false;
            if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
              makeScales();
            }
        }
      }
      return chart;
    };

    chart.colorPalette = function(Palette){
      if (!arguments.length){
        return colorPalette;
      }
      colorPalette = Palette;
      return chart;
     };
  
     chart.dispatch = function(_){
        if(!arguments.length)
          return eDispatch;
        eDispatch = _;
        return this;
      };

    function getCSSStyle() {
      style.hoverline = ctx.styleManager.queryDefault(CSSCLASS_HOVERLINE);
    }

    chart.destroy = function(){
      if(ctx){
        ctx.destroy();
        ctx = null;
      }
      
      sWrapper = null;
      yScale.domain([0,1]).range([0,1]);
      yScale = null;
      xScale.domain([0,1]).range([0,1]);
      xScale = null;
      yDimensionScale.domain([0,1]).range([0,1]);
      yDimensionScale = [];
      
      decorativeShape = null; 
      dimensionGroup = [], 
      dimensionDomain = [], 
      seriesData = [], 
      legendData = [], 
      regionData = [], 
      dimensionData = [], 
      boxplotData = [],
      colorPalette = [],
      boxColorPalette = [],
      _data = null; 
      dimensions = null;
      
    };
    
    getCSSStyle();
    _properties = manifest.props(null);
    return chart;
  };

  return boxplot;
});
define('sap/viz/modules/manifests/xy/HorizontalBoxplot',['sap/viz/modules/manifests/Module','sap/viz/modules/horizontalboxplot','sap/viz/modules/manifests/xy/Base'],
function Setup(Manifest, fn) {
  var module = {
    'id' : 'sap.viz.modules.horizontalboxplot',
    'name' : 'horizontal boxplot',
    base : "sap.viz.modules.xy.base",
    'properties' : { 
          'primaryValuesColorPalette' : { 'isExported' : false },
          'secondaryValuesColorPalette' : { 'isExported' : false },
          'tooltip' : {
            'name' : 'tooltip',
            'supportedValueType' : 'Object',
            'supportedValues' : {
              'enabled' : {
                'name' : 'enabled',
                'supportedValueType' : 'Boolean',
                'defaultValue' : true,
                'description' : 'Set enabled/disabled tooltip.'
              }
            },
            'isExported' : false,
            'description' : 'Settings for tooltip related properties.'
          }
    },
    'feeds' : {
      configure : {
          secondaryValues:null,
          axisLabels:{
            acceptMND: -1,
            min : 1,
            max : 1
          }
      }
    },
    'css' : {
        '.v-hovershadow' : {
            'description' : 'Define style for hover shadow color.',
            'value' : {
                'fill' : '#cccccc',
            }
        }
    },
    fn : fn
  };

  Manifest.register(module);
});
define('sap/viz/manifests/xy/HorizontalBoxplotChart',['sap/viz/manifests/Viz','sap/viz/modules/manifests/RootContainer','sap/viz/modules/manifests/xy/HorizontalBoxplot',
'sap/viz/manifests/xy/BaseHorizontalChart','sap/viz/modules/manifests/controller/Interaction'],
function Setup(Manifest) {
    var chart = {
      id : 'viz/horizontal_boxplot',
      name : 'IDS_HORIZONTALBOXPLOTCHART',
      base : 'riv/basehorizontalchart',
      modules : {
        root : {
          modules : {
            tooltip : {
              id : 'sap.viz.modules.tooltip',
              configure : {
                propertyCategory : 'tooltip',
                properties : {
                  chartType : 'horizontalboxplot',
                  orientation : 'left'
                }
              }
          },
          interaction : {
            id : 'sap.viz.modules.controller.interaction',
            configure : {
              clientID : "main",
              propertyCategory : 'interaction'
            }
          },
          main : {
              modules : {
                dataLabel:null,
                yAxis : {
                  id : 'sap.viz.modules.axis',
                  configure : {
                    properties : {
                      isIndependentMode : true
                    }
                  }
                },
                plot : {
                  id : 'sap.viz.modules.horizontalboxplot',
                  configure : {
                    'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                    propertyCategory : 'plotArea'
                  }
                }
              }
            }
          }
        }
     },

     dependencies : {
       attributes : [ {
             targetModule : 'root.main.yAxis',
             target : 'scale',
             sourceModule : 'root.main.plot',
             source : 'categoryScale'
          },{
            targetModule : 'root.main.plot',
            target : 'primaryDataRange',
            sourceModule : 'root.main.xAxis',
            source : 'range'
          },{
            targetModule : 'root.main.xAxis',
            target : 'scale',
            sourceModule : 'root.main.plot',
            source : 'primaryScale'
          },{
             targetModule : 'root.main.xAxis',
             target : 'title',
             sourceModule : 'root.main.plot',
             source : 'primaryAxisTitle'
          },{
              targetModule : 'root.main.yAxis',
              target : 'independentData',
              sourceModule : 'root.main.plot',
              source : 'dimensionData'
          },{
              targetModule : 'root.legends.legend',
              target : 'colorPalette',
              sourceModule : 'root.main.plot',
              source : 'colorPalette'
          },{
              targetModule : 'root.legends.legend',
              target : 'setSelectionMode',
              sourceModule : 'root.interaction',
              source : 'getSelectionMode'
          } ],
           events : [ {
            targetModule : 'root.tooltip',
            listener : 'showTooltip',
            sourceModule : 'root.main.plot',
            type : 'showTooltip'
          }, {
            targetModule : 'root.tooltip',
            listener : 'hideTooltip',
            sourceModule : 'root.main.plot',
            type : 'hideTooltip'
          }, {
            targetModule : 'root.interaction',
            listener : 'registerEvent',
            sourceModule : 'root.main.plot',
            type : 'initialized'
          }, {
            targetModule : 'root.interaction',
            listener : 'highlightedByLegend',
            sourceModule : 'root.legends.legend',
            type : 'highlightedByLegend'
          }, {
            targetModule : 'root.legends.legend',
            listener : 'deselectLegend',
            sourceModule : 'root.interaction',
            type : 'deselectLegend'
          }, {
            targetModule : 'root.interaction',
            listener : 'defaultSelection',
            sourceModule : 'root.main.plot',
            type : 'initialized.defaultSelection'
          }
          ]
        }
    };
    Manifest.register(chart);
});
define('sap/viz/modules/mekko',["sap/viz/base/utils/TypeUtils", "sap/viz/modules/dispatch", "sap/viz/modules/util/MNDHandler",
    "sap/viz/modules/util/tooltipDataHandler", "sap/viz/util/ColorSeriesGenerator",
    "sap/viz/util/Scaler", "sap/viz/base/utils/ObjectUtils", "sap/viz/util/NumberUtils",
    "sap/viz/base/utils/Objects", "sap/viz/lang/langManager", "sap/viz/modules/util/BoundUtil",
    "sap/viz/modules/util/defaultSelectionUtil", "sap/viz/base/UADetector", "sap/viz/modules/Constants",
    "sap/viz/base/utils/oo", "sap/viz/modules/Base"
  ],
  function Setup(TypeUtils, dispatch, MNDHandler, tooltipDataHandler, ColorSeries, Scaler, ObjectUtils, NumberUtils, Objects, langManager, BoundUtil, defaultSelUtil, UADetector, Constants, oo, Base) {

    //////////////// shared functions, invisible from outside //////////////////////
    var updateFormerSize = function(width, height) {
      this._mko_formerWidth = width;
      this._mko_formerHeight = height;
    };
    ///////////////////////////////
    var CLASSMARKERSELECTED = Constants.CSS.CLASS.DATAPOINTSELECTED;
    var CLASSDATAPOINT = Constants.CSS.CLASS.DATAPOINT;
    var CLASSMORPHABLEDATAPOINT = Constants.CSS.CLASS.MORPHABLEDATAPOINT;

    var CSSCLASS_HOVERSHADOW = "v-hovershadow";
    var CLASSDATAPOINTCOMBINED = CLASSDATAPOINT + " " + CLASSMORPHABLEDATAPOINT;

    var DEFAULT_STRING = langManager.get("IDS_ISNOVALUE");
    var MEKKO_DIMENSION_ID = "sap.viz.modules.mekko.dimension";

    var TOTAL_INTERVAL_TIME = 1000;
    var HALF_INTERVAL_TIME = TOTAL_INTERVAL_TIME / 2;

    var Mekko = function(manifest, ctx) {
      this._mko_data = null;
      this._mko_data1 = [
        []
      ];
      this._mko_data2 = [
        []
      ];
      this._mko_seriesData = null;
      this._mko_tooltipData = [];
      this._mko_primaryAxisTopBoundary = 0;
      this._mko_primaryAxisBottomBoundary = 0;
      this._mko_primaryAxisManualRange = false;
      this._mko_secondaryAxisTopBoundary = 0;
      this._mko_secondaryAxisBottomBoundary = 0;
      this._mko_secondaryAxisManualRange = false;
      this._mko_gWrapper = null;

      this._mko_width = 0;
      this._mko_height = 0;
      this._mko_formerWidth = null;
      this._mko_formerHeight = null;
      this._mko_colorPalette = [];
      this._mko_axis1ColorPalette = [];
      this._mko_shapePalette = ["squareWithRadius"];
      this._mko_properties = manifest.props(null);
      this._mko_eDispatch = new dispatch("selectData", "deselectData", "showTooltip", "hideTooltip", "initialized", "startToInit");
      this._mko_style = {};

      this._mko_effectManager = ctx.effectManager;
      this._mko_styleManager = ctx.styleManager;

      this._mko_categoryScale = d3.scale.ordinal();
      this._mko_valueScale = d3.scale.linear();
      this._mko_valueScale2 = d3.scale.linear();
      this._mko_categoryScale.noEqual = true;

      this._mko_decorativeShape = null;
      this._mko_lastHovered = null;

      this._mko_barNumber = 1;
      this._mko_barGroupNumber = null;
      this._mko_barNumberinGroup = null;
      this._mko_barSize = null;
      this._mko_positiveIndexes = [];
      this._mko_negativeIndexes = [];

      this._mko_enableDataLoadingAnimation = true;
      this._mko_enableDataUpdatingAnimation = true;
      this._mko_enableResizingAnimation = true;
      this._mko_enableRoundCorner = false;

      this._mko_hasDefaultSelection = false;
      this._mko_isOnlyInitAnimation = false;
      this._mko_tooltipVisible = true;

      this._mko_defsEnter = null;
      this._mko_roundCornerDefs = null;
      this._mko_suffix = ObjectUtils.guid();
      this._mko_id = Math.floor(Math.random() * 10000);

      this._mko_mode = "comparison";
      this._mko_drawingEffect = "normal";

      this._mko_sizeChange = false;
      this._mko_dataStructureChange = false;
      this._mko_dataValueChange = false;
      this._mko_modeChange = false;

      this._mko_dimensionData = {};
      this._mko_dimensionData[MEKKO_DIMENSION_ID] = {
        key: MEKKO_DIMENSION_ID,
        values: [{
          col: {
            val: ""
          },
          rows: []
        }]
      };


      this._mko_rangeBounds = [];
      this._mko_rangeSum = [];

      this._mko_isHorizontal = true;
      this._mko_afterAttachToDOM = false;

      this._mkofn_getCssStyle();
    };

    oo.extend(Mekko, Base);

    Mekko.prototype.render = function(selection) {
      function generateRCId(i, j, indexinGroup) {
        return "roundCorner-clip" + "-" + indexinGroup + i + j + this._mko_suffix;
      }
      var width = this._mko_width;
      var height = this._mko_height;
      if (this._mko_formerWidth !== null && this._mko_formerHeight !== null) {
        if (!this._mko_sizeChange) {
          this._mko_sizeChange = this._mko_formerWidth !== width || this._mko_formerHeight !== height;
        }
      }
      updateFormerSize.call(this, width, height);
      BoundUtil.drawBound(selection, width, height);
      this._mkofn_recoveryValues();
      //deal with percentage mode
      if (this._mko_mode === "percentage") {
        this._mkofn_turnToPercentage();
      }
      if (this._mko_mode === "comparison") {
        this._mkofn_turnToComparison();
      }
      //if there is no scale, do not need to draw anything.
      if (!TypeUtils.isExist(this._mko_valueScale)) {
        return;
      }
      this._mko_eDispatch.startToInit();
      var that = this;
      selection.each(function() {
        var seriesData = that._mko_seriesData;

        var decorativeShape = that._mko_decorativeShape;
        var defsEnter = that._mko_defsEnter;
        var roundCornerDefs = that._mko_roundCornerDefs;
        var id = that._mko_id;
        var isHorizontal = that._mko_isHorizontal;
        var enableAnimation = that._mkofn_enableAnimation();
        var rangeBounds = that._mko_rangeBounds;
        var fillingColor = that._mko_colorPalette;

        var barNumber = (that._mko_barNumber = (TypeUtils.isExist(that._mko_data2)) ? 2 : 1);
        var rangeBand = that._mko_categoryScale.rangeBand();
        var barSize = (that._mko_barSize = 8 * rangeBand / (9 * barNumber + 7));

        var positiveIndexes = that._mko_positiveIndexes;
        var negativeIndexes = that._mko_negativeIndexes;

        var barNumberinGroup = seriesData[0][0].length;
        if (TypeUtils.isExist(seriesData[0][1])) {
          barNumberinGroup += seriesData[0][1].length;
        }
        this._mko_barNumberinGroup = barNumberinGroup;

        var barGroupNumber = seriesData.length;
        var svg = (that._mko_gWrapper = d3.select(this));
        //append decorativeShape
        if (decorativeShape === null) {
          decorativeShape = (that._mko_decorativeShape = svg.append("rect").attr("fill", that._mko_style.hovershadow.fill).attr("class", CSSCLASS_HOVERSHADOW));
        }
        decorativeShape.attr("visibility", "hidden");
        if (isHorizontal) {
          decorativeShape.attr("width", width).attr("height", rangeBand - barSize / 2);
        } else {
          decorativeShape.attr("width", rangeBand - barSize / 2).attr("height", height);
        }

        if (defsEnter === null) {
          defsEnter = (that._mko_defsEnter = svg.append("defs").append("clipPath").attr("id", "clipPlot_" + id).append("rect"));
        }
        defsEnter.attr("width", width).attr("height", height);

        if (roundCornerDefs === null) {
          roundCornerDefs = (that._mko_roundCornerDefs = svg.append("defs").attr("id", "round-corner-clip" + that._mko_suffix));
        } else if (that._mko_dataStructureChange || that._mko_sizeChange || that._mko_dataValueChange || !that._mko_enableRoundCorner) {
          roundCornerDefs.selectAll(".v-clippath").remove();
        }

        var datashapesgroup = svg.selectAll("g.v-datashapesgroup");
        if (!TypeUtils.isExist(datashapesgroup[0][0])) {
          datashapesgroup = svg.append("g").attr("class", "v-datashapesgroup").attr("clip-path", "url(#clipPlot_" + id + ")");
        }

        var barGroup = datashapesgroup.selectAll("g.v-bar").data(seriesData);
        barGroup.enter().append("g");

        barGroup.attr("class", "v-bar").each(function(perGroupData, i) {
          var barFinalSize = isHorizontal ?
            rangeBounds[barGroupNumber - i - 1] - rangeBounds[barGroupNumber - i] :
            rangeBounds[i + 1] - rangeBounds[i];
          if (barFinalSize > 1) {
            barFinalSize = barFinalSize - 1;
          }
          var barSizeInitial = 8 * barFinalSize / (9 * barNumberinGroup + 7);
          var r = Math.log(barFinalSize) / Math.log(2);
          if (r < 0) {
            that._mko_enableRoundCorner = false;
          }
          var enableRoundCorner = that._mko_enableRoundCorner;
          var axisGroup = d3.select(this).selectAll("g.v-axisGroup").data(perGroupData);
          axisGroup.enter().append("g");
          axisGroup.attr("class", "v-axisGroup").each(function(perAxisData, j) {
            var rcFunction = function() {};
            var yArray = [],
              xArray = [];
            // wrap a datashape g for each rect
            var barShape = d3.select(this).selectAll("g.v-datashape").data(perAxisData);
            barShape.enter().append("g").attr("class", "v-datashape");
            barShape.each(function(d) {
              var bar = d3.select(this).selectAll("rect").data([d]);
              bar.enter().append("rect");
              bar.exit().remove();
            });
            barShape.exit().remove();

            if (enableAnimation && that._mko_afterAttachToDOM) {
              barShape.each(function() {
                if (TypeUtils.isExist(this.getTransformToElement(this.parentNode))) {
                  xArray.push(this.getTransformToElement(this.parentNode).e);
                  yArray.push(this.getTransformToElement(this.parentNode).f);
                } else {
                  xArray.push(0);
                  yArray.push(0);
                }
              });
            }

            that._mkofn_setTransformForShape(barShape, i);

            var bar = d3.select(this).selectAll("rect");

            var valueMeasureName = "height";
            var valueCoordinateName = "y";
            var categoryMeaureName = "width";
            var categoryCoordinateName = "x";
            var valueCoordinateDefault = function(d) {
              return that._mkofn_getValueFromData(d);
            };
            var valueCoordinateFinal = function(isNegative) {
              return isNegative ? -r : 0;
            };
            if (isHorizontal) {
              valueMeasureName = "width";
              valueCoordinateName = "x";
              categoryMeaureName = "height";
              categoryCoordinateName = "y";
              valueCoordinateDefault = 0;
              valueCoordinateFinal = function(isNegative) {
                return isNegative ? 0 : -r;
              };
            }
            bar.attr("class", CLASSDATAPOINTCOMBINED)
              .attr("fill-opacity", 1)
              .attr('stroke', 'none')
              .attr("fill", function(d, colorIndex) {
                var color = (d.fillColor = fillingColor[colorIndex]);
                return that._mkofn_getEffectColor(color);
              });
            if (enableAnimation) {
              if (that._mko_dataStructureChange) {
                //We need to redraw if there is data structure change or the first creation.
                bar.attr(valueCoordinateName, valueCoordinateDefault)
                  .attr(categoryCoordinateName, function(perRectData, m) {
                    return barSizeInitial * m;
                  }).attr(valueMeasureName, 0).attr(categoryMeaureName, barSizeInitial)
                  .transition().duration(HALF_INTERVAL_TIME)
                  .attr(valueCoordinateName, 0)
                  .attr(valueMeasureName, function(perRectData, m) {
                    return that._mkofn_getValueFromData(perRectData);
                  }).transition().delay(HALF_INTERVAL_TIME).duration(HALF_INTERVAL_TIME)
                  .attr(categoryCoordinateName, 0)
                  .attr(categoryMeaureName, barFinalSize)
                  .attr(valueMeasureName, function(perRectData, m) {
                    return that._mkofn_getValueFromData(perRectData);
                  }).each("end", function(perRectData, m) {
                    if (i === 0 && m === barNumberinGroup - 1) {
                      that._mkofn_initialized();
                    }
                  });

                if (enableRoundCorner) {
                  rcFunction = function() {
                    bar.attr("clip-path", function(perRectData, indexinGroup) {
                      if (indexinGroup === negativeIndexes[j][i] || indexinGroup === positiveIndexes[j][i]) {
                        var id = generateRCId(i, j, indexinGroup);
                        var isNegative = (indexinGroup === negativeIndexes[j][i]);
                        var finalValue = valueCoordinateFinal(isNegative);
                        var size = that._mkofn_getValueFromData(perRectData) + r;
                        roundCornerDefs.append("clipPath").attr("id", id).attr("class", "v-clippath")
                          .append("rect").attr("class", "v-roundCorner-clip")
                          .attr("rx", r).attr("ry", r)
                          .attr("x", this.x.baseVal.value).attr("y", this.y.baseVal.value)
                          .attr(valueMeasureName, 0)
                          .attr(categoryMeaureName, barSizeInitial)
                          .transition().duration(HALF_INTERVAL_TIME)
                          .attr(valueCoordinateName, finalValue)
                          .attr(valueMeasureName, size)
                          .transition().delay(HALF_INTERVAL_TIME).duration(HALF_INTERVAL_TIME)
                          .attr(categoryCoordinateName, 0)
                          .attr(categoryMeaureName, barFinalSize);
                        return "url(#" + id + ")";
                      }
                    });
                  };
                }

              } else {
                //All the other animations are the same except resize need a default value measure.
                bar.attr("x", function(d, k) {
                  return xArray[k] - this.parentNode.getTransformToElement(this.parentNode.parentNode).e;
                }).attr("y", function(d, k) {
                  return yArray[k] - this.parentNode.getTransformToElement(this.parentNode.parentNode).f;
                }).transition().duration(HALF_INTERVAL_TIME)
                  .attr("x", 0).attr("y", 0)
                  .attr(categoryMeaureName, barFinalSize)
                  .attr(valueMeasureName, function(perRectData, m) {
                    return that._mkofn_getValueFromData(perRectData);
                  }).each("end", function(perRectData, m) {
                    if (i === 0 && m === barNumberinGroup - 1) {
                      that._mkofn_initialized();
                    }
                  });
                if (that._mko_sizeChange && !that._mko_modeChange) {
                  bar.attr(valueMeasureName, function(perRectData) {
                    var newSize = that._mkofn_getValueFromData(perRectData);
                    var originalSize = parseFloat(this[valueMeasureName].baseVal.value);
                    return originalSize > newSize ? originalSize : newSize;
                  });
                }

                if (enableRoundCorner) {
                  rcFunction = function() {
                    bar.attr("clip-path", function(perRectData, indexinGroup) {
                      if (indexinGroup === negativeIndexes[j][i] || indexinGroup === positiveIndexes[j][i]) {
                        var id = generateRCId(i, j, indexinGroup);
                        var isNegative = (indexinGroup === negativeIndexes[j][i]);
                        var finalValue = valueCoordinateFinal(isNegative);
                        var value = parseFloat(this[valueCoordinateName].baseVal.value) + finalValue;
                        var size = that._mkofn_getValueFromData(perRectData) + r;
                        roundCornerDefs.append("clipPath").attr("id", id).attr("class", "v-clippath")
                          .append("rect").attr("class", "v-roundCorner-clip")
                          .attr("rx", r).attr("ry", r)
                          .attr(valueCoordinateName, value)
                          .attr(categoryCoordinateName, this[categoryCoordinateName].baseVal.value)
                          .attr(valueMeasureName, this[valueMeasureName].baseVal.value + r)
                          .attr(categoryMeaureName, this[categoryMeaureName].baseVal.value)
                          .transition().duration(HALF_INTERVAL_TIME)
                          .attr(valueCoordinateName, finalValue)
                          .attr(categoryCoordinateName, 0)
                          .attr(valueMeasureName, size)
                          .attr(categoryMeaureName, barFinalSize);
                        return "url(#" + id + ")";
                      }
                    });
                  };
                }
              } //end if (dataStructureChange)
            } else {
              //When animation is disabled.
              bar.attr("x", 0).attr("y", 0)
                .attr(categoryMeaureName, barFinalSize)
                .attr(valueMeasureName, function(perRectData, m) {
                  return that._mkofn_getValueFromData(perRectData);
                });
              if (enableRoundCorner) {
                rcFunction = function() {
                  bar.attr("clip-path", function(perRectData, indexinGroup) {
                    if (indexinGroup === negativeIndexes[j][i] || indexinGroup === positiveIndexes[j][i]) {
                      var id = generateRCId(i, j, indexinGroup);
                      var isNegative = (indexinGroup === negativeIndexes[j][i]);
                      var finalValue = valueCoordinateFinal(isNegative);
                      var size = that._mkofn_getValueFromData(perRectData) + r;
                      roundCornerDefs.append("clipPath").attr("id", id).attr("class", "v-clippath")
                        .append("rect").attr("class", "v-roundCorner-clip")
                        .attr("rx", r).attr("ry", r)
                        .attr(valueCoordinateName, finalValue)
                        .attr(categoryCoordinateName, 0)
                        .attr(valueMeasureName, size)
                        .attr(categoryMeaureName, barFinalSize);
                      return "url(#" + id + ")";
                    }
                  });
                };
              }
            }

            rcFunction();

          });
          axisGroup.exit().remove();
        });
        //adjust values
        if (!enableAnimation) {
          that._mkofn_adjustValues();
          that._mkofn_initialized();
        }

        barGroup.exit().remove();
      });
      this._mko_sizeChange = false, this._mko_dataValueChange = false, this._mko_dataStructureChange = false;
      this._mko_isOnlyInitAnimation = true;
      return this;

    };

    Mekko.prototype.hoverOnPoint = function(point) {
      var xOnModule = point.x,
        yOnModule = point.y;
      // find the closet dimension

      var isHorizontal = this._mko_isHorizontal;
      var width = this._mko_width;
      var height = this._mko_height;
      var rangeBounds = this._mko_rangeBounds;
      var seriesData = this._mko_seriesData;
      var decorativeShape = this._mko_decorativeShape;

      var wrapper = this._mko_gWrapper[0][0];
      var i = 0,
        len = rangeBounds.length - 1,
        currentBound = 0;
      if (isHorizontal) {
        while (i < len) {
          if (yOnModule >= (height - rangeBounds[i]) && yOnModule < (height - rangeBounds[i + 1])) {
            currentBound = rangeBounds[i] - rangeBounds[i + 1];
            break;
          }
          i++;
        }
      } else {
        while (i < len) {
          if (xOnModule >= (rangeBounds[i]) && xOnModule < (rangeBounds[i + 1])) {
            currentBound = rangeBounds[i + 1] - rangeBounds[i];
            break;
          }
          i++;
        }
      }
      if (i > (seriesData.length - 1) || i < 0) {
        decorativeShape.attr("visibility", "hidden");
        return;
      }
      decorativeShape.attr("visibility", "visible");
      if (isHorizontal) {
        decorativeShape.attr("y", height - rangeBounds[i])
          .attr("height", currentBound);
      } else {
        decorativeShape.attr("x", rangeBounds[i])
          .attr("width", currentBound);
      }
      if (i !== this._mko_lastHovered) {
        if (this._mko_tooltipVisible) {
          this._mko_lastHovered = i;
          //this.parentNode.parentNode.parentNode point to the main container
          var transform = wrapper.getTransformToElement(wrapper.ownerSVGElement);
          var xoffset = transform.e;
          var yoffset = transform.f;
          var tData = isHorizontal ? this._mkofn_generateTooltipData(this._mko_barGroupNumber - i - 1) : this._mkofn_generateTooltipData(i);

          tData.point = {
            x: isHorizontal ? xOnModule : rangeBounds[i] + currentBound / 2 + xoffset,
            y: isHorizontal ? height - rangeBounds[i] + currentBound / 2 + yoffset : yOnModule
          };
          tData.plotArea = {
            x: xoffset,
            y: yoffset,
            width: width,
            height: height
          };
          tData.valueAxis0Count = seriesData[0][0].length;
          tData.valueAxis1Count = TypeUtils.isExist(seriesData[0][1]) ? seriesData[0][1].length : 0;
          this._mko_eDispatch.showTooltip(tooltipDataHandler.formatTooltipData(tData));
        }
      }
    };

    Mekko.prototype.blurOut = function() {
      this._mko_decorativeShape.attr("visibility", "hidden");
      this._mko_lastHovered = null;
      if (this._mko_tooltipVisible) {
        this._mko_eDispatch.hideTooltip();
      }
    };

    Mekko.prototype.parent = function() {
      return this._mko_gWrapper;
    };

    Mekko.prototype.highlight = function(elems) {
      if (elems instanceof Array) {
        for (var i = 0, len = elems.length; i < len; i++) {
          elems[i].setAttribute("class", CLASSDATAPOINTCOMBINED + " " + CLASSMARKERSELECTED);
          elems[i].setAttribute("fill-opacity", 1);
          if (!this._mko_enableRoundCorner) {
            elems[i].setAttribute("stroke", "#333333");
          }
        }
      } else {
        elems.setAttribute("class", CLASSDATAPOINTCOMBINED + " " + CLASSMARKERSELECTED);
        elems.setAttribute("fill-opacity", 1);
        if (!this._mko_enableRoundCorner) {
          elems.setAttribute("stroke", "#333333");
        }
      }

      if (this._mko_hasDefaultSelection) {
        defaultSelUtil.clearSelectionInfo(this._mko_gWrapper, true, elems);
      }
    };

    Mekko.prototype.unhighlight = function(elems) {
      if (elems instanceof Array) {
        for (var i = 0, len = elems.length; i < len; i++) {
          elems[i].setAttribute("class", CLASSDATAPOINTCOMBINED);
          elems[i].setAttribute("fill-opacity", 0.4);
          elems[i].setAttribute("stroke", "none");
        }
      } else {
        elems.setAttribute("class", CLASSDATAPOINTCOMBINED);
        elems.setAttribute("fill-opacity", 0.4);
        elems.setAttribute("stroke", "none");
      }
      if (this._mko_hasDefaultSelection) {
        defaultSelUtil.clearSelectionInfo(this._mko_gWrapper, false, elems);
      }

    };

    Mekko.prototype.clear = function(gray) {
      var wrapper = this._mko_gWrapper;
      var rects = wrapper.selectAll(".v-datapoint");
      if (gray) {
        rects.attr("fill-opacity", 0.4).attr("stroke", "none").attr("class", CLASSDATAPOINTCOMBINED);
      } else {
        rects.attr("fill-opacity", 1).attr("stroke", "none").attr("class", CLASSDATAPOINTCOMBINED);
        if (this._mko_hasDefaultSelection) {
          defaultSelUtil.clearSelectionInfo(wrapper, false, rects);
        }
      }
    };

    Mekko.prototype.afterUIComponentAppear = function() {
      this._mko_eDispatch.initialized();
    };

    Mekko.prototype.width = function(value) {
      if (!arguments.length) {
        return this._mko_width;
      }
      this._mko_width = value;
      this._mkofn_makeScales();

      return this;
    };

    Mekko.prototype.height = function(value) {
      if (!arguments.length) {
        return this._mko_height;
      }
      this._mko_height = value;
      this._mkofn_makeScales();
      return this;
    };

    Mekko.prototype.data = function(value) {
      if (!arguments.length) {
        return this._mko_data;
      }
      this._mko_data = value;
      var obj = ObjectUtils.extend(true, {}, MNDHandler(this._mko_data));
      var _data1 = obj["MG1"];
      var _data2 = obj["MG2"];
      this._mko_hasDefaultSelection = false;
      if (_data1[0] && _data1[0][0].info && _data1[0][0].info.defaultSelection) {
        this._mko_hasDefaultSelection = true;
      }
      if (_data2[0] && _data2[0][0].info && _data2[0][0].info.defaultSelection) {
        this._mko_hasDefaultSelection = true;
      }
      if (this._mko_data1.length !== _data1.length || this._mko_data1[0].length !== _data1[0].length) {
        this._mko_dataStructureChange = true;
      } else {
        this._mko_dataValueChange = true;
      }
      var _seriesData = this._mkofn_dataHandler(_data1, _data2);
      this._mko_data1 = _data1;
      this._mko_data2 = _data2;
      this._mko_seriesData = _seriesData;
      this._mko_tooltipData = ObjectUtils.extend(true, {}, _seriesData);
      this._mkofn_makeScales();
      this._mkofn_parseOptions();
      return this;
    };

    Mekko.prototype.properties = function(props) {
      if (!arguments.length) {
        return this._mko_properties;
      }
      Objects.extend(true, this._mko_properties, props);
      this._mkofn_parseOptions();
      this._mkofn_makeScales();
      return this;
    };

    Mekko.prototype.colorPalette = function(Palette) {
      if (!arguments.length) {
        return this._mko_colorPalette;
      }
      this._mko_colorPalette = Palette;
      return this;
    };

    Mekko.prototype.categoryScale = function(scale) {
      if (!arguments.length) {
        return this._mko_categoryScale;
      }
      this._mko_categoryScale = scale;
      return this;
    };

    Mekko.prototype.dimensionData = function(_) {
      if (!arguments.length) {
        return this._mko_dimensionData;
      }
      this._mko_dimensionData = _;
      return this;
    };

    Mekko.prototype.secondCategoryScale = function(_) {
      if (!arguments.length) {
        return this._mko_categoryScale;
      }
      this._mko_categoryScale = _;
      return this;
    };

    Mekko.prototype.primaryDataRange = function(range) {
      if (!arguments.length) {
        var maxt, mint;
        if (this._mko_mode === "percentage") {
          maxt = 1;
          mint = 0;
        } else {
          mint = this._mko_primaryAxisBottomBoundary < 0 ? this._mko_primaryAxisBottomBoundary : 0;
          maxt = this._mko_primaryAxisTopBoundary;
        }
        return {
          min: mint,
          max: maxt
        };
      }
      var isHorizontal = this._mko_isHorizontal;
      var valueScale = this._mko_valueScale;
      var tempMax, tempMin;
      if (range !== null) {
        if (!isNaN(range.max)) {
          tempMax = range.max;
        } else {
          if (isHorizontal) {
            tempMax = valueScale.perfectDomainEnd;
          } else {
            tempMax = valueScale.perfectDomainBegin;
          }
        }
        if (!isNaN(range.min)) {
          tempMin = range.min;
        } else {
          if (isHorizontal) {
            tempMin = valueScale.perfectDomainBegin;
          } else {
            tempMin = valueScale.perfectDomainEnd;
          }
        }
        if (tempMax > tempMin) {
          this._mko_primaryAxisTopBoundary = tempMax;
          this._mko_primaryAxisBottomBoundary = tempMin;
          if (range.from === "axis") {
            this._mko_primaryAxisManualRange = true;
          }
          if (TypeUtils.isExist(this._mko_width) && TypeUtils.isExist(this._mko_height)) {
            this._mkofn_makeScales();
          }
        }
      } else {
        if (this._mko_primaryAxisManualRange === true) {
          if (isHorizontal) {
            this._mko_primaryAxisTopBoundary = valueScale.perfectDomainEnd;
            this._mko_primaryAxisBottomBoundary = valueScale.perfectDomainBegin;
          } else {
            this._mko_primaryAxisTopBoundary = valueScale.perfectDomainBegin;
            this._mko_primaryAxisBottomBoundary = valueScale.perfectDomainEnd;
          }
          this._mko_primaryAxisManualRange = false;
          if (TypeUtils.isExist(this._mko_width) && TypeUtils.isExist(this._mko_height)) {
            this._mkofn_makeScales();
          }
        }
      }
      return this;
    };

    Mekko.prototype.secondDataRange = function(range) {
      if (!arguments.length) {
        var maxt, mint;
        if (this._mko_mode === "percentage") {
          maxt = 1;
          mint = 0;
        } else {
          mint = this._mko_secondaryAxisBottomBoundary < 0 ? this._mko_secondaryAxisBottomBoundary : 0;
          maxt = this._mko_secondaryAxisTopBoundary;
        }
        return {
          min: mint,
          max: maxt
        };
      }
      var isHorizontal = this._mko_isHorizontal;
      var valueScale2 = this._mko_valueScale2;
      var tempMax, tempMin;
      if (range !== null) {
        if (!isNaN(range.max)) {
          tempMax = range.max;
        } else {
          if (isHorizontal) {
            tempMax = valueScale2.perfectDomainEnd;
          } else {
            tempMax = valueScale2.perfectDomainBegin;
          }
        }
        if (!isNaN(range.min)) {
          tempMin = range.min;
        } else {
          if (isHorizontal) {
            tempMin = valueScale2.perfectDomainBegin;
          } else {
            tempMin = valueScale2.perfectDomainEnd;
          }
        }
        if (tempMax > tempMin) {
          this._mko_secondaryAxisTopBoundary = tempMax;
          this._mko_secondaryAxisBottomBoundary = tempMin;
          if (range.from === "axis") {
            this._mko_secondaryAxisManualRange = true;
          }
          if (TypeUtils.isExist(this._mko_width) && TypeUtils.isExist(this._mko_height)) {
            this._mkofn_makeScales();
          }
        }
      } else {
        if (this._mko_secondaryAxisManualRange === true) {
          if (isHorizontal) {
            this._mko_secondaryAxisTopBoundary = valueScale2.perfectDomainEnd;
            this._mko_secondaryAxisBottomBoundary = valueScale2.perfectDomainBegin;
          } else {
            this._mko_secondaryAxisTopBoundary = valueScale2.perfectDomainBegin;
            this._mko_secondaryAxisBottomBoundary = valueScale2.perfectDomainEnd;
          }
          this._mko_secondaryAxisManualRange = false;
          if (TypeUtils.isExist(this._mko_width) && TypeUtils.isExist(this._mko_height)) {
            this._mkofn_makeScales();
          }
        }
      }
      return this;
    };

    Mekko.prototype.primaryScale = function(scale) {
      if (!arguments.length) {
        return this._mko_valueScale;
      }
      this._mko_valueScale = scale;
      return this;
    };

    Mekko.prototype.primaryAxisColor = function() {
      //as in mekko, it does not has MND feed, so always return undefined.
      return undefined;
    };

    Mekko.prototype.dispatch = function(_) {
      if (!arguments.length) {
        return this._mko_eDispatch;
      }
      this._mko_eDispatch = _;
      return this;
    };

    Mekko.prototype.getPreferredSize = function() {};

    Mekko.prototype.dataLabel = function(_) {};

    Mekko.prototype.primaryAxisTitle = function(_) {
      if (!arguments.length) {
        var titles = this._mko_data.getMeasureValuesGroupDataByIdx(0),
          title = [];
        if (titles) {
          for (var i = 0, len = titles.values.length; i < len; i++) {
            if (titles.values[i].col !== null && titles.values[i].col !== undefined) {
              title.push(titles.values[i].col);
            } else {
              title.push(DEFAULT_STRING);
            }
          }
        }
        return title.join(" & ");
      }
      return this;
    };

    Mekko.prototype.secondAxisTitle = function(_) {
      if (!arguments.length) {
        var titles = this._mko_data.getMeasureValuesGroupDataByIdx(1),
          title = [];
        if (titles) {
          for (var i = 0, len = titles.values.length; i < len; i++) {
            if (titles.values[i].col !== null && titles.values[i].col !== undefined) {
              title.push(titles.values[i].col);
            } else {
              title.push(DEFAULT_STRING);
            }
          }
        }
        return title.join(" & ");
      }
      return this;
    };

    Mekko.prototype.destroy = function() {
      if (this._mko_categoryScale) {
        this._mko_categoryScale.domain([0, 1]).range([0, 1]);
      }
      if (this._mko_valueScale) {
        this._mko_valueScale.domain([0, 1]).range([0, 1]);
      }
      if (this._mko_valueScale2) {
        this._mko_valueScale2.domain([0, 1]).range([0, 1]);
      }
      if (this._mko_effectManager && this._mko_effectManager.destroy) {
        this._mko_effectManager.destroy();
      }
      if (this._mko_styleManager && this._mko_styleManager.destroy) {
        this._mko_styleManager.destroy();
      }
      this._mko_categoryScale = null;
      this._mko_valueScale = null;
      this._mko_valueScale2 = null;
      this._mko_effectManager = null;
      this._mko_styleManager = null;
      this._mko_data = null;
      this._mko_data1 = null;
      this._mko_data2 = null;
      this._mko_seriesData = null;
      this._mko_tooltipData = null;
      this._mko_gWrapper = null;
      this._mko_colorPalette = null;
      this._mko_axis1ColorPalette = null;
      this._mko_shapePalette = null;
      this._mko_properties = null;
      this._mko_style = null;
      this._mko_decorativeShape = null;
      this._mko_lastHovered = null;
      this._mko_positiveIndexes = null;
      this._mko_negativeIndexes = null;
      this._mko_defsEnter = null;
      this._mko_roundCornerDefs = null;
      this._mko_dimensionData = null;
      this._mko_rangeBounds = null;
      this._mko_rangeSum = null;
    };

    Mekko.prototype._mkofn_setTransformForShape = function(barShape, i) {
      var isHorizontal = this._mko_isHorizontal;
      var rangeBounds = this._mko_rangeBounds;
      var barGroupNumber = this._mko_barGroupNumber;
      var valueScale = this._mko_valueScale;
      var height = this._mko_height;

      var positiveStackedValue = 0,
        negativeStackedValue = 0;

      barShape.attr("transform", function(perRectData, k) {
        var x, y;
        if (isHorizontal) {
          y = height - rangeBounds[barGroupNumber - i - 1];
          if (perRectData.val >= 0) {
            x = valueScale(positiveStackedValue);
            positiveStackedValue += perRectData.val;
          } else {
            negativeStackedValue += perRectData.val;
            x = valueScale(negativeStackedValue);
          }
        }
        //for vertical valueScale has been reversed.
        else {
          x = rangeBounds[i];
          if (perRectData.val >= 0) {
            positiveStackedValue += perRectData.val;
            y = valueScale(positiveStackedValue);
          } else {
            y = valueScale(negativeStackedValue);
            negativeStackedValue += perRectData.val;
          }
        }
        return "translate(" + x + "," + y + ")";
      });
    };

    Mekko.prototype._mkofn_getValueFromData = function(data) {
      var valueScale = this._mko_valueScale;
      if (valueScale){
        return Math.abs(valueScale(data.val) - valueScale(0));
      } else {
        return 0;
      }
    };

    Mekko.prototype._mkofn_getEffectColor = function(color) {
      var parameter = {
        drawingEffect: this._mko_drawingEffect,
        fillColor: color,
        direction: this._mko_isHorizontal ? "vertical" : "horizontal"
      };
      return this._mko_effectManager.register(parameter);
    };

    Mekko.prototype._mkofn_adjustScale = function(rangeBounds) {
      var width = this._mko_width;
      var height = this._mko_height;
      var isHorizontal = this._mko_isHorizontal;
      var i, len = rangeBounds.length;
      for (i = 0; i < len; i++) {
        if (!NumberUtils.isNoValue(rangeBounds[i]) && rangeBounds[i] !== 0) {
          return;
        }
      }
      var interval = isHorizontal ? height / (len - 1) : width / (len - 1);
      for (i = 1; i < len; i++) {
        rangeBounds[i] = i * interval;
      }
    };

    Mekko.prototype._mkofn_makeScales = function() {
      var width = this._mko_width;
      var height = this._mko_height;
      var seriesData = this._mko_seriesData;
      if (TypeUtils.isExist(width) && TypeUtils.isExist(height) && TypeUtils.isExist(seriesData)) {
        var data2 = this._mko_data2;
        var isHorizontal = this._mko_isHorizontal;
        var categoryScale = this._mko_categoryScale;
        var valueScale = this._mko_valueScale;
        var primaryAxisTopBoundary = this._mko_primaryAxisTopBoundary;
        var primaryAxisBottomBoundary = this._mko_primaryAxisBottomBoundary;
        var primaryAxisManualRange = this._mko_primaryAxisManualRange;
        var dimensionDataValue = this._mko_dimensionData[MEKKO_DIMENSION_ID].values[0];
        var mode = this._mko_mode;
        var rangeBounds = (this._mko_rangeBounds = []);
        rangeBounds[0] = 0;
        var rangeSum = (this._mko_rangeSum = []),
          domain = [],
          total = 0,
          tempsum = 0;
        var i, j, len;
        var rows = (dimensionDataValue.rows = []);
        dimensionDataValue.col.val = this._mko_data.getMeasureValuesGroupDataByIdx(1).values[0].col;
        for (i = 0, len = data2.length; i < len; i++) {
          for (j = 0; j < data2[i].length; j++) {
            if (TypeUtils.isExist(rangeSum[j])) {
              rangeSum[j] += data2[i][j].val;
            } else {
              rangeSum[j] = data2[i][j].val;
            }
          }
        }
        for (i = 0, len = rangeSum.length; i < len; i++) {
          domain.push(i);
          total += rangeSum[i] > 0 ? rangeSum[i] : -rangeSum[i];
        }
        for (i = 0, len = rangeSum.length; i < len; i++) {
          tempsum += Math.abs(rangeSum[i]);
          tempsum = NumberUtils.precise(tempsum);
          rangeBounds[i + 1] = total === 0 ? null : Math.abs(isHorizontal ? tempsum / total * height : tempsum / total * width);
          rows.push({
            val: TypeUtils.isExist(rangeSum[i]) ? rangeSum[i] : DEFAULT_STRING
          });
        }
        //adjust domain and rangebouds, for all no_value or zero value
        this._mkofn_adjustScale(rangeBounds);
        //if is horizontal we need to reverse the categoryScale, otherwise we need to reverse the valueScale
        if (isHorizontal) {
          categoryScale.domain(domain).range(rangeBounds.reverse());
          if (mode === "percentage") {
            valueScale.domain([0, 1]).range([0, width]);
          } else {
            //when all data is 0 or null, we make domain (0,1)
            if (primaryAxisBottomBoundary === 0 && primaryAxisTopBoundary === 0) {
              valueScale.domain([0, 1]).range([0, width]);
            } else {
              valueScale.domain([primaryAxisBottomBoundary, primaryAxisTopBoundary]).range([0, width]);
            }
          }
        } else {
          categoryScale.domain(domain).range(rangeBounds);
          if (mode === "percentage") {
            valueScale.domain([1, 0]).range([0, height]);
          } else {
            if (primaryAxisBottomBoundary === 0 && primaryAxisTopBoundary === 0) {
              valueScale.domain([1, 0]).range([0, height]);
            } else {
              valueScale.domain([primaryAxisTopBoundary, primaryAxisBottomBoundary]).range([0, height]);
            }
          }
        }
        if (!primaryAxisManualRange) {
          Scaler.perfect(valueScale);
        } else {
          Scaler.getRoughTickNum(valueScale);
        }
      }

    };

    Mekko.prototype._mkofn_turnToPercentage = function() {
      var seriesData = this._mko_seriesData;
      var tooltipData = this._mko_tooltipData;
      for (var i = 0, len = seriesData.length; i < len; i++) {
        for (var j = 0, rowSeriesData = seriesData[i], rowTooltipData = tooltipData[i]; j < rowSeriesData.length; j++) {
          var sum = 0,
            avaCount = 0,
            k;
          for (k = 0; k < rowSeriesData[j].length; k++) {
            sum += Math.abs(rowSeriesData[j][k].val);
            if (!rowSeriesData[j][k].isNaN) {
              avaCount++;
            }
          }
          if (sum === 0) {
            for (k = 0; k < rowSeriesData[j].length; k++) {
              rowSeriesData[j][k].value = TypeUtils.isExist(rowSeriesData[j][k].value) ? rowSeriesData[j][k].value : rowSeriesData[j][k].val;
              rowSeriesData[j][k].val = rowSeriesData[j][k].isNaN ? 0 : 1 / avaCount;
              if (TypeUtils.isExist(rowTooltipData[j]) && TypeUtils.isExist(rowTooltipData[j][k])) {
                rowTooltipData[j][k].val = rowTooltipData[j][k].isNaN ? " " : 1 / avaCount;
              }
            }
          } else {
            for (k = 0; k < rowSeriesData[j].length; k++) {
              if (rowSeriesData[j][k].val < 0) {
                rowSeriesData[j][k].isNegative = true;
              }
              rowSeriesData[j][k].value = TypeUtils.isExist(rowSeriesData[j][k].value) ? rowSeriesData[j][k].value : rowSeriesData[j][k].val;
              rowSeriesData[j][k].val = Math.abs(rowSeriesData[j][k].val / sum);
              if (TypeUtils.isExist(rowTooltipData[j]) && TypeUtils.isExist(rowTooltipData[j][k])) {
                rowTooltipData[j][k].val = rowTooltipData[j][k].isNaN ? " " : rowTooltipData[j][k].val / sum;
              }
            }
          }
        }
      }
    };

    Mekko.prototype._mkofn_turnToComparison = function() {
      var obj = ObjectUtils.extend(true, {}, MNDHandler(this._mko_data));

      var _data1 = obj["MG1"];
      var _data2 = obj["MG2"];

      var _seriesData = this._mkofn_dataHandler(_data1, _data2);

      this._mko_seriesData = _seriesData;
      this._mko_data1 = _data1;
      this._mko_data2 = _data2;
      this._mko_tooltipData = ObjectUtils.extend(true, {}, this._mko_seriesData);
    };

    Mekko.prototype._mkofn_initialized = function() {
      this._mko_eDispatch.initialized();
      this._mko_afterAttachToDOM = true;
    };

    Mekko.prototype._mkofn_dataHandler = function(valueAxis1Data, valueAxis2Data) {
      var i, j,
        positiveIndex = -1,
        negativeIndex = -1;
      var positiveIndexes = (this._mko_positiveIndexes = [
        [],
        []
      ]);
      var negativeIndexes = (this._mko_negativeIndexes = [
        [],
        []
      ]);

      this._mko_primaryAxisTopBoundary = this._mko_primaryAxisBottomBoundary = 0;
      this._mko_secondaryAxisTopBoundary = this._mko_secondaryAxisBottomBoundary = 0;
      var stackedBarGroupsData = [];
      var barGroupNumber = (this._mko_barGroupNumber = valueAxis1Data[0].length);
      var temp, temp2;
      for (j = 0; j < barGroupNumber; j++) {
        var tempDataSetAxis1 = [],
          tempDataSetAxis2 = [];
        var oneGroupDataSet = [];
        temp = 0, temp2 = 0;
        positiveIndex = -1, negativeIndex = -1;
        for (i = 0; i < valueAxis1Data.length; i++) {
          if (NumberUtils.isNoValue(valueAxis1Data[i][j].val)) {
            valueAxis1Data[i][j].val = 0;
            valueAxis1Data[i][j].isNaN = true;
          } else {
            if (valueAxis1Data[i][j].val >= 0) {
              temp += valueAxis1Data[i][j].val;
              positiveIndex = i;
            } else {
              temp2 += valueAxis1Data[i][j].val;
              negativeIndex = i;
            }
          }
          tempDataSetAxis1.push(valueAxis1Data[i][j]);
        }
        positiveIndexes[0].push(positiveIndex);
        negativeIndexes[0].push(negativeIndex);
        if (this._mko_primaryAxisTopBoundary < temp) {
          this._mko_primaryAxisTopBoundary = temp;
        }
        if (this._mko_primaryAxisBottomBoundary > temp2) {
          this._mko_primaryAxisBottomBoundary = temp2;
        }
        if (TypeUtils.isExist(valueAxis2Data)) {
          temp = 0, temp2 = 0;
          positiveIndex = -1, negativeIndex = -1;
          for (i = 0; i < valueAxis2Data.length; i++) {
            positiveIndex = 0, negativeIndex = -1;
            if (NumberUtils.isNoValue(valueAxis2Data[i][j].val)) {
              //we do not set it to 0, because category axis needs "No Value"
              valueAxis2Data[i][j].isNaN = true;
            } else {
              if (valueAxis2Data[i][j].val >= 0) {
                temp += valueAxis2Data[i][j].val;
                positiveIndex = i;
              } else {
                temp2 += valueAxis2Data[i][j].val;
                negativeIndex = i;
              }
            }
            tempDataSetAxis2.push(valueAxis2Data[i][j]);
          }
          positiveIndexes[1].push(positiveIndex);
          negativeIndexes[1].push(negativeIndex);
          if (this._mko_secondaryAxisTopBoundary < temp) {
            this._mko_secondaryAxisTopBoundary = temp;
          }
          if (this._mko_secondaryAxisBottomBoundary > temp2) {
            this._mko_secondaryAxisBottomBoundary = temp2;
          }
        }
        //merge the two dataset (2 MG)
        var dataSet = [];
        var k;
        for (k = 0; k < tempDataSetAxis1.length; k++) {
          var item = {};
          var prop = null;
          for (prop in tempDataSetAxis1[k]) {
            if (tempDataSetAxis1[k].hasOwnProperty(prop)) {
              item[prop] = [];
              item[prop].push(tempDataSetAxis1[k][prop]);
              item[prop].push(tempDataSetAxis2[k][prop]);
            }
          }
          item.isNaN = tempDataSetAxis1[k].isNaN;
          item.val = tempDataSetAxis1[k].val;
          item.val2 = tempDataSetAxis2[k].val;
          dataSet.push(item);
        }
        oneGroupDataSet.push(dataSet);
        stackedBarGroupsData.push(oneGroupDataSet);
      }

      return stackedBarGroupsData;
    };

    Mekko.prototype._mkofn_generateTooltipData = function(aai1) {
      var tData = {
        "body": [],
        "footer": []
      };
      var data = this._mko_data;
      var tooltipData = this._mko_tooltipData;
      var shapePalette = this._mko_shapePalette;
      var colorPalette = this._mko_colorPalette;
      var rangeSum = this._mko_rangeSum;

      var g0data = data.getMeasureValuesGroupDataByIdx(0).values;
      var g1data = data.getMeasureValuesGroupDataByIdx(1).values;
      var a0data = data.getAnalysisAxisDataByIdx(0).values;
      // have two analysis
      var a1dataObject = data.getAnalysisAxisDataByIdx(1);
      var a1data = null;
      if (TypeUtils.isExist(a1dataObject)) {
        a1data = a1dataObject.values;
      }
      //make up body data
      var elemcount = tooltipData[0][0].length;
      var i, j, t, ilen, tlen;
      var tbody = {}, rows = [];
      for (i = 0, ilen = g0data.length; i < ilen; i++) {
        tbody = {}, rows = [];
        tbody.name = g0data[i].col;
        tbody.val = rows;
        for (j = 0; j < elemcount; j++) {
          var label = "";
          if (TypeUtils.isExist(a1data)) {
            for (t = 0, tlen = a1data.length; t < tlen; t++) {
              var dName = a1data[t].rows[j].val;
              if (dName === null || dName === undefined) {
                dName = DEFAULT_STRING;
              }
              label += t === 0 ? dName : " / " + dName;
            }
          }
          rows.push({
            value: tooltipData[aai1][0][j].isNaN ? DEFAULT_STRING : tooltipData[aai1][0][j].val,
            label: label,
            shape: shapePalette[0],
            color: colorPalette[j]
          });
        }
        tData.body.push(tbody);
      }
      //make up body data
      //from d1data
      tbody = {}, rows = [];
      tbody.name = g1data[0].col;
      tbody.val = rows;
      rows.push({
        value: TypeUtils.isExist(rangeSum[aai1]) ? rangeSum[aai1] : DEFAULT_STRING,
        valueAxis: 1
      });
      tData.body.push(tbody);
      //from a0data
      for (i = 0, ilen = a0data.length; i < ilen; i++) {
        var footer = {
          label: a0data[i].col.val
        };
        var vFoot = a0data[i].rows[aai1].val;
        if (vFoot === null || vFoot === undefined) {
          vFoot = DEFAULT_STRING;
        }
        footer.value = vFoot;
        tData.footer.push(footer);
      }
      return tData;
    };

    Mekko.prototype._mkofn_getCssStyle = function() {
      this._mko_style.hovershadow = this._mko_styleManager.queryDefault(CSSCLASS_HOVERSHADOW);
    };

    Mekko.prototype._mkofn_enableAnimation = function() {
      var hasAnmation = false;
      if (!this._mko_isOnlyInitAnimation) {
        hasAnmation = this._mko_enableDataLoadingAnimation;
      } else if (this._mko_dataStructureChange || this._mko_dataValueChange || this._mko_modeChange) {
        hasAnmation = this._mko_enableDataUpdatingAnimation;
      } else if (this._mko_sizeChange) {
        hasAnmation = this._mko_enableResizingAnimation;
      }
      return hasAnmation;
    };

    Mekko.prototype._mkofn_parseOptions = function() {
      var properties = this._mko_properties;
      if (this._mko_mode !== properties.mode) {
        this._mko_modeChange = true;
      }
      this._mko_mode = properties.mode === "percentage" ? "percentage" : "comparison";
      this._mko_isHorizontal = properties.orientation === "horizontal" ? true : false;
      this._mko_enableRoundCorner = properties.isRoundCorner;
      this._mko_enableDataLoadingAnimation = properties.animation.dataLoading;
      this._mko_enableDataUpdatingAnimation = properties.animation.dataUpdating;
      this._mko_enableResizingAnimation = properties.animation.resizing;
      this._mko_tooltipVisible = properties.tooltip.enabled;

      this._mko_drawingEffect = properties.drawingEffect;

      var colorPalette = (this._mko_axis1ColorPalette = properties.colorPalette);
      var colorLength = colorPalette.length;
      this._mko_colorPalette = [];
      var i, j, lenI, lenJ;
      var seriesData = this._mko_seriesData;
      for (i = 0, lenI = seriesData[0].length; i < lenI; i++) {
        for (j = 0, lenJ = seriesData[0][0].length; j < lenJ; j++) {
          this._mko_colorPalette.push(colorPalette[j % colorLength]);
        }
      }
    };

    Mekko.prototype._mkofn_recoveryValues = function() {
      var i, j, lenI, lenJ;
      var seriesData = this._mko_seriesData;
      if (TypeUtils.isExist(seriesData)) {
        if (TypeUtils.isArray(seriesData[0][0][0].val)) {
          for (i = 0, lenI = seriesData.length; i < lenI; i++) {
            for (j = 0, lenJ = seriesData[i][0].length; j < lenJ; j++) {
              if (TypeUtils.isArray(seriesData[i][0][j].val)) {
                seriesData[i][0][j].val = seriesData[i][0][j].val[0];
              }
            }
          }
        }
      }
    };

    Mekko.prototype._mkofn_adjustValues = function() {
      var i, j, lenI, lenJ;
      var seriesData = this._mko_seriesData;
      for (i = 0, lenI = seriesData.length; i < lenI; i++) {
        for (j = 0, lenJ = seriesData[i][0].length; j < lenJ; j++) {
          var valArray = [];
          var data = seriesData[i][0][j];
          var value = data.value;

          valArray.push(value === undefined ? data.val : value);
          valArray.push(data.val2);
          data.val = valArray;
        }
      }
    };

    return Mekko;
  });
define('sap/viz/modules/manifests/xy/Mekko',['sap/viz/modules/manifests/Module','sap/viz/modules/mekko','sap/viz/modules/manifests/xy/BaseBar'],
function Setup(Manifest, fn) {
	/**
	 * Mekko chart's feed defination is similar with bar chart. It accept a dimension axis and two measure value axis like dual bar chart.
	 */
  var module = {
    'id' : 'sap.viz.modules.mekko',
    'name' : 'mekko',
    base : "sap.viz.modules.xy.bar.base",
    'properties' : {
    	'mode' : {
            'name' : 'mode',
            'supportedValueType' : 'String',
            'supportedValues' : [ 'comparison', 'percentage' ],
            'defaultValue' : 'comparison',
            'description' : 'Set dispaly mode of mekko chart.'
          },
          'orientation' : {
            'name' : 'orientation',
            'supportedValueType' : 'String',
            'supportedValues' : [ 'vertical', 'horizontal' ],
            'defaultValue' : 'horizontal',
            'description' : 'vertical or horizontal mekko chart.'
          },
    },
    fn : fn
  };

  Manifest.register(module);
});
define('sap/viz/manifests/xy/MekkoChart',['sap/viz/manifests/Viz','sap/viz/modules/manifests/RootContainer',
'sap/viz/manifests/xy/DesktopVerticalBar','sap/viz/modules/manifests/xy/Mekko'],
function Setup(Manifest) {
  var chart = {
    id : 'viz/mekko',
    name : 'IDS_MEKKOCHART',
    base : 'viz/desktopverticalbar',
    modules : {
      root : {
        modules : {
          main : {
              modules : {
                dataLabel : {
                  id : 'sap.viz.modules.datalabel',
                  configure : {
                    properties : {
                      automaticInOutside : false,
                      isStackMode : true,
                      isMekko : true,
                      showZero : false
                    },
                    propertiesOverride:{
                      position : {
                        isExported : false
                      }
                    }
                  }
                },
                plot: {
                  id : 'sap.viz.modules.mekko',
                  configure: {
                    propertyCategory : 'plotArea',
                    properties : {
                        orientation: 'vertical'
                      },
                      propertiesOverride:{
                        primaryValuesColorPalette:{
                          isExported: false
                        },
                        
                        mode: {
                          isExported: false
                        },
                        orientation: {
                          isExported: false
                        }
                     }
                  }
                },
                yAxis:{
                      id : 'sap.viz.modules.axis',
                    configure:{
                      'description':'Settings for the value axis at left or bottom of an XY chart with 2 value axis.',
                      properties:{
                        position : 'left'
                      }
                    }
                },
                xAxis : {
                   id : 'sap.viz.modules.axis',
                   configure : {
                     properties:{
                       type : 'category',
                             position : 'bottom',
                             label:{
                               hideStrategy : 'greedy'
                             }
                     }
                   }
                },
                xAxis2 : {
                    id : 'sap.viz.modules.axis',
                    configure : {
                      'description':'Settings for the value axis at right or top of an XY chart with 2 value axis.',
                        propertyCategory : 'xAxis2',
                        properties : {
                          isIndependentMode : true,
                            type : 'category',
                            position : 'top',
                            isTruncateAvailable : false,
                            gridline : {
                                visible : false
                            },                          
                            label:{
                              hideStrategy : 'greedy'
                            }
                  
                        },
                        propertiesOverride:{
                            gridline: {
                              isExported: false
                            },
                            axisline: {
                              isExported: false
                            },
                            label:{
                              numberFormat:{
                                isExported: false
                              }
                            },
                            scale : { 
                              fixedRange : {isExported : false},
                              minValue : {isExported : false},
                              maxValue : {isExported : false},
                              isExported : false 
                            }
                         }
                    }
                }
         
              }
          },
          tooltip : {
              id : 'sap.viz.modules.tooltip',
              configure : {
                propertyCategory : 'tooltip',
                properties : {
                  chartType : 'mekko',
                  orientation : 'bottom'
                }
              }
          }
        }
      }
    },
    feeds:{
    secondaryValues: {
      min : 1,
      max : 1
    },
    primaryValues : {
       min : 1,
         max : 1
    },
    regionColor :{
      min: 0,
      max: 1,
      acceptMND: -1
    },
    axisLabels :{
      min: 1,
      max: 1,
      acceptMND: -1
    }
    },
      dependencies : {
        attributes : [ 
        {
          targetModule : 'root.main.plot',
          target : 'primaryDataRange',
          sourceModule : 'root.main.yAxis',
          source : 'range'
        }, {
          targetModule : 'root.main.yAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'primaryScale'
        }, {
          targetModule : 'root.main.xAxis2',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'secondCategoryScale'
        }, {
          targetModule : 'root.main.yAxis',
          target : 'color',
          sourceModule : 'root.main.plot',
          source : 'primaryAxisColor'
        }, {
          targetModule : 'root.main.xAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'categoryScale'
        },{
      targetModule : 'root.main.yAxis',
       target : 'title',
       sourceModule : 'root.main.plot',
       source : 'primaryAxisTitle'
    }, {
      targetModule : 'root.main.xAxis2',
       target : 'title',
       sourceModule : 'root.main.plot',
       source : 'secondAxisTitle'
    },{
        targetModule : 'root.main.xAxis2',
        target : 'independentData',
        sourceModule : 'root.main.plot',
        source : 'dimensionData'
    }, {
          targetModule : 'root.legends.legend',
          target : 'colorPalette',
          sourceModule : 'root.main.plot',
          source : 'colorPalette'
        }, {
        targetModule : 'root.legends.legend',
        target : 'setSelectionMode',
        sourceModule : 'root.interaction',
        source : 'getSelectionMode'
      } ]
    }
  };

  Manifest.register(chart);
});
define('sap/viz/manifests/xy/PercentageMekkoChart',['sap/viz/manifests/Viz','sap/viz/modules/manifests/RootContainer','sap/viz/manifests/xy/MekkoChart'],
function Setup(Manifest) {
  var chart = {
    id : 'viz/100_mekko',
    name : 'IDS_PERCENTAGEMEKKOCHART',
    base : 'viz/mekko',
      modules : {
        root : {
          modules : {
             tooltip : {
              id : 'sap.viz.modules.tooltip',
              configure : {
                propertyCategory : 'tooltip',
                properties : {
                  formatString: [["0.00%"],[""]]
                }
              }
          },
          main : {
              modules : {
                dataLabel : {
                  id : 'sap.viz.modules.datalabel',
                  configure : {
                    propertyCategory : 'dataLabel',
                    properties : {
                      isPercentMode: true
                    }
                  }
                },
                plot: {
                  id : 'sap.viz.modules.mekko',
                  configure: {
                    propertyCategory : 'plotArea',
                    properties : {
                        mode: 'percentage'
                      },
                      propertiesOverride:{
                        primaryValuesColorPalette:{
                          isExported: false
                        },
                       
                        mode: {
                          isExported: false
                        },
                        orientation: {
                            isExported: false
                          }
                     }
                  }
                },
                yAxis : {
                    id : 'sap.viz.modules.axis',
                    configure : {
                    'description': 'Settings for the value axis of an XY chart.',
                      propertyCategory : 'yAxis',
                      properties : {
                        isPercentMode : true
                      },
                      propertiesOverride : {
                        scale : { 
                          fixedRange : {isExported : false},
                          minValue : {isExported : false},
                          maxValue : {isExported : false},
                          isExported : false 
                        }
                      }
                    }
                  }
              }
            }
          }
        }
      }
    };


  Manifest.register(chart);
});
define('sap/viz/manifests/xy/HorizontalMekkoChart',['sap/viz/manifests/Viz','sap/viz/modules/manifests/RootContainer',
'sap/viz/manifests/xy/BarChart','sap/viz/modules/manifests/xy/Mekko'],
function Setup ( Manifest ) {
  var chart = {
    id : 'viz/horizontal_mekko',
    name : 'IDS_HORIZONTALMEKKOCHART',
    base : 'viz/bar',
    modules : {
      root : {
        modules : {
          main : {
              modules : {
                dataLabel : {
                  id : 'sap.viz.modules.datalabel',
                  configure : {
                    properties : {
                      automaticInOutside : false,
                      isStackMode : true,
                      isMekko : true,
                      showZero : false
                    },
                    propertiesOverride:{
                      position : {
                        isExported : false
                      }
                    }
                  }
                },
                plot: {
                  id : 'sap.viz.modules.mekko',
                  configure: {
                    propertyCategory : 'plotArea',
                      propertiesOverride:{
                        primaryValuesColorPalette:{
                          isExported: false
                        },
                        
                        mode: {
                          isExported: false
                        },
                        orientation: {
                          isExported: false
                        }
                     }
                  }
                },
                xAxis:{
                      id : 'sap.viz.modules.axis',
                    configure:{
                      'description':'Settings for the value axis at left or bottom of an XY chart with 2 value axis.'
                    }
                },
                yAxis : {
                   id : 'sap.viz.modules.axis',
                   configure : {
                     properties:{
                       type : 'category',
                             position : 'left',
                             label:{
                               hideStrategy : 'greedy'
                             }
                     }
                   }
                },
                yAxis2 : {
                    id : 'sap.viz.modules.axis',
                    configure : {
                      'description':'Settings for the value axis at right or top of an XY chart with 2 value axis.',
                        propertyCategory : 'yAxis2',
                        properties : {
                          isIndependentMode : true,
                            type : 'category',
                            position : 'right',
                            isTruncateAvailable : false,
                            gridline : {
                                visible : false
                            },
                            label:{
                              hideStrategy : 'greedy'
                            }
                  
                        },
                        propertiesOverride:{
                            gridline: {
                              isExported: false
                            },
                            axisline: {
                              isExported: false
                            },
                            label:{
                              numberFormat:{
                                isExported: false
                              }
                            },
                            scale : { 
                              fixedRange : {isExported : false},
                              minValue : {isExported : false},
                              maxValue : {isExported : false},
                              isExported : false 
                            }
                         }
                    }
                }
         
              }
          },
          tooltip : {
            id : 'sap.viz.modules.tooltip',
            configure : {
              propertyCategory : 'tooltip',
              properties : {
                chartType : 'mekko',
                orientation : 'left'
              }
            }
        }
        }
      }      
    },
    feeds:{
    secondaryValues: {
      min : 1,
      max : 1
    },
    primaryValues : {
       min : 1,
         max : 1
    },
    regionColor :{
      min: 0,
      max: 1,
      acceptMND: -1
    },
    axisLabels :{
      min: 1,
      max: 1,
      acceptMND: -1
    }
    },
      dependencies : {
        attributes : [ 
        {
          targetModule : 'root.main.plot',
          target : 'primaryDataRange',
          sourceModule : 'root.main.xAxis',
          source : 'range'
        }, {
          targetModule : 'root.main.xAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'primaryScale'
        }, {
          targetModule : 'root.main.yAxis2',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'secondCategoryScale'
        }, {
          targetModule : 'root.main.xAxis',
          target : 'color',
          sourceModule : 'root.main.plot',
          source : 'primaryAxisColor'
        }, {
          targetModule : 'root.main.yAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'categoryScale'
        },{
      targetModule : 'root.main.xAxis',
       target : 'title',
       sourceModule : 'root.main.plot',
       source : 'primaryAxisTitle'
    }, {
      targetModule : 'root.main.yAxis2',
       target : 'title',
       sourceModule : 'root.main.plot',
       source : 'secondAxisTitle'
    },{
        targetModule : 'root.main.yAxis2',
        target : 'independentData',
        sourceModule : 'root.main.plot',
        source : 'dimensionData'
    }, {
          targetModule : 'root.legends.legend',
          target : 'colorPalette',
          sourceModule : 'root.main.plot',
          source : 'colorPalette'
        }, {
        targetModule : 'root.legends.legend',
        target : 'setSelectionMode',
        sourceModule : 'root.interaction',
        source : 'getSelectionMode'
      } ]
    }
  };

  Manifest.register(chart);
});
define('sap/viz/manifests/xy/PercentageHorizontalMekkoChart',['sap/viz/manifests/Viz','sap/viz/modules/manifests/RootContainer','sap/viz/manifests/xy/HorizontalMekkoChart'],
function Setup(Manifest) {
  var chart = {
    id : 'viz/100_horizontal_mekko',
    name : 'IDS_PERCENTAGEHORIZONTALMEKKOCHART',
    base : 'viz/horizontal_mekko',
      modules : {
        root : {
          modules : {
            tooltip : {
              id : 'sap.viz.modules.tooltip',
              configure : {
                propertyCategory : 'tooltip',
                properties : {
                  chartType : 'mekko',
                  formatString: [["0.00%"],[""]]
                }
              }
          },
          main : {
              modules : {
                dataLabel : {
                    id : 'sap.viz.modules.datalabel',
                    configure : {
                      propertyCategory : 'dataLabel',
                      properties : {
                        isPercentMode: true
                      }
                    }
                  },
                plot: {
                  id : 'sap.viz.modules.mekko',
                  configure: {
                    propertyCategory : 'plotArea',
                    properties : {
                        mode: 'percentage'
                      },
                      propertiesOverride:{
                        primaryValuesColorPalette:{
                          isExported: false
                        },
                        
                        mode: {
                          isExported: false
                        },
                        orientation: {
                            isExported: false
                          }
                     }
                  }
                },
                xAxis : {
                    id : 'sap.viz.modules.axis',
                    configure : {
                    'description': 'Settings for the value axis of an XY chart.',
                      propertyCategory : 'xAxis',
                      properties : {
                        isPercentMode : true
                      },
                      propertiesOverride : {
                        scale : { 
                          fixedRange : {isExported : false},
                          minValue : {isExported : false},
                          maxValue : {isExported : false},
                          isExported : false 
                        }
                      }
                    }
                  }
              }
            }
          }
        }
      }
    };


  Manifest.register(chart);
});
define('sap/viz/modules/area',['sap/viz/modules/util/dataUtil','sap/viz/modules/dispatch','sap/viz/modules/util/MNDHandler',
'sap/viz/base/utils/TypeUtils','sap/viz/util/Scaler','sap/viz/util/ColorSeriesGenerator',
'sap/viz/util/BoundingBox','sap/viz/util/NumberUtils','sap/viz/lang/langManager',
'sap/viz/util/DrawUtil','sap/viz/modules/util/tooltipDataHandler','sap/viz/modules/manifests/Module',
'sap/viz/base/utils/ObjectUtils','sap/viz/base/utils/Objects','sap/viz/base/UADetector',
'sap/viz/modules/util/BoundUtil','sap/viz/modules/util/defaultSelectionUtil','sap/viz/modules/Constants'],
function Setup(dataUtil, dispatch, MNDHandler, TypeUtils, Scaler, ColorSeries, BoundingBox, NumberUtils, langManager, DrawUtil, TooltipDataHandler, Manifest, ObjectUtils, Objects,UADetector, BoundUtil, defaultSelUtil, Constants) 
{
  return function(manifest, ctx) 
  {
    var CLASSMARKERSELECTED = Constants.CSS.CLASS.DATAPOINTSELECTED,
        CLASSMARKERHOVER = Constants.CSS.CLASS.DATAPOINTHOVER,
        CLASSMARKERDEFAULT = Constants.CSS.CLASS.DATAPOINTDEFAULT,
        CLASSDATAPOINT = Constants.CSS.CLASS.DATAPOINT,
        SEL_CLASSDATAPOINT = '.' + CLASSDATAPOINT,
        CLASSMORPHABLEDATAPOINT = Constants.CSS.CLASS.MORPHABLEDATAPOINT,
        MORPHABLEAREABG = Constants.CSS.CLASS.MORPHABLEAREABG;
    var CLASSAREABG='v-areabg',
        SEL_CLASSAREABG = '.'+CLASSAREABG;
        
    var CLASSDATAPOINTCOMBINED = CLASSDATAPOINT + ' ' + CLASSMORPHABLEDATAPOINT,
        CLASSAREABGCOMBINED = CLASSAREABG + ' '+ MORPHABLEAREABG;

    var width, height;
    var data_ = null, props;
    //alistar zhu
    var randomSuffix = ObjectUtils.guid();
    //alex su
    var tooltipData = null;
    var _tooltipDataHandler;

    var bgColor = "#FFFFFF";
    var hoverColor = "#cccccc";
    var selectedColor = "#333333";

    var xScale = d3.scale.ordinal();
    var mouseMoveLine;
    var preHighLightIndex;
    var g;
    var svgMarkersGroup, svgAreasGroup, svgAreaBgGroup;
    var eDispatch = new dispatch('showTooltip', 'hideTooltip', 'initialized', 'startToInit');
    var effectManager = ctx.effectManager;
    var valueAxis1Data = {
        data: [],
        scale: d3.scale.linear(),
        colorPalette:null,
        selectedMarkers: null,
        markers:[],
        areas:[],
        bottomValue: null,
        topValue:null,
        drawData:null
    };
    var areaShapeline = null;
  
    var colorPalette = [];
    var bAnimationComplete = false;
 
    var selectedMarkerNum = 0;
    var gSelection = null;

    // clip defs for enimation

    var isDataSchemaChanged = false, isDataLoading = true, isSizeChanged = false, isDatasetChanged = false, hasDefaultSelection = false;
    
    var clipRect;
    
    var OPACITY = 0.4;
    
    var bDataUpdated = false;
    
    //@Alex Su, judge whether we should enable animation
    
    function enableAnimation(){
      var hasAnmation = false;
      if(isDataLoading){
        hasAnmation = props.animation.dataLoading;
      }else if(isDatasetChanged){
        hasAnmation = props.animation.dataUpdating;
      }else if(isSizeChanged){
        hasAnmation = props.animation.resizing;
      }
      return hasAnmation;
    }

    function area(selection) {
      //selection.each(generate);
      BoundUtil.drawBound(selection, width, height);
      //alex su
      _tooltipDataHandler = TooltipDataHandler();
      
      renderChart(selection);
      isDataSchemaChanged = false, isDataLoading = false, isSizeChanged = false, isDatasetChanged = false;
      return area;
    }

   // For normal stacked area chart, currently we only use globally stacked 
//    function calculateStackedMinMax(axisValue, minMax)
//    {
//    
//      var accuPositiveValues = new Array(axisValue.data[0].length);
//      var accuNegativeValues = new Array(axisValue.data[0].length);
//      var i;
//      for(i = 0; i < accuPositiveValues.length; ++i)
//      {
//        accuPositiveValues[i] = 0;
//        accuNegativeValues[i] = 0;
//      }
//      for(i = 0; i < axisValue.data.length; ++i)
//      {
//        for(var j = 0; j < axisValue.data[i].length; ++j)
//        {
//          if(!NumberUtils.isNoValue(axisValue.data[i][j].val))
//          {
//            if(axisValue.data[i][j].val >= 0)
//            {
//              accuPositiveValues[j] += axisValue.data[i][j].val ;
//            } else {
//              accuNegativeValues[j] += axisValue.data[i][j].val ;
//            }
//          }
//        }
//      }
//      minMax.max = d3.max(accuPositiveValues);
//      minMax.min = d3.min(accuNegativeValues);
//    }
    
    function calculateGloballyStackedMinMax(axisValue, minMax)
    {
    
      var accuValues = new Array(axisValue.data[0].length);
      var i;
      for(i = 0; i < accuValues.length; ++i)
      {
        accuValues[i] = 0;
      }
      for(i = 0; i < axisValue.data.length; ++i)
      {
        for(var j = 0; j < axisValue.data[i].length; ++j)
        {
          if(!NumberUtils.isNoValue(axisValue.data[i][j].val))
          {
              accuValues[j] += axisValue.data[i][j].val;
              if(minMax.min === null)
              {
                minMax.min = accuValues[j];
                minMax.max = accuValues[j];
              }else{
                minMax.min = minMax.min > accuValues[j] ? accuValues[j] : minMax.min;
                minMax.max = minMax.max > accuValues[j] ? minMax.max : accuValues[j];
              }
          }
        }
      }
    }


    function calculateMinMax(axisValue)
    {
      var minMax = {
          min:null,
          max:null
      };
      if(!axisValue.data || axisValue.data.length === 0){
        return minMax;}
      if(props.mode === "percentage"){
        minMax.min = 0;
        minMax.max = 1;
        return minMax;
      }
      /*  for normal stacked chart and non-stacked chart
     if(props.bStacked){
        calculateStackedMinMax(axisValue, minMax);
      }else{
        minMax.max = Number(d3.max(axisValue.data, function(d){
          return d3.max(d, function(_){ return _.val;});
        }));
        minMax.min = Number(d3.min(axisValue.data, function(d){
          return d3.min(d, function(_){ return _.val;});
        }));
      }
      */
      calculateGloballyStackedMinMax(axisValue, minMax);
      if(NumberUtils.isNoValue(minMax.max )) { return null;}
      
      if(minMax.min >= 0)
      {
        minMax.min = 0;
        minMax.max += minMax.max * 5 / (props.orientation === "vertical" ? height :width) ;
      }
      else if(minMax.max <= 0){
        minMax.max = 0;
        minMax.min +=  minMax.min * 5/ (props.orientation === "vertical" ? height :width);
      }else{
        var temp = (minMax.max - minMax.min) * 5 / (props.orientation === "vertical" ? height :width);
        minMax.min -= temp;
        minMax.max += temp;
      }
      if(minMax.min === 0 && minMax.max === 0){
        minMax.max = 1;
      }
      return minMax;
    }

    function createColorPalette()
    {
      colorPalette = [];
      var i = 0, j = 0;
      valueAxis1Data.colorPalette = props.colorPalette;
      for(i = 0; i < valueAxis1Data.data.length; ++i)
      {
      colorPalette.push(valueAxis1Data.colorPalette[i% valueAxis1Data.colorPalette.length]);
      }
    }

    function calculateScale(axisValue)
    {
       var range = (props.orientation === "vertical" ? [height, 0] : [0,width])
      if(axisValue.data && axisValue.data.length > 0)
      { 
        if(axisValue.topValue === null || axisValue.topValue === undefined)
        {
          var minMax = calculateMinMax(axisValue);
          if(!minMax) {
            axisValue.scale.domain([0, 1]).range (range);
            axisValue.bottomValue = null;
            axisValue.topValue = null;
          }
          else  {
            axisValue.scale.domain([minMax.min, minMax.max]).range(range);
            axisValue.bottomValue = minMax.min;
            axisValue.topValue = minMax.max;
          }
        }
        else{
          axisValue.scale.domain([axisValue.bottomValue, axisValue.topValue]).range(range);
        }
        if (!axisValue.manualRange) {
            Scaler.perfect(axisValue.scale);
        } else {
            Scaler.getRoughTickNum(axisValue.scale);
        }
      }
      else{
        axisValue.scale.domain([0,0]).range([0,0]);
      }
      return axisValue.scale;
    }

    function computeScales()
    {
      if(!(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(data_)))
      {
        return;
      }
      var domain = [];
      var categoryNum = valueAxis1Data.data[0].length;
     
      for (var i=0; i < categoryNum; i++){
        domain.push(i);
      }
      xScale.domain(domain).rangeBands(props.orientation === "vertical" ? [0, width] :[height, 0]);
      calculateScale(valueAxis1Data);
    }

    function changeGroupMarker(groupIndex, visible, className)
    {
      if(groupIndex === undefined || groupIndex === null){
        return;
      }
      var seriesIndex = 0;
      for(seriesIndex = 0; seriesIndex < valueAxis1Data.data.length; ++seriesIndex)
      {   
        if(!valueAxis1Data.selectedMarkers[seriesIndex][groupIndex])
        {
          changeOneMarker(seriesIndex, groupIndex, className, valueAxis1Data);
        }
      }
    }
    
    function changeOneArea(seriesIndex, xIndex, valueAxis, visible)
    {
      if(!valueAxis.areas[seriesIndex])
      {
        valueAxis.areas[seriesIndex] = [];  
      }
      if(!valueAxis.areas[seriesIndex][xIndex] && visible === "visible")
      {
        valueAxis.areas[seriesIndex][xIndex] = svgAreasGroup.append("svg:path").attr('class','v-areashape')
        .attr("d", areaShapeline(valueAxis.drawData.data[seriesIndex][xIndex])).attr("stroke", function (){
           var para = { graphType:"line", 
             fillColor:valueAxis.colorPalette[seriesIndex %  valueAxis.colorPalette.length]};
             return effectManager.register(para);
           }).attr("stroke-width", 1).attr("fill",  function (){
           var para = { 
                drawingEffect:props.drawingEffect,
                graphType:"rectangle", 
                direction : props.orientation,
                fillColor:valueAxis.colorPalette[seriesIndex %  valueAxis.colorPalette.length]};
                return effectManager.register(para);
           });
      }
      if(valueAxis.areas[seriesIndex][xIndex])
      {
        valueAxis.areas[seriesIndex][xIndex].attr("visibility", visible);
      }
    }
    
    function changeOneMarker(seriesIndex, xIndex, className, valueAxis)
    {
      var stroke, tempOpacity;

      if (className === CLASSMARKERSELECTED) {
        stroke = selectedColor;
        tempOpacity = 1;
        changeOneArea(seriesIndex, xIndex, valueAxis, "visible");
        valueAxis.selectedMarkers[seriesIndex][xIndex] = true;
      } else {
        changeOneArea(seriesIndex, xIndex, valueAxis, "hidden");
        valueAxis.selectedMarkers[seriesIndex][xIndex] = false;
        if(selectedMarkerNum > 0) {
            tempOpacity = OPACITY;
        } else {
            tempOpacity = 1;
        }
        
        if (className === CLASSMARKERHOVER) {
            stroke = bgColor;
        } else {
            stroke = "transparent";
            if (props.marker.visible === false) {
                tempOpacity = 0;
        }
        }
      }
  
      d3.select(valueAxis.markers[seriesIndex][xIndex])
        .attr("class", CLASSDATAPOINTCOMBINED + ' ' + className).attr("stroke", stroke).attr("opacity", tempOpacity);
    }

    function getCategoryIndex(val)
    {
      var index = val / xScale.rangeBand();
      index = Math.floor(index);
      var categoryNum = 0;
      categoryNum = valueAxis1Data.data[0].length;
      if(index > categoryNum - 1) {index = categoryNum - 1;}
      if(index < 0) { index = 0;}
      return (props.orientation === "vertical" ? index : categoryNum - 1 - index);
    }

    function processOneAxisSelect(valueAxis, marker) {
      svgAreaBgGroup.selectAll(".v_areabg").attr("opacity", OPACITY).attr("stroke-opacity", OPACITY);

      var findFlag = false, yi, xi;
      for(var i = 0; i < valueAxis.markers.length && !findFlag; i++)
      {
        var xMarks = valueAxis.markers[i];
        for (var j = 0; j<xMarks.length && !findFlag ; j++)
        {
          if(xMarks[j] === marker) {
            findFlag = true;
            yi = i;
            xi = j;
          }
        } //for j
      }//for i

      if (!findFlag) {
        return false;
      }

      if (valueAxis.selectedMarkers[yi][xi]) {
        return true;
      }
      ++selectedMarkerNum;
      changeOneMarker(yi, xi, CLASSMARKERSELECTED, valueAxis);
    }

    function processOneAxisDeselect (valueAxis, marker) {
      var xi = preHighLightIndex;

      var findFlag = false, yi;
      for(var i = 0; i < valueAxis.markers.length && !findFlag; i++)
      {
        var xMarks = valueAxis.markers[i];
        for (var j = 0; j<xMarks.length && !findFlag ; j++)
        {
          if(xMarks[j] === marker) {
            findFlag = true;
            yi = i;
            xi = j;
          }
        } 
      }

      if (!findFlag) {
        return false;
      }

      if (!valueAxis.selectedMarkers[yi][xi]){
        return true;
      }

      if(xi === preHighLightIndex){
        changeOneMarker(yi, xi, CLASSMARKERHOVER, valueAxis);
      }
      else{
        changeOneMarker(yi, xi, CLASSMARKERDEFAULT, valueAxis);
      }
    }
    
//    function processNullValue(axisValue)
//    {
//      var result = {
//          data:[],
//          color:[]
//      };
//      var arr = [];
//      var k;
//      var obj = {};
//      for(var i = 0; i < axisValue.length; ++i)
//      {
//        var preIndex = 0;
//        for(var j = 0; j < axisValue[i].length; ++j)
//        {
//          if(NumberUtils.isNoValue(axisValue[i][j].val))
//          {
//            if(j > preIndex)
//            {
//              arr = [];
//              arr.push({x:preIndex, y:0});
//              for(k = preIndex; k < j; k++)
//              {
//                obj = {};
//                obj.y = axisValue[i][k].val;
//                obj.x = k;  
//                arr.push(obj);
//              }
//              arr.push({x:k-1, y:0});
//              result.data.push(arr);
//              result.color.push(i);
//             }
//             preIndex = j + 1;
//           }
//        }
//        
//        if(preIndex < axisValue[i].length)
//        {
//          arr = [];
//          arr.push({x:preIndex, y:0});
//          for(k = preIndex; k <  axisValue[i].length; k++)
//          {
//            obj = {};
//            obj.y = axisValue[i][k].val;
//            obj.x = k;
//            arr.push(obj);
//          }
//          arr.push({x:k-1, y:0});
//          result.data.push(arr);
//          result.color.push(i);
//        }
//      }
//      return result;
//    }
//    
//    // for normal stacked area chart, currently not used
//    function generateAreaData(axisValue)
//    {
//      var result = {
//          data:[],
//          color:[],
//          accuPositiveVal:[],
//          accuNegativeVal:[]
//      };
//      var arr = [];
//      var i;
//      var topAreaData = [];
//      var bottomAreaData = [];
//      //generate area for all series
//      for(i = 0; i < axisValue.length; ++i)
//      {
//        result.accuPositiveVal[i] = new Array(axisValue[i].length);
//        result.accuNegativeVal[i] = new Array(axisValue[i].length);
//        for(var j = 0; j < axisValue[i].length; ++j)
//        {
//          result.accuPositiveVal[i][j] = (i > 0 ? result.accuPositiveVal[i-1][j] : 0);
//          result.accuNegativeVal[i][j] =  (i > 0 ? result.accuNegativeVal[i-1][j] : 0);
//          if(!NumberUtils.isNoValue(axisValue[i][j].val))
//          {
//            if(axisValue[i][j].val >= 0)
//            {
//              bottomAreaData.push({x:j, y:result.accuPositiveVal[i][j]});
//              result.accuPositiveVal[i][j] += axisValue[i][j].val ;
//              topAreaData.push({x:j, y: result.accuPositiveVal[i][j]});
//              
//            } else if(axisValue[i][j].val < 0){
//              topAreaData.push({x:j, y:result.accuNegativeVal[i][j]});
//              result.accuNegativeVal[i][j] += axisValue[i][j].val ;
//              bottomAreaData.push({x:j, y:result.accuNegativeVal[i][j]});
//            } 
//            
//            } else {
//            if(j > 0 && !NumberUtils.isNoValue(axisValue[i][j-1].val) )
//            {
//              if(axisValue[i][j - 1].val >= 0)
//              {
//                topAreaData.push({x:j, y: result.accuPositiveVal[i][j]});
//              } else {
//                topAreaData.push({x:j, y:result.accuNegativeVal[i][j]});
//              }
//              topAreaData = topAreaData.concat(bottomAreaData.reverse());
//              result.data.push(topAreaData);
//              result.color.push(i);
//              topAreaData = [];
//              bottomAreaData = [];
//            }
//            
//            if( j < axisValue[i].length - 1 &&  !NumberUtils.isNoValue(axisValue[i][j+1].val))
//            {
//              if(axisValue[i][j+1].val >= 0)
//              {
//                topAreaData.push({x:j, y:result.accuPositiveVal[i][j]});
//              }else{
//                topAreaData.push({x:j, y:result.accuNegativeVal[i][j]});
//              }
//            }
//          }
//        }
//        
//        if(topAreaData.length > 0)
//        {
//          topAreaData = topAreaData.concat(bottomAreaData.reverse());
//          result.data.push(topAreaData);
//          result.color.push(i);
//          topAreaData = [];
//          bottomAreaData = [];
//        }
//      }
//      return result;
//    }

    function generateGloballyStackedAreaData(axisValue)
    {
      var data = axisValue.data;
      var result = {
          data:[],   // store data for each point which use to highlight one area 
          bgAreaData:[], // draw area background region
          accuVal:[]  // accumulated values for stacked area
      };
      var i , j;
      var topAreaData = [];
      var bottomAreaData = [];
   
      // speical process for percentage chart, divide regions for zero values
      var groupValueNumbers = new Array(data[0].length);
      if(props.mode === "percentage" && bDataUpdated)
      {
        turnToPercentage(data);
        bDataUpdated = false;
      }
      
      for( i = 0; i < groupValueNumbers.length; ++i)
      {
        groupValueNumbers[i] = 0;
      }
      result.bgAreaData = new Array(data.length);
      for(i = 0; i < data.length; ++i)
      {     
        result.bgAreaData[i] = [];
        result.accuVal[i] = new Array(data[i].length);
        for( j = 0; j < data[i].length; ++j)
        {
          result.accuVal[i][j] = (i > 0 ? result.accuVal[i-1][j] : 0);
          if(!NumberUtils.isNoValue(data[i][j].val))
          {
            groupValueNumbers[j] ++;
            result.accuVal[i][j] += (props.mode === "percentage" ? Math.abs(data[i][j].val) : data[i][j].val);
          }
        }
      }
      
      // generate background area shape
      for(i = 0; i < data.length; ++i)
      {
        for(j = 0; j < data[i].length; ++j)
        {      
          if(!NumberUtils.isNoValue(data[i][j].val))
          {
            // there are 0 values in group and group contain 0 and null value only 
              bottomAreaData.push({ctx:data[i][j].ctx, x:j, y: ( i > 0 ? result.accuVal[i - 1][j] : 0)});
              topAreaData.push({ctx:data[i][j].ctx, x:j, y: result.accuVal[i][j]});
          } else {
            if(groupValueNumbers[j] > 0)
            {
              if(j > 0 && !NumberUtils.isNoValue(data[i][j-1].val) )
              {
                topAreaData.push({ctx:data[i][j].ctx, x:j, y: result.accuVal[i][j]}); 
                topAreaData = topAreaData.concat(bottomAreaData.reverse());
                result.bgAreaData[i].push(topAreaData);
                topAreaData = [];
                bottomAreaData = [];
              }

              if( j < data[i].length - 1 &&  !NumberUtils.isNoValue(data[i][j+1].val))
              {
                topAreaData.push({ctx:data[i][j].ctx, x:j, y:result.accuVal[i][j]});
              }
            }else if(topAreaData.length > 0)
            {
              topAreaData = topAreaData.concat(bottomAreaData.reverse());
              result.bgAreaData[i].push(topAreaData);
              topAreaData = [];
              bottomAreaData = [];
            }
          }         
        }

        if(topAreaData.length > 0)
        {
          topAreaData = topAreaData.concat(bottomAreaData.reverse());
          result.bgAreaData[i].push(topAreaData);
          topAreaData = [];
          bottomAreaData = [];
        }
      }
      
      
      // generate path for every point's area
      var element = {};
      for(i = 0; i < data.length; ++i)
      {
        result.data[i] = [];
        for(j = 0; j < data[i].length; ++j)
        {  
            if( j > 0 )
            {
               if( groupValueNumbers[j - 1] > 0)
               {
                 topAreaData.push({x: j - 0.5, y : (result.accuVal[i][j - 1] + result.accuVal[i][j]) / 2});
                 bottomAreaData.push({x : j - 0.5, y: (i > 0 ? ((result.accuVal[i - 1][j - 1] + result.accuVal[i - 1][j]) / 2) : 0)});
               }
            }
            topAreaData.push({x: j, y : result.accuVal[i][j]});
            bottomAreaData.push({x :j, y: ( i > 0 ? result.accuVal[i - 1][j] : 0)});
            if(j < data[0].length - 1)
            {
              if( groupValueNumbers[j + 1] > 0)
              {
                topAreaData.push({x: j + 0.5, y : (result.accuVal[i][j] + result.accuVal[i][j + 1]) / 2});
                bottomAreaData.push({x : j + 0.5, y: (i > 0 ? ((result.accuVal[i - 1][j] + result.accuVal[i - 1][j + 1]) / 2) : 0)});
              }
            }
            topAreaData = topAreaData.concat(bottomAreaData.reverse());
            result.data[i].push(topAreaData);
            topAreaData = [];
            bottomAreaData = [];
            
        }
      }
      axisValue.drawData = result;
      return result;
    }
    
    
    function processOneAxis(axisValue)
    {
      if(!axisValue.data || axisValue.data.length === 0){
        return;
      }
      var result = generateGloballyStackedAreaData(axisValue);
      // for normal stacked and non-stacked
//      if(props.bStacked){
//        result = generateAreaData(axisValue.data);
//      } else {
//        result = processNullValue(axisValue.data);
//      }


      var areas = svgAreaBgGroup.selectAll("." + "v-areagroup").data(result.bgAreaData);
      areas.enter().append("svg:g").attr("class", "v-areagroup");
      areas.exit().remove();
      // draw area chart
      var line = (props.orientation === "vertical" ?  d3.svg.line().x(function(d,i) { return xScale(d.x) + xScale.rangeBand(
) / 2; }).
      y(function(d) {  return axisValue.scale(d.y); }) :
      d3.svg.line().y(function(d,i) { return xScale(d.x) + xScale.rangeBand() / 2; }).
      x(function(d) {  return axisValue.scale(d.y); }));
      areas.attr("transform", 
          function(d, i) {
            var areaShapes = d3.select(this).selectAll(SEL_CLASSAREABG).data(d);
            areaShapes.enter().append("svg:path").attr("stroke-linejoin", "round").attr("class", CLASSAREABGCOMBINED).attr("opacity", 1).attr("stroke-opacity", 1);
            areaShapes.exit().remove();
            areaShapes.attr("transform", function(areapath, index)
            {
            d3.select(this).attr("d", line(areapath)).attr("stroke", function (){
              var para = { graphType:"line", 
                  fillColor:axisValue.colorPalette[i %  axisValue.colorPalette.length]};
                  return effectManager.register(para);
                  })
            .attr("stroke-width", 1)
            .attr("fill",  function (){
                var para = { 
                  drawingEffect:props.drawingEffect,
                  graphType:"rectangle", 
                  direction : props.orientation,
                  fillColor:axisValue.colorPalette[i %  axisValue.colorPalette.length]};
                  return effectManager.register(para);
                });
            });
      });
      
      areaShapeline = ( props.orientation === "vertical" ? d3.svg.line().x(function(d,i) { return (d.x + 0.5) * xScale.rangeBand();})
      .y(function(d) {  return axisValue.scale(d.y); }) :
      d3.svg.line().y(function(d,i) { return height - (d.x + 0.5) * xScale.rangeBand();}).
      x(function(d) {  return axisValue.scale(d.y); }));
      axisValue.areas = [];
      svgAreasGroup.selectAll(".v-areashape").remove();
      
      axisValue.selectedMarkers = new Array(axisValue.data.length);
      axisValue.markers = [];
      
      // draw markers
      for(var seriesIndex = 0; seriesIndex < axisValue.data.length; ++seriesIndex)
      {
        axisValue.selectedMarkers[seriesIndex] = [];
        for(var dataIndex = 0; dataIndex < axisValue.data[0].length; ++dataIndex)
        {
          axisValue.selectedMarkers[seriesIndex][dataIndex] = false;
        }
      }
 
      var groups = svgMarkersGroup.selectAll("g.v-marker").data(axisValue.data);
      groups.enter().append("svg:g").attr("class", "v-marker");
      groups.exit().remove();
      
      var visible = "hidden";
      if(props && props.marker && props.marker.visible){
        visible  = "visible";
      }
      groups.attr("transform", function(d, i) {
        
        var seriesMarkers = d3.select(this).selectAll(".v-datashape").data(d);
        var datashape = seriesMarkers.enter().append('g').attr('class','v-datashape');
        DrawUtil.createElements(datashape,{shape: props.marker.shape, className: CLASSDATAPOINTCOMBINED + " " + CLASSMARKERDEFAULT } );
        seriesMarkers.exit().remove();
        var markerArr = [];
        seriesMarkers.attr("transform",function(point, index)
        {   
          if(NumberUtils.isNoValue(point.val))
          { 
              d3.select(this).remove();
              markerArr.push(null);
              return;
          }
          markerArr.push(d3.select(this).selectAll('path').node());
        
          var parameter = {
              drawingEffect:props.drawingEffect,
              graphType: props.marker.shape,
              fillColor : axisValue.colorPalette[i % axisValue.colorPalette.length],
              direction : 'vertical',
              rx: props.marker.size / 2,
              ry: props.marker.size / 2,
              borderWidth: 2,
              borderColor: props.style.marker.stroke,
              strokeOpacity: 0.3,
              node:d3.select(this).select('path'),
              visibility: visible
          };

          DrawUtil.drawGraph(parameter, effectManager);
 
          return   props.orientation === "vertical"
           ? "translate(" + (xScale(index) + xScale.rangeBand() / 2) + "," + axisValue.scale(result.accuVal[i][index]) + ")"
           :  "translate(" + axisValue.scale(result.accuVal[i][index]) + "," + (xScale(index) + xScale.rangeBand() / 2) + ")";
          
//         for non-stacked and normal stacked case
 //         if(props.bStacked)
 //         {
 //           return  "translate(" + (xScale(index) + xScale.rangeBand() / 2) + "," + axisValue.scale(point.val >= 0 ? result.accuPositiveVal[i][index] : result.accuNegativeVal[i][index]) + ")"; 
 //         } else {
 //            return  "translate(" + (xScale(index) + xScale.rangeBand() / 2) + "," + axisValue.scale(point.val) + ")";  
 //         }
        });

        axisValue.markers.push(markerArr); 
      });
    }

    function processOneAxisDeselectAll(valueAxis, xIndex)
    {
      if(!valueAxis.selectedMarkers || valueAxis.selectedMarkers.length === 0){
        return;
      }

      for(var seriesIndex = 0; seriesIndex < valueAxis.selectedMarkers.length; ++seriesIndex)
      {
        for(var groupIndex = 0; groupIndex < valueAxis.selectedMarkers[0].length; ++groupIndex)
        {
          if(!valueAxis.selectedMarkers[seriesIndex][groupIndex]) {continue;}

          (valueAxis.areas[seriesIndex][groupIndex]).attr("visibility", "hidden");
 
          if(groupIndex === xIndex)
          {
            changeOneMarker(seriesIndex, groupIndex, CLASSMARKERHOVER, valueAxis);
          }
          else
          {
            changeOneMarker(seriesIndex, groupIndex, CLASSMARKERDEFAULT, valueAxis);
          }
        }
      }
    }
    function getCurrentEvent() {
        if (d3.event) {
            return d3.event;
        } else {
            return window.event;
        }
    }
    function deselectedAllHandler()
    {
      var event = getCurrentEvent();
      var xpoint =   props.orientation === "vertical" ? (event ? event.clientX : 0) - g.node().getBoundingClientRect().left 
      :(event ? event.clientY : 0) - g.node().getBoundingClientRect().top;
      var xIndex = getCategoryIndex(xpoint);
      selectedMarkerNum = 0;
      processOneAxisDeselectAll(valueAxis1Data, xIndex);
    }

    
    function renderChart(selection)
    {
      gSelection = selection;
      getCSSStyle();
      eDispatch.startToInit();
      if(!g){ g = selection.append("svg:g");}
      
      if(!clipRect){
        clipRect = g.append("svg:defs").append("svg:clipPath").attr("id", "clip1_" + randomSuffix).append("rect");
      }
      if( props.orientation === "vertical" )
      {
        clipRect.attr("x", 0).attr("y", 0).attr("height", height).attr("width", 0 );
      }else{
        clipRect.attr("x", 0).attr("y",  height).attr("height", 0).attr("width", width);
      }

      if(!svgMarkersGroup)
      {
        svgAreaBgGroup = g.append("svg:g").attr("class", "v-areasbg");
        svgAreasGroup = g.append("svg:g").attr("class", "v-areas");
        if(!mouseMoveLine) {mouseMoveLine = g.append("svg:line").attr("stroke", hoverColor).attr("class", "v-hoverline viz-plot-hoverline");}
        svgMarkersGroup = g.append("svg:g").attr("class", "v-markers v-datashapesgroup");
      }    
      if( props.orientation === "vertical" )
      {
        mouseMoveLine.attr("x1", 0).attr("y1", 0).attr("x2", 0).attr("y2", height)
       .attr("stroke-width", 1)
       .attr("visibility", "hidden").attr("stroke-linejoin", "round");
      }else {
        mouseMoveLine.attr("x1", 0).attr("y1", 0).attr("x2", width).attr("y2", 0)
        .attr("stroke-width", 1).attr("stroke", hoverColor)
        .attr("visibility", "hidden").attr("shape-rendering", "crispEdges");
      }
      selectedMarkerNum = 0;
      lightAll();
      
      // when we do windowing, some area may out of plot area. so we should keep clippath
      svgAreaBgGroup.attr("clip-path", "url(#clip1_" + randomSuffix + ")").attr("fill", "none");
      svgMarkersGroup.attr("clip-path", "url(#clip1_" + randomSuffix + ")").attr("fill", "none");
      svgAreasGroup.attr("clip-path", "url(#clip1_" + randomSuffix + ")").attr("fill", "none");
      
      //[21-Jan-2013 Nick] FIX BUG. Draw chart before 'initialized' event is fired out.
      processOneAxis(valueAxis1Data);
      if(enableAnimation()){
        if( props.orientation === "vertical" ){
        clipRect
          .attr("x", 0).attr("y", 0).attr("height", height).attr("width", 0).transition().duration(1000)
          .attr("width", function(){return width;}).each("end", function(){
          eDispatch.initialized();});
        } else {
          clipRect
          .attr("x", 0).attr("y", height).attr("height", 0).attr("width", width).transition().duration(1000)
          .attr("height", function(){return height;}).attr("y", 0).each("end", function(){
          eDispatch.initialized();});
        }
      }else{
        clipRect
        .attr("x", 0).attr("y", 0).attr("height", height).attr("width", width);
        eDispatch.initialized();
      }

    }
    
    // turn to percentage for value axis
    function turnToPercentage(data)
    {
      
      if(data === null || data === undefined  || data[0].length === 0)
        return;
      
      var i = 0, j = 0;
      var groupSums = new Array(data[0].length);
      var zeroNumbers = new Array(data[0].length);
      for( i = 0; i < groupSums.length; ++i)
      {
        groupSums[i] = 0;
        zeroNumbers[i] = 0;
      }
      for(i = 0; i < data.length; ++i)
      {
        for(j = 0; j < data[i].length; ++j)
        {
          if(!NumberUtils.isNoValue(data[i][j].val))
          {
            groupSums[j] += Math.abs(data[i][j].val);
            if(data[i][j].val === 0)
            {
              ++zeroNumbers[j];
            }
          }
        }
      }
      
      for(i = 0; i < data.length; ++i)
      {
        for(j = 0; j < data[i].length; ++j)
        {
           data[i][j].value = data[i][j].val;
          if(!NumberUtils.isNoValue(data[i][j].val))
              {
                if(groupSums[j] > 0){
                  data[i][j].value = data[i][j].val;
                  data[i][j].val = data[i][j].val / groupSums[j];
                }else if(zeroNumbers[j] > 0){
                  data[i][j].val = 1 / zeroNumbers[j];
                }
              } 
        }
      }

    }
  

    function lightAll() {
      svgAreaBgGroup.selectAll(SEL_CLASSAREABG).attr("opacity", 1).attr("stroke-opacity", 1);
      svgAreasGroup.selectAll(".v-areashape").attr("visibility", "hidden");
      if (props.marker.visible === true) {
        tempopacity = 1;
      } else {
        tempopacity = 0;
      }      
      svgMarkersGroup.selectAll('.'+ CLASSMARKERSELECTED).attr("opacity", tempopacity).attr("class", CLASSDATAPOINTCOMBINED + " " + CLASSMARKERDEFAULT);
    }

    function grayAll() {
      svgAreaBgGroup.selectAll(SEL_CLASSAREABG).attr("opacity", OPACITY).attr("stroke-opacity", OPACITY);
      svgAreasGroup.selectAll(".v-areashape").attr("visibility", "hidden");
      var tempopacity;
      if (props.marker.visible === true) {
        tempopacity = OPACITY;
      } else {
        tempopacity = 0;
      }
      svgMarkersGroup.selectAll('.'+ CLASSMARKERSELECTED).attr("opacity", tempopacity).attr("class",CLASSDATAPOINTCOMBINED + " " + CLASSMARKERDEFAULT,true);
    }
    
    function getCSSStyle() {
      if (!props.style){
        props.style = {};
      } 
      var cssDef;

      if (!props.style.marker){
        props.style.marker = {};
      }
      props.style.marker.stroke = "transparent";
     
      cssDef = ctx.styleManager.queryDefault('v-hoverline');
      if(cssDef)
      {
        if (cssDef['stroke']){
          hoverColor = cssDef['stroke'];
        }
      }
    }
    function resetDataRange(){
      valueAxis1Data.topValue = null;
      valueAxis1Data.bottomValue = null;
    }
    area.width = function(value) {
      if (!arguments.length){
        return width;
      }
      isSizeChanged = (!isSizeChanged && (value === width)) ? false : true;
      width = value;
      computeScales();
     
      return area;
    };
    
    area.height = function(value) {
      if (!arguments.length){
        return height;
      }
      isSizeChanged = (!isSizeChanged && (value === height)) ? false : true;
      height = value;
      computeScales();
      return area;
    };
    
    area.afterUIComponentAppear = function(){
      eDispatch.initialized(); 
    };
    /*
     * get/set properties
     */
    area.properties = function(_) {
      if (!arguments.length){
        return props;
      } 
      Objects.extend(true, props, _);
      computeScales();
     // if(props.marker.size < 4 || props.marker.size > 32) { props.marker.size = 6;}
     // if(props.width < 1 || props.width > 7) { props.width = 2; }
      props.marker.size = 4;
      props.marker.shape = "circle";

      createColorPalette();
      return area;
    };
    
    area.primaryAxisColor = function(){
          return null;
    };
        
        
    /**
     * get/set your event dispatch if you support event
     */
    area.dispatch = function(_){
      if(!arguments.length){
        return eDispatch;}
      eDispatch = _;
      return area;
    };
    /**
     * set/get data, for some modules like Title, it doesn't need data
     */
    area.data = function(value){
      if (!arguments.length){
        return data_;
      }
      isDatasetChanged = true;
      isDataSchemaChanged = false;
      if (! dataUtil().hasSameSchema(data_, value)){
        isDataSchemaChanged = true;
      }
      allDataIsNaN = true;
      bDataUpdated = true;
      data_ = value;
      var obj = MNDHandler(data_);
      valueAxis1Data.data = obj["MG1"];
      
      //[04-Mar-2013 Nick] Testify whether defaultselection
      var dataInfo = (valueAxis1Data.data.length === 0 ? valueAxis2Data.data[0][0] : valueAxis1Data.data[0][0]);
      if(dataInfo.info &&  dataInfo.info.defaultSelection){
        hasDefaultSelection = true;
      }else{
        hasDefaultSelection = false;
      }
      
      resetDataRange();
      
      //alex su
      tooltipData = TooltipDataHandler.dataTransform(obj);
      computeScales();
      createColorPalette();
      return area;        
    };
    
    area.dataLabel = function(_){};
      
      area.primaryAxisTitle = function(_){
        if(!arguments.length){
          var titles =  data_.getMeasureValuesGroupDataByIdx(0), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined) {
                  title.push(titles.values[i].col);
                } else {
                  title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join(' & ');
        }
        return this;
      };
      
     
    /**
     * get color palette
     */
    area.getColorPalette = function() {
      if(colorPalette.length === 0)
      {
        createColorPalette();
      }
      return colorPalette;
    };

    area.shapePalette = function(){
      if(!arguments.length){
        return [props.marker.shape];
      }
      return area;
    };

    area.primaryScale = function(scale)
    {
      if(!arguments.length)
      {
        return valueAxis1Data.scale;
      }
      valueAxis1Data.scale = scale;
      return area;
    };

    area.categoryScale = function(scale)
    {
      if(!arguments.length)
      {
        return xScale;
      }
      xScale = scale;
      return area;

    };

    area.primaryDataRange = function(range){
      if (!arguments.length){
        var maxt, mint;
        if(props.mode === 'percentage'){
          maxt = 1;
          mint = 0;
        }else{
          mint = valueAxis1Data.bottomValue;
          maxt = valueAxis1Data.topValue;
        }
        return {
          min: mint,
          max: maxt
        };
      }
      var tempMax, tempMin;
      if (range !== null) {
          if (!isNaN(range.max)) {
            tempMax = range.max;
          } else {
            tempMax = valueAxis1Data.scale.perfectDomainEnd;
          }
          if (!isNaN(range.min)) {
            tempMin = range.min;
          } else {
            tempMin = valueAxis1Data.scale.perfectDomainBegin;
          }
          if (tempMax > tempMin) {
            valueAxis1Data.topValue = tempMax;
            valueAxis1Data.bottomValue = tempMin;
            if (range.from === 'axis') {
              valueAxis1Data.manualRange = true;
            }
            if(TypeUtils.isExist(width) && TypeUtils.isExist(height)) {
              calculateScale(valueAxis1Data);
            }
          }
      } else {
          if (valueAxis1Data.manualRange === true) {
            valueAxis1Data.topValue = valueAxis1Data.scale.perfectDomainEnd;
            valueAxis1Data.bottomValue = valueAxis1Data.scale.perfectDomainBegin;
            valueAxis1Data.manualRange = false;
            if(TypeUtils.isExist(width) && TypeUtils.isExist(height)) {
              calculateScale(valueAxis1Data);
            }
          }
      }
      return area;
    };

    area.parent = function() { 
      return gSelection;
    };

    /**
     * get/set size
     */
    area.size = function(_) {
      if (arguments.length === 0){
        return {
          width : area.width(),
          height : area.height()
        };
      }
      isSizeChanged = (!isSizeChanged && (_.width === width) && (_.height === height)) ? false : true;
      width = _.width;
      height = _.height;
      computeScales();
      return area;
    };
    
    area.clear = function (gray) {
      deselectedAllHandler();
      var markers = [];
      if (gray === null || gray === undefined || gray === false){
        lightAll();
        markers.push(svgMarkersGroup.selectAll("g.v-marker").selectAll(SEL_CLASSDATAPOINT));
        if(hasDefaultSelection){
          defaultSelUtil.clearSelectionInfo(gSelection, false, markers);
        }
      } else {
        grayAll();
      }
    };

    area.highlight = function (elements) {
      var elementArray;
      if (elements instanceof Array) {
        elementArray = elements;
      } else {
        elementArray = [];
        elementArray.push(elements);
      }

      for (var i=0; i<elementArray.length; i++)
      {
        var marker = elementArray[i];
        processOneAxisSelect(valueAxis1Data, marker );
      }
      
      svgMarkersGroup.selectAll("."+ CLASSMARKERHOVER).attr("opacity", OPACITY);
	  if (props.marker.visible){
		svgMarkersGroup.selectAll("."+ CLASSMARKERDEFAULT).attr("opacity", OPACITY);
	  }
      if(hasDefaultSelection){
        defaultSelUtil.clearSelectionInfo(gSelection, true, elementArray);
      }
    };

    area.unhighlight = function (elements) {
      var elementArray;
      if (elements instanceof Array) {
        elementArray = elements;
      } else {
        elementArray = [];
        elementArray.push(elements);
      }
      
      selectedMarkerNum -= elementArray.length;
      for (var i=0; i<elementArray.length; i++)
      {
        var marker = elementArray[i];
        processOneAxisDeselect(valueAxis1Data, marker);
      }
      if(selectedMarkerNum === 0)
      {
        svgMarkersGroup.selectAll("."+ CLASSMARKERHOVER).attr("opacity", 1);
		  if (props.marker.visible){
			svgMarkersGroup.selectAll("."+ CLASSMARKERDEFAULT).attr("opacity", 1);
		  }
      }
   
      if(hasDefaultSelection){
        defaultSelUtil.clearSelectionInfo(gSelection, false, elementArray);
      }
    };
    
    area.hoverOnPoint = function(point)
    {  
      var point0 = point.x, point1 = point.y;
      if (props.orientation === "vertical" ){
        if(point0 < 0 || point0 > width){
          return;
        }
      } else {
        if(point1 < 0 || point1 > height){
          return;
        }
      }

      var xIndex = getCategoryIndex(props.orientation === "vertical" ? point0 : point1);
      if(preHighLightIndex === xIndex) { return; }
      var xCoord = xScale(xIndex) + xScale.rangeBand() / 2;
      changeGroupMarker(preHighLightIndex, "hidden", CLASSMARKERDEFAULT);
      changeGroupMarker(xIndex, "visible", CLASSMARKERHOVER);  

      preHighLightIndex = xIndex;


      if (props.hoverline.visible) {
        mouseMoveLine.attr( props.orientation === "vertical" ? "x1" : "y1", xCoord).attr(props.orientation === "vertical" ? "x2" : "y2", xCoord);
        mouseMoveLine.attr("visibility", "visible");
      } else {
        mouseMoveLine.attr("visibility", "hidden");
      }

      if (props.tooltip.enabled) {
        var pt = {};
        var matrix = g.node().getTransformToElement(g.node().ownerSVGElement);
        if(props.orientation === "vertical")
        {
          pt.x = xScale(xIndex) + xScale.rangeBand() / 2 + matrix.e;
          pt.y = height / 4 + matrix.f;
        } else {
          pt.x = width * 3 / 4 + matrix.e;
          pt.y = xCoord + matrix.f;
        }
        //var globalPoint = pt.matrixTransform(g.node().parentNode.parentNode.getScreenCTM().inverse());
        //var tData = generateTooltipData(xIndex);
        //alex su
        var tData = _tooltipDataHandler.generateTooltipData(data_, 
               tooltipData, 
               xIndex, 
               colorPalette, 
               [props.marker.shape]);
        tData.point = pt;
        tData.plotArea = {
          x : matrix.e,
          y : matrix.f,
          width : width,
          height : height
        };
        eDispatch.showTooltip(TooltipDataHandler.formatTooltipData(tData));
      }

    };

    area.blurOut = function()
    {  
      mouseMoveLine.attr("visibility", "hidden");
      changeGroupMarker(preHighLightIndex, "hidden", CLASSMARKERDEFAULT);
      preHighLightIndex = null;
      if (props.tooltip.enabled) { 
        eDispatch.hideTooltip();
      }
    };
    
    area.dataLabel = function(_){};
    
    area.destroy = function(){
      if(xScale)
        xScale.domain([0,1]).range([0,1]);
      mouseMoveLine = null;
      g = null;
      svgMarkersGroup = null;
      svgAreasGroup = null;
      svgAreaBgGroup = null;

      if(effectManager && effectManager.destroy){
        effectManager.destroy();
      }
      
      valueAxis1Data.data = null;
      if(valueAxis1Data.scale){
        valueAxis1Data.scale.domain([0,1]).range([0,1]);
      }
      valueAxis1Data.selectedMarkers = null;
      valueAxis1Data.markers = null;
      valueAxis1Data.areas = null;
      valueAxis1Data = null;
      areaShapeline = null;
      gSelection = null;
      clipRect = null;
      data_ = null;
      xScale = null;
      if(ctx){
        ctx.destroy();
        ctx = null;
      }
    };
    
    props = manifest.props(null);
    return area;
  };
});

define('sap/viz/modules/manifests/xy/Area',['sap/viz/modules/manifests/Module','sap/viz/modules/Constants','sap/viz/modules/area','sap/viz/modules/manifests/xy/Base'],
function Setup(Manifest,Constants,fn) {
  var module = {
    'id' : 'sap.viz.modules.area',
    'name' : 'area',
     base : 'sap.viz.modules.xy.base',
    'properties' : {
    'tooltip' : {
        'name' : 'tooltip',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'enabled' : {
            'name' : 'enabled',
            'supportedValueType' : 'Boolean',
            'defaultValue' : true,
            'description' : 'Set enabled/disabled tooltip.'
          }
        },
        'isExported' : false,
        'description' : 'Settings for tooltip related properties.'
      },
      'mode' : {
        'name' : 'mode',
        'supportedValueType' : 'String',
        'supportedValues' : [ 'comparison', 'percentage' ],
        'defaultValue' : 'comparison',
        'description' : 'Set dispaly mode of area chart.',
         'isExported' : false
      },
      'orientation' : {
        'name' : 'orientation',
        'supportedValueType' : 'String',
        'supportedValues' : [ 'vertical', 'horizontal' ],
        'defaultValue' : 'vertical',
        'description' : 'vertical or horizontal area chart.',
        'isExported' : false
      },
      'animation' : {
          'name' : 'animation',
          'supportedValueType' : 'Object',
          'supportedValues' : {
            'dataLoading' : {
              'name' : 'dataLoading',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enable/disable data loading animation of plot area.'
            },
            'dataUpdating' : {
              'name' : 'dataUpdating',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enable/disable data updating animation of plot area.'
            },
            'resizing' : {
              'name' : 'resizing',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enable/disable resizing animation of plot area.'
            }
          },
          'description' : 'Settings for animation of plot area.',
          'example': "<a href='"+Constants.DocExample.SnippetUrl+"8535' target='_blank'>"+Constants.DocExample.TryThisValue+"</a>"
     },
      'hoverline' : {
          'name' : 'hoverline',
          'supportedValueType' : 'Object',
          'description' : 'Settings for hoverline properties.',
          'supportedValues' : {
            'visible' : {
              'name' : 'visible',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set to enabled/disabled hoverline or not.'
            }
          }
      },
      'marker' : {
        'name' : 'marker',
      'description': 'Settings for marker/data point graphics',
        'supportedValueType' : 'Object',
        'isExported' :false,
        'supportedValues' : {
          'visible' : {
            'name' : 'visible',
            'supportedValueType' : 'Boolean',
            'defaultValue' : false,
            'description' : 'Set show marker or not.',
            'isExported' :false
          },
          'shape' : {
            'name' : 'shape',
            'supportedValueType' : 'String',
            'supportedValues' : ['circle', 'diamond', 'triangleUp', 'triangleDown', 'triangleLeft', 'triangleRight', 'cross', 'intersection'],
            'defaultValue' : 'circle',
            'description' : 'Set marker shapes for chart.'
          },
          'size' : {
            'name' : 'size',
            'supportedValueType' : 'PositiveInt',
            'defaultValue' : "4",
            'min' : '4',
            'max' : '32',
            'description' : 'Set marker size of data point, range[4,32]. When beyond the range, the marker size is default size 4.'
          }
        }
      }
    },
    'css' : {
     
        '.viz-plot-hoverline.v-hoverline': {
          'description' : 'Define style for hoverline in line.',
          'value' : {
            'stroke' : '#cccccc'
           }
        }
    },
    fn : fn
  };

  Manifest.register(module);
});
define('sap/viz/manifests/xy/AreaChart',['sap/viz/manifests/Viz','sap/viz/modules/manifests/RootContainer','sap/viz/modules/manifests/xy/Area',
'sap/viz/manifests/xy/BaseVerticalChart','sap/viz/modules/manifests/controller/Interaction'],
function Setup(Manifest) {
  var chart = {
    id : 'viz/area',
    name : 'IDS_AREACHART',
    base: 'riv/baseverticalchart',
    
    modules : {
      root : {
        modules : {
          tooltip : {
            configure : { properties : { chartType : 'line', orientation : 'left' } }
          },

          main : {
            modules : {
              dataLabel : {
                id : 'sap.viz.modules.datalabel',
                configure : {
                  propertyCategory : 'dataLabel',
                  properties : {
                    position : 'outside',
                    automaticInOutside : false,
                    outsidePosition : 'down',
                    showZero : false
                  },
                  propertiesOverride:{
                    position : { isExported : false }
                  }
                }
              },
              
              plot : {
                id : 'sap.viz.modules.area',
                configure : {
                  description : 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory : 'plotArea',
                  propertiesOverride: { bStacked :true }
                }
              }
            }
          }
        }
      }
    },
    
    feeds:{ secondaryValues: null },
    
    dependencies : {
      attributes : [ {
        targetModule : 'root.main.xAxis',
        target : 'scale',
        sourceModule : 'root.main.plot',
        source : 'categoryScale'
      }, {
        targetModule : 'root.legends.legend',
        target : 'colorPalette',
        sourceModule : 'root.main.plot',
        source : 'getColorPalette'
      }, {
        targetModule : 'root.main.plot',
        target : 'primaryDataRange',
        sourceModule : 'root.main.yAxis',
        source : 'range'
      }, {
        targetModule : 'root.main.yAxis',
        target : 'scale',
        sourceModule : 'root.main.plot',
        source : 'primaryScale'
      }, {
      targetModule : 'root.main.yAxis',
      target : 'title',
      sourceModule : 'root.main.plot',
      source : 'primaryAxisTitle'
    }, {
        targetModule : 'root.legends.legend',
        target : 'shapes',
        sourceModule : 'root.main.plot',
        source : 'shapePalette'
      }, {
        targetModule : 'root.legends.legend',
        target : 'setSelectionMode',
        sourceModule : 'root.interaction',
        source : 'getSelectionMode'
      } ],
      events : [ {
        targetModule : 'root.tooltip',
        listener : 'showTooltip',
        sourceModule : 'root.main.plot',
        type : 'showTooltip'
      }, {
        targetModule : 'root.tooltip',
        listener : 'hideTooltip',
        sourceModule : 'root.main.plot',
        type : 'hideTooltip'
      }, {
        targetModule : 'root.interaction',
        listener : 'registerEvent',
        sourceModule : 'root.main.plot',
        type : 'initialized.interaction'
      }, {
        targetModule : 'root.interaction',
        listener : 'highlightedByLegend',
        sourceModule : 'root.legends.legend',
        type : 'highlightedByLegend'
      }, {
        targetModule : 'root.legends.legend',
        listener : 'deselectLegend',
        sourceModule : 'root.interaction',
        type : 'deselectLegend'
      }, {
        targetModule : 'root.main.dataLabel',
        listener : 'showLabel',
        sourceModule : 'root.main.plot',
        type : 'initialized.datalabel'
      }, {
        targetModule : 'root.main.dataLabel',
        listener : 'removeLabel',
        sourceModule : 'root.main.plot',
        type : 'startToInit.datalabel'
      }, {
        targetModule : 'root.interaction',
        listener : 'defaultSelection',
        sourceModule : 'root.main.plot',
        type : 'initialized.defaultSelection'
      }]
    }
  };
  
  Manifest.register(chart);
});
define('sap/viz/manifests/xy/PercentageAreaChart',['sap/viz/manifests/Viz','sap/viz/modules/manifests/RootContainer','sap/viz/manifests/xy/AreaChart'],
function Setup(Manifest) {
  var chart = {
    id : 'viz/100_area',
    name : 'IDS_PERCENTAGEAREACHART',
    base: 'viz/area',
    
    modules : {
      root : {
        modules : {
          main : {    
            'modules' : {
              plot : {
                configure : {
                  properties: {
                    mode : "percentage"
                  }
                }
              },
              yAxis : {
                id : 'sap.viz.modules.axis',
                configure : {
                'description': 'Settings for the value axis of an XY chart.',
                  propertyCategory : 'yAxis',
                  properties : {
                    isPercentMode : true
                  },
                  propertiesOverride : {
                    scale : { 
                      fixedRange : {isExported : false},
                      minValue : {isExported : false},
                      maxValue : {isExported : false},
                      isExported : false 
                    }
                  }
                }
              },
              dataLabel : {
                id : 'sap.viz.modules.datalabel',
                configure : {
                  propertyCategory : 'dataLabel',
                  properties : {
                    isPercentMode: true
                  }
                }
              }
            }
          },
          tooltip : {
            id : 'sap.viz.modules.tooltip',
            configure : {
              propertyCategory : 'tooltip',
              properties : {
                chartType : 'line',
                orientation : 'left',
                formatString: [["0.00%"],["0.00%"]]
              }
            }
          }
        }
      }
    }   
  };
  Manifest.register(chart);
});
define('sap/viz/manifests/xy/HorizontalAreaChart',['sap/viz/manifests/Viz','sap/viz/modules/manifests/RootContainer','sap/viz/modules/manifests/xy/Area',
'sap/viz/manifests/xy/BaseHorizontalChart','sap/viz/modules/manifests/controller/Interaction'],
function Setup(Manifest) {
  var chart = {
    id : 'viz/horizontal_area',
    name : 'IDS_HORIZONTALAREACHART',
    base: 'riv/basehorizontalchart',
    modules : {
      root : {      
        modules : {
          tooltip : {
            configure : {
              properties : {
                chartType : 'horizontalline',
                orientation : 'left'
              }
            }
          },

          main : {
            modules : {
              dataLabel : {
                id : 'sap.viz.modules.datalabel',
                configure : {
                  propertyCategory : 'dataLabel',
                  properties : {
                    position : 'outside',
                    automaticInOutside : false,
                    outsidePosition  : 'left',
                    showZero : false
                  },
                  propertiesOverride:{
                    position : {
                      isExported : false
                    }
                  }
                }
              },
              plot : {
                id : 'sap.viz.modules.area',
                configure : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory : 'plotArea',
                  propertiesOverride: {
                    bStacked :true             
                  },
                  properties : {
                     orientation:'horizontal'
                  }
                }
              }
            }
          }
     
        }
      }
    },
    feeds:{
      secondaryValues:null
    },
    dependencies : {
      attributes : [ {
        targetModule : 'root.main.yAxis',
        target : 'scale',
        sourceModule : 'root.main.plot',
        source : 'categoryScale'
      }, {
        targetModule : 'root.legends.legend',
        target : 'colorPalette',
        sourceModule : 'root.main.plot',
        source : 'getColorPalette'
      }, {
        targetModule : 'root.main.plot',
        target : 'primaryDataRange',
        sourceModule : 'root.main.xAxis',
        source : 'range'
      }, {
        targetModule : 'root.main.xAxis',
        target : 'scale',
        sourceModule : 'root.main.plot',
        source : 'primaryScale'
      }, {
      targetModule : 'root.main.xAxis',
      target : 'title',
      sourceModule : 'root.main.plot',
      source : 'primaryAxisTitle'
    }, {
        targetModule : 'root.legends.legend',
        target : 'shapes',
        sourceModule : 'root.main.plot',
        source : 'shapePalette'
      }, {
        targetModule : 'root.legends.legend',
        target : 'setSelectionMode',
        sourceModule : 'root.interaction',
        source : 'getSelectionMode'
      } ],
      events : [ {
        targetModule : 'root.tooltip',
        listener : 'showTooltip',
        sourceModule : 'root.main.plot',
        type : 'showTooltip'
      }, {
        targetModule : 'root.tooltip',
        listener : 'hideTooltip',
        sourceModule : 'root.main.plot',
        type : 'hideTooltip'
      }, {
        targetModule : 'root.interaction',
        listener : 'registerEvent',
        sourceModule : 'root.main.plot',
        type : 'initialized.interaction'
      }, {
        targetModule : 'root.interaction',
        listener : 'highlightedByLegend',
        sourceModule : 'root.legends.legend',
        type : 'highlightedByLegend'
      }, {
        targetModule : 'root.legends.legend',
        listener : 'deselectLegend',
        sourceModule : 'root.interaction',
        type : 'deselectLegend'
      }, {
        targetModule : 'root.main.dataLabel',
        listener : 'showLabel',
        sourceModule : 'root.main.plot',
        type : 'initialized.datalabel'
      }, {
        targetModule : 'root.main.dataLabel',
        listener : 'removeLabel',
        sourceModule : 'root.main.plot',
        type : 'startToInit.datalabel'
      }, {
        targetModule : 'root.interaction',
        listener : 'defaultSelection',
        sourceModule : 'root.main.plot',
        type : 'initialized.defaultSelection'
      } ]
    }
  };
  Manifest.register(chart);
});
define('sap/viz/manifests/xy/PercentageHorizontalAreaChart',['sap/viz/manifests/Viz','sap/viz/modules/manifests/RootContainer','sap/viz/manifests/xy/HorizontalAreaChart'],
function Setup(Manifest) {
  var chart = {
    id : 'viz/100_horizontal_area',
    name : 'IDS_PERCENTAGEHORIZONTALAREACHART',
    base: 'viz/horizontal_area',
    
    modules : {  
      root : {
        modules : {
           main : {    
              'modules' : {
                plot : {
                  
                  configure : {
                    properties: {
                      mode : "percentage"
                    }
                  }
                },
                xAxis : {
                  id : 'sap.viz.modules.axis',
                  configure : {
                  'description': 'Settings for the value axis of an XY chart.',
                    propertyCategory : 'xAxis',
                    properties : {
                      isPercentMode : true
                    },
                    propertiesOverride : {
                      scale : { 
                        fixedRange : {isExported : false},
                        minValue : {isExported : false},
                        maxValue : {isExported : false},
                        isExported : false 
                      }
                    }
                  }
                },
                dataLabel : {
                  id : 'sap.viz.modules.datalabel',
                  configure : {
                    propertyCategory : 'dataLabel',
                    properties : {
                      isPercentMode: true
                    }
                  }
                }
              }
            },
            tooltip : {
              id : 'sap.viz.modules.tooltip',
              configure : {
                propertyCategory : 'tooltip',
                properties : {
                  chartType : 'horizontalline',
                  orientation : 'left',
                  formatString: [["0.00%"],["0.00%"]]
                }
              }
          }
           
        }
      }

    }   
  };
  Manifest.register(chart);
});
define('sap/viz/modules/threeD/Vector3D',['sap/viz/modules/threeD/Vector','sap/viz/modules/threeD/Point'],
function Setup(Vector, Point) {
  function Vector3D() {
    Vector.apply(this, arguments);
  }

  Vector3D.prototype = Object.create(Vector.prototype);

  Vector3D.prototype.transform = function(m) {
    var p1 = new Point(0, 0, 0).transform(m);
    var p2 = new Point(this.value(0), this.value(1), this.value(2))
        .transform(m);
    this.value(0, p2.x - p1.x);
    this.value(1, p2.y - p1.y);
    this.value(2, p2.z - p1.z);
    return this;
  };

  return Vector3D;
});
define('sap/viz/modules/xyzcontainer',['sap/viz/base/utils/TypeUtils','sap/viz/base/utils/Objects','sap/viz/base/utils/FunctionUtils','sap/viz/manifest',
'sap/viz/data/handler/SingleChartDataHandler','sap/viz/modules/dispatch',
'sap/viz/modules/threeD/matrix','sap/viz/modules/threeD/Point','sap/viz/modules/threeD/Vector3D',
'sap/viz/modules/util/BoundUtil','sap/viz/util/ignite'],
function Setup(TypeUtils, Objects, Functions, Manifest,
    SingleChartDataHandler, dispatch, matrix, Point3D, Vector3D, boundUtil, ignite) {

  // xyzcontainer
  var retfn = function(manifest, ctx) {

    var width = 0, height = 0, properties = {}, data = {}, config = {}, modules = {}, selections = {}, spaceWithoutPlot, parent = null; // a d3
    // selection

    var eDispatch = new dispatch('initialized', 'showTooltip', 'hideTooltip'), 
        initializedModules = 0;
    
    var innerProperties = manifest.props(null);
    var xAngle = 20, yAngle = 50;

    var yAxisScale = d3.scale.linear(); // can be linear or ordinal scale
    var xAxisScale =  d3.scale.ordinal(); // can be linear or ordinal scale
    var zAxisScale =  d3.scale.ordinal();
    // /////////////////////can be moved to base container/////////////////////
    var resolveProperties = function(nodeConfig, isContainer) {
      var props = {}, // Empty properties basket
      propsCat, // Property category node
      usrProps, // User set properties
      sysProps; // Predefined properties in configure node
      if (isContainer) {
        // Jimmy/8/15/2012 pay attention to the property structure, for
        // container we will pass
        // all properties instead of properties under propsCat only.
        if (nodeConfig) {
          propsCat = nodeConfig.propertyCategory;
          usrProps = properties;
          sysProps = {};
          sysProps[propsCat] = nodeConfig.properties;
          Objects.extend(true, props, sysProps, usrProps);
        } else {
          props = properties;
        }
      } else {
        if (nodeConfig) {
          propsCat = nodeConfig.propertyCategory;
          usrProps = properties[propsCat];
          sysProps = nodeConfig.properties;
          // User properties will override predefined properties
          Objects.extend(true, props, sysProps, usrProps);
        }
      }
      return props;
    };

    var updateProperties = function(id, isContainer) {
      var moduleManifest = config.modules; // Module configurations
      var props, nodeConfig, propsCat;
      if (moduleManifest[id] && modules[id]) {
        nodeConfig = moduleManifest[id].configure;
        if (isContainer) {
          props = properties;
        } else {
          if (nodeConfig) {
            propsCat = nodeConfig.propertyCategory;
            props = Objects.extend(true, {}, properties[propsCat]);
          } else {
            props = {};
          }
        }
        modules[id].properties(props);
      }
    };
    // /////////////////////can be moved to base container/////////////////////

    function initialize() {
      if (TypeUtils.isEmptyObject(config))
        Functions.error('Container configuration missing');

      initializedModules = 0;

      initAxis('xAxis');
      initAxis('yAxis');
      initAxis('zAxis');
      initAxis('background');

      var plotConfig = config.modules.plot;
      if (!plotConfig)
        return;
      var plot = modules.plot = ignite(plotConfig.id, ctx, "plot");
      var dataHandler = new SingleChartDataHandler(data);
      plot.data(dataHandler.getDataAdapter());

      var props;
      if (plotConfig.configure) {
        props = resolveProperties(plotConfig.configure);
        plot.properties(props);
      }

      if (plot.dispatch) {
        var dis = plot.dispatch();
        if (dis.initialized) {
          initializedModules++;
          dis.on('initialized.xycontainer', initialized);
        }
        ;
        if (dis.showTooltip)
          dis.on('showTooltip.xycontainer', showTooltip);
        if (dis.hideTooltip)
          dis.on('hideTooltip.xycontainer', hideTooltip);
      }

      var dataLabelConfig = config.modules.dataLabel;
      if (TypeUtils.isExist(dataLabelConfig)
          && TypeUtils.isExist(plot.dataLabel)) {
        var dataLabel = modules.dataLabel = ignite(dataLabelConfig.id, ctx);
        plot.dataLabel(dataLabel);
        dataLabel.plot(plot);
        if (dataLabelConfig.configure) {
          props = resolveProperties(dataLabelConfig.configure);
          dataLabel.properties(props);
        }
      }

      if (modules.xAxis && !selections.xAxis)
        selections.xAxis = parent.append('g').attr('class', 'v-m-xAxis');
      if (modules.yAxis && !selections.yAxis)
        selections.yAxis = parent.append('g').attr('class', 'v-m-yAxis');
      if (modules.zAxis && !selections.zAxis)
        selections.zAxis = parent.append('g').attr('class', 'v-m-zAxis');
      if (modules.plot && !selections.plot)
        selections.plot = parent.append('g').attr('class', 'v-m-plot');
      if (modules.background && !selections.background)
        selections.background = parent.insert('g', ':first-child').attr(
            'class', 'background');
    }

    function updateAxisData(id) {
      if (modules[id]) {
        var axisConfig = config.modules[id];
        var axisDataConfig = axisConfig.data;
        if (axisDataConfig) {
          modules[id].data(data.createDataAdapterForModule(axisDataConfig));
        }
      }
    }
    ;

    function initAxis(id) {
      if (!config.modules[id])
        return;

      var axisConfig = config.modules[id], axis = modules[id] = ignite(axisConfig.id, ctx, id);

      updateAxisData(id);

      var props = resolveProperties(axisConfig.configure);
      axis.properties(props);

      if (axis.dispatch && axis.dispatch()['initialized']) {
        initializedModules++;
        axis.dispatch().on('initialized.xycontainer', initialized);
      }
    }

    var initBoundingBox = function(width, height, depth) {
      var bounds = [ {
        x : 0,
        y : 0,
        z : 0
      }, {
        x : 0,
        y : 0,
        z : depth
      }, {
        x : width,
        y : 0,
        z : 0
      }, {
        x : width,
        y : 0,
        z : depth
      }, {
        x : 0,
        y : height,
        z : 0
      }, {
        x : 0,
        y : height,
        z : depth
      }, {
        x : width,
        y : height,
        z : 0
      }, {
        x : width,
        y : height,
        z : depth
      } ];

      return bounds.map(function(bound) {
        return new Point3D(bound.x, bound.y, bound.z);
      });
    };

    var computeTransformBB = function(bounds, m) {
      var point = bounds[0];
      point.transform(m);

      var minx = point.x, miny = point.y, maxx = point.x, maxy = point.y;

      for ( var i = 1, len = bounds.length; i < len; i++) {
        point = bounds[i];
        point.transform(m);

        minx = Math.min(minx, point.x);
        miny = Math.min(miny, point.y);
        maxx = Math.max(maxx, point.x);
        maxy = Math.max(maxy, point.y);
      }

      return {
        x : minx,
        y : miny,
        z : maxx,
        w : maxy
      };

    };

    function radian(deg) {
      return deg * Math.PI / 180;
    }

    var computeMargin = function(params, info3d, omatrix, cwidth, cheight,
        cdepth, southPrefSize, westPrefSize, eastPrefSize) {

      var sangle = layoutAxis('south', params, 'xAxis', xAxisScale, omatrix, 0,
          0, cwidth, cheight, cdepth, info3d.x0, info3d.x1, info3d.y0,
          info3d.z0, info3d.z1)
      var asangle = Math.abs(radian(sangle));

      var wangle = layoutAxis('west', params, 'yAxis', yAxisScale, omatrix, 0,
          0, cwidth, cheight, cdepth, info3d.x0, info3d.x1, info3d.y0,
          info3d.z0, info3d.z1)
      var awangle = Math.abs(radian(wangle));

      var zangle = layoutAxis('none', params, 'zAxis', zAxisScale, omatrix, 0,
          0, cwidth, cheight, cdepth, info3d.x0, info3d.x1, info3d.y0,
          info3d.z0, info3d.z1)
      var azangle = Math.abs(radian(zangle));

      var left = 0, top = 0, right = 0, bottom = 0;

      left = westPrefSize.width * Math.cos(awangle);

      if (zangle <= 1 && sangle > 0
          && !(zangle == 1 && sangle == 91 && xAngle > 0)) {
        left = (left > southPrefSize.height * Math.cos(asangle)) ? left
            : southPrefSize.height * Math.cos(asangle);
        right = eastPrefSize.height * Math.cos(azangle);

        bottom = (southPrefSize.height * Math.sin(asangle) > eastPrefSize.height
            * Math.sin(azangle)) ? southPrefSize.height * Math.sin(asangle)
            : eastPrefSize.height * Math.sin(azangle);

      } else {
        left = (left > eastPrefSize.height * Math.cos(azangle)) ? left
            : eastPrefSize.height * Math.cos(azangle);
        right = southPrefSize.height * Math.cos(asangle);

        bottom = (southPrefSize.height * Math.sin(asangle) > eastPrefSize.height
            * Math.sin(azangle)) ? southPrefSize.height * Math.sin(asangle)
            : eastPrefSize.height * Math.sin(azangle);
      }
      return {
        top : 0,
        left : left,
        bottom : bottom,
        right : right
      };
    };

    var prepareScale = function(sizeH, sizeV, bb, margin, param) {
      var bbSizeX = bb.z - bb.x;
      var bbSizeY = bb.w - bb.y;

      var ratioX = sizeH / bbSizeX;
      var ratioY = sizeV / bbSizeY;
      var minRatio = Math.min(ratioX, ratioY);

      return {
        x : minRatio,
        y : ratioY,
        z : minRatio
      };

    };

    var generateRendererParam = function(m) {
      var camera_ = new Vector3D(0, 0, 1);

      var isRenderRT = false, // left
      isRenderTP = false, // top
      isRenderFT = false; // front

      var origin = new Point3D(0, 0, 0);
      var pointX = new Point3D(1, 0, 0);
      var pointY = new Point3D(0, -1, 0);
      var pointZ = new Point3D(0, 0, 1);

      origin.transform(m);
      pointX.transform(m);
      pointY.transform(m);
      pointZ.transform(m);

      var renderingOrderX = new Vector3D(pointX.x - origin.x, pointX.y
          - origin.y, pointX.z - origin.z), renderingOrderY = new Vector3D(
          pointY.x - origin.x, pointY.y - origin.y, pointY.z - origin.z), renderingOrderZ = new Vector3D(
          pointZ.x - origin.x, pointZ.y - origin.y, pointZ.z - origin.z)

      if (camera_.dotProduct(renderingOrderX) < 0) {
        isRenderRT = true;
      }

      if (camera_.dotProduct(renderingOrderY) < 0) {
        isRenderTP = true;
      }

      if (camera_.dotProduct(renderingOrderZ) > 0) {
        isRenderFT = true;
      }

      return {
        isRenderRT : isRenderRT,
        isRenderTP : isRenderTP,
        isRenderFT : isRenderFT,
        renderingOrderX : renderingOrderX,
        renderingOrderY : renderingOrderY,
        renderingOrderz : renderingOrderZ
      };
    };

    function layoutAxis3D(params_, x_, y_, width_, height_, yDepth_) {
      var x0, x1, y0, y1, z0, z1;
      y0 = y_ + height_;

      if (params_.isRenderFT) {
        x0 = x_;
        if (params_.isRenderTP)
          z0 = 0;
        else
          z0 = yDepth_;
      } else {
        x0 = x_ + width_;
        if (params_.isRenderTP)
          z0 = yDepth_;
        else
          z0 = 0;
      }
      if (params_.isRenderRT) {
        z1 = 0;
        if (params_.isRenderTP)
          x1 = x_ + width_;
        else
          x1 = x_;
      } else {
        z1 = yDepth_;
        if (params_.isRenderTP)
          x1 = x_;
        else
          x1 = x_ + width_;
      }

      return {
        x0 : x0,
        x1 : x1,
        y0 : y0,
        z0 : z0,
        z1 : z1
      };
    }
    ;

    function layoutAxis(type, params, axis, scale, m, x_, y_, width_, height_,
        yDepth_, x0, x1, y0, z0, z1) {
      var origin, point, tick, vector;
      var length, angle, labelAngle, tickAngle, gap;

      switch (type) {
        case 'south':
          origin = new Point3D(x_, y0, z0);
          gap = (0 == z0) ? -yDepth_ : yDepth_;
          tick = new Point3D(x_, y0, z0 + gap);
          point = new Point3D(x_ + width_, y0, z0);
          break;
        case 'north':
          origin = new Point3D(x_, height_ - y0, yDepth_ - z0);
          gap = (0 == z0) ? -yDepth_ : yDepth_;
          tick = new Point3D(x_, y0, yDepth_ - z0 + gap);
          point = new Point3D(x_ + width_, height_ - y0, yDepth_ - z0);
          break;
        case 'west':
          origin = new Point3D(x0, y_, z1);
          tick = new Point3D(x0 - width_, y_, z1);
          point = new Point3D(x0, y_ - height_, z1);
          break;
        case 'east':
          origin = new Point3D(width_ - x0, y_ + height_, yDepth_ - z1);
          tick = new Point3D(width_, y_ + height_, yDepth_ - z1);
          point = new Point3D(width_ - x0, y_, yDepth_ - z1);
          break;
        default:
          origin = new Point3D(x1, y0, 0);
          gap = (x_ == x1) ? -width_ : width_;
          tick = new Point3D(x1 + gap, y0, 0);
          point = new Point3D(x1, y0, yDepth_);
          break;
      }

      origin.transform(m);
      tick.transform(m);
      point.transform(m);

      if (type == 'west') {
        labelAngle = 0;
        tickAngle = 0;
      } else {
        vector = new Vector3D(tick.x - origin.x, tick.y - origin.y, point.z
            - origin.z);
        labelAngle = Math.atan2(vector.values[0], vector.values[1]) * 180
            / Math.PI + 90;
        if (labelAngle > 90)
          labelAngle -= 180;
        else if (labelAngle < -90)
          labelAngle += 180;
        labelAngle = computeAngle3D(labelAngle);
        tickAngle = Math.atan2(vector.values[1], vector.values[0]) * 180
            / Math.PI;
      }

      modules[axis].labelAngle(labelAngle).tickAngle(tickAngle);

      vector = new Vector3D(point.x - origin.x, point.y - origin.y, point.z
          - origin.z);
      selections[axis].attr('transform', 'translate(' + origin.x + ' '
          + origin.y + ')');
      angle = Math.atan2(vector.values[1], vector.values[0]) * 180 / Math.PI
          + 90;

      // a special setting, if the angle
      if (type === 'none' && angle == 0) {
        angle = -1;
      }
      modules[axis].angle(angle);

      modules[axis].labelAlign('start');

      length = (point.x - origin.x) * (point.x - origin.x)
          + (point.y - origin.y) * (point.y - origin.y);

      if (length < 0.01)
        length = 0;

      if (type == 'west') {
        modules[axis].height(Math.sqrt(length));
      } else {
        modules[axis].width(Math.sqrt(length));
      }

      if (scale.rangeBands) {
          var range = scale.range();
          if(range[range.length -1] > range[0]){
              scale.rangeBands([ Math.sqrt(length),  0 ]);
          }else{
              scale.rangeBands([ 0, Math.sqrt(length) ]);
          }
      } else {
          var range = scale.range();
          if(range[range.length -1] > range[0]){
              scale.range([ Math.sqrt(length), 0]);
          }else{
              scale.range([ 0, Math.sqrt(length)]);
          }
      }

      return labelAngle;
    }
    ;

    function computeAngle3D(angleParam) {

      var angle = angleParam % 360;
      if (-271 < angle && angle < -270)
        return -271;
      else if (-270 <= angle && angle < -269)
        return -269;
      if (-181 < angle && angle < -180)
        return -181;
      else if (-180 <= angle && angle < -179)
        return -179;
      else if (-91 < angle && angle < -90)
        return -91;
      else if (-90 <= angle && angle < -89)
        return -89;
      else if (-1 < angle && angle < 0)
        return -1;
      else if (0 <= angle && angle < 1)
        return 1;
      else if (89 < angle && angle < 90)
        return 89;
      else if (90 <= angle && angle < 91)
        return 91;
      else if (179 < angle && angle < 180)
        return 179;
      else if (180 <= angle && angle < 181)
        return 181;
      else if (269 < angle && angle < 270)
        return 269;
      else if (270 <= angle && angle < 271)
        return 271;
      else if (359 < angle && angle < 360)
        return 359;
      return Math.round(angleParam);
    }

    function relayout(firstLayout) {
      if (TypeUtils.isEmptyObject(modules) || !width || !height)
        return;

      width = width < 0 ? 0 : width;
      height = height < 0 ? 0 : height;

        modules.plot.width(width).height(height);
        
        modules.xAxis.drawable(true);
        modules.yAxis.drawable(true);
        modules.zAxis.drawable(true);
        

        var southPrefSize = modules.xAxis.getPreferredSize();
        var westPrefSize = modules.yAxis.getPreferredSize();
        var eastPrefSize = modules.zAxis.getPreferredSize();

        var cwidth = modules.plot.width(), cheight = modules.plot.height(), cdepth = modules.plot.depth();
        var omatrix = matrix().rotateY(yAngle).rotateX(xAngle);

        var params = generateRendererParam(omatrix);
        var info3d = layoutAxis3D(params, 0, 0, cwidth, cheight, cdepth);

        var bounds = initBoundingBox(cwidth, cheight, cdepth);
        var bb = computeTransformBB(bounds, omatrix);

        var margin = computeMargin(params, info3d, omatrix, cwidth, cheight,
            cdepth, southPrefSize, westPrefSize, eastPrefSize);
        
        if(margin.left > width/3 || margin.right > width/3 || margin.bottom > height/3){
            modules.yAxis.drawable(false);
            modules.zAxis.drawable(false);
            modules.xAxis.drawable(false);

            southPrefSize = modules.xAxis.getPreferredSize();
            westPrefSize = modules.yAxis.getPreferredSize();
            eastPrefSize = modules.zAxis.getPreferredSize();

            cwidth = modules.plot.width(), cheight = modules.plot.height(), cdepth = modules.plot.depth();
            omatrix = matrix().rotateY(yAngle).rotateX(xAngle);

            params = generateRendererParam(omatrix);
            info3d = layoutAxis3D(params, 0, 0, cwidth, cheight, cdepth);

            bounds = initBoundingBox(cwidth, cheight, cdepth);
            bb = computeTransformBB(bounds, omatrix);

            margin = computeMargin(params, info3d, omatrix, cwidth, cheight,
                cdepth, southPrefSize, westPrefSize, eastPrefSize);
        } 
        
        var sizeV = height - margin.bottom - margin.top;
        var sizeH = width - margin.left - margin.right;
        var scale = prepareScale(sizeH, sizeV, bb, margin);
        var scaleMatrix = omatrix.unit().scale(scale.x, scale.y, scale.z)
            .clone();
        omatrix.rotateY(yAngle).rotateX(xAngle);

        var offsetX = 0, offsetY = 0;
        var exit = 0;
        while (exit < 10) {

          bounds = initBoundingBox(cwidth, cheight, cdepth);
          bb = computeTransformBB(bounds, omatrix);

          offsetX = 0 - bb.x + margin.left + (sizeH - bb.z + bb.x) / 2;
          offsetY = 0 - bb.y + margin.top + (sizeV - bb.w + bb.y) / 2;

          if (offsetX > 0 && offsetY > 0) {
            break;
          }

          scale = prepareScale(sizeH, sizeV, bb, margin);

          omatrix = scaleMatrix.clone();
          omatrix.scale(scale.x, scale.y, scale.z);
          scaleMatrix = omatrix.clone();

          omatrix.rotateY(yAngle).rotateX(xAngle);
          exit++;
        }

        modules.plot.matrix(omatrix);

        layoutAxis('south', params, 'xAxis', xAxisScale, omatrix, 0, 0, cwidth,
            cheight, cdepth, info3d.x0, info3d.x1, info3d.y0, info3d.z0,
            info3d.z1);

        layoutAxis('west', params, 'yAxis', yAxisScale, omatrix, 0, 0, cwidth,
            cheight, cdepth, info3d.x0, info3d.x1, info3d.y0, info3d.z0,
            info3d.z1);

        layoutAxis('none', params, 'zAxis', zAxisScale, omatrix, 0, 0, cwidth,
            cheight, cdepth, info3d.x0, info3d.x1, info3d.y0, info3d.z0,
            info3d.z1);

        var nwestPrefSize =  modules.yAxis.getPreferredSize();
        
        var node = selections.yAxis.node(), transform = node
            .getTransformToElement(node.parentNode);
        selections.yAxis.attr('transform', 'translate('
            + (transform.e - nwestPrefSize.width) + ',' + transform.f + ')');

        bounds = initBoundingBox(cwidth, cheight, cdepth);
        bb = computeTransformBB(bounds, omatrix);

        node = selections.yAxis.node(), transform = node
            .getTransformToElement(node.parentNode);
        selections.yAxis.attr('transform', 'translate('
            + (transform.e + offsetX) + ',' + (transform.f + offsetY) + ')');

        node = selections.xAxis.node(), transform = node
            .getTransformToElement(node.parentNode);
        selections.xAxis.attr('transform', 'translate('
            + (transform.e + offsetX) + ',' + (transform.f + offsetY) + ')');

        node = selections.zAxis.node(), transform = node
            .getTransformToElement(node.parentNode);
        selections.zAxis.attr('transform', 'translate('
            + (transform.e + offsetX) + ',' + (transform.f + offsetY) + ')');

        node = selections.plot.node();
        selections.plot.attr('transform', 'translate(' + (offsetX) + ','
            + (offsetY) + ')');

    };

    function container(selection) {
        relayout();
      selection.each(function(data) {
        parent = selection;
        boundUtil.drawBound(selection, width, height);
        if (TypeUtils.isEmptyObject(modules))
          initialize();
        render();
      });
      return container;
    }

    container.width = function(_, firstLayout) {
      if (!arguments.length)
        return width;
      width = _;
      // Jimmy,8/20/2012, as a container, you don't know whether your
      // sub elements need relayout even if the container size remains
      // the same. so here we just give a chance to sub elements to relayout
      if ( height ) { relayout(); }
      return container;
    };

    container.height = function(_, firstLayout) {
      if (!arguments.length)
        return height;
      height = _;
      // see @width
      if ( width ) { relayout(); }
      return container;
    };

    container.size = function(_) {
      if (!arguments.length)
        return {
          'width' : width,
          'height' : height
        };
      height = _.height;
      width = _.width;
      // see @width
      relayout();
      return container;
    };

    container.data = function(_) {
      if (!arguments.length)
        return data;
      data = _;
      if (!TypeUtils.isEmptyObject(modules)) {
        // plot exists, we need update its data
        var dataHandler = new SingleChartDataHandler(data);
        modules.plot.data(dataHandler.getDataAdapter());
        updateAxisData('xAxis');
        updateAxisData('yAxis');
        updateAxisData('zAxis');
      }

      return container;
    };

    container.properties = function(_) {
      if (!arguments.length)
        return innerProperties;
      properties = _;
      if (!TypeUtils.isEmptyObject(modules)) {
        updateProperties('xAxis');
        updateProperties('yAxis');
        updateProperties('zAxis');
        updateProperties('plot');
        updateProperties('datalabel');
        updateProperties('background');
      }
      Objects.extend(true, innerProperties, _.xyzcontainer);
      xAngle = innerProperties && innerProperties.xAngle ? innerProperties.xAngle
          : xAngle;
      yAngle = innerProperties && innerProperties.yAngle ? innerProperties.yAngle
          : yAngle;
      return container;
    };

    container.config = function(_) {
      if (!arguments.length)
        return config;
      config = _;
      return container;
    };

    container.modules = function(_) {
      if (!arguments.length) {
        if (TypeUtils.isEmptyObject(modules)) {
          initialize();
        }
        return modules;
      }
      modules = _;
      return container;
    };

    container.parent = function(_) {
      if (!arguments.length)
        return parent;
      parent = _;
      return container;
    };

    container.rotate = function(_){
      if(!arguments.length){
        return {
          xAngle: xAngle,
          yAngle: yAngle
        };
      }
      
      innerProperties.xAngle = (xAngle = _.xAngle);
      innerProperties.yAngle = (yAngle = _.yAngle);
      relayout();
      render();
      
      return container;
    };
    
    container.dispatch = function(_) {
      if (!arguments.length)
        return eDispatch;
      eDispatch = _;
      return container;
    };

    container.infoForSizeLegend = function() {
      return {
        space : spaceWithoutPlot,
        number : 1,
        plotHeight : modules.plot.height()
      };
    };

    container.yAxis = function(_) {
      if (!arguments.length) {
        return yAxisScale;
      }
      yAxisScale = _.copy();
      yAxisScale.tickHint = _.tickHint;
      yAxisScale.tickNum = _.tickNum;
      return container;
    };

    container.xAxis = function(_) {
      if (!arguments.length) {
        return xAxisScale;
      }
      xAxisScale = _.copy();
      xAxisScale.tickHint = _.tickHint;
      xAxisScale.tickNum = _.tickNum;
      return container;
    };

    container.zAxis = function(_) {
      if (!arguments.length) {
        return zAxisScale;
      }
      zAxisScale = _.copy();
      return container;
    };

    container.xAxisScaleChange = function(_, range){
      if(  xAxisScale.rangeBands ){
        xAxisScale.rangeBands(range);
      }else {
        xAxisScale.range(range);
      }
    };
    
    container.zAxisScaleChange = function(_, range){
        zAxisScale.rangeBands(range);
    };
    
    container.yAxisScaleChange = function(_, range){
      if(  yAxisScale.rangeBands ){
        yAxisScale.rangeBands(range);
      }else {
        yAxisScale.range(range);
      }
    };
    
    container.destroy = function(){
        if(yAxisScale){
          yAxisScale.domain([0,1]).range([0,1]);
        }
        if(xAxisScale){
          xAxisScale.domain([0,1]).range([0,1]);
        }
        if(zAxisScale){
          zAxisScale.domain([0,1]).range([0,1]);
        }
        yAxisScale = null;
        xAxisScale = null;
        zAxisScale = null;
        
        //remove listener
      for(var mkey in modules){
        if(modules.hasOwnProperty(mkey)){
          var m = modules[mkey];
          if(m.dispatch){
            var dis =  m.dispatch();
            if ( dis.initialized ) { dis.on('initialized.xyzcontainer', null);};
            if ( dis.showTooltip ) dis.on('showTooltip.xyzcontainer', null);
            if ( dis.hideTooltip ) dis.on('hideTooltip.xyzcontainer', null);
          }
        }
      }
      modules = null;
      data = null;
      parent = null;
      selections = null;
        //destroy ctx
        if(ctx){
          ctx.destroy();
          ctx = null;
        }
    }
    function render() {
      for ( var sel in selections) {
        if (selections.hasOwnProperty(sel)) {
          selections[sel].datum(modules[sel].data()).call(modules[sel]);
        }
      }
      if (TypeUtils.isExist(modules.dataLabel)) {
        modules.dataLabel();
      }
    }

    var initializedCount = 0;
    function initialized() {
      if (initializedModules == ++initializedCount) {
        initializedCount = 0;
        eDispatch.initialized();
      }
    }

    function showTooltip(evt) {
      eDispatch.showTooltip(evt);
    }

    function hideTooltip(evt) {
      eDispatch.hideTooltip(evt);
    }

    return container;
  };
  return retfn;
});
define('sap/viz/modules/manifests/XYZContainer',['sap/viz/modules/manifests/Module','sap/viz/modules/Constants','sap/viz/modules/xyzcontainer'],
function Setup(Manifest, Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.xyzcontainer',
    'type' : Constants.Type.Container,
    'name' : 'single container',
    'properties' : {
      'xAngle': {
         name : 'xAngle',
         supportedValueType: 'Number',
         defaultValue: 20,
         description : 'The angle should between -90 and 90.'
      },
      'yAngle': {
         name: 'yAngle',
         supportedValueType: 'Number',
         defaultValue : 50,
         description : 'The angle should between -180 and 180.'
      }
    },
    'css' : null,
    'configure' : null,
    'events' : {
      'showTooltip' : Constants.Event.TooltipShow.desc,
      'hideTooltip' : Constants.Event.TooltipHide.desc
    },
    fn : fn
  };

  Manifest.register(module);
});
define('sap/viz/modules/threeD/cube',['sap/viz/modules/threeD/Vector4D','sap/viz/modules/threeD/Vector3D','sap/viz/modules/threeD/matrix',
'sap/viz/modules/threeD/Point','sap/viz/util/NumberUtils'],
function Setup(Vector4D, Vector3D, matrix, Point3D, NumberUtils) {
  return function() {
    var width, height, depth, transformMatrix, color, colorlightC, colordarkC, originalcolor;
    
    var drawingEffect, effectManager;
    var CLASS_MARKER_ORIGINAL = "v-datapoint-hover";
    
    function cube(parent) {
      var wrapper = parent.selectAll("g.v-cube").data(function(d, i) {
        var wv = d3.functor(width).apply(this, arguments);
        var hv = d3.functor(height).apply(this, arguments);
        var dv = d3.functor(depth).apply(this, arguments);
        var m = d3.functor(transformMatrix).apply(this, arguments);
        var c = d3.functor(color).apply(this, arguments);
        var lightC = d3.functor(colorlightC).apply(this, arguments);
        var darkC = d3.functor(colordarkC).apply(this, arguments);
        var oc = d3.functor(originalcolor).apply(this, arguments);       

        return [ {
          wv : wv,
          hv : hv,
          dv : dv,
          m : m,
          data : d,
          c : c,
          lightC: lightC,
          darkC: darkC,
          oc: oc,
          ctx : d.data.ctx,
          val : d.data.val
        } ];
      });
      wrapper.exit().remove();
      wrapper.enter().append("g").attr("class", "v-cube v-datapoint v-morphable-datapoint "+ CLASS_MARKER_ORIGINAL);

      var initBoundingBox = function(w, h, d){
        return [
                [0,0,0],
                [0,h,0],
                [0,h,d],
                [0,0,d],
                [w,0,0],
                [w,h,0],
                [w,h,d],
                [w,0,d]
                ];
      };
      
      
      var rects = wrapper.selectAll("rect[class|=\"v-cube-surface\"]").data(
          function(d) {
            var wv = d.wv;
            var hv = d.hv;
            var dv = d.dv;

            var c = d.c;
            
            //var hsl = d3.rgb(c).hsl();
            //var light = hsl.l;
            //var lightC = d3.hsl(hsl.h, hsl.s, light * 1.06).rgb().toString();
            var lightC = d.lightC;
            //var darkC = d3.hsl(hsl.h, hsl.s, light * 0.94).rgb().toString();
            var darkC = d.darkC;
            
            var setEffectColor = function(rectDatas){
              
              
              if (!effectManager){
                return;
              }
              var parameter = {
                graphType: "cubeSide",
                drawingEffect: drawingEffect,
                fillColor : c
              };
              c = effectManager.register(parameter);
              parameter.fillColor = darkC;
              darkC = effectManager.register(parameter);
              var showSurface = [];
              rectDatas.forEach(function (o){
                showSurface.push(o.type);
              });
              parameter.fillColor = lightC;
              parameter.graphType = "cubeTop";
              if (showSurface.indexOf("front") > -1 && showSurface.indexOf("right") > -1 && showSurface.indexOf("top") > -1){
                parameter.direction = "LeftRight";
              } else if (showSurface.indexOf("right") > -1 && showSurface.indexOf("back") > -1 && showSurface.indexOf("top") > -1){
                parameter.direction = "BottomUp";
              } else if (showSurface.indexOf("back") > -1 && showSurface.indexOf("left") > -1 && showSurface.indexOf("top") > -1){
                parameter.direction = "RightLeft";
              } else if (showSurface.indexOf("left") > -1 && showSurface.indexOf("front") > -1 && showSurface.indexOf("top") > -1){
                parameter.direction = "TopDown";
              } else if (showSurface.indexOf("front") > -1 && showSurface.indexOf("right") > -1 && showSurface.indexOf("bottom") > -1){
                parameter.direction = "LeftRight";
              } else if (showSurface.indexOf("right") > -1 && showSurface.indexOf("back") > -1 && showSurface.indexOf("bottom") > -1){
                parameter.direction = "TopDown";
              } else if (showSurface.indexOf("back") > -1 && showSurface.indexOf("left") > -1 && showSurface.indexOf("bottom") > -1){
                parameter.direction = "RightLeft";
              } else if (showSurface.indexOf("left") > -1 && showSurface.indexOf("front") > -1 && showSurface.indexOf("bottom") > -1){
                parameter.direction = "BottomUp";
              }
              lightC = effectManager.register(parameter);
            };

            var rectDatas = new Array({
              m : matrix().rotateX(90).translate(0, hv, 0).transform(d.m),
              type : "bottom"
            }, {
              m : matrix().rotateY(180).translate(0, 0, dv).transform(d.m),
              type : "back"
            }, {
              m : matrix().rotateY(90).transform(d.m),
              type : "left"
            }, {
              type : "front",
              m : d.m
            }, {
              m : matrix().rotateY(-90).translate(wv, 0, 0).transform(d.m),
              type : "right"
            }, {
              m : matrix().rotateX(-90).transform(d.m),
              type : "top"
            });

            rectDatas.forEach(function(o) {
              o.normal = new Vector3D(0, 0, -1).transform(o.m);
            });

            rectDatas = rectDatas.filter(function(o) {
              return o.normal.value(2) < 0;
            });
            
            setEffectColor(rectDatas);
            
            rectDatas.forEach(function(o) {
              switch (o.type) {
              case "bottom":
                o.x = 0;
                o.y = 0;
                o.w = wv;
                o.h = dv;
                break;
              case "back":
                o.x = -wv;
                o.y = 0;
                o.w = wv;
                o.h = hv;
                break;
              case "left":
                o.x = -dv;
                o.y = 0;
                o.w = dv;
                o.h = hv;
                break;
              case "front":
                o.x = 0;
                o.y = 0;
                o.w = wv;
                o.h = hv;
                break;
              case "right":
                o.x = 0;
                o.y = 0;
                o.w = dv;
                o.h = hv;
                break;
              case "top":
                o.x = 0;
                o.y = -dv;
                o.w = wv;
                o.h = dv;
                break;
              }

              var normalX = o.normal.value(0);
              o.fill = NumberUtils.precise(normalX) === 0 ? lightC : (normalX < 0 ? c : darkC);
            });

            return rectDatas;
          });

      rects.exit().remove();

      rects.enter().append("rect").attr("class", function(d) {
        return "v-cube-surface-" + d.type;
      });

      rects.attr("x", function(d) {
        return d.x;
      }).attr("y", function(d) {
        return d.y;
      }).attr("width", function(d) {
        return d.w;
      }).attr("height", function(d) {
        return d.h;
      }).attr("transform", function(d) {
        if (d.m) {
          return d.m.projection();
        }
      }).attr("fill", function(d) {
        return d.fill;
      });

      wrapper.each(function(d) {
        var flbpz = 0;
        if (d.m) {
          var ctMz = d.m.row(2);
          flbpz = new Vector4D(0, d.hv, 0, 1).dotProduct(ctMz);
        }
        d3.select(this.parentNode).datum().flbpz = flbpz;
        
        var points = initBoundingBox(d.wv, d.hv, d.dv), npoints = [];
        points.forEach(function(p){
          npoints.push(new Point3D(p[0], p[1], p[2]).transform(d.m));
        });
        
        npoints.sort(function(a, b) {
          return (b.x - a.x);
         });
         
         npoints.splice(2);
         
         npoints.sort(function(a,b){
           return (a.y - b.y);
         });
       
         d.rtp = npoints[0];
      });

      parent.sort(function(a, b) {
        return d3.descending(a.flbpz, b.flbpz);
      });
    }

    cube.width = function() {
      if (arguments.length === 0) {
        return width;
      }

      width = arguments[0];
      return cube;
    };

    cube.height = function() {
      if (arguments.length === 0) {
        return height;
      }

      height = arguments[0];
      return cube;
    };

    cube.depth = function() {
      if (arguments.length === 0) {
        return depth;
      }

      depth = arguments[0];
      return cube;
    };

    cube.matrix = function() {
      if (arguments.length === 0) {
        return transformMatrix;
      }

      transformMatrix = arguments[0];
      return cube;
    };

    cube.color = function() {
      if (arguments.length === 0) {
        return color;
      }

      color = arguments[0];
      return cube;
    };
    cube.colorlightC = function() {
        if (arguments.length === 0) {
          return colorlightC;
        }

        colorlightC = arguments[0];
        return cube;
      };
    cube.colordarkC = function() {
        if (arguments.length === 0) {
          return colordarkC;
        }

        colordarkC = arguments[0];
        return cube;
      };
      cube.originalcolor = function() {
        if (arguments.length === 0) {
          return originalcolor;
        }

        originalcolor = arguments[0];
        return cube;
      };
      cube.effectManager = function() {
        if (arguments.length === 0) {
          return effectManager;
        }

        effectManager = arguments[0];
        return cube;
      };
      cube.drawingEffect = function() {
        if (arguments.length === 0) {
          return drawingEffect;
        }

        drawingEffect = arguments[0];
        return cube;
      };
    return cube;
  };
});
define('sap/viz/modules/bar3d',['sap/viz/modules/util/MNDHandler','sap/viz/util/Scaler','sap/viz/base/utils/Objects','sap/viz/modules/threeD/cube',
'sap/viz/modules/threeD/matrix','sap/viz/lang/langManager','sap/viz/base/utils/ObjectUtils',
'sap/viz/modules/dispatch','sap/viz/base/utils/TypeUtils',
'sap/viz/modules/tooltip','sap/viz/modules/util/tooltipDataHandler','sap/viz/util/NumberUtils'],
function Setup(MNDHandler, Scaler, Objects, cube, matrix, langManager, ObjectUtils, dispatch, TypeUtils, tooltip, tooltipDataHandler, NumberUtils) {

  var barPaddingRatio = 0.5;

  return function(manifest,ctx) {
    var width = 0, height = 0, depth = 0, data, properties = manifest.props(null), m = matrix();
    var datas, d = dispatch('initialized', 'showTooltip', 'hideTooltip', 'valueScaleChange', 'primaryCategoryScaleChange', 'secondaryCategoryScaleChange');
    var parent = null;
    var lastHovered = null;
    var drawingEffect = 'normal';
    
    var CLASS_MARKER_SELECTED = "v-datapoint-selected",
        CLASS_MARKER_ORIGINAL = "v-datapoint-default";

    var strokeSettings = {
        'normal' : '#FFFFFF',
        'selected' : '#000000',
        'deselected': '#FFFFFF'        
    };
    
    var styles = {
        'normal' : 'opacity:1',
        'selected' : 'opacity:1',
        'deselected': 'opacity:0.4'
    };
    
    var secondaryCategoryData = {
        'sap.viz.modules.column3d.dimension':{
          key: 'sap.viz.modules.column3d.dimension',
          values : [{
            col: {val:''},
            rows: []
          }]
        }
    };
    
    var primaryCategoryData = {
        'sap.viz.modules.column3d.dimension':{
          key: 'sap.viz.modules.column3d.dimension',
          values : [{
            col: {val:''},
            rows: []
          }]
        }
    };
    
    var primaryCategoryScale = d3.scale.ordinal(), secondaryCategoryScale = d3.scale
        .ordinal(), valueScale = d3.scale.linear();

    var cubeBuilder = cube();

    var colorPalette = d3.scale.ordinal();

    var effectManager = ctx.effectManager;
    
    function setDatapointAttributes(target, type){
      target.setAttribute("class", "v-cube v-datapoint v-morphable-datapoint "+ getClassByType(type));
      target.setAttribute('style', styles[type]);
      target.setAttribute("stroke", strokeSettings[type]);
    }
    
    function getClassByType(type){
      var ret = null;
      switch (type){
      case "normal":
        ret = CLASS_MARKER_ORIGINAL;
        break;
      case "selected":
        ret = CLASS_MARKER_SELECTED;
        break;
      case "deselected":
        ret = CLASS_MARKER_ORIGINAL;
        break;  
      }
      return ret;
    }
    
    function chart(selection) {

      parent = selection;

      colorPalette.range(properties.colorPalette);
      drawingEffect = properties.drawingEffect; 

      var primaryCategoryRangeBand = primaryCategoryScale.rangeBand();
      var secondaryCategoryRangeBand = secondaryCategoryScale.rangeBand();

      var vertical = isVertical();

      var barCategorySize = primaryCategoryRangeBand /
          (1 + 2 * barPaddingRatio);
      var barDepth = barCategorySize;
      var barCategoryPadding = barCategorySize * barPaddingRatio;
      var barValueSize = vertical ? function(d) {
          if(NumberUtils.isNoValue(d.data.val)) {return 0;}
          if(d.data.val < 0){ 
              return valueScale(d.data.val) - valueScale(0);
          } else {
              return valueScale(0) - valueScale(d.data.val) ;
          }
      } : function(d) {
        if(NumberUtils.isNoValue(d.data.val)) {return 0;}
        if(d.data.val < 0){ 
            return valueScale(0) - valueScale(d.data.val);
        } else {
            return valueScale(d.data.val) - valueScale(0);
        }
      };
      var barDepthValue = function(d){
          if(NumberUtils.isNoValue( d.data.val) ){
              return 0;
          }else{
              return barDepth;
          }
      };
      
      cubeBuilder.width(vertical ? barCategorySize : barValueSize).height(
          vertical ? barValueSize : barCategorySize).depth(barDepthValue).matrix(
          function(d) {
            var primaryCategoryOffset = d.aa1 * primaryCategoryRangeBand +
                barCategoryPadding;

            var x = 0;
            
            if(vertical){
                x = primaryCategoryOffset;
            }else{
                if(d.data.val < 0){
                    x =  valueScale(d.data.val);
                }else{
                    x =  valueScale(0);
                }
            }
            
            var y = 0;
            if(vertical){
                if(d.data.val < 0){
                    y = valueScale(0);
                }else{
                    y = valueScale(d.data.val);
                }
            }else{
                y = height -
                primaryCategoryOffset - 2*barCategoryPadding;
            }
            var z = d.aa2 * secondaryCategoryRangeBand + barCategoryPadding;
            return matrix().translate(x, y, z).transform(m);
          }).color(function(d) {       
             return colorPalette(d.aa2);
      }).colorlightC(function(d){
    	  var c = colorPalette(d.aa2);
    	  var hsl = d3.rgb(c).hsl();
          var light = hsl.l;
         return d3.hsl(hsl.h, hsl.s, light * 1.06).rgb().toString();
      }).colordarkC(function(d){
    	  var c = colorPalette(d.aa2);
    	  var hsl = d3.rgb(c).hsl();
          var light = hsl.l;
         return d3.hsl(hsl.h, hsl.s, light * 0.94).rgb().toString();
      }).originalcolor(function(d){
		  return colorPalette(d.aa2); 
      }).effectManager(effectManager).drawingEffect(drawingEffect);

      var mainShapesGroup = selection.select('g.v-datashapesgroup');
      if(!TypeUtils.isExist(mainShapesGroup[0][0])){
        mainShapesGroup = selection.append('g').attr('class', 'v-datashapesgroup');
      }
      
      var dataShapes = mainShapesGroup.selectAll("g.v-datashape").data(datas);
      
      dataShapes.enter().append("g").attr("class", "v-datashape");
      dataShapes.exit().remove();
      
      cubeBuilder(mainShapesGroup.selectAll('g.v-datashape'));

      selection.selectAll('.v-datapoint').each(function(){
          this.setAttribute('style', styles.normal);
          this.setAttribute("stroke", strokeSettings.normal);
      });
      
      d.initialized();
     
    }
    chart.afterUIComponentAppear = function(){
      d.initialized(); 
    };
    
    chart.width = function(value) {
      if (!arguments.length) {
        return width;
      }

      width = value;

      if (isVertical()) {
        updatePrimaryCategoryScaleRange();
        updateSecondaryCategoryScaleRange();
      } else {
        updateValueScaleRange();
      }

      return chart;
    };

    chart.depth = function(value){
        if (!arguments.length){
            return depth;
        }
        depth = value;
        return chart;
    };
    
    chart.height = function(value) {
      if (!arguments.length) {
        return height;
      }

      height = value;

      if (isVertical()) {
        updateValueScaleRange();
      } else {
        updatePrimaryCategoryScaleRange();
        updateSecondaryCategoryScaleRange();
      }

      return chart;
    };

    chart.primaryCategoryScale = function(scale) {
      if (!arguments.length) {
        return primaryCategoryScale;
      }
      primaryCategoryScale = scale;
      return chart;
    };

    chart.secondaryCategoryScale = function(scale) {
      if (!arguments.length) {
        return secondaryCategoryScale;
      }
      secondaryCategoryScale = scale;
      return chart;
    };

    chart.valueScale = function(scale) {
      if (!arguments.length) {
        return valueScale;
      }
      valueScale = scale;
      return chart;
    };

    chart.valueScaleTitle = function(_){
          if(!arguments.length){
            var titles =  data.getMeasureValuesGroupDataByIdx(0), title = [];
            if(titles){
              for(var i=0, len =titles.values.length; i< len;i++ ){
                  if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                  {
                      title.push(titles.values[i].col);
                  }
                  else
                  {
                      title.push(langManager.get('IDS_ISNOVALUE'));
                  }
              }
            }
            return title.join(' & ');
          }
          return this;
    };
    
    chart.data = function(value) {
      if (!arguments.length) {
        return data;
      }
      data = value;

      var mndData = MNDHandler(data);
      
      generateSecondCategoryData(mndData, data);
      
      var parsedData = mndData.MG1;

      var i;

      var primaryCategoryLength = parsedData[0].length;
      var primaryCategoryDomain = new Array(primaryCategoryLength);
      for (i = 0; i < primaryCategoryLength; i++) {
        primaryCategoryDomain[i] = i;
      }
      primaryCategoryScale.domain(primaryCategoryDomain);

      var secondaryCategoryLength = parsedData.length;
      var secondaryCategoryDomain = new Array(secondaryCategoryLength);
      for (i = 0; i < secondaryCategoryLength; i++) {
        secondaryCategoryDomain[i] = i;
      }
      secondaryCategoryScale.domain(secondaryCategoryDomain);

      updateSecondaryCategoryScaleRange();

      datas = [];
      for ( var i = 0, len1 = parsedData.length; i < len1; i++) {
        var groupData = parsedData[i];
        for ( var j = 0, len2 = groupData.length; j < len2; j++) {
          datas.push({
            data : groupData[j],
            aa2 : i,
            aa1 : j
          });
        }
      }

      var extent = d3.extent(datas, function(o) {
        return o.data.val;
      });
      var min = extent[0], max = extent[1];
      min = (min === undefined)? 0 : min;
      max == (max === undefined ) ? 1 :max;
      var bottom = min >= 0 ? 0 : min;
      var top = max <= 0 ? 0 : max;
      if (bottom === 0 && top === 0) {
        top = 1;
      }

      valueScale.domain([ bottom, top ]);
      return chart;
    };

    /**
     * set/get properties
     */
    chart.properties = function(props) {
      if (!arguments.length) {
        return properties;
      }
      Objects.extend(true, properties, props);

      updatePrimaryCategoryScaleRange();
      updateSecondaryCategoryScaleRange();
     

      return chart;
    };

    chart.colorPalette = function(_) {
      if (!arguments.length) {
        return properties.colorPalette;
      }
      properties.colorPalette = _;
      return this;
    };

    chart.matrix = function(_) {
      if (!arguments.length) {
        return m;
      }
      m = _;
      return this;
    };

    chart.secondaryCategoryData = function(_){
      if(!arguments.length){
        return secondaryCategoryData;
      }
      secondaryCategoryData = _;
      return this;
    };

    chart.primaryCategoryData = function(_){
      if(!arguments.length) {
        return primaryCategoryData;
      }
      primaryCategoryData = _;
      return chart;
    };
    
    chart.dispatch = function(_){
      if(!arguments.length){
        return d;
      }
      d = _;
      return chart;
    };
    
    chart.parent = function(){
      if( !arguments.length ){
        return parent;
      }
      parent = _;
      return chart;
    };
    
    chart.highlight = function(_){
      if (_ instanceof Array) {
        for ( var i = 0; i < _.length; i++) {
          // _[i].setAttribute('opacity', 1);
          setDatapointAttributes(_[i], "selected");
        }
      } else {
        // _.setAttribute('opacity', 1);
        setDatapointAttributes(_, "selected");
       }
    };
    
    chart.unhighlight = function(_){
      if (_ instanceof Array) {
        for ( var i = 0; i < _.length; i++) {
          // _[i].setAttribute('opacity', 0.4);
          setDatapointAttributes(_[i], "deselected");
        }
      } else {
        setDatapointAttributes(_, "deselected");
      }
    };
    
    chart.clear = function(gray){
      if (gray == null) {
        parent.selectAll('.v-datapoint').each(function(){
          setDatapointAttributes(this, "normal");
        });
      } else {
        parent.selectAll('.v-datapoint').each(function(){
          setDatapointAttributes(this, "deselected");
        });
      }
    };
    
    chart.mouseover = function(node) {
      if (lastHovered === node) {
        return;
      }

      var tooltipData = {
        body : [],
        footer : []
      };

      var nd = node.__data__.data, body = tooltipData.body, footer = tooltipData.footer;
      var path = nd.data.ctx.path;

      body.push({
        name : handleNull(data.getMeasureValuesGroupDataByIdx(0).values[path.mi].col),
        val : [ {
          value : handleNull(nd.data.val),
          color : node.__data__.oc,
          shape : 'squareWithRadius'
        } ],
        ctx : {'path' : path}
      });

      var a0data = data.getAnalysisAxisDataByIdx(0), aa1 = path.dii_a1;
      if (a0data) {
        for ( var i = 0, len = a0data.values.length; i < len; i++) {
          if (a0data.values[i].type === 'MND') {
            continue;
          }
          footer.push({
            'label' : handleNull(a0data.values[i].col.val),
            'value' : handleNull(a0data.values[i].rows[aa1].val)
          });
        }
      }

      var a1data = data.getAnalysisAxisDataByIdx(1), aa2 = path.dii_a2;
      if (a1data) {
        for ( var i = 0, len = a1data.values.length; i < len; i++) {
          if (a1data.values[i].type === 'MND') {
            continue;
          }
          footer.push({
            'label' : handleNull(a1data.values[i].col.val),
            'value' : handleNull(a1data.values[i].rows[aa2].val)
          });
        }
      }
      var transform = parent.node().getTransformToElement(
          parent.node().ownerSVGElement);

      var rtp = node.__data__.rtp;
      tooltipData.point = {
        x : rtp.x + transform.e,
        y : rtp.y + transform.f
      };

      tooltipData.plotArea = {
        x : transform.e,
        y : transform.f,
        width : width,
        height : height
      };

      lastHovered = node;
      d.showTooltip(tooltipDataHandler.formatTooltipData(tooltipData));

    };

    chart.mouseout = function(target) {
      lastHovered = null;
      d.hideTooltip();
    };
    
    chart.destroy = function(target) {
      data = null;
      datas = null;
      parent = null;
      lastHovered = null;
      secondaryCategoryData['sap.viz.modules.column3d.dimension'].key = null;
      secondaryCategoryData['sap.viz.modules.column3d.dimension'].values[0].col = null;
      secondaryCategoryData['sap.viz.modules.column3d.dimension'].values[0].rows = null;
      secondaryCategoryData = null;
    
      primaryCategoryData['sap.viz.modules.column3d.dimension'].key = null;
      primaryCategoryData['sap.viz.modules.column3d.dimension'].values[0].col = null;
      primaryCategoryData['sap.viz.modules.column3d.dimension'].values[0].rows = null;
      primaryCategoryData = null;
    
      if(primaryCategoryScale){
        primaryCategoryScale.domain([0,1]).range([0,1]);
      }
      if(secondaryCategoryScale){
        secondaryCategoryScale.domain([0,1]).range([0,1]);
      }
      if(valueScale){
        valueScale.domain([0,1]).range([0,1]);
      }
	  primaryCategoryScale = null;
	  secondaryCategoryScale = null;
	  valueScale = null;
      
      cubeBuilder = null;
      if(colorPalette){
        colorPalette.domain([0,1]).range([0,1]);
      }
      
      if(effectManager && effectManager.destroy){
        effectManager.destroy();
      }
      
       m.destroy();
       m = null;

        //destroy ctx
      if(ctx){
        ctx.destroy();
        ctx = null;
      }
    };
    
    function isVertical() {
      return properties.direction === "vertical";
    }

    function updatePrimaryCategoryScaleRange() {
      primaryCategoryScale.rangeBands(isVertical() ? [ 0, width ]
          : [ height, 0 ]);
      d.primaryCategoryScaleChange(primaryCategoryScale,isVertical() ? [ 0, width ]
      : [ height, 0 ]);
    }

    function updateSecondaryCategoryScaleRange() {
      
      depth = primaryCategoryScale.rangeBand() * secondaryCategoryScale.domain().length;
      secondaryCategoryScale.rangeBands([
          0, depth]);
      d.secondaryCategoryScaleChange(secondaryCategoryScale, [0, depth ]);
    }

    function updateValueScaleRange() {
      valueScale.range(isVertical() ? [ height, 0 ] : [ 0, width ]);
      Scaler.perfect(valueScale);
      d.valueScaleChange(valueScale,  isVertical() ? [ height, 0 ] : [ 0, width ]);
    }
    
    var handleNull = function(_){
      var defaultString = langManager.get('IDS_ISNOVALUE');
      if (_ === null || _ === undefined){
        return defaultString;
      }
      else{ 
        return _;
      }
    };
    
    var handleNullInArray = function(array){
      for (var i = 0; i < array.length; ++i){
        array[i].val = handleNull(array[i].val);
      }
      return array;
    };
    
    var _setPathByaa = function(path){
      var pathObj = {};
      switch(path.aa){
        case 0:
          pathObj.dii_a1 = path.dii;
          break;
        case 1:
          pathObj.dii_a2 = path.dii;
          break;
        case 2:
          pathObj.dii_a3 = path.dii;
          break;
      }
      return pathObj;
    };
    
    var _parseColorLegendFeeds = function(colorFeeds, shapeFeeds){
      var title, colorFeedLength, shapeFeedLength;
      var colorData = _parseLegendFeed(title, colorFeeds, colorFeedLength);
      colorFeedLength = colorData.feedsLength;
      var shapeData = _parseLegendFeed(title, shapeFeeds, shapeFeedLength);
      shapeFeedLength = shapeData.feedsLength;
      
      secondaryCategoryData['sap.viz.modules.column3d.dimension'].values[0].rows = shapeData.labels;
      secondaryCategoryData['sap.viz.modules.column3d.dimension'].values[0].col.val = shapeData.title;
      if(shapeData.MNDInfo.hasOnlyMND){
          secondaryCategoryData['sap.viz.modules.column3d.dimension'].values[0].type = 'MND';
      }
      
      
      primaryCategoryData['sap.viz.modules.column3d.dimension'].values[0].rows = colorData.labels;
      primaryCategoryData['sap.viz.modules.column3d.dimension'].values[0].col.val = colorData.title;
      if(colorData.MNDInfo.hasOnlyMND){
          primaryCategoryData['sap.viz.modules.column3d.dimension'].values[0].type = 'MND';
      }
    };
    
    var getCartesian = function(arrays, symbol) {
      var result = arrays[0];
      var fff = function(arr) {
        var ar = result;
        result = [];
        for(var i = 0; i < ar.length; i++) {
          for(var j = 0; j < arr.length; j++) {
            var t1 = (ar[i].val === undefined) ? ar[i].val : ar[i].val, t2 = (arr[j].val === undefined) ? arr[j].val : arr[j].val;
            var ctx = {
              path : {}
            };
            ObjectUtils.extend(ctx.path, ar[i].ctx.path, arr[j].ctx.path);
            result.push({
              'val': t1 + symbol + t2, 
              'ctx': ctx
            });
          }
        }
      };
      for(var i = 1; i < arrays.length; i++) {
        fff(arrays[i]);
      }

      return result;
    };
    
    var _parseLegendFeed = function(title, feeds, feedsLength){
      var labels = [], rows = [], dimensionTag = ' / ', measureTag = ' - ';
      var MNDIndex, hasOnlyMND = false, i, j, len;
      //Handle colors feeds
      if(feeds && feeds.length > 0){
        for(i = 0, len = feeds.length; i < len; i++) {
          if(feeds[i].type !== 'MND') {
            if(title === undefined) {
              title = handleNull(feeds[i].col.val);
            } else {
              title = title + dimensionTag + handleNull(feeds[i].col.val);
            }
            
            rows = feeds[i].rows;
            for(j = 0; j < rows.length; j++) {
              if(labels[j] === undefined) {
                labels[j] = {};
                labels[j].val = handleNull(rows[j].val);
                labels[j].ctx = {
                  path : _setPathByaa(rows[j].ctx.path)
                };
              } else {
                labels[j].val = labels[j].val + dimensionTag + handleNull(rows[j].val);
              }
            }
          } else {
            MNDIndex = i;
          }
        }
        feedsLength = labels.length;
      }
      
      //Handle Colors with MND
      if(MNDIndex !== undefined) {
        //Save color feed with MND status.
        if(labels.length > 0){
          if(feeds[MNDIndex].rows.length > 1){
            if(MNDIndex === 0) {
              title = langManager.get('IDS_DEFAULTMND') + measureTag + title; 
              //MND is the first feed type. Legend label should be 'MND - A/B/C'
              labels = getCartesian([handleNullInArray(feeds[MNDIndex].rows), labels], measureTag);
              feedsLength = feedsLength * feeds[MNDIndex].rows.length;
            } else if(MNDIndex === feeds.length - 1) {
              title = title + measureTag + langManager.get('IDS_DEFAULTMND');
              //MND is the last feed type. Legend label should be 'A/B/C - MND'
              labels = getCartesian([labels, handleNullInArray(feeds[MNDIndex].rows)], measureTag);
              feedsLength = feedsLength * feeds[MNDIndex].rows.length;
            } 
          }
        }else{
          title = langManager.get('IDS_DEFAULTMND');
          rows = feeds[MNDIndex].rows;
          for(j = 0; j < rows.length; j++) {
            rows[j].val = handleNull(rows[j].val);
            labels.push(rows[j]);
          }
          feedsLength = rows.length;
          if(feeds.length === 1){
            hasOnlyMND = true;
          }
        }
      }
      
      return {
        'title' : title,
        'labels' : labels,
        'feedsLength' : feedsLength,
        'MNDInfo' : {
          'MNDIndex' : MNDIndex,
          'hasOnlyMND': hasOnlyMND //Only has MND, no cartesian
        }
      };
    };

    function generateSecondCategoryData(){
      var colorFeeds = null, shapeFeeds = null;;
      var aa = data.getAnalysisAxisDataByIdx(0);
      if(aa){ 
        colorFeeds = aa.values;
      }
     
      aa = data.getAnalysisAxisDataByIdx(1);
      if(aa){
        shapeFeeds = aa.values;
      }
     
      _parseColorLegendFeeds(colorFeeds, shapeFeeds);
    };
    
    return chart;
  };
});
define('sap/viz/modules/manifests/xyz/Bar3D',['sap/viz/modules/manifests/Module','sap/viz/modules/bar3d','sap/viz/modules/Constants','sap/viz/modules/manifests/xy/BaseBar'],
function Setup(Manifest, fn, Constants) {
  var module = {
    'id' : 'sap.viz.modules.bar3d',
    'name' : '3d bar',
    'type' : Constants.Type.Chart,
    fn : fn,
    'properties' : {
      'colorPalette' : {
        'name' : 'colorPalette',
        'supportedValueType' : 'StringArray',
        'defaultValue' : Constants.COLOR.SAPColorSingleAxis,
        'description' : 'Set color palette.',
        'example': "<a href='"+Constants.DocExample.SnippetUrl+"4449' target='_blank'>"+Constants.DocExample.TryThisValue+"</a>"
      },
      'direction' : {
        'name' : "direction",
        'supportedValueType' : 'String',
        'supportedValues' : [ 'vertical', 'horizontal' ],
        'defaultValue' : "vertical",
        'description' : 'Set direction.',
        'isExported' : false
      },
      'drawingEffect':{
        'name' : 'drawingEffect',
          'description' : 'Set drawing effect of 3D elements.',
        'supportedValueType' : 'String',
          'supportedValues' : [ 'normal', 'glossy' ],
          'defaultValue' : 'normal',
          'isExported' : true,
      }
    },
    'feeds' : {
      id : "xy",
      configure : {
        secondaryValues : null
      }
    }
  };

  Manifest.register(module);
});
define('sap/viz/manifests/xyz/Base3DChart',['sap/viz/manifests/Viz','sap/viz/modules/manifests/Title','sap/viz/modules/manifests/Legend',
'sap/viz/modules/manifests/XYZContainer','sap/viz/modules/manifests/Axis','sap/viz/modules/manifests/Background',
'sap/viz/modules/manifests/xyz/Bar3D','sap/viz/modules/manifests/controller/Interaction',
'sap/viz/modules/manifests/controller/Rotate',
'sap/viz/modules/manifests/layout/Dock','sap/viz/modules/manifests/legend/Common'],
function Setup(Manifest) {
  return function(direction) {
    var isVertical = direction === "vertical";

    var categoryAxis, valueAxis;
    if ( isVertical ) {
      categoryAxis = "xAxis";
      valueAxis = "yAxis";
    } else {
      categoryAxis = "yAxis";
      valueAxis = "xAxis";
    }

    var chart = {
      id : 'viz/3d_' + (isVertical ? 'column' : 'bar'),
      name : 'IDS_3D_' + (isVertical ? 'COLUMN' : 'BAR'),
      modules : {
        root : {
          id : 'sap.viz.modules.rootContainer',
          configure : { propertyCategory : 'general' },
          modules : {
            title : {
              id : 'sap.viz.modules.title',
              configure : {
                propertyCategory : 'title',
                properties : {
                  layout : {
                    position : 'top',
                    priority : 1
                  }
                }
              }
            },
            legends : {
              id : 'sap.viz.modules.legend',
              configure : {
                propertyCategory : 'legendGroup',
                properties : {
                  layout : {
                    position : 'right',
                    priority : 1
                  }
                }
              },
              modules : {
                layout : {
                  id : 'sap.viz.modules.layout.stack'
                },
                legend : {
                  id : 'sap.viz.modules.legend.common',
                  data : { aa : [ 2 ] },
                  configure : {
                    propertyCategory : 'legend',
                    properties : {
                      layout : {
                        position : 'top',
                        priority : 0
                      }
                    }
                  }
                }
              }
            },
            tooltip : {
              id : 'sap.viz.modules.tooltip',
              configure : {
                propertyCategory : 'tooltip',
                properties : { orientation : 'left' }
              }
            },
            
            layout : {
              id : 'sap.viz.modules.layout.dock'
            },
            
            interaction : {
              id : 'sap.viz.modules.controller.interaction',
              configure : {
                clientID : 'main',
                propertyCategory : 'interaction',
                properties : {
                  //supportedEventNames: ['mouseup', 'mousemove', 'touchstart'],
                  selectability: {
                    mode: 'multiple',
                    lassoWithCtrlKey: true
                  },
                  preserveSelectionWhenDragging: true
                }
              }
            },
            
            rotate : {
              id : 'sap.viz.modules.controller.rotate',
              configure : {
                clientID : 'main',
                propertyCategory: 'rotate'
              }
            },
            
            main : {
              id : 'sap.viz.modules.xyzcontainer',
              modules : {
                plot : {
                  id : 'sap.viz.modules.bar3d',
                  configure : {
                    'description' : 'Settings regarding the chart area and plot area as well as general chart options.',
                    propertyCategory : 'plotArea',
                    properties : { direction : direction }
                  }
                },
                
                zAxis : {
                  id : 'sap.viz.modules.axis',
                  configure : {
                    'description' : 'Settings for the category axis of an XYZ chart.',
                    propertyCategory : 'zAxis',
                    properties : {
                      type : 'category',
                      position : 'bottom',
                      forceVerticalFont : true,
                      forceLabelArea: true,
                      gridline : {
                        visible : false
                      },
                      shapeRendering : false,
                      isIndependentMode : true
                    },
                    propertiesOverride : {
                      gridline : { isExported : false },
                      axisline: { isExported : false },
                      label : { isExported : false },
                      scale : { 
                        fixedRange : {isExported : false},
                        minValue : {isExported : false},
                        maxValue : {isExported : false},
                        isExported : false 
                      }
                    }
                  }
                },
    
                background : {
                  id : 'sap.viz.modules.background',
                  configure : {
                    propertyCategory : 'background',
                    properties : {
                      direction : direction
                    }
                  }
                }
              },
              
              configure : {
                propertyCategory : 'xyzcontainer',
                properties : {
                  xAngle : 20, 
                  yAngle : 50,
                  layout : {
                    position : 'center',
                    priority : 10
                  }
                }
              }
            }
          }
        }
      },
      
      dependencies : {
        attributes : [{
          targetModule : 'root.main',
          target : categoryAxis ,
          sourceModule : 'root.main.plot',
          source : 'primaryCategoryScale'
        }, {
          targetModule : 'root.main',
          target : valueAxis,
          sourceModule : 'root.main.plot',
          source : 'valueScale'
        },{
          targetModule : 'root.main.' + valueAxis,
          target : 'scale',
          sourceModule : 'root.main',
          source : valueAxis
        }, {
          targetModule : 'root.main.' + categoryAxis,
          target : 'scale',
          sourceModule : 'root.main',
          source : categoryAxis
        },{
          targetModule : 'root.main',
          target : 'zAxis',
          sourceModule : 'root.main.plot',
          source : 'secondaryCategoryScale'
        }, {
          targetModule : 'root.main.zAxis',
          target : 'scale',
          sourceModule : 'root.main',
          source : 'zAxis'
        },{
          targetModule : 'root.legends.legend',
          target : 'colorPalette',
          sourceModule : 'root.main.plot',
          source : 'colorPalette'
        },{
          targetModule : 'root.main.zAxis',
          target : 'independentData',
          sourceModule : 'root.main.plot',
          source : 'secondaryCategoryData'
        },{
        targetModule : 'root.main.'+categoryAxis,
        target : 'independentData',
        sourceModule : 'root.main.plot',
        source : 'primaryCategoryData'
      }, {
          targetModule : 'root.main.'+valueAxis,
          target : 'title',
          sourceModule : 'root.main.plot',
          source : 'valueScaleTitle'
      } ],
        events : [ {
          targetModule : 'root.interaction',
          listener : 'registerEvent',
          sourceModule : 'root.main.plot',
          type : 'initialized.interaction'
        }, {
          targetModule : 'root.rotate',
          listener : 'registerEvent',
          sourceModule : 'root.main.plot',
          type : 'initialized.rotate'
        }, {
          targetModule : 'root.main',
          listener : isVertical? 'xAxisScaleChange': 'yAxisScaleChange',
          sourceModule : 'root.main.plot',
          type : 'primaryCategoryScaleChange.xyzcontainer'
        },{
          targetModule : 'root.main',
          listener : isVertical? 'yAxisScaleChange': 'xAxisScaleChange',
          sourceModule : 'root.main.plot',
          type : 'valueScaleChange.xyzcontainer'
        },{
          targetModule : 'root.main',
          listener : 'zAxisScaleChange',
          sourceModule : 'root.main.plot',
          type : 'secondaryCategoryScaleChange.xyzcontainer'
        },{
          targetModule : 'root.tooltip',
          listener : 'showTooltip',
          sourceModule : 'root.main.plot',
          type : 'showTooltip.tooltip'
        }, {
          targetModule : 'root.tooltip',
          listener : 'hideTooltip',
          sourceModule : 'root.main.plot',
          type : 'hideTooltip.tooltip'
        },{
          targetModule : 'root.interaction',
          listener : 'highlightedByLegend',
          sourceModule : 'root.legends.legend',
          type : 'highlightedByLegend'
        }, {
          targetModule : 'root.legends.legend',
          listener : 'deselectLegend',
          sourceModule : 'root.interaction',
          type : 'deselectLegend'
        }]
      }
    };

    var modules = chart.modules.root.modules.main.modules;

    modules[categoryAxis] = {
      id : 'sap.viz.modules.axis',
      data : {
        aa : [ 1 ]
      },
      configure : {
        'description' : 'Settings for the category axis of an XYZ chart.',
        propertyCategory : categoryAxis,
        properties : {
          type : 'category',
          isIndependentMode : true,
          position : isVertical ? 'bottom' : 'left',
          forceVerticalFont : (isVertical ? true : undefined),
          forceLabelArea :true,
          gridline : {
            visible : false,
            showFirstLine: false,
            showLastLine: false
          },
          shapeRendering : false
        },
        propertiesOverride : {
          gridline : { isExported : false },
          axisline : { isExported : false },
          label : { isExported : false },
          scale : { 
            fixedRange : {isExported : false},
            minValue : {isExported : false},
            maxValue : {isExported : false},
            isExported : false 
          }
        }
      }
    };

    modules[valueAxis] = {
      id : 'sap.viz.modules.axis',
      configure : {
        'description' : 'Settings for the value axis of an XYZ chart.',
        propertyCategory : valueAxis,
        properties : {
          type : 'value',
          position : (isVertical ? 'left' : 'bottom'),
          forceVerticalFont : (isVertical ? undefined : true),
          shapeRendering : false,
          gridline : {
              visible : false,
              showFirstLine: false,
              showLastLine: false
          }
        },
        propertiesOverride : {
            gridline : { isExported : false },
            scale : { 
              fixedRange : {isExported : false},
              minValue : {isExported : false},
              maxValue : {isExported : false},
              isExported : false 
            }
        }
      }
    };

    Manifest.register(chart);
  };
});

define('sap/viz/manifests/xyz/Column3DChart',['sap/viz/manifests/xyz/Base3DChart'],
function Setup(fn) {
  fn("vertical");
});
define('sap/viz/manifests/xyz/Bar3DChart',['sap/viz/manifests/xyz/Base3DChart'],
function Setup(fn) {
  fn("horizontal");
});
define('sap/viz/manifests/MultiRadarChart',['sap/viz/manifests/Viz','sap/viz/manifests/BaseChart','sap/viz/modules/manifests/RootContainer',
'sap/viz/modules/manifests/XYContainer','sap/viz/modules/manifests/TableContainer',
'sap/viz/modules/manifests/Axis','sap/viz/modules/manifests/Radar','sap/viz/modules/manifests/controller/Interaction',
'sap/viz/manifests/BaseMultipleChart','sap/viz/manifests/BaseMultipleXYChart',
'sap/viz/modules/manifests/Tooltip','sap/viz/modules/manifests/Background'],
function Setup(Manifest) {
  var multiRadarChart = {
    id : 'viz/multi_radar',
    name : 'IDS_MULTIRADARCHART',
    base : 'riv/base/multiple/xy',
    modules : {
      root : {
        modules : {
          legends : {
            modules : {
              legend : { data : { aa : [ 3] } }
            }
          },
          tooltip : {
            id : "sap.viz.modules.tooltip",
            configure : {
              properties : {
                chartType : "radar",
                orientation : "left"
              }
            }
          },
          
          'interaction' : {
            id : 'sap.viz.modules.controller.interaction',
            configure : {
              clientID : "main",
              propertyCategory : 'interaction',
              properties : {
                      supportedEventNames: ['mouseup', 'mousemove', 'touchstart']
              }
            }
          },
          
          main : {
            configure : {
              properties : {
                'mergeDataRange' : ['primary']
              }
            },
            modules: {
              plot : {
                id : 'sap.viz.modules.xycontainer',
                modules : {
                  dataLabel : {
                    id : 'sap.viz.modules.datalabel',
                    configure : {
                      propertyCategory : 'dataLabel',
                      properties : {
                        orientation : 'vertical',
                        position : 'outside',
                        automaticInOutside : false,
                        outsidePosition : 'up',
                        positionPreference : true
                      }
                    }
                  },
                  plot : {
                    id : 'sap.viz.modules.radar',
                    configure : {
                      description: 'Settings regarding the chart area and plot area as well as general chart options.',
                      propertyCategory : "plotArea",
                      properties : {
                        multichart : true
                      }
                    }
                  },
                  background : {
                    configure : {
                      propertyCategory : 'background',
                      properties : {
                        visible : false
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      
    },
    feeds : {
      multiplier : {
        acceptMND : 0,
        max : 2
      },
      
      regionShape : {
        max : 0
      }
      
    },
    dependencies : {
      attributes : [
      {
        targetModule : 'root.main.xAxis2',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'xCategoryScale'
      }, 
      {
        targetModule : 'root.main.yAxis',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'yCategoryScale'
      },
      {
        targetModule : 'root.main',
        target : 'primaryDataRange',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'root.main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'root.main',
        source : 'primaryDataRange'
      },
      {
        targetModule : "root.legends.legend",
        target : "colorPalette",
        sourceModule : "root.main.plot.plot",
        source : "colorPalette"
      }, 
      {
        targetModule : 'root.legends.legend',
        target : 'shapes',
        sourceModule : 'root.main.plot.plot',
        source : 'shapes'
      }
      ], 
      events : [ 
      {
        targetModule : 'root.interaction',
        listener : 'registerEvent',
        sourceModule : 'root.main',
        type : 'initialized.interaction'
      }, {
        targetModule : 'root.tooltip',
        listener : 'showTooltip',
        sourceModule : 'root.main',
        type : 'showTooltip'
      }, {
        targetModule : 'root.tooltip',
        listener : 'hideTooltip',
        sourceModule : 'root.main',
        type : 'hideTooltip'
      }, {
        targetModule : 'root.interaction',
        listener : 'highlightedByLegend',
        sourceModule : 'root.legends.legend',
        type : 'highlightedByLegend'
      }, {
        targetModule : 'root.legends.legend',
        listener : 'deselectLegend',
        sourceModule : 'root.interaction',
        type : 'deselectLegend'
      }, {
        targetModule : 'root.main.plot.dataLabel',
        listener : 'showLabel',
        sourceModule : 'root.main.plot.plot',
        type : 'initialized.datalabel'
      }, {
        targetModule : 'root.main.plot.dataLabel',
        listener : 'removeLabel',
        sourceModule : 'root.main.plot.plot',
        type : 'startToInit.datalabel'
      }]
    }
  };

  Manifest.register(multiRadarChart);
});
define('sap/viz/manifests/MultiBarChart',['sap/viz/manifests/Viz','sap/viz/manifests/BaseChart','sap/viz/modules/manifests/RootContainer',
'sap/viz/modules/manifests/XYContainer','sap/viz/modules/manifests/TableContainer',
'sap/viz/modules/manifests/Axis','sap/viz/modules/manifests/xy/Bar','sap/viz/modules/manifests/controller/Interaction',
'sap/viz/manifests/BaseMultipleChart','sap/viz/manifests/BaseMultipleXYChart'],
function Setup(Manifest) {
  var multiBarChart = {
    id : 'viz/multi_bar',
    name : 'IDS_MULTIBARCHART',
    base : 'riv/base/multiple/xy',
    modules : {
      root : {
        modules : {
          legends : {
            modules : {
              legend : {
                data : { aa : [ 3 ] }
              }
            }
          },
          
          tooltip : {
            configure : {
              properties : { chartType : 'bar', orientation : 'left' }
            }
          },
          
          interaction : {
            id : 'sap.viz.modules.controller.interaction',
            configure : {
              clientID : 'main',
              propertyCategory : 'interaction',
              properties : {
                supportedEventNames: ['mouseup', 'mousedown', 'mousemove', 'mouseover', 'mouseout', 'touchstart'],
                holdSelection : true
              }
             }
          },

          main : {   
            configure : {
              properties : {
                'mergeDataRange' : ['primary']
              }
            },
            modules: {
              plot : {
                id : 'sap.viz.modules.xycontainer',
                modules : {
                  background : {
                    configure : { properties : { direction : 'horizontal' } }
                  },
                  
                  dataLabel : {
                    id : 'sap.viz.modules.datalabel',
                    configure : {
                      propertyCategory : 'dataLabel',
                      properties : {
                        orientation : 'horizontal',
                        outsidePosition : 'right'
                      }
                    }
                  },
                  
                  xAxis : {
                    id : 'sap.viz.modules.axis',
                    configure : {
                      description :'Settings for the value axis of an XY chart.',
                      propertyCategory : 'xAxis',
                      properties : {
                        title : { visible : false },
                        type : 'value',
                        position : 'bottom'
                      },
                      propertiesOverride : {
                        title : { isExported : false }                    
                      }
                    }
                  },

                  yAxis : {
                    id : 'sap.viz.modules.axis',
                    data : { aa : [ 1 ] },
                    configure : {
                      description : 'Settings for the category axis of an XY chart.',
                      propertyCategory : 'yAxis',
                      properties : {
                        type : 'category',
                        position : 'left',
                        gridline : { visible : false }
                      },
                      propertiesOverride : {
                        title : { isExported : false },
                        gridline : { isExported : false },
                        label : { isExported : false },
                        axisline : { isExported : false },
                        scale : { 
                          fixedRange : {isExported : false},
                          minValue : {isExported : false},
                          maxValue : {isExported : false},
                          isExported : false 
                        }
                      }
                    }
                  },
                  
                  plot : {
                    id : 'sap.viz.modules.bar',
                    configure : {
                      description : 'Settings regarding the chart area and plot area as well as general chart options.',
                      propertyCategory : 'plotArea'
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    feeds:{
      multiplier:{
      max:1
     },
      secondaryValues: null,
      axisLabels:{
        max:1
      }
    },
    dependencies : {
      attributes : [
        {
          targetModule : 'root.main.plot.plot',
          target : 'primaryDataRange',
          sourceModule : 'root.main.plot.xAxis',
          source : 'range'
        }, 
        {
          targetModule : 'root.main.xAxis2',
          target : 'scale',
          sourceModule : 'root.main',
          source : 'xCategoryScale'
        }, 
        {
          targetModule : 'root.main.yAxis',
          target : 'scale',
          sourceModule : 'root.main',
          source : 'yCategoryScale'
        },
        {
          targetModule : 'root.main',
          target : 'primaryDataRange',
          sourceModule : 'root.main.plot.plot',
          source : 'primaryDataRange'
        },
        {
          targetModule : 'root.main.plot.plot',
          target : 'primaryDataRange',
          sourceModule : 'root.main',
          source : 'primaryDataRange'
        },
        {
          /**
           * [jimmy/8/8/2012]each node in the path may have several entities
           * like main.plot, we may create several main.plots
           * (here the xycontainer), by using 'main.plot.xAxis'
           * here we actually means for xAxis in each main.plot
           * 
           * in the future, we may need support more complicated dependency resolving
           * like 'the 3rd xycontainer's xAxis', can be described
           * as main.plot[2].xAxis
           */
          targetModule : 'root.main.plot.xAxis',
          target : 'scale',
          sourceModule : 'root.main.plot.plot',
          source : 'primaryScale'
        }, 
        { 
          targetModule : 'root.main.plot.xAxis',
          target : 'title',
          sourceModule : 'root.main.plot.plot',
          source : 'primaryAxisTitle'
        },
        {
          targetModule : 'root.main.plot.yAxis',
          target : 'scale',
          sourceModule : 'root.main.plot.plot',
          source : 'categoryScale'
        }, 
        {
          targetModule : 'root.legends.legend',
          target : 'colorPalette',
          sourceModule : 'root.main.plot.plot',
          source : 'colorPalette'
        }, 
        {
          targetModule : 'root.legends.legend',
          target : 'setSelectionMode',
          sourceModule : 'root.interaction',
          source : 'getSelectionMode'
        }
      ],
      events : [ 
        {
          targetModule : 'root.interaction',
          listener : 'registerEvent',
          sourceModule : 'root.main',
          type : 'initialized.interaction'
        }, 
        {
          targetModule : 'root.tooltip',
          listener : 'showTooltip',
          sourceModule : 'root.main',
          type : 'showTooltip'
        }, 
        {
          targetModule : 'root.tooltip',
          listener : 'hideTooltip',
          sourceModule : 'root.main',
          type : 'hideTooltip'
        },
        {
          targetModule : 'root.interaction',
          listener : 'highlightedByLegend',
          sourceModule : 'root.legends.legend',
          type : 'highlightedByLegend'
        }, 
        {
          targetModule : 'root.legends.legend',
          listener : 'deselectLegend',
          sourceModule : 'root.interaction',
          type : 'deselectLegend'
        }, 
        {
          targetModule : 'root.main.plot.dataLabel',
          listener : 'showLabel',
          sourceModule : 'root.main.plot.plot',
          type : 'initialized.datalabel'
        }, 
        {
          targetModule : 'root.main.plot.dataLabel',
          listener : 'removeLabel',
          sourceModule : 'root.main.plot.plot',
          type : 'startToInit.datalabel'
        }
      ]
    }
  };

  Manifest.register(multiBarChart);
});
define('sap/viz/manifests/MultiVerticalBarChart',['sap/viz/manifests/Viz','sap/viz/manifests/BaseChart','sap/viz/modules/manifests/RootContainer',
'sap/viz/modules/manifests/XYContainer','sap/viz/modules/manifests/TableContainer',
'sap/viz/modules/manifests/Axis','sap/viz/modules/manifests/xy/VerticalBar',
'sap/viz/manifests/BaseMultipleChart','sap/viz/manifests/BaseMultipleXYChart','sap/viz/manifests/MultiBarChart'],
function Setup(Manifest) {
  var multiVBarChart = {
    id : 'viz/multi_column',
    name : 'IDS_MULTIVERTICALBARCHART',
    base : 'viz/multi_bar',
    modules : {
      root : {
        modules : {
          tooltip : {
            configure : {
              properties : {
                chartType : 'verticalbar',
                orientation : 'left'
              }
            }
          },
          interaction : {
            id : 'sap.viz.modules.controller.interaction',
            configure : {
              clientID : 'main',
              propertyCategory : 'interaction',
              properties : {
                holdSelection : true
              }
             }
          },

          main : {
            modules: {
              plot : {
                modules : {
                  background : {
                    configure : {
                      properties : {
                        direction : 'vertical'
                      }
                    }
                  },
                  dataLabel : {
                    id : 'sap.viz.modules.datalabel',
                    configure : {
                      propertyCategory : 'dataLabel',
                      properties : {
                        orientation : 'vertical',
                        outsidePosition : 'up'
                      }
                    }
                  },
                  xAxis : {
                    data : {
                      aa : [ 1 ]
                    },
                    configure : {
                      'description':'Settings for the category axis of an XY chart.',
                      properties : {
                        type : 'category',
                        gridline : {
                          visible : false
                        }
                      },
                      propertiesOverride : {
                        gridline : { isExported : false },
                        label : { isExported : false },
                        axisline : { isExported : false },
                        scale : { 
                          fixedRange : {isExported : false},
                          minValue : {isExported : false},
                          maxValue : {isExported : false},
                          isExported : false 
                        }
                      }
                    }
                  },
                  /**
                   * 'xAxis2' : { },
                   */
        
                  yAxis : {
                    data : null,
                    configure : {
                      'description':'Settings for the value axis of an XY chart.',
                      properties : {
                        type : 'value',
                        gridline : {
                          visible : true
                        }
                      },
                      propertiesOverride : {
                        gridline : { isExported : true },
                        label : { isExported : true },
                        axisline : { isExported : true },
                        scale : { 
                          fixedRange : {isExported : true},
                          minValue : {isExported : true},
                          maxValue : {isExported : true},
                          isExported : true 
                        }
                      }
                    }
                  },
                  
                  plot : {
                    id : 'sap.viz.modules.verticalbar',
                    configure : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                      propertyCategory : 'plotArea'
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    feeds:{  
        multiplier:{
        max:1
      },
        axisLabels:{
        max:1
      },
      secondaryValues: null
    },
    dependencies : {
      attributes : [
      {
        targetModule : 'root.main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'root.main.plot.yAxis',
        source : 'range'
      },
      {
        targetModule : 'root.main.xAxis2',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'xCategoryScale'
      }, 
      {
        targetModule : 'root.main.yAxis',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'yCategoryScale'
      },
      {
        targetModule : 'root.main',
        target : 'primaryDataRange',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'root.main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'root.main',
        source : 'primaryDataRange'
      },
      {
        /**
         * [jimmy/8/8/2012]each node in the path may have several entities
         * like main.plot, we may create several main.plots
         * (here the xycontainer), by using 'main.plot.xAxis'
         * here we actually means for xAxis in each main.plot
         * 
         * in the future, we may need support more complicated dependency resolving
         * like 'the 3rd xycontainer's xAxis', can be described
         * as main.plot[2].xAxis
         */
        targetModule : 'root.main.plot.yAxis',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryScale'
      }, { targetModule : 'root.main.plot.yAxis',
        target : 'title',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryAxisTitle'
      }, {
        targetModule : 'root.main.plot.xAxis',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'categoryScale'
      }, {
        targetModule : 'root.legends.legend',
        target : 'colorPalette',
        sourceModule : 'root.main.plot.plot',
        source : 'colorPalette'
      }
      ]
    }
  };

  Manifest.register(multiVBarChart);
});
define('sap/viz/manifests/MultiDualVerticalBarChart',['sap/viz/manifests/Viz','sap/viz/manifests/BaseChart','sap/viz/modules/manifests/RootContainer',
'sap/viz/modules/manifests/XYContainer','sap/viz/modules/manifests/TableContainer',
'sap/viz/modules/manifests/Axis','sap/viz/modules/manifests/xy/VerticalBar',
'sap/viz/manifests/BaseMultipleChart','sap/viz/manifests/BaseMultipleXYChart',
'sap/viz/manifests/MultiVerticalBarChart'],
function Setup(Manifest) {
  var multiVBarChart = {
    id : 'viz/multi_dual_column',
    name : 'IDS_MULTIDUALVERTICALBARCHART',
    base : 'viz/multi_column',
    modules : {
      root : {
        modules : {
          main : {
            configure : { properties : { 'mergeDataRange' : ['primary', 'second'] } },
            modules: {
              plot : {
                modules : {
                  plot: {
                    configure: {
                      propertiesOverride:{
                        primaryValuesColorPalette:{ isExported: true },
                        secondaryValuesColorPalette: { isExported: true }
                      }
                    }
                  },
                  yAxis:{
                    id : 'sap.viz.modules.axis',
                    configure:{
                      'description':'Settings for the value axis at left or bottom of an XY chart with 2 value axis.'
                    }
                  },
                  yAxis2 : {
                    id : 'sap.viz.modules.axis',
                    configure : {
                      'description':'Settings for the value axis at right or top of an XY chart with 2 value axis.',
                      propertyCategory : 'yAxis2',
                      properties : {
                        title : { visible : false },
                        gridline : { visible : false },
                        type : 'value',
                        position : 'right'
                      },
                      propertiesOverride : {
                        title : { isExported : false }                    
                      }
                    }
                  }
                }
              }
            }
          }
      }
    }
    
    },
    feeds:{
      multiplier : { max:1 },
      secondaryValues : { min : 1, max : Number.POSITIVE_INFINITY  },
      axisLabels:{ max:1 }
    },
    
    dependencies : {
      attributes : [
      {
        targetModule : 'root.main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'root.main.plot.yAxis',
        source : 'range'
      },
      {
        targetModule : 'root.main.plot.plot',
        target : 'secondDataRange',
        sourceModule : 'root.main.plot.yAxis2',
        source : 'range'
      },
      {
        targetModule : 'root.main.xAxis2',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'xCategoryScale'
      }, 
      {
        targetModule : 'root.main.yAxis',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'yCategoryScale'
      },
      {
        targetModule : 'root.main',
        target : 'primaryDataRange',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'root.main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'root.main',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'root.main',
        target : 'secondDataRange',
        sourceModule : 'root.main.plot.plot',
        source : 'secondDataRange'
      },
      {
        targetModule : 'root.main.plot.plot',
        target : 'secondDataRange',
        sourceModule : 'root.main',
        source : 'secondDataRange'
      },
      {
        targetModule : 'root.main.plot.yAxis',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryScale'
      }, {
        targetModule : 'root.main.plot.yAxis',
        target : 'title',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryAxisTitle'
      },
      {
        targetModule : 'root.main.plot.yAxis2',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'secondScale'
      }, {
        targetModule : 'root.main.plot.yAxis2',
        target : 'title',
        sourceModule : 'root.main.plot.plot',
        source : 'secondAxisTitle'
      },
      {
        targetModule : 'root.main.plot.yAxis',
        target : 'color',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryAxisColor'
      },
      {
        targetModule : 'root.main.plot.yAxis2',
        target : 'color',
        sourceModule : 'root.main.plot.plot',
        source : 'secondAxisColor'
      },
      {
        targetModule : 'root.main.plot.xAxis',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'categoryScale'
      },
      {
        targetModule : 'root.legends.legend',
        target : 'colorPalette',
        sourceModule : 'root.main.plot.plot',
        source : 'colorPalette'
      }
      ]
    }
  };

  Manifest.register(multiVBarChart);
});
define('sap/viz/manifests/MultiDualBarChart',['sap/viz/manifests/Viz','sap/viz/manifests/BaseChart','sap/viz/modules/manifests/RootContainer',
'sap/viz/modules/manifests/XYContainer','sap/viz/modules/manifests/TableContainer',
'sap/viz/modules/manifests/Axis','sap/viz/modules/manifests/xy/Bar',
'sap/viz/manifests/BaseMultipleChart','sap/viz/manifests/BaseMultipleXYChart',
'sap/viz/manifests/MultiBarChart'],
function Setup(Manifest) {
  var multiBarChart = {
    id : 'viz/multi_dual_bar',
    name : 'IDS_MULTIDUALBARCHART',
    base : 'viz/multi_bar',
    modules : {
      root : {
        modules : {
          main : {
            configure : { properties : { 'mergeDataRange' : ['primary', 'second'] } },
            modules: {
              plot : {
                id : 'sap.viz.modules.xycontainer',
                modules : {
                   plot : {
                    configure : {
                      propertiesOverride : {
                        primaryValuesColorPalette : { isExported: true },
                        secondaryValuesColorPalette: { isExported: true }
                      }
                    }
                  },
                  
                  xAxis:{
                    id : 'sap.viz.modules.axis',
                    configure:{
                      description : 'Settings for the value axis at left or bottom of an XY chart with 2 value axis.'
                    }
                  },
                  
                  xAxis2 : {
                    id : 'sap.viz.modules.axis',
                    configure : {
                      description : 'Settings for the value axis at right or top of an XY chart with 2 value axis.',
                      propertyCategory : 'xAxis2',
                      properties : {
                        title : { visible : false },
                        gridline : { visible : false },
                        type : 'value',
                        position : 'top'
                      },
                      propertiesOverride : {
                        title : { isExported : false }                    
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    
    feeds : {
      multiplier : { max:1 },
      secondaryValues : { min: 1, max : Number.POSITIVE_INFINITY },
      axisLabels : { max:1 }
    },
    
    dependencies : {
      attributes : [
      {
        targetModule : 'root.main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'root.main.plot.xAxis',
        source : 'range'
      },
      {
        targetModule : 'root.main.plot.plot',
        target : 'secondDataRange',
        sourceModule : 'root.main.plot.xAxis2',
        source : 'range'
      },
      {
        targetModule : 'root.main.xAxis2',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'xCategoryScale'
      }, 
      {
        targetModule : 'root.main.yAxis',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'yCategoryScale'
      },
      {
        targetModule : 'root.main',
        target : 'primaryDataRange',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'root.main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'root.main',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'root.main',
        target : 'secondDataRange',
        sourceModule : 'root.main.plot.plot',
        source : 'secondDataRange'
      },
      {
        targetModule : 'root.main.plot.plot',
        target : 'secondDataRange',
        sourceModule : 'root.main',
        source : 'secondDataRange'
      },
      {
        targetModule : 'root.main.plot.xAxis',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryScale'
      },   {
        targetModule : 'root.main.plot.xAxis',
        target : 'title',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryAxisTitle'
      },   {
        targetModule : 'root.main.plot.xAxis2',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'secondScale'
      },
   {
        targetModule : 'root.main.plot.xAxis2',
        target : 'title',
        sourceModule : 'root.main.plot.plot',
        source : 'secondAxisTitle'
      },
      {
        targetModule : 'root.main.plot.xAxis',
        target : 'color',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryAxisColor'
      },
      {
        targetModule : 'root.main.plot.xAxis2',
        target : 'color',
        sourceModule : 'root.main.plot.plot',
        source : 'secondAxisColor'
      },
      {
        targetModule : 'root.main.plot.yAxis',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'categoryScale'
      }, {
        targetModule : 'root.legends.legend',
        target : 'colorPalette',
        sourceModule : 'root.main.plot.plot',
        source : 'colorPalette'
      }
      ]
    }
  };

  Manifest.register(multiBarChart);
});
define('sap/viz/manifests/MultiStackedBarChart',['sap/viz/manifests/Viz','sap/viz/manifests/BaseChart','sap/viz/modules/manifests/RootContainer',
'sap/viz/modules/manifests/XYContainer','sap/viz/modules/manifests/TableContainer',
'sap/viz/modules/manifests/Axis','sap/viz/modules/manifests/xy/StackedBar',
'sap/viz/manifests/BaseMultipleChart','sap/viz/manifests/BaseMultipleXYChart','sap/viz/manifests/MultiBarChart'],
function Setup(Manifest) {
  var multiBarChart = {
    id : 'viz/multi_stacked_bar',
    name : 'IDS_MULTISTACKEDBARCHART',
    base : 'viz/multi_bar',
    modules : {
      root : {
        modules : {
          main : {
            modules: {
              plot : {
                id : 'sap.viz.modules.xycontainer',
                modules : {
                  plot : {
                    id : 'sap.viz.modules.stackedbar',
                    configure : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                      propertyCategory : 'plotArea'
                    }
                  },
                  dataLabel : {
                    id : 'sap.viz.modules.datalabel',
                    configure : {
                      properties : {
                        automaticInOutside : false,
                        isStackMode : true,
                        showZero : false
                      },
                      propertiesOverride : {
                        position : {
                          isExported : false
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      
    },
    feeds:{  
        multiplier:{
        max:1
      },
        axisLabels:{
        max:1
      },
      secondaryValues:null
    },
    dependencies : {
      attributes : [
      {
        targetModule : 'root.main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'root.main.plot.xAxis',
        source : 'range'
      },
      {
        targetModule : 'root.main.xAxis2',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'xCategoryScale'
      }, 
      {
        targetModule : 'root.main.yAxis',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'yCategoryScale'
      },
      {
        targetModule : 'root.main',
        target : 'primaryDataRange',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'root.main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'root.main',
        source : 'primaryDataRange'
      },
      {
        /**
         * [jimmy/8/8/2012]each node in the path may have several entities
         * like main.plot, we may create several main.plots
         * (here the xycontainer), by using 'main.plot.xAxis'
         * here we actually means for xAxis in each main.plot
         * 
         * in the future, we may need support more complicated dependency resolving
         * like 'the 3rd xycontainer's xAxis', can be described
         * as main.plot[2].xAxis
         */
        targetModule : 'root.main.plot.xAxis',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryScale'
      },{ 
      targetModule : 'root.main.plot.xAxis',
        target : 'title',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryAxisTitle'
      }, {
        targetModule : 'root.main.plot.yAxis',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'categoryScale'
      }, {
        targetModule : 'root.legends.legend',
        target : 'colorPalette',
        sourceModule : 'root.main.plot.plot',
        source : 'colorPalette'
      }
      ]
    }
  };

  Manifest.register(multiBarChart);
});
define('sap/viz/manifests/MultiStackedVerticalBarChart',['sap/viz/manifests/Viz','sap/viz/manifests/BaseChart','sap/viz/modules/manifests/RootContainer',
'sap/viz/modules/manifests/XYContainer','sap/viz/modules/manifests/TableContainer',
'sap/viz/modules/manifests/Axis','sap/viz/modules/manifests/xy/StackedVerticalBar',
'sap/viz/manifests/BaseMultipleChart','sap/viz/manifests/BaseMultipleXYChart',
'sap/viz/manifests/MultiVerticalBarChart'],
function Setup(Manifest) {
  var multiBarChart = {
    id : 'viz/multi_stacked_column',
    name : 'IDS_MULTISTACKEDVERTICALBARCHART',
    base : 'viz/multi_column',
    modules : {
      root : {
        modules : {
          main : {
            modules : {
              plot : {
                id : 'sap.viz.modules.xycontainer',
                modules : {
                  plot : {
                    id : 'sap.viz.modules.stackedverticalbar',
                    configure : {
                      'description' : 'Settings regarding the chart area and plot area as well as general chart options.',
                      propertyCategory : 'plotArea'
                    }
                  },
                  dataLabel : {
                    id : 'sap.viz.modules.datalabel',
                    configure : {
                      properties : {
                        automaticInOutside : false,
                        isStackMode : true,
                        showZero : false
                      },
                      propertiesOverride : {
                        position : {
                          isExported : false
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    feeds : {
      multiplier : {
        max : 1
      },
      axisLabels : {
        max : 1
      },
      secondaryValues : null
    },
    dependencies : {
      attributes : [ {
        targetModule : 'root.main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'root.main.plot.yAxis',
        source : 'range'
      }, {
        targetModule : 'root.main.xAxis2',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'xCategoryScale'
      }, {
        targetModule : 'root.main.yAxis',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'yCategoryScale'
      }, {
        targetModule : 'root.main',
        target : 'primaryDataRange',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryDataRange'
      }, {
        targetModule : 'root.main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'root.main',
        source : 'primaryDataRange'
      }, {
        /**
         * [jimmy/8/8/2012]each node in the path may have several entities
         * like main.plot, we may create several main.plots
         * (here the xycontainer), by using 'main.plot.xAxis'
         * here we actually means for xAxis in each main.plot
         *
         * in the future, we may need support more complicated dependency resolving
         * like 'the 3rd xycontainer's xAxis', can be described
         * as main.plot[2].xAxis
         */
        targetModule : 'root.main.plot.yAxis',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryScale'
      }, {
        targetModule : 'root.main.plot.yAxis',
        target : 'title',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryAxisTitle'
      }, {
        targetModule : 'root.main.plot.xAxis',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'categoryScale'
      }, {
        targetModule : 'root.legends.legend',
        target : 'colorPalette',
        sourceModule : 'root.main.plot.plot',
        source : 'colorPalette'
      }]
    }
  };

  Manifest.register(multiBarChart);
});
define('sap/viz/manifests/MultiDualStackedBarChart',['sap/viz/manifests/Viz','sap/viz/manifests/BaseChart','sap/viz/modules/manifests/RootContainer',
'sap/viz/modules/manifests/XYContainer','sap/viz/modules/manifests/TableContainer',
'sap/viz/modules/manifests/Axis','sap/viz/modules/manifests/xy/StackedBar',
'sap/viz/manifests/BaseMultipleChart','sap/viz/manifests/BaseMultipleXYChart','sap/viz/manifests/MultiDualBarChart'],
function Setup(Manifest) {
  var multiBarChart = {
    id : 'viz/multi_dual_stacked_bar',
    name : 'IDS_MULTIDUALSTACKEDBARCHART',
    base : 'viz/multi_dual_bar',
    modules : {
      root : {
        modules : {
          main : {
            modules: {
              plot : {
                id : 'sap.viz.modules.xycontainer',
                modules : {
                  plot : {
                    id : 'sap.viz.modules.stackedbar',
                    configure : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                      propertyCategory : 'plotArea'
                    }
                  },
                  dataLabel : {
                    id : 'sap.viz.modules.datalabel',
                    configure : {
                      properties : {
                        automaticInOutside : false,
                        isStackMode : true,
                        showZero : false
                      },
                      propertiesOverride : {
                        position : {
                          isExported : false
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      
    }
  };

  Manifest.register(multiBarChart);
});
define('sap/viz/manifests/MultiDualStackedVerticalBarChart',['sap/viz/manifests/Viz','sap/viz/manifests/BaseChart','sap/viz/modules/manifests/RootContainer',
'sap/viz/modules/manifests/XYContainer','sap/viz/modules/manifests/TableContainer',
'sap/viz/modules/manifests/Axis','sap/viz/modules/manifests/xy/StackedVerticalBar',
'sap/viz/manifests/BaseMultipleChart','sap/viz/manifests/BaseMultipleXYChart',
'sap/viz/manifests/MultiDualVerticalBarChart'],
function Setup(Manifest) {
  var multiVBarChart = {
    id : 'viz/multi_dual_stacked_column',
    name : 'IDS_MULTIDUALSTACKEDVERTICALBARCHART',
    base : 'viz/multi_dual_column',
    modules : {
      root : {
        modules : {
          main : {
            modules: {
              plot : {
                modules : {
                  plot : {
                    id : 'sap.viz.modules.stackedverticalbar',
                    configure : {
                      'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                      propertyCategory : 'plotArea'
                    }
                  },
                  dataLabel : {
                    id : 'sap.viz.modules.datalabel',
                    configure : {
                      properties : {
                        automaticInOutside : false,
                        isStackMode : true,
                        showZero : false
                      },
                      propertiesOverride : {
                        position : {
                          isExported : false
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  };

  Manifest.register(multiVBarChart);
});
define('sap/viz/manifests/MultiPercentageStackedBarChart',['sap/viz/manifests/Viz','sap/viz/manifests/BaseChart','sap/viz/modules/manifests/RootContainer',
'sap/viz/modules/manifests/XYContainer','sap/viz/modules/manifests/TableContainer',
'sap/viz/modules/manifests/Axis','sap/viz/modules/manifests/xy/StackedBar',
'sap/viz/manifests/BaseMultipleChart','sap/viz/manifests/BaseMultipleXYChart','sap/viz/manifests/MultiStackedBarChart'],
function Setup(Manifest) {
  var multiBarChart = {
    id : 'viz/multi_100_stacked_bar',
    name : 'IDS_MULTIPERCENTAGESTACKEDBARCHART',
    base : 'viz/multi_stacked_bar',
    feeds:{
      multiplier:{
      max:1
     },
     secondaryValues: null,
      axisLabels:{
        max:1
      }
    },
    modules : {
      root : {
        modules : {
          main : {
        modules: {
          plot : {
            id : 'sap.viz.modules.xycontainer',
            modules : {
              xAxis : {
                id : 'sap.viz.modules.axis',
                configure : {
                  properties : {
                    isPercentMode : true
                  },
                  propertiesOverride : {
                    scale : { 
                      fixedRange : {isExported : false},
                      minValue : {isExported : false},
                      maxValue : {isExported : false},
                      isExported : false 
                    }
                  }
                }
              },
              plot : {
                id : 'sap.viz.modules.stackedbar',
                configure : {
                  properties : {
                    'mode' : 'percentage'
                  }
                }
              },
              dataLabel : {
                  id : 'sap.viz.modules.datalabel',
                  configure : {
                    propertyCategory : 'dataLabel',
                    properties : {
                      isPercentMode : true,
                      type : 'value',
                      showZero : true
                    }
                  }
                  }
                }
              }
            }
          },
          tooltip : {
              id : 'sap.viz.modules.tooltip',
              configure : {
                propertyCategory : 'tooltip',
                properties : {
            formatString: [["0.00%"],["0.00%"]]
                }
              }
          }
        }
      }
    }
  };

  Manifest.register(multiBarChart);
});
define('sap/viz/manifests/MultiPercentageStackedVerticalBarChart',['sap/viz/manifests/Viz','sap/viz/manifests/BaseChart','sap/viz/modules/manifests/RootContainer',
'sap/viz/modules/manifests/XYContainer','sap/viz/modules/manifests/TableContainer',
'sap/viz/modules/manifests/Axis','sap/viz/modules/manifests/xy/StackedVerticalBar',
'sap/viz/manifests/BaseMultipleChart','sap/viz/manifests/BaseMultipleXYChart',
'sap/viz/manifests/MultiStackedVerticalBarChart'],
function Setup(Manifest) {
  var multiBarChart = {
    id : 'viz/multi_100_stacked_column',
    name : 'IDS_MULTIPERCENTAGESTACKEDVERTICALBARCHART',
    base : 'viz/multi_stacked_column',
    feeds : { 
      multiplier : { max : 1 },
      secondaryValues : null, 
      axisLabels : { max:1 }
    },
    modules : {
      root : {
        modules : {
          main : {
        modules: {
          plot : {
            id : 'sap.viz.modules.xycontainer',
            modules : {
              yAxis : {
                id : 'sap.viz.modules.axis',
                configure : {
                  properties : { isPercentMode : true },
                  propertiesOverride : {
                    scale : { 
                      fixedRange : {isExported : false},
                      minValue : {isExported : false},
                      maxValue : {isExported : false},
                      isExported : false 
                    }
                  }
                }
              },
              plot : {
                id : 'sap.viz.modules.stackedverticalbar',
                configure : {
                  properties : { 'mode' : 'percentage' }
                }
              },
              dataLabel : {
                  id : 'sap.viz.modules.datalabel',
                  configure : {
                    propertyCategory : 'dataLabel',
                    properties : {
                      isPercentMode : true,
                      showZero : true
                    }
                  }
                }
                }
              }
            }
          },
          
          tooltip : {
              id : 'sap.viz.modules.tooltip',
              configure : {
                propertyCategory : 'tooltip',
                properties : {
            formatString: [["0.00%"],["0.00%"]]
                }
              }
          }
        }
      }
    }
  };

  Manifest.register(multiBarChart);
});
define('sap/viz/manifests/MultiDualPercentageStackedBarChart',['sap/viz/manifests/Viz','sap/viz/manifests/BaseChart','sap/viz/modules/manifests/RootContainer',
'sap/viz/modules/manifests/XYContainer','sap/viz/modules/manifests/TableContainer',
'sap/viz/modules/manifests/Axis','sap/viz/modules/manifests/xy/StackedBar',
'sap/viz/manifests/BaseMultipleChart','sap/viz/manifests/BaseMultipleXYChart','sap/viz/manifests/MultiDualStackedBarChart'],
function Setup(Manifest) {
  var multiBarChart = {
    id : 'viz/multi_100_dual_stacked_bar',
    name : 'IDS_MULTIDUALPERCENTAGESTACKEDBARCHART',
    base : 'viz/multi_dual_stacked_bar',
    modules : {
      root : {
        modules : {
          main : {
              modules: {
                plot : {
                  id : 'sap.viz.modules.xycontainer',
                  modules : {
                    xAxis : {
                      id : 'sap.viz.modules.axis',
                      configure : {
                        properties : {
                          isPercentMode : true
                        },
                        propertiesOverride : {
                          scale : { 
                            fixedRange : {isExported : false},
                            minValue : {isExported : false},
                            maxValue : {isExported : false},
                            isExported : false 
                          }
                        }
                      }
                    },
                    xAxis2 : {
                      id : 'sap.viz.modules.axis',
                      configure : {
                        properties : {
                          isPercentMode : true
                        },
                        propertiesOverride : {
                          scale : { 
                            fixedRange : {isExported : false},
                            minValue : {isExported : false},
                            maxValue : {isExported : false},
                            isExported : false 
                          }
                        }
                      }
                    },
                    plot : {
                      id : 'sap.viz.modules.stackedbar',
                      configure : {
                        properties : {
                          'mode' : 'percentage'
                        }
                      }
                    },
                    
                    dataLabel : {
                        id : 'sap.viz.modules.datalabel',
                        configure : {
                          propertyCategory : 'dataLabel',
                          properties : {
                            isPercentMode : true,
                            type : 'value',
                            showZero : true
                          }
                        }
                      }
                  }
                }
              }
            },
            
            tooltip : {
                id : 'sap.viz.modules.tooltip',
                configure : {
                  propertyCategory : 'tooltip',
                  properties : {
                    formatString: [["0.00%"],["0.00%"]]
                  }
                }
            }
        }
      }
    }
  };

  Manifest.register(multiBarChart);
});
define('sap/viz/manifests/MultiDualPercentageStackedVerticalBarChart',['sap/viz/manifests/Viz','sap/viz/manifests/BaseChart','sap/viz/modules/manifests/RootContainer',
'sap/viz/modules/manifests/XYContainer','sap/viz/modules/manifests/TableContainer',
'sap/viz/modules/manifests/Axis','sap/viz/modules/manifests/xy/StackedVerticalBar',
'sap/viz/manifests/BaseMultipleChart','sap/viz/manifests/BaseMultipleXYChart',
'sap/viz/manifests/MultiDualStackedVerticalBarChart'],
function Setup(Manifest) {
  var multiVBarChart = {
    id : 'viz/multi_100_dual_stacked_column',
    name : 'IDS_MULTIDUALPERCENTAGESTACKEDVERTICALBARCHART',
    base : 'viz/multi_dual_stacked_column',
    modules : {
      root : {
        modules : {
          main : {
            modules: {
              plot : {
                modules : {
                  yAxis : {
                    id : 'sap.viz.modules.axis',
                    configure : {
                      properties : {
                        isPercentMode : true
                      },
                      propertiesOverride : {
                        scale : { 
                          fixedRange : {isExported : false},
                          minValue : {isExported : false},
                          maxValue : {isExported : false},
                          isExported : false 
                        }
                      }
                    }
                  },
                  yAxis2 : {
                    id : 'sap.viz.modules.axis',
                    configure : {
                      properties : {
                        isPercentMode : true
                      },
                      propertiesOverride : {
                        scale : { 
                          fixedRange : {isExported : false},
                          minValue : {isExported : false},
                          maxValue : {isExported : false},
                          isExported : false 
                        }
                      }
                    }
                  },
                  plot : {
                    id : 'sap.viz.modules.stackedverticalbar',
                    configure : {
                      properties : {
                        'mode' : 'percentage'
                      }
                    }
                  },
                  
                  dataLabel : {
                      id : 'sap.viz.modules.datalabel',
                      configure : {
                        propertyCategory : 'dataLabel',
                        properties : {
                          isPercentMode : true,
                          type : 'value',
                          showZero : true
                        }
                      }
                    }
                }
              }
            }
          },
          tooltip : {
              id : 'sap.viz.modules.tooltip',
              configure : {
                propertyCategory : 'tooltip',
                properties : {
            formatString: [["0.00%"],["0.00%"]]
                }
              }
          }
        }
      }
    }
  };

  Manifest.register(multiVBarChart);
});
define('sap/viz/manifests/MultiAreaChart',['sap/viz/manifests/Viz','sap/viz/manifests/BaseChart','sap/viz/modules/manifests/RootContainer',
'sap/viz/modules/manifests/XYContainer','sap/viz/modules/manifests/TableContainer',
'sap/viz/modules/manifests/Axis','sap/viz/modules/manifests/xy/Area','sap/viz/manifests/BaseMultipleChart',
'sap/viz/manifests/BaseMultipleXYChart','sap/viz/modules/manifests/controller/Interaction'],
function Setup(Manifest) {
  var multiAreaChart = {
    id : 'viz/multi_area',
    name : 'IDS_MULTIAREACHART',
    base : 'riv/base/multiple/xy',
    modules : {
      root : {
        modules : {
          legends : {
            modules : {
              legend : {
                data : { aa : [ 3 ] }
              }
            }
          },
          
          tooltip : {
            configure : {
              properties : { chartType : 'line', orientation : 'left' }
            }
          },
        
          interaction : {
            id : 'sap.viz.modules.controller.interaction',
            configure : { clientID : 'main', propertyCategory : 'interaction' }
          },
          
          main : {
            configure : {
              properties : { 'mergeDataRange' : ['primary'] }
            },
            
            modules: {
              plot : {
                id : 'sap.viz.modules.xycontainer',
                modules : {
                  xAxis : {
                    id : 'sap.viz.modules.axis',
                    data : { aa : [ 1 ] },
                    configure : {
                      description : 'Settings for the category axis of an XY chart.',
                      propertyCategory : 'xAxis',
                      properties : {
                        title : { visible : false },
                        gridline : { visible : false },
                        type : 'category',
                        position : 'bottom'
                      },
                      propertiesOverride : {
                        title : { isExported : false },
                        gridline : { isExported : false },
                        label : { isExported : false },
                        axisline : { isExported : false },
                        scale : { 
                          fixedRange : {isExported : false},
                          minValue : {isExported : false},
                          maxValue : {isExported : false},
                          isExported : false 
                        }
                      }
                    }
                  },
                  yAxis : {
                    id : 'sap.viz.modules.axis',
                    configure : {
                      description : 'Settings for the value axis of an XY chart.',
                      propertyCategory : 'yAxis',
                      properties : {
                        type : 'value',
                        position : 'left'
                      },
                      propertiesOverride : {
                        title : { isExported : false }
                      }
                    }
                  },
                  dataLabel : {
                    id : 'sap.viz.modules.datalabel',
                    configure : {
                      propertyCategory : 'dataLabel',
                      properties : {
                        position : 'outside',
                        orientation : 'vertical',
                        automaticInOutside : false,
                        outsidePosition : 'down'
                      },
                      propertiesOverride:{
                        position : { isExported : false }
                      }
                    }
                  },
                  plot : {
                    id : 'sap.viz.modules.area',
                    configure : {
                      description : 'Settings regarding the chart area and plot area as well as general chart options.',
                      propertyCategory : 'plotArea'
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    
    feeds:{
      multiplier : { max:1 },
      secondaryValues: null,
      axisLabels : { max:1 }
    },
    
    dependencies : {
      attributes : [
        {
          targetModule : 'root.main.plot.plot',
          target : 'primaryDataRange',
          sourceModule : 'root.main.plot.yAxis',
          source : 'range'
        },
        {
          targetModule : 'root.main.xAxis2',
          target : 'scale',
          sourceModule : 'root.main',
          source : 'xCategoryScale'
        }, 
        {
          targetModule : 'root.main.yAxis',
          target : 'scale',
          sourceModule : 'root.main',
          source : 'yCategoryScale'
        },
        {
          targetModule : 'root.main',
          target : 'primaryDataRange',
          sourceModule : 'root.main.plot.plot',
          source : 'primaryDataRange'
        },
        {
          targetModule : 'root.main.plot.plot',
          target : 'primaryDataRange',
          sourceModule : 'root.main',
          source : 'primaryDataRange'
        },
        {
          targetModule : 'root.main.plot.xAxis',
          target : 'scale',
          sourceModule : 'root.main.plot.plot',
          source : 'categoryScale'
        }, {
          targetModule : 'root.main.plot.yAxis',
          target : 'scale',
          sourceModule : 'root.main.plot.plot',
          source : 'primaryScale'
        }, {
          targetModule : 'root.main.plot.yAxis',
          target : 'title',
          sourceModule : 'root.main.plot.plot',
          source : 'primaryAxisTitle'
        },
        {
          targetModule : 'root.legends.legend',
          target : 'colorPalette',
          sourceModule : 'root.main.plot.plot',
          source : 'getColorPalette'
        },
        {
          targetModule : 'root.legends.legend',
          target : 'shapes',
          sourceModule : 'root.main.plot.plot',
          source : 'shapePalette'
        }, {
          targetModule : 'root.legends.legend',
          target : 'setSelectionMode',
          sourceModule : 'root.interaction',
          source : 'getSelectionMode'
        }
      ],
      events : [
        {
          targetModule : 'root.interaction',
          listener : 'registerEvent',
          sourceModule : 'root.main',
          type : 'initialized.interaction'
        }, 
        {
          targetModule : 'root.tooltip',
          listener : 'showTooltip',
          sourceModule : 'root.main',
          type : 'showTooltip'
        }, 
        {
          targetModule : 'root.tooltip',
          listener : 'hideTooltip',
          sourceModule : 'root.main',
          type : 'hideTooltip'
        }, 
        {
          targetModule : 'root.interaction',
          listener : 'highlightedByLegend',
          sourceModule : 'root.legends.legend',
          type : 'highlightedByLegend'
        },
        {
          targetModule : 'root.legends.legend',
          listener : 'deselectLegend',
          sourceModule : 'root.interaction',
          type : 'deselectLegend'
        },
        {
          targetModule : 'root.main.plot.dataLabel',
          listener : 'showLabel',
          sourceModule : 'root.main.plot.plot',
          type : 'initialized.datalabel'
        }, 
        {
          targetModule : 'root.main.plot.dataLabel',
          listener : 'removeLabel',
          sourceModule : 'root.main.plot.plot',
          type : 'startToInit.datalabel'
        }
      ]
    }
  };

  Manifest.register(multiAreaChart);
});
define('sap/viz/manifests/MultiPercentageAreaChart',['sap/viz/manifests/Viz','sap/viz/manifests/BaseChart','sap/viz/modules/manifests/RootContainer',
'sap/viz/modules/manifests/XYContainer','sap/viz/modules/manifests/TableContainer',
'sap/viz/modules/manifests/Axis','sap/viz/modules/manifests/xy/Area','sap/viz/manifests/BaseMultipleChart',
'sap/viz/manifests/BaseMultipleXYChart','sap/viz/modules/manifests/controller/Interaction',
'sap/viz/manifests/MultiAreaChart'],
function Setup(Manifest) {
  var multiBarChart = {
    id : 'viz/multi_100_area',
    name : 'IDS_MULTIPERCENTAGEAREACHART',
    base : 'viz/multi_area',
    modules : {
      root : {
        modules : {
          tooltip : {
            configure : {
              properties : {
                chartType : 'line',
                orientation : 'left',
                formatString: [["0.00%"],["0.00%"]]
              }
            }
          },
          main : {
            modules: {
              plot : {
                id : 'sap.viz.modules.xycontainer',
                modules : {
                  yAxis : {
                    id : 'sap.viz.modules.axis',
                    configure : {
                      properties : {
                        isPercentMode : true
                      },
                      propertiesOverride : {
                        scale : { 
                          fixedRange : {isExported : false},
                          minValue : {isExported : false},
                          maxValue : {isExported : false},
                          isExported : false 
                        }
                      }
                    }
                  },
                  
                  plot : {
                    id : 'sap.viz.modules.area',
                    configure : {
                      'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                      propertyCategory : 'plotArea',
                      properties: {
                      mode : "percentage"
                     }
                    }
                  },
                  dataLabel : {
                    id : 'sap.viz.modules.datalabel',
                    configure : {
                      propertyCategory : 'dataLabel',
                      properties : {
                        isPercentMode: true
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  };

  Manifest.register(multiBarChart);
});
define('sap/viz/manifests/MultiHorizontalAreaChart',['sap/viz/manifests/Viz','sap/viz/manifests/BaseChart','sap/viz/modules/manifests/XYContainer',
'sap/viz/modules/manifests/TableContainer','sap/viz/modules/manifests/Axis',
'sap/viz/modules/manifests/xy/Area','sap/viz/manifests/BaseMultipleChart','sap/viz/manifests/MultiAreaChart'],
function Setup(Manifest) {
  var multiAreaChart = {
    id : 'viz/multi_horizontal_area',
    name : 'IDS_MULTIHORIZONTALAREACHART',
    base : 'viz/multi_area',
    modules : {
      root : {
        modules : {
          tooltip : {
            configure : {
              properties : {
                chartType : 'horizontalline',
                orientation : 'left'
              }
            }
          },  
          main : {
            modules: {
              plot : {
                id : 'sap.viz.modules.xycontainer',
                modules : {
                  background : {
                    configure : {
                      properties : {
                        direction : 'horizontal'
                      }
                    }
                  },
                  xAxis : {
                    id : 'sap.viz.modules.axis',
                    data : null,
                    configure : {
                      'description':'Settings for the value axis of an XY chart.',
                      propertyCategory : 'xAxis',
                      properties : {
                        gridline : {
                          visible : true
                        },
                        type : 'value',
                        position : 'bottom'
                      },
                      propertiesOverride : {
                        title : { isExported : false },
                        gridline : { isExported : true },
                        label : { isExported : true },
                        axisline : { isExported : true },
                        scale : { 
                          fixedRange : {isExported : true},
                          minValue : {isExported : true},
                          maxValue : {isExported : true},
                          isExported : true 
                        }
                      }
                    }
                  },
    
                  yAxis : {
                    id : 'sap.viz.modules.axis',
                    data : { aa : [ 1 ] }, 
                    configure : {
                      'description':'Settings for the catetory axis of an XY chart.',
                      propertyCategory : 'yAxis',
                      properties : {
                        gridline : { visible : false },
                        type : 'category',
                        position : 'left'
                      },
                      propertiesOverride : {
                        title : { isExported : false },
                        gridline : { isExported : false },
                        label : { isExported : false },
                        axisline : { isExported : false },
                        scale : { 
                          fixedRange : {isExported : false},
                          minValue : {isExported : false},
                          maxValue : {isExported : false},
                          isExported : false 
                        }
                      }
                    }
                  },
                  dataLabel : {
                    id : 'sap.viz.modules.datalabel',
                    configure : {
                      propertyCategory : 'dataLabel',
                      properties : {
                        position : 'outside',
                        orientation : 'horizontal',
                        automaticInOutside : false,
                        outsidePosition : 'left'
                      },
                      propertiesOverride:{
                        position : { isExported : false }
                      }
                    }
                  },             
                  plot : {
                    id : 'sap.viz.modules.area',
                    configure : {
                    'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                      propertyCategory : 'plotArea',
                       properties : {
                       orientation: 'horizontal'
                      }
                    }
                  }
                }
                
              }
            }
            }
        }
      }
    },
   
    dependencies : {
      attributes : [
      {
        targetModule : 'root.main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'root.main.plot.xAxis',
        source : 'range'
      },
      {
        targetModule : 'root.main.xAxis2',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'xCategoryScale'
      }, 
      {
        targetModule : 'root.main.yAxis',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'yCategoryScale'
      },
      {
        targetModule : 'root.main',
        target : 'primaryDataRange',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'root.main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'root.main',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'root.main.plot.yAxis',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'categoryScale'
      }, {
        targetModule : 'root.main.plot.xAxis',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryScale'
      }, {
        targetModule : 'root.main.plot.xAxis',
        target : 'title',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryAxisTitle'
      },
      {
        targetModule : 'root.legends.legend',
        target : 'colorPalette',
        sourceModule : 'root.main.plot.plot',
        source : 'getColorPalette'
      },
      {
        targetModule : 'root.legends.legend',
        target : 'shapes',
        sourceModule : 'root.main.plot.plot',
        source : 'shapePalette'
      }, {
        targetModule : 'root.legends.legend',
        target : 'setSelectionMode',
        sourceModule : 'root.interaction',
        source : 'getSelectionMode'
      }
      ],
      events : [  {
          targetModule : 'root.interaction',
          listener : 'registerEvent',
          sourceModule : 'root.main',
          type : 'initialized.interaction'
        }, {
            targetModule : 'root.tooltip',
            listener : 'showTooltip',
            sourceModule : 'root.main',
            type : 'showTooltip'
        }, {
            targetModule : 'root.tooltip',
            listener : 'hideTooltip',
            sourceModule : 'root.main',
            type : 'hideTooltip'
        } , {
          targetModule : 'root.interaction',
        listener : 'highlightedByLegend',
        sourceModule : 'root.legends.legend',
        type : 'highlightedByLegend'
      }, {
          targetModule : 'root.legends.legend',
        listener : 'deselectLegend',
        sourceModule : 'root.interaction',
        type : 'deselectLegend'
        }]
    }
  };

  Manifest.register(multiAreaChart);
});
define('sap/viz/manifests/MultiPercentageHorizontalAreaChart',['sap/viz/manifests/Viz','sap/viz/manifests/BaseChart','sap/viz/modules/manifests/RootContainer',
'sap/viz/modules/manifests/XYContainer','sap/viz/modules/manifests/TableContainer',
'sap/viz/modules/manifests/Axis','sap/viz/modules/manifests/xy/Area','sap/viz/manifests/BaseMultipleChart',
'sap/viz/manifests/MultiHorizontalAreaChart'],
function Setup(Manifest) {
  var multiAreaChart = {
    id : 'viz/multi_100_horizontal_area',
    name : 'IDS_MULTIPERCENTAGEHORIZONTALAREACHART',
    base : 'viz/multi_horizontal_area',
    modules : {
      root : {
        modules : {
          tooltip : {
            configure : {
              properties : {
                chartType : 'horizontalline',
                orientation : 'left',
                formatString: [["0.00%"],["0.00%"]]
              }
            }
          },  
          main : {
            modules: {
              plot : {
                id : 'sap.viz.modules.xycontainer',
                modules : {
                   xAxis : {
                     id : 'sap.viz.modules.axis',
                     configure : {
                       properties : {
                           isPercentMode : true
                       },
                        propertiesOverride : {
                          scale : { 
                            fixedRange : {isExported : false},
                            minValue : {isExported : false},
                            maxValue : {isExported : false},
                            isExported : false 
                          }
                        }
                     }
                  },
                  dataLabel : {
                    id : 'sap.viz.modules.datalabel',
                    configure : {
                      propertyCategory : 'dataLabel',
                      properties : {
                        isPercentMode: true
                      }
                    }
                  },
    
                  plot : {
                    id : 'sap.viz.modules.area',
                    configure : {
                      'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                      propertyCategory : 'plotArea',
                      properties : {
                        mode:'percentage'
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }   
  };

  Manifest.register(multiAreaChart);
});
define('sap/viz/modules/DivContainer',['sap/viz/base/utils/oo','sap/viz/modules/BaseContainer','sap/viz/util/EffectManager'],
function Setup ( oo, BaseContainer, EffectManager ) {
    
    var DivContainer = function ( manifest, context ) {
      DivContainer.superclass.constructor.apply(this, arguments);
      context.effectManager = new EffectManager();
    };
    
    oo.extend(DivContainer, BaseContainer);
    
    DivContainer.prototype.drawBackground = function( parent ) {
      //override parent function, do nothing for now
    };
    
    return DivContainer;
});
define('sap/viz/modules/manifests/DivContainer',['sap/viz/modules/manifests/Module','sap/viz/modules/Constants','sap/viz/modules/DivContainer', 'sap/viz/modules/manifests/BaseContainer'],
function Setup( Manifest, Constants, fn ) {
  
  var module = {
    id : "sap.viz.modules.divcontainer",
    base : "sap.viz.modules.basecontainer",
    renderto : Constants.RenderTo.DIV,
    name : "DivContainer",
    description : "Represents the modular unit of the div container.",
    fn : fn
  };
  
  Manifest.register(module);
  
});
define('sap/viz/modules/plotContainer',['jquery', 'sap/viz/base/utils/TypeUtils','sap/viz/base/utils/Objects','sap/viz/base/utils/FunctionUtils',
'sap/viz/modules/layout','sap/viz/modules/util/DimensionalInfoHandler','sap/viz/data/handler/MultiChartDataHandler',
'sap/viz/modules/manifests/Module','sap/viz/data/MultiAxesDataAdapter','sap/viz/data/handler/MeasureDataHandler',
'sap/viz/modules/dispatch','sap/viz/modules/util/BoundUtil','sap/viz/util/ignite',
'sap/viz/util/fn/createContext','sap/viz/modules/util/dataUtil'],
function Setup ($, TypeUtils, Objects, Functions, layout, DIHandler, MCHandler, 
  Manifest, MultiAxesDataAdapter, MeasureDataHandler, dispatch, boundUtil, ignite, createContext, dataUtil ) {
  
  var retfn =  function (manifest, ctx) {
      var width, 
        height,
        properties = {},
        data = null,
        config = {},
        modules = {},
        plotSelections = [],
        parentDIV = null, // div, d3 selection
        borderDIV = null,
        parent = null,   //svg, d3 selection
        eDispatch = new dispatch('initialized', 'showTooltip', 'hideTooltip');

      var left =0, top =0;
      var initCounter = { pending:0, finished:0 };      
      var cellSize ={ width : 200, height: 100};
      var cellPadding = { left:0, top: 0, right:0, bottom:0 };
      var rowCount = 1;
      var columnCount = 1;
    
    function drawBorders(){
        $(borderDIV.node()).select('div.v-cell-border').empty();       
        //column
        var borderWidth = cellSize.width * columnCount;
        var borderHeight = cellSize.height * rowCount;
        var color = '#dddddd';
        var i =1;
        for(i=1; i<rowCount; i++){
          borderDIV.append("div").attr('class','v-cell-border').attr('style','position: absolute; border-width: 1px 0px 0px 0px; border-color: '+color+' transparent; border-style: solid; height: 0px;  left: 0px; width:'+borderWidth+'px; top: '+i*cellSize.height+'px');
        }           
        //row
        for(i=1; i<columnCount; i++){
          borderDIV.append("div").attr('class','v-cell-border').attr('style','position: absolute; border-width: 0px 1px 0px 0px; border-color: transparent '+color+'; border-style: solid; width: 0px;  top: 0px; height:'+borderHeight+'px; left: '+i*cellSize.width+'px');
        }
    }
        
    function getData(row, column){
        var dataHandler = data.dataHandler;
        var context = data.contexts[row][column];
        return dataHandler.getSubDataAdapter(context);
    }
    
    function initialized(){
      initCounter.finished ++;
      if(initCounter.pending === initCounter.finished){
        initCounter.pending =0;
        initCounter.finished = 0;
        if(modules.interaction){
            //Make sure interaction can register events
            modules.interaction.module(container); 
        }
        
        eDispatch.initialized();
      }
    }
    
    function showTooltip(evt){
      eDispatch.showTooltip(evt);
    }
    
    function hideTooltip(evt){
      eDispatch.hideTooltip(evt);
    }
    
    function getIndex(row, column){
        return row * columnCount + column;
    }
    
    function initPlot(row, column){
        var plotConfig = config.modules.plot;
        var plotManifest = Manifest.get(plotConfig.id);
        var plotContext = createContext(plotManifest, ctx, "v-m-plot");
        var plotModule = ignite(plotManifest, plotContext);        
        var index = getIndex(row, column);
        modules.plot[index] =plotModule;
        modules['plot-'+row+'-'+column] =plotModule;
                
        modules.dataLabel[index] = initModule('dataLabel'); 
        modules.plot[index].dataLabel(modules.dataLabel[index]);
        modules.dataLabel[index].plot(modules.plot[index]);
        
        var dis =  plotModule.dispatch();
        if(dis.initialized) {
          dis.on('initialized.plotContainer', initialized);
          dis.on('initialized.datalabel', function(){ modules.dataLabel[index].showLabel(); });
        }
        if(dis.startToInit) {
            dis.on('startToInit.datalabel', function(){modules.dataLabel[index].removeLabel(); });
          }
        if(dis.showTooltip) {
          dis.on('showTooltip.plotContainer', showTooltip);
        }
        if(dis.hideTooltip) {
          dis.on('hideTooltip.plotContainer', hideTooltip);
        }
       
        var cellData = getData(row, column);
        plotModule.data(cellData);
    }
    
    function createPlot(row, column){
        var index = getIndex(row, column);
        var plotModule = modules.plot[index];
        
        var vis = parent.append('g');
        updatePlot(row, column, plotModule, vis);
        
        return vis;
    }
    
    function updatePlot(row, column, plotModule, vis){
        plotModule.width(cellSize.width - cellPadding.left - cellPadding.right);
        plotModule.height(cellSize.height - cellPadding.top - cellPadding.bottom);        
        plotModule.properties(properties.plotArea);
        
        var position = getPosition(row, column);
        vis.attr('class','v-m-plot-'+row+'-'+column).attr('transform','translate('+position.x+','+position.y+')');
        vis.datum(plotModule.data()).call(plotModule);  
    }
        
    /**
     * Get visible range.
     * @param {Number} left Left of visible window
     * @param {Number} top Top of visible window
     * @returns {Object} 
     */
    function getVisibleRange(left, top){
        var colStart = Math.floor(left/cellSize.width);
        var colEnd = Math.min(columnCount, Math.ceil( (left + width)/cellSize.width));
        var rowStart = Math.floor(top/cellSize.height);
        var rowEnd = Math.min(rowCount, Math.ceil((top+height)/cellSize.height));
        
        return {
            rowStart : rowStart,
            rowEnd : rowEnd,
            colStart : colStart,
            colEnd : colEnd
        };
    }
    
    function redrawVisiblePlots(left, top){
        var visibleRange = getVisibleRange(left, top);
        //hide invisible plot
        var index;
        for(var i=0; i<rowCount; i++){
            for(var j=0; j<columnCount; j++){
                index = getIndex( i, j);
                if(!plotSelections[index]){
                    continue;
                }
                if(i>= visibleRange.rowStart && i<visibleRange.rowEnd && j>=visibleRange.colStart && j<visibleRange.colEnd){
                    continue;
                }
                $(plotSelections[index].node()).detach();
            }
        }
        
        //create plots in visible range
        for(var row=visibleRange.rowStart; row<visibleRange.rowEnd; row ++){
            for(var column=visibleRange.colStart; column <visibleRange.colEnd; column++){
                initCounter.pending ++;
                index = getIndex( row, column);                
                var plotSelection = plotSelections[index];
                if(!plotSelection){
                    plotSelections[index] = createPlot(row, column);
                }else{                    
                    //check whether vis is detached from DOM tree.
                    var visNode = plotSelection.node();
                    if(!visNode.parentNode){
                        $(visNode).appendTo(parent.node());
                    }
                    var plotModule = modules.plot[index];
                    updatePlot(row, column, plotModule, plotSelection);
                }
                
            }
        }
        
        
    }
    
    /**
     * Get position for specified cell.
     */
    function getPosition(row, column){
        return {
            x : column * cellSize.width + cellPadding.left,
            y : row * cellSize.height + cellPadding.top
        };
    }
    
    function render(left, top){
        redrawVisiblePlots(left, top);
        drawBorders();
    }
    
    function getUsrProperties(moduleID){
        var moduleConfig = config.modules[moduleID];        
        var propsCat = moduleConfig.configure.propertyCategory;
        return properties[ propsCat ];       
    }
    
    function initModule(moduleID){
         var moduleConfig = config.modules[moduleID];
         var manifest = Manifest.get(moduleConfig.id);
         var context = createContext(manifest, ctx, "v-m-"+moduleID);
         var result = ignite(manifest, context);
         
         var props = {};         
         var usrProps = getUsrProperties(moduleID);
         var sysProps = moduleConfig.configure.properties || {};
         // User properties will override predefined properties 
         Objects.extend( true, props, sysProps, usrProps );
         result.properties(props);
         
         return result;
    }
    
    function initialize(){
        modules.plot = [];
        modules.dataLabel = [];
        var plotConfig = config.modules.plot;
        var plotManifest = Manifest.get(plotConfig.id);
        var plotContext = createContext(plotManifest, ctx, "v-m-plot");
        for(var row=0; row<rowCount; row++){
            for(var column=0; column<columnCount; column++){
                initPlot(row, column);
            }
        }
        
        //interaction        
        modules.interaction = initModule('interaction');
        //tooltip       
        modules.tooltip = initModule('tooltip');
        modules.tooltip = modules.tooltip(parentDIV.node());        
    }    
    
    function updateProperties(){
      if(!modules.plot){
        return;
      }
    
      var plotProps = getUsrProperties('plot');
      var dataLabelProps = getUsrProperties('dataLabel');      
      for(var i=0; i<modules.plot.length; i++){
        modules.plot[i].properties( Objects.extend(true, {}, plotProps));
        modules.dataLabel[i].properties( Objects.extend(true, {}, dataLabelProps));
      }
    
      var interactionProps =  Objects.extend(true, {}, getUsrProperties('interaction'));
      var tooltipProps =  Objects.extend(true, {}, getUsrProperties('tooltip'));
      modules.interaction.properties(interactionProps);
      modules.tooltip.properties(tooltipProps);
    }
    
    function updateData(){
      if(!modules.plot){
          return;
        }
    
      for(var row=0; row<rowCount; row++){
            for(var column=0; column<columnCount; column++){
              var index = row * columnCount + column;
              modules.plot[index].data( getData(row, column)); 
            }
        }
    }
    
    function container( selection ) {
      var totalWidth = cellSize.width * columnCount;
      var totalHeight = cellSize.height * rowCount;
      parent.attr('width',totalWidth).attr('height',totalHeight);
      selection.each(function ( data ) {
        if ( TypeUtils.isEmptyObject(modules) ){ 
          initialize();
        }
        modules.tooltip.zone({ 'width' : width, 'height' : height});
        render(left,top);
      });
            
      return container;
    }
    /**
     * Get/Set scroll left of plot container
     * @param {Number} value
     */
    container.scrollLeft = function(value){        
        if ( !arguments.length ) {
          return left;
        }
        
        if(value>=0){
            left = value;
            render(left,top);
        }
    };
    /**
     * Get/Set scroll top of plot container
     * @param {Number} value
     */
    container.scrollTop = function(value){        
        if ( !arguments.length ) {
          return top;
        }
        
        if(value>=0){
            top = value;
            render(left,top);
        }
    };
    /**
     * Get/Set row count of plot.
     * @param {Number} value
     */
    container.rowCount = function (_) {
      if ( !arguments.length ) {
        return rowCount;
      }
      rowCount = _;
      return container;
    };
    /**
     * Get/Set column count of plot.
     * @param {Number} value
     */
    container.columnCount = function (_) {
      if ( !arguments.length ) {
        return columnCount;
      }
      columnCount = _;
      return container;
    };
    
    container.width = function (_) {
      if ( !arguments.length ) {
        return width;
      }
      width = _;
     
      return container;
    };
    
    container.height = function (_) {
      if ( !arguments.length ) {
        return height;
      }
      height = _;
      return container;
    };
    
    container.size = function(_) {
      if ( !arguments.length ) {
        return {
          'width' : width,
          'height' : height
        };
      }
      height = _.height;
      width = _.width;
      return container;
    };
    /**
     * Get/set size for one plot.
     */
    container.cellSize = function (_) {
      if ( !arguments.length ) {
        return cellSize;
      }
      cellSize = _;
      for (var i = 0; i < modules.plot.length; i++) {
        modules.plot[i].width(cellSize.width - cellPadding.left - cellPadding.right);
        modules.plot[i].height(cellSize.height - cellPadding.top - cellPadding.bottom);
      }
      return container;
    };    
    
    container.data = function (_) {
      if ( !arguments.length ) {
        return data;
      }
      
      data = _;
      updateData();
      return container;
    };
    
    container.properties = function (_) {
      if ( !arguments.length ) {
        return properties;
      }
      
      Objects.extend(true, properties, _);
      updateProperties();
      return container;
    };
    
    container.config = function (_) {
      if ( !arguments.length ) {
        return config;
      }
      config = _;
      return container;
    }; 
    
    container.parentDiv = function (_) {
      if ( !arguments.length ) {
        return parentDIV;
      }
      parentDIV = _;      
      parent = parentDIV.append('svg');
      borderDIV = parentDIV.append('div');
      return container;
  };
  
    container.reset = function(){
      modules = {};
      plotSelections = [];
      $(parentDIV.node()).empty();
      parent = parentDIV.append('svg');
      borderDIV = parentDIV.append('div');
    };
    
    container.parent = function (_) {
      if ( !arguments.length ) {
        return parent;
      }
      parent = _;
      return container;
    };
    
    container.modules = function (_) {
      if ( !arguments.length ) {
        if ( TypeUtils.isEmptyObject(modules) ) {
          initialize();
        } 
        return modules;
      }
      modules = _;
      return container;
    };
    
    container.dispatch = function(_){
      if( !arguments.length){
        return eDispatch;
      }
      eDispatch = _;
      return container;
    };
    
    container.destroy = function(){
      //destroy ctx
      if(ctx){
        ctx.destroy();
        ctx = null;
      }
    };
    return container;
  };
  
  return retfn;
  
});
define('sap/viz/modules/manifests/PlotContainer',['sap/viz/modules/manifests/Module','sap/viz/modules/Constants','sap/viz/modules/plotContainer',
'sap/viz/data/feed/Constants'],
function Setup(Manifest, moduleConstants, fn, feedConstants) {
  var module = {
    'id' : 'sap.viz.modules.plotContainer',
    'type' : moduleConstants.Type.Container,
    'name' : 'plot container',
    'description': 'Settings for the subcharts layout of trilles charts.',
    //TODO support different layout: row/column/dimensional
    'properties' : {},
    'events' : {
        'showTooltip' : moduleConstants.Event.TooltipShow.desc,
        'hideTooltip' : moduleConstants.Event.TooltipHide.desc
     },
    //TODO
    'css' : null,
    'fn' : fn
  };
  Manifest.register(module);
});
define('sap/viz/modules/axis/baseCategoryHelper',['jquery', 'sap/viz/util/TextUtils','sap/viz/base/utils/TypeUtils','sap/viz/util/Objects','sap/viz/base/utils/Objects',
'sap/viz/lang/langManager','sap/viz/util/NumberUtils',
'sap/viz/modules/dispatch','sap/viz/format/FormatManager','sap/viz/modules/threeD/matrix',
'sap/viz/modules/util/BoundUtil', 'sap/viz/base/UADetector'],
function Setup(jQuery, TextUtils, TypeUtils,VizObjects, Objects, langManager, NumberUtils, dispatch, FormatManager, matrix, BoundUtil, UADetector) {

  var ret = function(manifest, ctx) {
        //we should build the axis Data Module, and then draw the axis.
        var m_coreModule = null;

        var m_AxisDM = null;
        var m_axisCore;

        var parent = null;
        var m_width = 0;
        var m_height = 0;

        var m_isDrawBody = true;

        var m_spaceLimit = -1;

        var m_axClassName = "viz-axis";
        var m_axBodyClassName = "viz-axis-body";
        var m_axTitleClassName = "viz-axis-title";

        var m_vClassNames = 
        {
            axis:"v-axis",
            axisBody:"v-body",
            axisTitle:"v-title",
            axisLabel:"v-label"
        };

        var m_titleOffset = 11;

        var m_data = { };
        var m_dataAxis = { };
        
        var m_isTitleVisible = true;
        
        var m_props = manifest.props(null);
        
        var m_drawable = true;

        var eDispatch = new dispatch('initialized');
        
        var m_defaultColor = m_props.color;

        var m_scale = null;

        var m_effectManager;
        if(ctx)
        {
           m_effectManager = ctx.effectManager;
        }
        
        var m_title = null;
        
        var m_style = {
            "realStyle": {},
            "defaultStyle": {}
        };
        
        var getThemeStyleDef = function () {
          if(ctx)  {
              m_style.realStyle.title = Objects.extend(true, {}, ctx.styleManager.query(m_vClassNames.axisTitle));
              m_style.realStyle.label = Objects.extend(true, {}, ctx.styleManager.query(m_vClassNames.axisLabel));

              m_style.defaultStyle.title = Objects.extend(true, {}, ctx.styleManager.queryDefault(m_vClassNames.axisTitle));
              m_style.defaultStyle.label = Objects.extend(true, {}, ctx.styleManager.queryDefault(m_vClassNames.axisLabel));

              m_style.realStyle.titleString = ctx.styleManager.query(m_vClassNames.axisTitle).toString();
              m_style.realStyle.labelString = ctx.styleManager.query(m_vClassNames.axisLabel).toString();

              m_style.defaultStyle.titleString = ctx.styleManager.queryDefault(m_vClassNames.axisTitle).toString();
              m_style.defaultStyle.labelString = ctx.styleManager.queryDefault(m_vClassNames.axisLabel).toString();

              if (m_props.title.applyAxislineColor){
                m_style.realStyle.title.fill = m_props.color;
                m_style.defaultStyle.title.fill = m_props.color;
              }
          }
        };

        var m_matrix = matrix(), labelAngle = null, labelAlign = null, angle = null, tickAngle = null;
        
        var drawAll = function()
        {
            if(!m_drawable)
            {
                //do not draw bacause of smart layout
                return false;
            }
            else
            {
                if(!drawBody() && !drawTitle())
                {
                    return false;
                }
            }

            return true;
        };

        var drawTitle = function() 
        {
            return m_props.title.visible && m_props.visible;
        };

        var drawBody = function() 
        {
            if(!m_isDrawBody)
            {
                return false;
            }

            var rangeArray = m_scale.range();
            var domainArray = m_scale.domain();
            var rangeBand = null;
            if(m_props.type === "category")
            {
                rangeBand = m_scale.rangeBand();
            }

            var hasData = false;
            if(!m_props.isIndependentMode)
            {
                if(m_dataAxis)
                {
                    hasData = true;
                }
            }
            else
            {
                if(m_data)
                {
                    hasData = true;
                }
            }

            return !(!m_props.visible ||
                   (rangeArray[0] === 0 && rangeArray[rangeArray.length-1] === 0 && rangeArray.length >=2 ) ||
                   (rangeArray.length === 1 && rangeArray[0] === 0 &&
                    domainArray.length === 1 && domainArray[0] === 0 && m_props.type === "value") ||
                   ((!rangeBand || !hasData) && rangeArray.length === 1 && rangeArray[0] === 0 &&
                     domainArray.length === 1 && domainArray[0] === 0 && m_props.type === "category")    
                );
        };
        

        var buildAxisTitle = function() {
            //build axis title Text
            var title = [];
            if (m_props.title.text !== undefined && m_props.title.text !== null) {
                title = m_props.title.text;
            } else {
                var dataset = [];
                if (m_props.isIndependentMode) {
                    if (m_data) {
                        for (var dataObj in m_data) {
                            if (m_data.hasOwnProperty(dataObj)) {
                                dataset = m_data[dataObj].values;
                                break;
                            }
                        }
                    }
                } else {
                    if (m_dataAxis) {
                        dataset = m_dataAxis.values;
                    }
                }

                for (var k = 0; k < dataset.length; k++) {
                    if (dataset[k].type) {
                        if (dataset[k].type === "MND")
                        {
                            title.push(langManager.get('IDS_DEFAULTMND'));
                        }
                    } else {
                        if (dataset[k].col.val) {
                            title.push(dataset[k].col.val);
                        } else {
                            title.push(langManager.get('IDS_ISNOVALUE'));
                        }

                    }
                }            
            }
            m_title = title;
            return title;
        }; 

        var axis = function (selection, isNewSVG) {
                if(isNewSVG)
                {
                    var newS = selection.append("svg");
                    newS.originalSelection = selection;

                    selection = newS;
                }

                var pre = axis.getPreferredSize();
                var basicWidth = (m_width < pre.width) ? m_width : pre.width;
                var basicHeight = (m_height < pre.height) ? m_height : pre.height;
                BoundUtil.drawBound(selection, basicWidth, basicHeight);
	              selection.attr('width', pre.width).attr('height', pre.height);
                parent = selection;
                //in axis, we cannot use data driven way like
                //        var e = selectDIV.selectAll("p")
                //.data(pdata,function(d){return d;});
             
                //e.enter().append("p")
                //.text(function(d){return d;});

                //e.exit().remove();
                //to control the redraw, because axis is not based on data, but based on scale

                //there should be only one axis Class
                var axisClass = selection.select("." + m_axClassName);

                var rangeArray = m_scale.range();
                var domainArray = m_scale.domain();
                if(!drawAll())
                {
                    //remove all the axis 
                    //to improve the performance, we should remove as less elements as possible.
                    axisClass.remove();
                }
                else
                {
                    //---we should dicide show or hide somethings because of the spaceLimit
                    var spacings = axis.getPreferredSize().spacings;

                    var titleSpace = spacings[0];
                    var bodySpace = 0;
                    for(var i = 1; i < spacings.length; i++)
                    {
                        bodySpace += spacings[i];
                    }

                    if(m_spaceLimit >= 0 && m_spaceLimit < (titleSpace + bodySpace))
                    {
                        m_isTitleVisible = false;
                    }

                    prepareProperties();

                    var core;
                    var coreScale;
                    var re = getCoreAndScale();
                    core = re.core;
                    coreScale = re.coreScale;
                    
                    var title = m_title;
                    
                    //the axis body
                    m_axisCore = core()
                                .setTitle(title)
                                .properties(m_props)
                                .style(m_style)
                                .position(m_props.position)
                                .axScale(coreScale)
                                .spaceLimit(m_spaceLimit)
                                .matrix(m_matrix)
                                .labelAngle(labelAngle)
                                .labelAlign(labelAlign)
                                .angle(angle)
                                .tickAngle(tickAngle);

                    var axisBody;
                    if(axisClass.empty())
                    {
                        axisClass = selection.append("g")
                                 .attr("class", m_axClassName + " "+ m_vClassNames.axis);

                        axisBody = axisClass.append("g")
                                  .attr("class", m_axBodyClassName + " " + m_vClassNames.axisBody);
                    }
                    else
                    {
                        //redraw axis body
                        var e=axisClass.select("." + m_axBodyClassName).remove();

                        axisBody = axisClass.append("g")
                                  .attr("class", m_axBodyClassName + " "+ m_vClassNames.axisBody);

                        axisBody = axisClass.select("." + m_axBodyClassName);
                    }

                    if(drawBody())
                    {
                        m_axisCore.call(this, selection);
                    }

                    //redraw axis title
                    var titleOffset = m_titleOffset;
                    axisClass.select("." + m_axTitleClassName).remove();

                    if(drawTitle())
                    {
                        if(m_props.title.visible && m_isTitleVisible)
                        {  
                            var pSize = m_axisCore.getPreferredSize();
                            var axTitle = axisClass.append("g")
                                  .attr("class", m_axTitleClassName + " " + m_vClassNames.axisTitle)
                                  .attr("text-anchor", "middle")
                                  .attr("fill", m_style.defaultStyle.title.fill)
                                  .attr("font-size", m_style.defaultStyle.title['font-size'])
                                  .attr("font-weight", m_style.defaultStyle.title['font-weight'])
                                  .attr("font-family", m_style.defaultStyle.title['font-family'])
                                  .append("text"); // text-align
                                  
                            if(m_props.position === "bottom")
                            {
                                if(!drawBody())
                                {
                                    pSize.height = 0;
                                }
                                  axTitle.attr("x", pSize.width/2)
                                         .attr("y", pSize.height + titleOffset)
                                         .attr("dominant-baseline", "hanging");//"auto")//"hanging")//"central");
                                    
                                  if(UADetector.isIE())
                                  {
                                      //dominant-baseline does not work
                                      var textHeight = m_style.realStyle.title['font-size'].toString();
                                      var indexPX = textHeight.indexOf("px");
                                      if(indexPX >= 0)
                                      {
                                          textHeight = textHeight.substr(0, indexPX);
                                      }
                                      axTitle.attr("y", Number(axTitle.attr("y")) + textHeight/2);
                                      axTitle.attr("dominant-baseline", "auto");
                                  }

                                TextUtils.ellipsis(title, axTitle.node(), pSize.width, m_style.realStyle.titleString);
                                
                               if(angle){
                                    var aAngle = angle * Math.PI /180;
                                    var cosAngle = Math.cos(aAngle);
                                    var sinAngle = (45 === angle) ? cosAngle : Math.sin(aAngle);
                                    var tAngle = tickAngle * Math.PI / 180;
                                    var cosTAngle = Math.cos(tAngle);
                                    var sinTAngle = Math.sin(tAngle);
                    
                                    var aaAngle = angle - 90;
                                    if( aaAngle > 90 ){
                                        aaAngle -= 180;
                                    }else if( aaAngle < -90 )(
                                        aaAngle += 180
                                    )
                                    
                                    var size = fastMeasure(title, m_style.realStyle.title)
                                    var x = ( pSize.width)/2 * sinAngle;
                                    var y = - ( pSize.width )/2 * cosAngle;
                                    
                                    x += (pSize.height + titleOffset) * cosTAngle;
                                    y += (pSize.height + titleOffset) * sinTAngle;
                                   
                                    var rotateStr ;
                                    rotateStr = 'rotate( ' + ( aaAngle) + ' ' + x + ' ' + y + ')';
                                    
                                    if(UADetector.isIE()){
                                      var textHeight = m_style.realStyle.title['font-size'].toString();
                                      var indexPX = textHeight.indexOf("px");
                                      if(indexPX >= 0)
                                      {
                                          textHeight = textHeight.substr(0, indexPX);
                                      }
                                      rotateStr += 'translate(0  '+ (textHeight) +')';
                                    }
                                    
                                    axTitle.attr('x', x).attr('y', y).attr('transform', rotateStr);
                                }
                            }
                            else if(m_props.position === "top")
                            {
                                if(!drawBody())
                                {
                                    pSize.height = 0;
                                }

                                titleHieght = fastMeasure(title, m_style.realStyle.title).height;
                                var transOffset = (title !== undefined && title !== null && title !== '' ? titleHieght + titleOffset : 0);

                                axisBody.attr("transform", "translate(0, " + transOffset + ")");

                                axTitle.attr("x", pSize.width/2)
                                  .attr("y", titleHieght)
                                  .attr("dx", "0") // padding-right
                                  .attr("dy", "0") // vertical-align: middle?
                                  .attr("dominant-baseline", "auto");//"auto")//"hanging")//"central")
                                
                                TextUtils.ellipsis(title, axTitle.node(), pSize.width, m_style.realStyle.titleString);
                            }
                            else if(m_props.position === "left")
                            {
                                if(!drawBody())
                                {
                                    pSize.width = 0;
                                }

                                //title is vertical
                                titleWidth = fastMeasure(title, m_style.realStyle.title).height;
                                var transOffset = (title !== undefined && title !== null && title !== '' ? titleWidth + titleOffset : 0);

                                axisBody.attr("transform", "translate(" + transOffset + ", " + 0 + ")");

                                var centerX = titleWidth;
                                var centerY = pSize.height/2;
                                var ac = "-90";

                                //axisClass.append("circle").attr("cx", centerX).attr("cy", centerY). attr("r", 5);
                                axTitle.attr("transform","rotate( " + ac + " " + centerX + " "  + centerY + " )")
                                  .attr("x", centerX)
                                  .attr("y", centerY)
                                  .attr("dominant-baseline", "auto");//"auto")//"hanging")//"central")
                                
                                TextUtils.ellipsis(title, axTitle.node(), pSize.height, m_style.realStyle.titleString);
                            }
                            else// if(m_props.position == "right")
                            {
                                if(!drawBody())
                                {
                                    pSize.width = 0;
                                }

                                //title is vertical
                                titleWidth = fastMeasure(title, m_style.realStyle.title).height;
                                
                                centerX = pSize.width + titleWidth/2 + titleOffset;
                                centerY = pSize.height/2;
                                var ac = "-90";

                                
                                axTitle.attr("transform","rotate( " + ac + " " + centerX + " "  + centerY + " )")
                                  .attr("x", centerX)
                                  .attr("y", centerY - titleWidth/2)
                                  .attr("dominant-baseline", "hanging")//"auto")//"hanging")//"central")

                                if(UADetector.isIE() )
                                {
                                    //dominant-baseline does not work
                                    var textHeight = m_style.realStyle.title['font-size'].toString();
                                    var indexPX = textHeight.indexOf("px");
                                    if(indexPX >= 0)
                                    {
                                        textHeight = textHeight.substr(0, indexPX);
                                    }

                                    centerY = Number(pSize.height/2) + textHeight/2;
                                    axTitle.attr("y", centerY);
                                    axTitle.attr("dominant-baseline", "auto");
                                }

                                TextUtils.ellipsis(title, axTitle.node(), pSize.height, m_style.realStyle.titleString);
                            }
                        }
                    }
                    m_isTitleVisible = true;
                }
                
            eDispatch.initialized();
            
            return axis;
        };
        
        axis.style = function(_){
          if(!arguments.length){
            return m_style;
          }
          m_style = _;
          return axis;
        };

        axis.matrix = function(_){
          if(!arguments.length){
            return m_matrix;
          }
          m_matrix = _;
          return axis;
        };

        axis.setCoreModule = function(_){
          m_coreModule = _;
          return axis;
        };
        
        axis.labelAngle = function(_){
          if(!arguments.length){
            return labelAngle;
          }
          labelAngle = pmod( _, 360);
          return axis;
        };
        
        axis.tickAngle = function(_){
          if(!arguments.length){
            return tickAngle;
          }
          tickAngle =pmod( _, 360);
          return axis;
        };
        
        axis.angle = function(_){
          if(!arguments.length){
            return angle;
          }
          angle = pmod( _, 360);
          return axis;
        };
        
        function pmod(a,m)
        {
          var ret = a % m;
          if (0 > ret)
            ret += m;
          return ret;
        }
        
        axis.labelAlign = function(_){
          if(!arguments.length){
            return labelAlign;
          }
          labelAlign = _;
          return axis;
        };
        
        axis.parent = function (_) {
          if ( !arguments.length ) return parent;
          parent = _;
          return axis;
        };

        axis.width = function(_width) {
            if (arguments.length == 0) {
                return m_width;
            }
            else {
                m_width = _width;

                if(m_props.position == "bottom" || m_props.position == "top")
                {
                    if(m_height)
                    {
                        m_spaceLimit = m_height;

                    }
                }
                else if(m_props.position == "left" || m_props.position == "right")
                {
                    if(m_width)
                    {
                        m_spaceLimit = m_width;
                    }
                }

                return axis;
            }
        };

        axis.height = function(_height) {
            if (arguments.length == 0)
                return m_height;
            
            m_height = _height;
            if(m_props.position == "bottom" || m_props.position == "top")
            {
                if(m_height)
                {
                    m_spaceLimit = m_height;

                }
            }
            else if(m_props.position == "left" || m_props.position == "right")
            {
                if(m_width)
                {
                    m_spaceLimit = m_width;
                }
            }

            
            return axis;
        };

        axis.gridlineLength = function(_gridlineLength) {
            if (arguments.length == 0)
                return m_props.gridline.length;
            m_props.gridline.length = _gridlineLength;
            return axis;
        };

        axis.startPadding = function() {
            var padding = 0;
            if(m_props.type == "value")
            {
                /*
                padding = valueAxisCore()
                         .properties(m_props)
                         .style(m_style)
                         .position(m_props.position)
                         .axScale(m_scale)
                         .startPadding();*/
            }
            return padding;
        };

        axis.endPadding = function() {
            var padding = 0;
            if(m_props.type == "value")
            {
                /*
                padding = valueAxisCore()
                         .properties(m_props)
                         .style(m_style)
                         .position(m_props.position)
                         .axScale(m_scale)
                         .endPadding();*/
            }
            return padding;
        };

        axis.mouseover = function(target){
            if(m_props.enableLabelSelection && m_props.type !== "value")
            {
                m_axisCore.mouseover(target);
            }
        };

        axis.mouseout = function(target){
            if(m_props.enableLabelSelection && m_props.type !== "value")
            {
                m_axisCore.mouseout(target);
            }
        };
        
        axis.cleanLabelAreas = function()
        {
            if(m_props.enableLabelSelection && m_props.type !== "value"
               && m_axisCore
               && m_axisCore.cleanLabelAreas)
            {
                m_axisCore.cleanLabelAreas();
            }
        };

        axis.mouseup = function(target){
            if(m_props.enableLabelSelection && m_props.type !== "value")
            {
                m_axisCore.mouseup(target);
            }
        };
        
        axis.mousedown = function(target){
            if(m_props.enableLabelSelection && m_props.type !== "value")
            {
                m_axisCore.mousedown(target);
            }
        };
                        
        axis.size = function(_size) {
            if (arguments.length == 0)
                return {
                           "width" : m_width,
                           "height": m_height,
                       };
            m_width = _size.width;
            m_height = _size.height;
            return axis;
        };
        
        /*
         * Jimmy/9/22/2012 if axis works under independentMode(boxplot for now)
         * it doesn't rely on the data passed through this API from container, instead, boxplot
         * will pass calculated data through dependency 
         */
        axis.independentData = function(_data) {
          if(m_props.isIndependentMode) {
            if (arguments.length == 0)
                return m_data;
            m_data = _data;
          }
        },

        axis.data = function(_data) {
            if (arguments.length == 0)
                return m_data;
            
            if(!m_props.isIndependentMode)
            {
              m_data = _data;
              if(_data.getAnalysisAxisDataByIdx)
              {
                m_dataAxis = m_data.getAnalysisAxisDataByIdx(0);
              }
            }
            return axis;
        };

        axis.title = function(_title) {
            if (arguments.length == 0)
                return m_title;
            m_title = _title;
            return axis;
        };

        axis.properties = function(_properties) {
            if (arguments.length == 0){
                return m_props;
            }
            var scaleRangeMinNaN = false,
                scaleRangeMaxNaN = false;
            if (_properties.scale && _properties.scale.fixedRange) {
                scaleRangeMinNaN = isNaN(Number(_properties.scale.minValue));
                scaleRangeMaxNaN = isNaN(Number(_properties.scale.maxValue));
            }

            Objects.extend(true, m_props, _properties);

            if (scaleRangeMinNaN) {
                m_props.scale.minValue = NaN;
            }
            if (scaleRangeMaxNaN) {
                m_props.scale.maxValue = NaN;
            }

            if(_properties.color)
            {
                m_props.customizedColor = _properties.color;
            }

            if (_properties.label && _properties.label.formatString && TypeUtils.isArray(_properties.label.formatString)) {
              if (TypeUtils.isArray(_properties.label.formatString[0])) {
                m_props.label.formatString = _properties.label.formatString[0][0];
              }
            }
            return axis;
        };

        axis.range = function() {
            var range = null,
                max = Number(m_props.scale.maxValue),
                min = Number(m_props.scale.minValue);
            if ((m_props.type === "value") && (m_props.scale.fixedRange)) {
                if (isNaN(max) || isNaN(min) || max>min) {
                    range = {
                        max : max,
                        min : min,
                        from : 'axis'
                    }; 
                }
            }
            return range;
        }

        axis.scale = function(_scale) {
            if (arguments.length == 0)
                return m_scale;

            m_scale = _scale;
            return axis;
        };

        axis.isDrawBody = function(_isDrawBody) {
            if (arguments.length == 0)
                return m_isDrawBody;

            m_isDrawBody = _isDrawBody;
            return axis;
        };

        axis.color = function(_color) {
          if (arguments.length == 0)
              return m_props.color;
          if (_color !== undefined){
            m_props.isAxisColorFixed = true;
          }
          if (m_props.customizedColor){
            _color = m_props.customizedColor;              
          }
          if(!_color){
              _color = m_defaultColor;
          }

          m_props = Objects.extend(true, m_props, {"color":_color});

          if (m_props.title.applyAxislineColor && _color) {
            m_style.realStyle.title.fill = _color;
            m_style.defaultStyle.title.fill = _color;
          }

          return axis;
        };

        axis.drawable = function(_drawable) {
            //drawable or not because of smart layout
            if (arguments.length == 0)
                return m_drawable;

            m_drawable = _drawable;

            return axis;
        };

        axis.getPreferredSize = function() {
            getThemeStyleDef();
            var rangeArray = [0];
            var domainArray = [0];
            if(m_scale)
            {
                rangeArray = m_scale.range();
                domainArray = m_scale.domain();
            }

            if(!m_scale || (!drawAll()) )            
            {
                return {
                    width : 0,
                    height : 0,
                    manual: false,
                };
            }
            else {
                //body size && title size
                var reCS = getCoreAndScale();
                
                var title = buildAxisTitle();
                var axisCore = (reCS.core)()
                              .setTitle(title)
                              .properties(m_props)
                              .style(m_style)
                              .position(m_props.position)
                              .axScale(reCS.coreScale)
                              .spaceLimit(m_spaceLimit);

                var resultSize;
                
                
                var titleHeight = 0;
                var titleWidth = 0;
                var titleOffset = 0;
                var axisSpacings = [];

                var sizeCore = axisCore.getPreferredSize();

                
                if(m_props.position == "bottom" || m_props.position == "top")
                {
                    if(!drawBody())
                    {
                        sizeCore.height = 0;
                        sizeCore.spacings = [];
                    }

                    if(m_props.title.visible && m_props.visible)
                    {
                        //title is vertical
                        if(title !== undefined && title !== null && title !== '') {
                            titleHeight = fastMeasure(title, m_style.realStyle.title).height;
                        } else {
                            titleHeight = 0;
                        }
                        titleOffset = titleHeight == 0 ? 0 : m_titleOffset;
                    }

                    var titleSpace = titleHeight + titleOffset;
                    axisSpacings = axisSpacings.concat([titleSpace]);
                    axisSpacings = axisSpacings.concat(sizeCore.spacings);

                    var bodySpace = 0;
                    for(var i = 1; i < axisSpacings.length; i++)
                    {
                        bodySpace += axisSpacings[i];
                    }

                    var fullHeight = titleSpace + bodySpace;
                    var realHeight = fullHeight;
                    
                    if(m_spaceLimit >= 0 && m_spaceLimit < fullHeight)
                    {
                        realHeight = sizeCore.height;//no title
                    }

                    resultSize = {
                        maxSizeConstant : 1 / 3,
                        width: sizeCore.width,
                        height: fullHeight,
                        realHeight: realHeight,
                        spacings: axisSpacings,
                        manual: false,
                        minTruncateSize : sizeCore.minTruncateSize
                    }
                }
                else if(m_props.position == "left" || m_props.position == "right")
                {
                    if(!drawBody())
                    {
                        sizeCore.width = 0;
                        sizeCore.spacings = [];
                    }

                    if(m_props.title.visible && m_props.visible)
                    {
                        //title is vertical
                        if(title !== undefined && title !== null && title !== '') {
                            titleWidth = fastMeasure(title, m_style.realStyle.title).height;
                        } else {
                            titleWidth = 0;
                        }
                        titleOffset = titleWidth == 0 ? 0 : m_titleOffset;
                    }

                    var titleSpace = titleWidth + titleOffset;
                    axisSpacings = axisSpacings.concat([titleSpace]);
                    axisSpacings = axisSpacings.concat(sizeCore.spacings);

                    var bodySpace = 0;
                    for(var i = 1; i < axisSpacings.length; i++)
                    {
                        bodySpace += axisSpacings[i];
                    }

                    var fullWidth = bodySpace + titleSpace;
                    var realWidth = fullWidth;
                    
                    if(m_spaceLimit >= 0 && m_spaceLimit < fullWidth)
                    {
                        realWidth = sizeCore.width;//no title
                    }
                    

                    resultSize = {
                        maxSizeConstant : 1 / 3,
                        width: fullWidth,
                        realWidth: realWidth,
                        height: sizeCore.height,
                        spacings: axisSpacings,
                        manual: false,
                        minTruncateSize : sizeCore.minTruncateSize
                    }
                }
                if ((m_props.type == 'category') && (m_props.layoutInfo.width > 0) && (m_props.layoutInfo.height > 0) ) {
                    resultSize.width = m_props.layoutInfo.width;
                    resultSize.realWidth = m_props.layoutInfo.width;
                    resultSize.height = m_props.layoutInfo.height;
                    resultSize.realHeight = m_props.layoutInfo.height;
                    resultSize.manual = true;
                }
                
                VizObjects.normalizeNumbersCeil(resultSize);
                return resultSize;
            }
        };

        axis.dispatch = function(_){
          if(!arguments.length)
            return eDispatch;
          eDispatch = _;return axis;
        };
        
        axis.destroy = function() {
            //destroy ctx
            if(ctx){
              ctx.destroy();
              ctx = null;
            }
            //sub destroy
            if(m_axisCore && m_axisCore.destroy){
              m_axisCore.destroy();
            }
            m_vClassNames = null;
            m_matrix.destroy();
            m_matrix = null;
            //self destroy
            parent = null;
            m_axisCore = null;
            m_dataAxis = null;
            m_data = null;
            if(m_scale){
              m_scale.domain([0,1]).range([0,1]);
            }
            m_scale = null;
        };
        
        var fastMeasure = function(_text, _style)
        {
            return TextUtils.superFastMeasure(_text, _style['font-size'],
                                                _style['font-weight'],
                                                _style['font-family']);
        };

        //Alex Su: to build a hierarchical structure basing on raw data.
        function hasMND(data){
          if (data[0].type === 'MND' || data[data.length - 1].type === 'MND'){
            return true;
          } else {
            return false;
          }
        }
        
        function hasOnlyMND(data){
          if (data.length === 1 && data[0].type === 'MND'){
            return true;
          } else {
            return false;
          }
        }
        
        function isMNDBefore(data){
          if (data[0].type === 'MND'){
            return true;
          } else {
            return false;
          }
        }
        
        function getMNDData(data){
          if (! hasMND(data)){
            return;
          }
          if (isMNDBefore(data)){
            return data[0];
          } else {
            return data[data.length - 1];
          }
        }
        
        function processRawData(data){
          if (! hasMND(data) || hasOnlyMND(data)){
            return data;
          }
          var newData = [];
          var i, j, k;
          for (i = 0; i < data.length; ++i){
            newData.push({
              col: data[i].col,
              rows: []
            });
          }
          var mndData = getMNDData(data);
          var mndLength = mndData.rows.length;
          var cateLength;
          if (isMNDBefore(data)){
            cateLength = data[1].rows.length;
            for (i = 0; i < mndLength; ++i){
              for (j = 0; j < cateLength; ++j){
                newData[0].rows.push(data[0].rows[i]);
              }
            }
            for (i = 1; i < data.length; ++i){
              for (j = 0; j < mndLength; ++j){
                //deep copy objects
                for(k = 0; k < data[i].rows.length; k++){
                  var itemDeepCopy = Objects.extend(true, {}, data[i].rows[k]);
                  newData[i].rows.push(itemDeepCopy);
                }
              }
            }
            //add the parent ctx to newData items
            for (i = 1; i < newData.length; ++i){
              for (j = 0; j < newData[i].rows.length; ++j){
                var parentCtx = newData[0].rows[j].ctx;
                var selfCtx = newData[i].rows[j].ctx;

                //merge ctx
                selfCtx = Objects.extend(true, selfCtx, parentCtx);
                newData[i].rows[j].ctx = selfCtx;
              }
            }
          } else {
            cateLength = data[0].rows.length;
            for (i = 0; i < cateLength; ++i){
                var iItem;
                var mNum = data[data.length - 1].rows.length;
                for(iItem = 0; iItem < mNum; iItem++)
                {
                    newData[newData.length - 1].rows.push(Objects.extend(true, {}, data[data.length - 1].rows[iItem]));

                    //add the parent ctx to rows items
                    if(data.length >= 2)
                    {
                        var parentCtx = data[data.length - 2].rows[i].ctx;
                        var selfCtx = Objects.extend(true, {}, data[data.length - 1].rows[iItem].ctx);

                        //merge ctx with data[data.length - 2].rows[i]
                        selfCtx = Objects.extend(true, selfCtx, parentCtx);
                        newData[newData.length - 1].rows[i*mNum + iItem].ctx = selfCtx;
                    }
                }
            }

            for (i = 0; i < data.length - 1; ++i){
              for (j = 0; j < cateLength; ++j){
                for (k = 0; k < mndLength; ++k){
                  newData[i].rows.push(data[i].rows[j]);
                }
              }
            }
          }
          return newData;
        }
        
        function buildHierarchicalData(data){
          var i,j;
          var categoryHierarchicalData = [];
          var rowData, cellData, spaceCount;
          var tempCellCount, tempSpaceCount;
          for (i = 0; i < data.length; ++i){
            rowData = [];
            spaceCount = 0;
            tempSpaceCount = 0;
            tempCellCount = 0;
            var tempLabelContexts = [];
            for (j = 0; j < data[i].rows.length; ++j){
              cellData = {};
              if (i === data.length - 1){
                cellData.value = data[i].rows[j];
                cellData.space = 1;
              } else {
                ++spaceCount;
                ++tempSpaceCount;
                if (i > 0 && tempSpaceCount >= categoryHierarchicalData[i - 1][tempCellCount].space){
                  cellData.value = data[i].rows[j];
                  cellData.space = spaceCount;
                  spaceCount = 0;
                  tempSpaceCount = 0;
                  ++tempCellCount;
                }
                else {
                  if (j + 1 < data[i].rows.length && data[i].rows[j].val === data[i].rows[j + 1].val){

                    if(data[i].rows[j].ctx)
                    {
                        tempLabelContexts.push(data[i].rows[j].ctx);
                    }

                    if(data[i].rows[j].contexts)
                    {
                        tempLabelContexts = tempLabelContexts.concat(data[i].rows[j].contexts);
                    }
                    continue;
                  }
                  else {
                    cellData.value = data[i].rows[j];
                    cellData.space = spaceCount;
                    spaceCount = 0;                  
                  }
                }                
              }

              if(data[i].rows[j].ctx)
              {
                tempLabelContexts.push(data[i].rows[j].ctx);
              }

              if(data[i].rows[j].contexts)
              {
                  tempLabelContexts = tempLabelContexts.concat(data[i].rows[j].contexts);
              }

              cellData.value.labelContexts = tempLabelContexts;
              rowData.push(cellData);
              tempLabelContexts = [];
            }
            categoryHierarchicalData.push(rowData);
          }
          return categoryHierarchicalData;
        }
                
        function processData(data){
          var newData = processRawData(data);
          var hierarchicalData = buildHierarchicalData(newData);
          return hierarchicalData;
        }
        
        function reverseHierarchicalData(hData){
          for (var i = 0; i < hData.length; ++i){
            hData[i].reverse();
          }
        }
        
        var getCoreAndScale = function()
        {
            var re = { };
            var core;
            var coreScale;
            if(m_props.type == "category") //a new scale is required
            {
                coreScale = [];
                //build labels (domain)
                var dataset = [];
                if(m_props.isIndependentMode) {
                    for(dataObj in m_data) {
                        dataset = m_data[dataObj].values;
                    }
                } else {
                    if(m_dataAxis) {
                        dataset = m_dataAxis.values;
                    }
                }
                var hierarchicalData = [];
                if (dataset && dataset.length){
                  hierarchicalData = processData(dataset);
                }
                //reverse domain or not,
                var oRange = m_scale.range();
                //by yuanhao 2012-12-17 ,
                if(oRange[0] > oRange[oRange.length -1 ])
                {
                    reverseHierarchicalData(hierarchicalData);
                }
                //if orRangeBand is 0, which means module do not use ordinal scale like normal, the scale is not equal every unit.
                var dataCount = hierarchicalData.length === 0 ? 0 : hierarchicalData[hierarchicalData.length - 1].length;
                var orRangeBand = m_scale.rangeBand(), orRangeBands = [];
                
                //Alex Su. Handling for boxplot.
                var isBoxPlotWithSingleAAFeed = false;
                if (dataset && dataset.length > 0 && dataset[0].rows.length === 0){
                  isBoxPlotWithSingleAAFeed = true;
                  dataCount = 1;
                  var cellData = {
                      value: {},
                      space: 1
                  };
                  
                  //add ctxs
                  var ctxs = [];
                  if(m_dataAxis.values)
                  {
                      var iItem;
                      for(iItem = 0; iItem < m_dataAxis.values[0].rows.length; iItem++)
                      {
                          ctxs.push(m_dataAxis.values[0].rows[iItem].ctx);
                      }
                  }

                  cellData.value = {
                      val: !m_dataAxis.values ? null : m_dataAxis.values[0].col.val,
                      labelContexts: ctxs
                  };
                  
                  hierarchicalData = [[cellData]];
                }
                
                var di;
                if(!m_scale.noEqual){
                  if (! hasOnlyMND(dataset) && ! isBoxPlotWithSingleAAFeed){
                    for(di = 0; di < dataCount; di++){
                        orRangeBands[di] = orRangeBand;
                    }
                  } else {
                    var tickSpace = parseInt(oRange.length / dataCount, 10);
                    for(di = 0; di < dataCount; di++){
                      orRangeBands[di] = orRangeBand * tickSpace;
                    }
                  }
                }else{
                  for(di = 0; di < dataCount; di++){
                      orRangeBands[di] = Math.abs(oRange[di] - oRange[di+1]);
                  }
                }
                
                function getRangeEnd(rangeStart, startIndex, spaceCount){
                    var sum = rangeStart;
                    for(var ix = 0; ix < spaceCount; ix++){
                        sum +=orRangeBands[startIndex + ix];
                    }
                    return sum;
                }
                var coreScaleItem = {};
                var cgDomain = [];
                var cgRange = [];
                var i, j, spaceCount = 0;
                var startIndex;
                var rangeStart, rangeEnd;
                for (i = 0; i < hierarchicalData.length; ++i){
                  cgDomain = [];
                  cgRange = [];
                  spaceCount = 0;
                  startIndex = 0;
                  for (j = 0; j < hierarchicalData[i].length; ++j){
                    spaceCount = 0;
                    cgDomain.push(hierarchicalData[i][j].value);
                    
                    spaceCount += hierarchicalData[i][j].space;
                    rangeStart = j > 0 ? cgRange[j - 1][1] : 0;
                    rangeEnd = getRangeEnd(rangeStart, startIndex, spaceCount);
                    startIndex += spaceCount;

                    cgRange.push([rangeStart, rangeEnd]);
                  }
                  var coreScaleItem = { 
                      "domain": cgDomain, 
                      "range":  cgRange,
                   };
       
                  coreScale.push(coreScaleItem);//add to the latest
                }
                
                core = m_coreModule;
            }
            else //value axis
            {   
                //core = valueAxisCore;
                coreScale = m_scale;
            }
            re.core = core;
            re.coreScale = coreScale;
            re.coreScale.noEqual = m_scale.noEqual;
            return re;
        }
        
        function prepareProperties()
        {
            if (!m_effectManager) return;

            if(m_props.customizedColor) {
                m_props.color = m_props.customizedColor;
            }
            var parameter = {
                    drawingEffect : 'normal',
                    fillColor : m_props.color,
            };
            m_props.color = m_effectManager.register(parameter);

            parameter = {
                drawingEffect : 'normal',
                fillColor : m_props.gridline.color,
            };
            m_props.gridline.color = m_effectManager.register(parameter);
            
            parameter = {
                    drawingEffect : 'normal',
                    fillColor : m_style.defaultStyle.label.fill,
            };
            m_style.defaultStyle.label.fill = m_effectManager.register(parameter);

            parameter = {
                    drawingEffect : 'normal',
                    fillColor : m_style.defaultStyle.title.fill,
            };
            m_style.defaultStyle.title.fill = m_effectManager.register(parameter);
        }

        return axis;
    };
  return ret;
});

define('sap/viz/modules/axis/baseCategoryCore',['jquery', 'sap/viz/modules/Constants', 'sap/viz/util/TextUtils', 'sap/viz/util/NumberUtils', 'sap/viz/base/utils/Objects', 'sap/viz/lang/langManager',
    'sap/viz/base/utils/TypeUtils', 'sap/viz/modules/threeD/Point', 'sap/viz/modules/threeD/matrix',
    'sap/viz/format/FormatManager', 'sap/viz/base/UADetector'],
  function Setup(jQuery, ModuleConstants, TextUtils, NumberUtils, Objects, langManager, TypeUtils, Point, matrix, FormatManager, UADetector) {

    var ret = function() {

      var m_title = [];

      var m_position;
      var m_axScale;
      var m_selection;

      var m_textOffset;
      var m_tickSize = 5;

      var m_styleLineSrokeWidth = 1;
      var m_styleGridLineColor = "#d8d8d8";
      var m_axLabelClassName = "viz-axis-label";

      var m_labelAreaMouseOverColor = "#cccccc";
      var m_labelAreaMouseDownColor = "#808080";

      var m_disableSpaceLimit = false;

      var m_style = null; //used to hold style passed from axis
      var m_props = {
        "title": {
          "visible": false,
          "text": undefined
        },
        "gridline": {
          "visible": false,
          "color": m_styleGridLineColor,
          "showFirstLine": false,
          "length": 0,
          "showLastLine": false,
          "type": "line"
        },
        "type": "value",
        "visible": true,
        "label": {
          "visible": true,
          "formatString": "",
          hideStrategy: ''
        },
        "position": "left",
        "color": "#333333",
        "forceLabelArea": false,
        "shapeRendering": true,
        "forceVerticalFont": false
      };

      var m_vClassNames = {
        axis: "v-axis",
        axisBody: "v-body",
        axisTitle: "v-title",
        axisLabel: "v-label",
        axisLine: "v-categoryaxisline",
        gridLine: "v-gridline",
        morphableLabel: ModuleConstants.CSS.CLASS.MORPHABLELABEL
      };

      var m_axisLabelClassCombined = m_vClassNames.axisLabel + ' ' + m_axLabelClassName + ' ' + m_vClassNames.morphableLabel;

      var m_matrix = matrix(),
        labelAngle = null,
        labelAlign = null,
        angle = null,
        tickAngle = null;

      var m_spaceLimit = -1;

      var adjustScale = function(spaceLimit) {
        //we have to adjust the scale because we may not draw all the levels.
        var scaleToDraw = [];
        var isMultilayer = m_axScale.length > 1 ? true : false;
        if (isMultilayer) {
          m_textOffset = 6;
        } else {
          m_textOffset = 11;
        }

        for (var iScale = 0; iScale < m_axScale.length; iScale++) {
          var axDomain = m_axScale[iScale].domain; //["a", "b"]
          var axRange = m_axScale[iScale].range; //[[0, 100], [100. 200], ...]

          //count the max text size
          var re = maxLabelTextHeight(axDomain, axRange, true);
          var isVertical = re.isVertical;

          if (m_position === "left" || m_position === "right") {
            m_axScale[iScale].labelsToDraw = buildLeftRightToDrawLabels(axDomain, axRange, isMultilayer, spaceLimit);
          } else {
            m_axScale[iScale].labelsToDraw = buildTopBottomToDrawLabels(axDomain, axRange, isVertical, isMultilayer, spaceLimit);
          }

          if (iScale === 0) {
            scaleToDraw.push(m_axScale[iScale]);
            if (spaceLimit >= 0) {
              break;
            }
          } else if (m_axScale[iScale].labelsToDraw.length === m_axScale[iScale].domain.length) {
            scaleToDraw.push(m_axScale[iScale]);
          }
          //for mekko chart ,the scale is not equal. So if a label can be draw, we should draw the whole layer.
          else if (m_axScale[iScale].labelsToDraw.length > 0 && TypeUtils.isExist(m_axScale.noEqual) && m_axScale.noEqual === true) {
            scaleToDraw.push(m_axScale[iScale]);
          }
        }
        return scaleToDraw;
      };

      var drawGridLine = function(selection, x1, y1, x2, y2) {
        var gridline = selection.append("line")
          .attr("class", m_vClassNames.gridLine)
          .attr("y1", y1)
          .attr("y2", y2)
          .attr("x1", x1)
          .attr("x2", x2)
          .attr("stroke", m_props.gridline.color)
          .attr("stroke-width", m_props.gridline.size)
          .attr("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
        if (m_props.gridline.type === "dotted") {
          gridline.attr("stroke-dasharray", "3, 2");
        }
      };

      function axis(selection) {
        m_selection = selection;
        //we have to adjust the scale
        var scaleToDraw = adjustScale();
        var isTruncated = false;

        var i;
        //---we should dicide show or hide somethings because of the spaceLimit
        if (m_spaceLimit >= 0) {
          var scaleToAdjust = [];
          var preferredSize = axis.getPreferredSize();
          var spacings = preferredSize.spacings;
          var minTruncateSize = preferredSize.minTruncateSize;
          var spaceLeft = m_spaceLimit;


          for (i = 0; i < spacings.length; i++) {
            if (spaceLeft >= spacings[i]) {
              scaleToAdjust.push(scaleToDraw[i]);
              spaceLeft -= spacings[i];
              spaceLeft = NumberUtils.precise(spaceLeft);
            } else {
              if (i === 0 && minTruncateSize > 0 && spaceLeft >= minTruncateSize) {
                isTruncated = true;
              }
              break;
            }
          }

          if (scaleToAdjust.length === 0 && scaleToDraw.length > 0 && !isTruncated) {
            //scaleToAdjust.push(scaleToDraw[0]);//always draw one
            var lastDomain = [];
            for (i = 0; i < scaleToDraw[0].domain.length; i++) {
              lastDomain.push('');
            }
            scaleToAdjust.push({
              domain: lastDomain,
              range: scaleToDraw[0].range
            });
          }

          scaleToDraw = scaleToAdjust;
          if (isTruncated) {
            scaleToDraw = adjustScale(m_spaceLimit);
          }
        }
        //------------------------------------------------------
        var isMultilayer = scaleToDraw.length > 1 ? true : false;
        var lastLevelWidth, lastLevelHeight;
        var iScale, axDomain, axRange;
        var re, maxTextWidth, lineOffset, isVertical, maxTextHeight;
        var x1, x2, y1, y2, dPath;
        var axLine, axTick1, axTick2;
        var labelsToDraw, customlabelCfg, m_label, labelG, axLabels, axTexts;
        if (m_position === "left") {
          lastLevelWidth = 0;

          for (iScale = 0; iScale < scaleToDraw.length; iScale++) {
            if (!m_props.label.visible && iScale !== (scaleToDraw.length - 1)) {
              continue;
            }

            axDomain = scaleToDraw[iScale].domain; //["a", "b"]
            axRange = scaleToDraw[iScale].range; //[[0, 100], [100. 200], ...]

            //count the max text size
            re = maxLabelTextWidth(axDomain, axRange);
            maxTextWidth = isTruncated ? maxLabelTextSize(scaleToDraw[iScale].labelsToDraw, false).maxWidth : re.maxLabelTextWidth;

            lineOffset = maxTextWidth + 2 * m_textOffset;
            if (!m_props.label.visible) {
              maxTextWidth = 0;
              lineOffset = 0;
            }

           lineOffset = isTruncated ? m_spaceLimit : lineOffset;

            if (iScale === (scaleToDraw.length - 1)) {
              if (m_props.gridline.showFirstLine) {
                drawGridLine(selection,
                  lastLevelWidth + lineOffset,
                  axRange[axRange.length - 1][1],
                  lastLevelWidth + lineOffset + m_props.gridline.length,
                  axRange[axRange.length - 1][1]);
              }

              if (m_props.gridline.showLastLine) {
                drawGridLine(selection,
                  lastLevelWidth + lineOffset,
                  axRange[0][0],
                  lastLevelWidth + lineOffset + m_props.gridline.length,
                  axRange[0][0]);
              }
            }

            ///////////////drawing the most inner vertical line////////////////
            if (scaleToDraw.length === 1) {
              ////////////////in single case, also include the first and last tick////////
              //<path d="M150 0 L75 200 L225 200 Z" />
              x1 = lastLevelWidth + lineOffset;
              x2 = lastLevelWidth + lineOffset;
              y1 = axRange[0][0];
              y2 = axRange[axRange.length - 1][1];
              if (m_props.axisline.visible) {
                dPath = "M" + (x1 - m_tickSize) + " " + y1;
                dPath += "L" + x1 + " " + y1;
                dPath += "L" + x2 + " " + y2;
                dPath += "L" + (x2 - m_tickSize) + " " + y2;

                axLine = selection.append("path");
                axLine.each(function() {
                  this.setAttribute("class", m_vClassNames.axisLine);
                  this.setAttribute("d", dPath);
                  this.setAttribute("fill", "none");
                  this.setAttribute("stroke", m_props.color);
                  this.setAttribute("stroke-width", m_props.lineSize);
                  this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");

                });
              }

            } else if (scaleToDraw.length >= 2 && (iScale === scaleToDraw.length - 1)) {
              axLine = selection.append("line");
              axLine.each(function() {
                this.setAttribute("x1", lastLevelWidth + lineOffset);
                this.setAttribute("x2", lastLevelWidth + lineOffset);
                this.setAttribute("y1", axRange[0][0]);
                this.setAttribute("y2", axRange[axRange.length - 1][1]);
                this.setAttribute("class", m_vClassNames.axisLine + " " + "domain");
                this.setAttribute("stroke", m_props.color);
                this.setAttribute("stroke-width", m_props.lineSize);
                this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
              });

            }
            /////////////// end of drawing the most inner vertical line////////////////


            ///////////////drawing vertical line for each level, based on lastLevelWidth///// 
            if (scaleToDraw.length >= 2 && m_props.label.visible) {
              axLine = selection.append("line");
              axLine.each(function() {
                this.setAttribute("x1", lastLevelWidth);
                this.setAttribute("x2", lastLevelWidth);
                this.setAttribute("y1", axRange[0][0]);
                this.setAttribute("y2", axRange[axRange.length - 1][1]);
                this.setAttribute("class", m_vClassNames.axisLine + " " + "domain");
                this.setAttribute("stroke", m_props.color);
                this.setAttribute("stroke-width", m_props.lineSize);
                this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
              });


            }
            ///////////////end of drawing vertical line for each level, based on lastLevelWidth/////

            //draw gridline in the last scaleToDraw///////////////////////
            //FIXME Jimmy/9/22/2012 currently the grid line only used for
            //multi charts. we have a bug for the last gridline here, if for example
            //we draw gridline for yaxis on [i][1], then the last gridline
            //will override xaxis. so we have to seperate last gridline
            if (m_props.gridline.visible && iScale === (scaleToDraw.length - 1)) {
              for (i = 0; i < axDomain.length; i++) {
                drawGridLine(selection,
                  lastLevelWidth + lineOffset,
                  axRange[i][0],
                  lastLevelWidth + lineOffset + m_props.gridline.length,
                  axRange[i][0]);
                if ((i === (axDomain.length - 1)) || (axRange[i][1] !== axRange[i + 1][0])) {
                  drawGridLine(selection,
                    lastLevelWidth + lineOffset,
                    axRange[i][1],
                    lastLevelWidth + lineOffset + m_props.gridline.length,
                    axRange[i][1]);
                }
              }
              //we need an extra line to close the gridline area, otherwise, if we have only one axis, the gridline area will be kept open
              drawGridLine(selection,
                lastLevelWidth + lineOffset + m_props.gridline.length,
                axRange[0][0],
                lastLevelWidth + lineOffset + m_props.gridline.length,
                axRange[i - 1][1]
              );
            }
            //end draw gridline in the last scaleToDraw///////////////////////


            for (i = 0; i < axDomain.length; i++) {
              /////////////////////////////draw tick for single case, horizontal line for multi case////////
              if (scaleToDraw.length === 1 || (scaleToDraw.length !== 1 && !m_props.label.visible)) //draw ticks
              {

                //Jimmy/9/22/2012 to @Catkin, in which scenario axRange[i][0] will not be equal with axRange[i-1][1]?
                if (i > 0 && (axRange[i][0] !== axRange[i - 1][1])) {
                  axTick1 = selection.append("line");
                  axTick1.each(function() {
                    this.setAttribute("class", m_vClassNames.axisLine);
                    this.setAttribute("x1", lineOffset - m_tickSize);
                    this.setAttribute("x2", lineOffset);
                    this.setAttribute("y1", axRange[i][0]);
                    this.setAttribute("y2", axRange[i][0]);
                    this.setAttribute("stroke", m_props.color);
                    this.setAttribute("stroke-width", m_props.lineSize);
                    this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                  });

                }

                ////////////////in single case, first and last tick is already drawn in path, ignore them here////////
                if (i !== (axDomain.length - 1)) {
                  axTick2 = selection.append("line");
                  axTick2.each(function() {
                    this.setAttribute("class", m_vClassNames.axisLine);
                    this.setAttribute("x1", lineOffset - m_tickSize);
                    this.setAttribute("x2", lineOffset);
                    this.setAttribute("y1", axRange[i][1]);
                    this.setAttribute("y2", axRange[i][1]);
                    this.setAttribute("stroke", m_props.color);
                    this.setAttribute("stroke-width", m_props.lineSize);
                    this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                  });
                }
              }

              if (scaleToDraw.length >= 2 && m_props.label.visible) {
                axLine = selection.append("line");
                axLine.each(function() {
                  this.setAttribute("class", m_vClassNames.axisLine);
                  this.setAttribute("x1", lastLevelWidth);
                  this.setAttribute("x2", lastLevelWidth + lineOffset);
                  this.setAttribute("y1", axRange[i][0]);
                  this.setAttribute("y2", axRange[i][0]);
                  this.setAttribute("stroke", m_props.color);
                  this.setAttribute("stroke-width", m_props.lineSize);
                  this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                });

                //Jimmy/9/22/2012 to @Catkin, in which scenario axRange[i][1] will not be equal with axRange[i+1][0]?
                if ((i === (axDomain.length - 1)) || (axRange[i][1] !== axRange[i + 1][0])) {
                  axLine = selection.append("line");
                  axLine.each(function() {
                    this.setAttribute("class", m_vClassNames.axisLine);
                    this.setAttribute("x1", lastLevelWidth);
                    this.setAttribute("x2", lastLevelWidth + lineOffset);
                    this.setAttribute("y1", axRange[i][1]);
                    this.setAttribute("y2", axRange[i][1]);
                    this.setAttribute("stroke", m_props.color);
                    this.setAttribute("stroke-width", m_props.lineSize);
                    this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                  });
                }
              }
              /////////////////////////////draw tick for single case, horizontal line for multi case////////
            }

            labelsToDraw = scaleToDraw[iScale].labelsToDraw;
            for (i = 0; i < labelsToDraw.length; i++) {
              customlabelCfg = labelsToDraw[i].custom;
              if (!(customlabelCfg && customlabelCfg.type === 'url')) {
                m_label = TypeUtils.isExist(labelsToDraw[i].text) ? labelsToDraw[i].text : '';
                if (m_props.label.visible) {
                  labelG = selection;

                  var offsetForBorder = 1;
                  var labelRectX = lastLevelWidth + offsetForBorder;

                  var isTextSize = m_props.forceLabelArea || labelsToDraw[i].height > labelsToDraw[i].rectHeight;
                  var rect = labelG.append("rect");
                  if (isTextSize) {
                    rect.each(function() {
                      this.setAttribute("x", lastLevelWidth + maxTextWidth - labelsToDraw[i].width + m_textOffset - offsetForBorder);
                      this.setAttribute("y", labelsToDraw[i].y - labelsToDraw[i].height / 2 - offsetForBorder);
                      this.setAttribute("width", labelsToDraw[i].width + 2 * offsetForBorder);
                      this.setAttribute("height", labelsToDraw[i].height + 2 * offsetForBorder);
                      this.setAttribute("opacity", 0);
                      this.setAttribute("class", "v-labelarea");
                    });
                  } else {
                    rect.each(function() {
                      this.setAttribute("x", labelRectX);
                      this.setAttribute("y", labelsToDraw[i].startY + offsetForBorder);
                      this.setAttribute("width", lineOffset - offsetForBorder);
                      this.setAttribute("height", (labelsToDraw[i].rectHeight - offsetForBorder) < 0 ? 0 : (labelsToDraw[i].rectHeight - offsetForBorder));
                      this.setAttribute("opacity", 0);
                      this.setAttribute("class", "v-labelarea");
                    });
                  }
                  rect.node().labelContexts = labelsToDraw[i].labelContexts;

                  axLabels = labelG.append("g");
                  axLabels.each(function() {
                    this.setAttribute("fill", m_style.defaultStyle.label.fill);
                    this.setAttribute("class", m_axisLabelClassCombined);
                    this.setAttribute("font-size", m_style.defaultStyle.label['font-size']);
                    this.setAttribute("font-weight", m_style.defaultStyle.label['font-weight']);
                    this.setAttribute("font-family", m_style.defaultStyle.label['font-family']);
                  });
                  axTexts = axLabels.append("text").text(m_label);
                  axTexts.each(function() {
                    this.setAttribute("pointer-events", "none");
                    this.setAttribute("x", lastLevelWidth + maxTextWidth + m_textOffset);
                    this.setAttribute("y", labelsToDraw[i].y);
                    this.setAttribute("dominant-baseline", "middle"); //"auto")//"hanging")//"central")
                    this.setAttribute("text-anchor", "end"); // text-align
                  });

                  adjustLabelForIE(axTexts);
                }
              }
              //else{ //draw as an icon, same size as text }
            }

            lastLevelWidth += (maxTextWidth + 2 * m_textOffset);
          }
        } else if (m_position === "right") {
          lastLevelWidth = 0;

          for (iScale = (scaleToDraw.length - 1); iScale >= 0; iScale--) {
            if (!m_props.label.visible && iScale !== (scaleToDraw.length - 1)) {
              continue;
            }

            axDomain = scaleToDraw[iScale].domain; //["a", "b"]
            axRange = scaleToDraw[iScale].range; //[[0, 100], [100. 200], ...]

            //count the max text size
            re = maxLabelTextWidth(axDomain, axRange);
            maxTextWidth = isTruncated ? maxLabelTextSize(scaleToDraw[iScale].labelsToDraw, false).maxWidth : re.maxLabelTextWidth;

            lineOffset = maxTextWidth + 2 * m_textOffset;
            if (!m_props.label.visible) {
              maxTextWidth = 0;
              lineOffset = 0;
            }

            lineOffset = isTruncated ? m_spaceLimit : lineOffset;

            if (iScale === (scaleToDraw.length - 1)) {
              if (m_props.gridline.showFirstLine) {
                drawGridLine(selection,
                  lastLevelWidth,
                  axRange[axRange.length - 1][1],
                  lastLevelWidth - m_props.gridline.length,
                  axRange[axRange.length - 1][1]);
              }

              if (m_props.gridline.showLastLine) {
                drawGridLine(selection,
                  lastLevelWidth,
                  axRange[0][0],
                  lastLevelWidth - m_props.gridline.length,
                  axRange[0][0]);
              }
            }

            if ((scaleToDraw.length === 1)) {
              //<path d="M150 0 L75 200 L225 200 Z" />
              x1 = lastLevelWidth;
              x2 = lastLevelWidth;
              y1 = axRange[0][0];
              y2 = axRange[axRange.length - 1][1];

              dPath = "M" + (x1 + m_tickSize) + " " + y1;
              dPath += "L" + x1 + " " + y1;
              dPath += "L" + x2 + " " + y2;
              dPath += "L" + (x1 + m_tickSize) + " " + y2;

              axLine = selection.append("path");
              axLine.each(function() {
                this.setAttribute("class", m_vClassNames.axisLine);
                this.setAttribute("d", dPath);
                this.setAttribute("fill", "none");
                this.setAttribute("stroke", m_props.color);
                this.setAttribute("stroke-width", m_props.lineSize);
                this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
              });

            } else if (scaleToDraw.length >= 2 && (iScale === (scaleToDraw.length - 1))) {
              axLine = selection.append("line");
              axLine.each(function() {
                this.setAttribute("class", m_vClassNames.axisLine);
                this.setAttribute("x1", lastLevelWidth);
                this.setAttribute("x2", lastLevelWidth);
                this.setAttribute("y1", axRange[0][0]);
                this.setAttribute("y2", axRange[axRange.length - 1][1]);
                this.setAttribute("stroke", m_props.color);
                this.setAttribute("stroke-width", m_props.lineSize);
                this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
              });

            }

            if (scaleToDraw.length >= 2 && m_props.label.visible) {
              axLine = selection.append("line");
              axLine.each(function() {
                this.setAttribute("class", m_vClassNames.axisLine);
                this.setAttribute("x1", lastLevelWidth + lineOffset);
                this.setAttribute("x2", lastLevelWidth + lineOffset);
                this.setAttribute("y1", axRange[0][0]);
                this.setAttribute("y2", axRange[axRange.length - 1][1]);
                this.setAttribute("stroke", m_props.color);
                this.setAttribute("stroke-width", m_props.lineSize);
                this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
              });

            }

            if (m_props.gridline.visible && iScale === (scaleToDraw.length - 1)) {
              for (i = 0; i < axDomain.length; i++) {
                drawGridLine(selection,
                  lastLevelWidth + lineOffset,
                  axRange[i][0],
                  lastLevelWidth + lineOffset + m_props.gridline.length,
                  axRange[i][0]);
                if ((i === (axDomain.length - 1)) || (axRange[i][1] !== axRange[i + 1][0])) {
                  drawGridLine(selection,
                    lastLevelWidth + lineOffset,
                    axRange[i][1],
                    lastLevelWidth + lineOffset + m_props.gridline.length,
                    axRange[i][1]);
                }
              }

            }

            for (i = 0; i < axDomain.length; i++) {
              if (scaleToDraw.length === 1 || (scaleToDraw.length !== 1 && !m_props.label.visible)) //draw ticks
              {
                if (i > 0 && (axRange[i][0] !== axRange[i - 1][1])) {
                  axTick1 = selection.append("line");
                  axTick1.each(function() {
                    this.setAttribute("class", m_vClassNames.axisLine);
                    this.setAttribute("x1", 0);
                    this.setAttribute("x2", m_tickSize);
                    this.setAttribute("y1", axRange[i][0]);
                    this.setAttribute("y2", axRange[i][0]);
                    this.setAttribute("stroke", m_props.color);
                    this.setAttribute("stroke-width", m_props.lineSize);
                    this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                  });
                }
                if (i !== (axDomain.length - 1)) {
                  axTick2 = selection.append("line");
                  axTick2.each(function() {
                    this.setAttribute("class", m_vClassNames.axisLine);
                    this.setAttribute("x1", 0);
                    this.setAttribute("x2", m_tickSize);
                    this.setAttribute("y1", axRange[i][1]);
                    this.setAttribute("y2", axRange[i][1]);
                    this.setAttribute("stroke", m_props.color);
                    this.setAttribute("stroke-width", m_props.lineSize);
                    this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                  });
                }
              }

              if (scaleToDraw.length >= 2 && m_props.label.visible) {
                axLine = selection.append("line");
                axLine.each(function() {
                  this.setAttribute("class", m_vClassNames.axisLine);
                  this.setAttribute("x1", lastLevelWidth);
                  this.setAttribute("x2", lastLevelWidth + lineOffset);
                  this.setAttribute("y1", axRange[i][0]);
                  this.setAttribute("y2", axRange[i][0]);
                  this.setAttribute("stroke", m_props.color);
                  this.setAttribute("stroke-width", 1);
                  this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                });

                if ((i === (axDomain.length - 1)) || (axRange[i][1] !== axRange[i + 1][0])) {
                  axLine = selection.append("line");
                  axLine.each(function() {
                    this.setAttribute("class", m_vClassNames.axisLine);
                    this.setAttribute("x1", lastLevelWidth);
                    this.setAttribute("x2", lastLevelWidth + lineOffset);
                    this.setAttribute("y1", axRange[i][1]);
                    this.setAttribute("y2", axRange[i][1]);
                    this.setAttribute("stroke", m_props.color);
                    this.setAttribute("stroke-width", m_props.lineSize);
                    this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                  });
                }
              }
            }

            labelsToDraw = scaleToDraw[iScale].labelsToDraw;
            for (i = 0; i < labelsToDraw.length; i++) {
              customlabelCfg = labelsToDraw[i].custom;
              if (!(customlabelCfg && customlabelCfg.type === 'url')) {
                m_label = TypeUtils.isExist(labelsToDraw[i].text) ? labelsToDraw[i].text : '';
                if (m_props.label.visible) {
                  labelG = selection;

                  axLabels = labelG.append("g");
                  axLabels.each(function() {
                    this.setAttribute("fill", m_style.defaultStyle.label.fill);
                    this.setAttribute("class", m_axisLabelClassCombined);
                    this.setAttribute("font-size", m_style.defaultStyle.label['font-size']);
                    this.setAttribute("font-weight", m_style.defaultStyle.label['font-weight']);
                    this.setAttribute("font-family", m_style.defaultStyle.label['font-family']);
                  });
                  axTexts = axLabels.append("text").text(m_label);
                  axTexts.each(function() {
                    this.setAttribute("x", lastLevelWidth + m_textOffset);
                    this.setAttribute("y", labelsToDraw[i].y);
                    this.setAttribute("text-anchor", "start"); // text-align
                    this.setAttribute("dominant-baseline", "middle"); //"auto")//"hanging")//"central")
                  });


                  adjustLabelForIE(axTexts);
                }
              }
              // else {//draw as an icon, same size as text}
            }

            lastLevelWidth += (maxTextWidth + 2 * m_textOffset);
          }
        } else if (m_position === "bottom") {
          lastLevelHeight = 0;

          for (iScale = (scaleToDraw.length - 1); iScale >= 0; iScale--) {
            if (!m_props.label.visible && iScale !== (scaleToDraw.length - 1)) {
              continue;
            }

            axDomain = scaleToDraw[iScale].domain; //["a", "b"]
            axRange = scaleToDraw[iScale].range; //[[0, 100], [100. 200], ...]

            //count the max text size
            re = maxLabelTextHeight(axDomain, axRange);
            isVertical = re.isVertical;
            maxTextHeight = isTruncated ? maxLabelTextSize(scaleToDraw[iScale].labelsToDraw, isVertical).maxHeight : re.maxLabelTextHeight;

            lineOffset = maxTextHeight + 2 * m_textOffset;
            if (!m_props.label.visible) {
              maxTextHeight = 0;
              lineOffset = 0;
            }

            lineOffset = isTruncated ? m_spaceLimit : lineOffset;

            if (iScale === (scaleToDraw.length - 1)) {
              if (m_props.gridline.showFirstLine) {
                drawGridLine(selection,
                  axRange[0][0],
                  lastLevelHeight,
                  axRange[0][0],
                  lastLevelHeight - m_props.gridline.length);
              }

              if (m_props.gridline.showLastLine) {
                drawGridLine(selection,
                  axRange[axRange.length - 1][0],
                  lastLevelHeight,
                  axRange[axRange.length - 1][0],
                  lastLevelHeight - m_props.gridline.length);
              }
            }

            var aAngle, cosAngle, sinAngle;
            if (scaleToDraw.length === 1) {
              x1 = axRange[0][0];
              x2 = axRange[axRange.length - 1][1];
              y1 = lastLevelHeight;
              y2 = lastLevelHeight;

              dPath = "M" + x1 + " " + (y1 + m_tickSize);
              dPath += "L" + x1 + " " + y1;
              dPath += "L" + x2 + " " + y2;
              dPath += "L" + x2 + " " + (y2 + m_tickSize);
              if (m_props.axisline.visible) {
                axLine = selection.append("path");
                if (angle) {
                  aAngle = angle * Math.PI / 180;
                  cosAngle = Math.cos(aAngle);
                  sinAngle = (45 === angle) ? cosAngle : Math.sin(aAngle);
                  dPath = 'M ' + axRange[0][0] + ' ' + lastLevelHeight;
                  dPath += 'L' + (axRange[0][0] + axRange[axRange.length - 1][1] * sinAngle) + ' ' + (lastLevelHeight - axRange[axRange.length - 1][1] * cosAngle);
                  dPath += 'Z';
                }
                axLine.each(function() {
                  this.setAttribute("class", m_vClassNames.axisLine);
                  this.setAttribute("d", dPath);
                  this.setAttribute("fill", "none");
                  this.setAttribute("stroke", m_props.color);
                  this.setAttribute("stroke-width", m_props.lineSize);
                  this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                });

              }
            } else if (scaleToDraw.length >= 2 && (iScale === scaleToDraw.length - 1)) {
              axLine = selection.append("line");
              axLine.each(function() {
                this.setAttribute("class", m_vClassNames.axisLine);
                this.setAttribute("x1", axRange[0][0]);
                this.setAttribute("x2", axRange[axRange.length - 1][1]);
                this.setAttribute("y1", lastLevelHeight);
                this.setAttribute("y2", lastLevelHeight);
                this.setAttribute("stroke", m_props.color);
                this.setAttribute("stroke-width", m_props.lineSize);
                this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
              });
            }

            if (scaleToDraw.length >= 2 && m_props.label.visible) {
              axLine = selection.append("line");
              axLine.each(function() {
                this.setAttribute("class", m_vClassNames.axisLine);
                this.setAttribute("x1", axRange[0][0]);
                this.setAttribute("x2", axRange[axRange.length - 1][1]);
                this.setAttribute("y1", lastLevelHeight + lineOffset);
                this.setAttribute("y2", lastLevelHeight + lineOffset);
                this.setAttribute("stroke", m_props.color);
                this.setAttribute("stroke-width", m_props.lineSize);
                this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
              });
            }

            //draw gridline in the last scaleToDraw///////////////////////
            if (m_props.gridline.visible && iScale === (scaleToDraw.length - 1)) {
              for (i = 0; i < axDomain.length; i++) {
                drawGridLine(selection,
                  axRange[i][0],
                  lastLevelHeight + lineOffset,
                  axRange[i][0],
                  lastLevelHeight + lineOffset + m_props.gridline.length
                );
                if ((i === (axDomain.length - 1)) || (axRange[i][1] !== axRange[i + 1][0])) {
                  drawGridLine(selection,
                    axRange[i][1],
                    lastLevelHeight + lineOffset,
                    axRange[i][1],
                    lastLevelHeight + lineOffset + m_props.gridline.length
                  );
                }
              }
            }
            //end draw gridline in the last scaleToDraw///////////////////////


            for (i = 0; i < axDomain.length; i++) {
              if (scaleToDraw.length === 1 || (scaleToDraw.length !== 1 && !m_props.label.visible)) //draw ticks
              {
                if (i > 0 && (axRange[i][0] !== axRange[i - 1][1])) {
                  axTick1 = selection.append("line");
                  axTick1.each(function() {
                    this.setAttribute("class", m_vClassNames.axisLine);
                    this.setAttribute("x1", axRange[i][0]);
                    this.setAttribute("x2", axRange[i][0]);
                    this.setAttribute("y1", 0);
                    this.setAttribute("y2", m_tickSize);
                    this.setAttribute("stroke", m_props.color);
                    this.setAttribute("stroke-width", m_props.lineSize);
                    this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                  });
                }
                if (i !== (axDomain.length - 1)) {
                  axTick2 = selection.append("line");
                  axTick2.each(function() {
                    this.setAttribute("class", m_vClassNames.axisLine);
                    this.setAttribute("x1", axRange[i][1]);
                    this.setAttribute("x2", axRange[i][1]);
                    this.setAttribute("y1", 0);
                    this.setAttribute("y2", m_tickSize);
                    this.setAttribute("stroke", m_props.color);
                    this.setAttribute("stroke-width", m_props.lineSize);
                    this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                  });

                  if (angle) {
                    aAngle = angle * Math.PI / 180;
                    cosAngle = Math.cos(aAngle);
                    sinAngle = (45 === angle) ? cosAngle : Math.sin(aAngle);
                    var tAngle = tickAngle * Math.PI / 180;
                    var cosTAngle = Math.cos(tAngle);
                    var sinTAngle = Math.sin(tAngle);

                    var tickStartX = axRange[i][1] * sinAngle;
                    var tickStartY = -axRange[i][1] * cosAngle;
                    x2 = tickStartX + m_tickSize * cosTAngle;
                    y2 = tickStartY + m_tickSize * sinTAngle;

                    axTick2.attr('x1', tickStartX).attr('y1', tickStartY).attr('x2', x2).attr('y2', y2);
                  }

                }
              }

              if (scaleToDraw.length >= 2 && m_props.label.visible) {
                axLine = selection.append("line");
                axLine.each(function() {
                  this.setAttribute("class", m_vClassNames.axisLine);
                  this.setAttribute("x1", axRange[i][0]);
                  this.setAttribute("x2", axRange[i][0]);
                  this.setAttribute("y1", lastLevelHeight);
                  this.setAttribute("y2", lastLevelHeight + lineOffset);
                  this.setAttribute("stroke", m_props.color);
                  this.setAttribute("stroke-width", m_props.lineSize);
                  this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                });

                if ((i === (axDomain.length - 1)) || (axRange[i][1] !== axRange[i + 1][0])) {
                  axLine = selection.append("line");
                  axLine.each(function() {
                    this.setAttribute("class", m_vClassNames.axisLine);
                    this.setAttribute("x1", axRange[i][1]);
                    this.setAttribute("x2", axRange[i][1]);
                    this.setAttribute("y1", lastLevelHeight);
                    this.setAttribute("y2", lastLevelHeight + lineOffset);
                    this.setAttribute("stroke", m_props.color);
                    this.setAttribute("stroke-width", m_props.lineSize);
                    this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                  });
                }
              }
            }

            labelsToDraw = scaleToDraw[iScale].labelsToDraw;
            drawTopBottomLabels(selection, labelsToDraw, lastLevelHeight, maxTextHeight, axDomain, isVertical, scaleToDraw.length !== 1);

            lastLevelHeight += (maxTextHeight + 2 * m_textOffset);
          }
        } else if (m_position === "top") {
          lastLevelHeight = 0;

          for (iScale = 0; iScale < scaleToDraw.length; iScale++) {
            if (!m_props.label.visible && iScale !== (scaleToDraw.length - 1)) {
              continue;
            }

            axDomain = scaleToDraw[iScale].domain; //["a", "b"]
            axRange = scaleToDraw[iScale].range; //[[0, 100], [100. 200], ...]

            //count the max text size
            re = maxLabelTextHeight(axDomain, axRange);
            isVertical = re.isVertical;
            maxTextHeight = isTruncated ? maxLabelTextSize(scaleToDraw[iScale].labelsToDraw, isVertical).maxHeight : re.maxLabelTextHeight;

            lineOffset = maxTextHeight + 2 * m_textOffset;
            if (!m_props.label.visible) {
              maxTextHeight = 0;
              lineOffset = 0;
            }

            lineOffset = isTruncated ? m_spaceLimit : lineOffset;

            if (iScale === (scaleToDraw.length - 1)) {
              if (m_props.gridline.showFirstLine) {
                drawGridLine(selection,
                  axRange[0][0],
                  lineOffset + lastLevelHeight,
                  axRange[0][0],
                  lineOffset + lastLevelHeight + m_props.gridline.length
                );
              }

              if (m_props.gridline.showLastLine) {
                drawGridLine(selection,
                  axRange[axRange.length - 1][1],
                  lineOffset + lastLevelHeight,
                  axRange[axRange.length - 1][1],
                  lineOffset + lastLevelHeight + m_props.gridline.length
                );
              }
            }

            if ((scaleToDraw.length === 1)) {
              x1 = axRange[0][0];
              x2 = axRange[axRange.length - 1][1];
              y1 = lineOffset + lastLevelHeight;
              y2 = lineOffset + lastLevelHeight;

              dPath = "M" + x1 + " " + (y1 - m_tickSize);
              dPath += "L" + x1 + " " + y1;
              dPath += "L" + x2 + " " + y2;
              dPath += "L" + x2 + " " + (y2 - m_tickSize);

              axLine = selection.append("path");
              axLine.each(function() {
                this.setAttribute("class", m_vClassNames.axisLine);
                this.setAttribute("d", dPath);
                this.setAttribute("fill", "none");
                this.setAttribute("stroke", m_props.color);
                this.setAttribute("stroke-width", m_props.lineSize);
                this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
              });
            } else if (scaleToDraw.length >= 2 && (iScale === scaleToDraw.length - 1)) {
              axLine = selection.append("line");
              axLine.each(function() {
                this.setAttribute("class", m_vClassNames.axisLine);
                this.setAttribute("x1", axRange[0][0]);
                this.setAttribute("x2", axRange[axRange.length - 1][1]);
                this.setAttribute("y1", lineOffset + lastLevelHeight);
                this.setAttribute("y2", lineOffset + lastLevelHeight);
                this.setAttribute("stroke", m_props.color);
                this.setAttribute("stroke-width", m_props.lineSize);
                this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
              });
            }

            if (scaleToDraw.length >= 2 && m_props.label.visible) {
              axLine = selection.append("line");
              axLine.each(function() {
                this.setAttribute("class", m_vClassNames.axisLine);
                this.setAttribute("x1", axRange[0][0]);
                this.setAttribute("x2", axRange[axRange.length - 1][1]);
                this.setAttribute("y1", lastLevelHeight);
                this.setAttribute("y2", lastLevelHeight);
                this.setAttribute("stroke", m_props.color);
                this.setAttribute("stroke-width", m_props.lineSize);
                this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
              });

            }

            //draw gridline in the last scaleToDraw///////////////////////
            if (m_props.gridline.visible && iScale === (scaleToDraw.length - 1)) {
              for (i = 0; i < axDomain.length; i++) {
                drawGridLine(selection,
                  axRange[i][0],
                  lastLevelHeight + lineOffset,
                  axRange[i][0],
                  lastLevelHeight + lineOffset + m_props.gridline.length
                );
                if ((i === (axDomain.length - 1)) || (axRange[i][1] !== axRange[i + 1][0])) {
                  drawGridLine(selection,
                    axRange[i][1],
                    lastLevelHeight + lineOffset,
                    axRange[i][1],
                    lastLevelHeight + lineOffset + m_props.gridline.length
                  );
                }
              }
              //we need an extra line to close the gridline area, otherwise, if we have only one axis, the gridline area will be kept open
              drawGridLine(selection,
                axRange[0][0],
                lastLevelHeight + lineOffset + m_props.gridline.length,
                axRange[i - 1][1],
                lastLevelHeight + lineOffset + m_props.gridline.length
              );
            }
            //end draw gridline in the last scaleToDraw///////////////////////

            for (i = 0; i < axDomain.length; i++) {
              if (scaleToDraw.length === 1 || (scaleToDraw.length !== 1 && !m_props.label.visible)) //draw ticks
              {
                if (i > 0 && (axRange[i][0] !== axRange[i - 1][1])) {
                  axTick1 = selection.append("line");
                  axTick1.each(function() {
                    this.setAttribute("class", m_vClassNames.axisLine);
                    this.setAttribute("x1", axRange[i][0]);
                    this.setAttribute("x2", axRange[i][0]);
                    this.setAttribute("y1", lineOffset);
                    this.setAttribute("y2", lineOffset - m_tickSize);
                    this.setAttribute("stroke", m_props.color);
                    this.setAttribute("stroke-width", m_props.lineSize);
                    this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                  });

                }

                ////////////////in single case, first and last tick is already drawn in path, ignore them here////////
                if (i !== (axDomain.length - 1)) {
                  axTick2 = selection.append("line");
                  axTick2.each(function() {
                    this.setAttribute("class", m_vClassNames.axisLine);
                    this.setAttribute("x1", axRange[i][1]);
                    this.setAttribute("x2", axRange[i][1]);
                    this.setAttribute("y1", lineOffset);
                    this.setAttribute("y2", lineOffset - m_tickSize);
                    this.setAttribute("stroke", m_props.color);
                    this.setAttribute("stroke-width", m_props.lineSize);
                    this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                  });
                }
              }

              if (scaleToDraw.length >= 2 && m_props.label.visible) {
                axLine = selection.append("line");
                axLine.each(function() {
                  this.setAttribute("class", m_vClassNames.axisLine);
                  this.setAttribute("x1", axRange[i][0]);
                  this.setAttribute("x2", axRange[i][0]);
                  this.setAttribute("y1", lastLevelHeight);
                  this.setAttribute("y2", lastLevelHeight + lineOffset);
                  this.setAttribute("stroke", m_props.color);
                  this.setAttribute("stroke-width", m_props.lineSize);
                  this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                });

                //Jimmy/9/22/2012 to @Catkin, in which scenario axRange[i][1] will not be equal with axRange[i+1][0]?
                if ((i === (axDomain.length - 1)) || (axRange[i][1] !== axRange[i + 1][0])) {
                  axLine = selection.append("line");
                  axLine.each(function() {
                    this.setAttribute("class", m_vClassNames.axisLine);
                    this.setAttribute("x1", axRange[i][1]);
                    this.setAttribute("x2", axRange[i][1]);
                    this.setAttribute("y1", lastLevelHeight);
                    this.setAttribute("y2", lastLevelHeight + lineOffset);
                    this.setAttribute("stroke", m_props.color);
                    this.setAttribute("stroke-width", m_props.lineSize);
                    this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                  });
                }
              }
            }

            labelsToDraw = scaleToDraw[iScale].labelsToDraw;
            drawTopBottomLabels(selection, labelsToDraw, lastLevelHeight, maxTextHeight, axDomain, isVertical, scaleToDraw.length !== 1);
            lastLevelHeight += (maxTextHeight + 2 * m_textOffset);
          }
        }
      }
      
      axis.spaceLimit = function(_spaceLimit) {
        if (!arguments.length){
          return m_spaceLimit;
        }

        if (!m_disableSpaceLimit) {
          m_spaceLimit = _spaceLimit;
        }

        return axis;
      };

      var adjustLabelForIE = function(text) {
        if (UADetector.isIE()) {
          //dominant-baseline does not work
          var textHeight = m_style.realStyle.label['font-size'].toString();
          var indexPX = textHeight.indexOf("px");
          if (indexPX >= 0) {
            textHeight = textHeight.substr(0, indexPX);
          }

          //textHeight = fastMeasure(text, m_style.realStyle.label).height;
          var y = text.attr("y");
          text.attr("y", Number(y) + textHeight / 2);
          text.attr("dominant-baseline", "auto");
        }
      };

      //get customlabel text from from the rawObj, if the type is url, return the original text
      var getCustomlabelText = function(rawObj) {
        var ret;
        if (rawObj.info) {
          var clobj = rawObj.info.customlabel;
          if (clobj) {
            if (clobj.type === 'url') {
              ret = rawObj.val;
            } else if (clobj.type === 'string') {
              ret = clobj.val;
            }
          } else {
            ret = rawObj.val;
          }
        } else {
          ret = rawObj.val;
        }
        if (ret === '') {
          ret = ' ';
        }
        //so we will first resolve customlabel and then do format
        ret = isInvalidString(ret) ? langManager.get('IDS_ISNOVALUE') : ret;
        ret = FormatManager.format(ret, m_props.label.formatString);
        return ret;
      };

      var getCustomlabelCfg = function(rawObj) {
        if (rawObj.info && rawObj.info.customlabel) {
          return rawObj.info.customlabel;
        }
      };

      var getTruncatedText = function(text, limit) {
        var style = 'font-weight: ' + m_style.realStyle.label['font-weight'] + '; font-family: ' + m_style.realStyle.label['font-family'] + '; font-size: ' + m_style.realStyle.label['font-size'] + ';';
        return TextUtils.ellipsis(text, undefined, limit, style);
      };

      var buildLeftRightToDrawLabels = function(allLabels, allLabelsLocation, isMultilayer, spaceLimit) {
        //Jimmy/12/26/2012 extend allLabels from stringArray to objectArray to support customlabel
        //we always draw the bottom label for yAxis.

        //build the "todraw" array
        //count all the labels y1 and y2, and save them.
        var fullHeight = 0;
        var allTicksLabels = [];
        var i, item;
        for (i = 0; i < allLabels.length; i++) {
          item = {};
          item.text = getCustomlabelText(allLabels[i]);
          item.custom = getCustomlabelCfg(allLabels[i]);
          item.labelContexts = allLabels[i].labelContexts;
          if (spaceLimit >= 0) {
            item.text = getTruncatedText(item.text, spaceLimit - 2 * m_textOffset);
          }
          //count y1 and y2
          var itemMeasure = fastMeasure(item.text, m_style.realStyle.label);
          var centerY = allLabelsLocation[i][0] + (allLabelsLocation[i][1] - allLabelsLocation[i][0]) / 2;
          item.width = itemMeasure.width;
          item.height = itemMeasure.height;
          item.startY = allLabelsLocation[i][0];
          item.rectHeight = allLabelsLocation[i][1] - allLabelsLocation[i][0];
          item.y = centerY;
          item.y1 = centerY - item.height / 2;
          item.y2 = centerY + item.height / 2;
          item.originalIndex = i;
          allLabels[i].drawLabel = false;
          allTicksLabels.push(item);

          fullHeight += item.rectHeight;
        }


        //now we should decide which label to draw.
        //iBeyond = 0:0,1,2,3,4,5,6,...
        //iBeyond = 1:0, ,2, ,4, ,6,...
        //iBeyond = 2:0, , ,3, , ,6,...
        //...
        //iBeyond = (allTicksLabels.length - 1):0
        var ticksLabelsToDraw = [], previousIndex, iBeyond;
        if (m_props.label.hideStrategy !== 'greedy') {
          //we must filter those labels which have already overflown the border.
          var filteredTicksLabels = allTicksLabels.concat();
          for (i = filteredTicksLabels.length - 1; i > -1; --i) {
            if (allLabelsLocation[0] && allLabelsLocation.length &&
              (filteredTicksLabels[i].y2 > allLabelsLocation[allLabelsLocation.length - 1][1] || filteredTicksLabels[i].y1 < allLabelsLocation[0][0])) {
              filteredTicksLabels.splice(i, 1);
            }
          }

          for (iBeyond = 0; iBeyond <= (filteredTicksLabels.length - 1); iBeyond++) {
            var isDrawable = true;
            for (i = (filteredTicksLabels.length - 1); i >= 0; i -= (iBeyond + 1)) {
              item = filteredTicksLabels[i];
              if (i !== (filteredTicksLabels.length - 1)) {
                previousIndex = i + (iBeyond + 1);

                if (filteredTicksLabels[i].y2 >= filteredTicksLabels[previousIndex].y1) {
                  isDrawable = false;
                  break;
                }
              }
              if (item.height > fullHeight) {
                break;
              }

              ticksLabelsToDraw.push(item);
              allLabels[item.originalIndex].drawLabel = true;
            }
            if (isDrawable) {
              break;
            } else {
              ticksLabelsToDraw = [];
            }
          }
        } else {

          for (previousIndex = iBeyond = (allTicksLabels.length - 1); iBeyond >= 0; iBeyond--) {
            item = allTicksLabels[iBeyond];

            if (previousIndex === iBeyond && allLabelsLocation[iBeyond][1] !== allLabelsLocation[iBeyond][0]) {
              if (isMultilayer && item.y1 > allLabelsLocation[iBeyond][0] && item.y2 < allLabelsLocation[iBeyond][1]) {
                ticksLabelsToDraw.push(item);
                allLabels[item.originalIndex].drawLabel = true;
              } else if (!isMultilayer) {
                if (item.height <= fullHeight) {
                  ticksLabelsToDraw.push(item);
                  allLabels[item.originalIndex].drawLabel = true;
                }
              }
            } else {
              if (item.y2 <= allTicksLabels[previousIndex].y1 && allLabelsLocation[iBeyond][1] !== allLabelsLocation[iBeyond][0]) {
                if (isMultilayer) {
                  //if have more than one layers, need to detecte whether the label is between gridlines
                  if (item.y1 > allLabelsLocation[iBeyond][0] && item.y2 < allLabelsLocation[iBeyond][1]) {
                    ticksLabelsToDraw.push(item);
                    allLabels[item.originalIndex].drawLabel = true;
                    previousIndex = iBeyond;
                  }
                } else {
                  //if have only one layer , just need to detecte whether overlap is exist
                  ticksLabelsToDraw.push(item);
                  allLabels[item.originalIndex].drawLabel = true;
                  previousIndex = iBeyond;
                }
              }
            }
          }
          //for greedy situation, we must filter it after because each cell has different width/height.
          for (i = ticksLabelsToDraw.length - 1; i > -1; --i) {
            if (allLabelsLocation[0] && allLabelsLocation.length &&
              (ticksLabelsToDraw[i].y2 > allLabelsLocation[allLabelsLocation.length - 1][1] || ticksLabelsToDraw[i].y1 < allLabelsLocation[0][0])) {
              allLabels[ticksLabelsToDraw[i].originalIndex].drawLabel = false;
              ticksLabelsToDraw.splice(i, 1);
            }
          }

        }
        return ticksLabelsToDraw;
      };

      var buildTopBottomToDrawLabels = function(allLabels, allLabelsLocation, isVertical, isMultilayer, spaceLimit) {
        //Jimmy/12/26/2012 extend allLabels from stringArray to objectArray to support customlabel
        //we always draw the first label for xAxis.

        //build the "todraw" array
        //count all the labels y1 and y2, and save them.
        var fullWidth = 0;
        var allTicksLabels = [];
        var i, item;
        for (i = 0; i < allLabels.length; i++) {
          item = {};
          item.text = getCustomlabelText(allLabels[i]);
          item.custom = getCustomlabelCfg(allLabels[i]);
          item.labelContexts = allLabels[i].labelContexts;

          if (spaceLimit >= 0) {
            item.text = getTruncatedText(item.text, spaceLimit - 2 * m_textOffset);
          }

          //count x1 and x2
          var itemMeasure = fastMeasure(item.text, m_style.realStyle.label);
          if (isVertical) {
            item.width = itemMeasure.height;
            item.height = itemMeasure.width;
          } else {
            item.width = itemMeasure.width;
            item.height = itemMeasure.height;
          }

          var centerX = allLabelsLocation[i][0] + (allLabelsLocation[i][1] - allLabelsLocation[i][0]) / 2;

          item.x = centerX;
          item.x1 = centerX - item.width / 2;
          item.x2 = centerX + item.width / 2;

          item.startX = allLabelsLocation[i][0];
          item.rectWidth = allLabelsLocation[i][1] - allLabelsLocation[i][0];
          item.originalIndex = i;
          allLabels[i].drawLabel = false;

          allTicksLabels.push(item);

          fullWidth += item.rectWidth;
        }

        //now we should decide which label to draw.
        //iBeyond = 0:0,1,2,3,4,5,6,...
        //iBeyond = 1:0, ,2, ,4, ,6,...
        //iBeyond = 2:0, , ,3, , ,6,...
        //...
        //iBeyond = (allTicksLabels.length - 1):0
        var ticksLabelsToDraw = [], previousIndex, iBeyond;
        if (m_props.label.hideStrategy !== 'greedy') {
          //we must filter those labels which have already overflown the border.
          var filteredTicksLabels = allTicksLabels.concat();
          for (i = filteredTicksLabels.length - 1; i > -1; --i) {
            if (allLabelsLocation[0] && allLabelsLocation.length &&
              (filteredTicksLabels[i].x2 > allLabelsLocation[allLabelsLocation.length - 1][1] || filteredTicksLabels[i].x1 < allLabelsLocation[0][0])) {
              filteredTicksLabels.splice(i, 1);
            }
          }
          for (iBeyond = 0; iBeyond <= (filteredTicksLabels.length - 1); iBeyond++) {
            var isDrawable = true;
            for (i = 0; i < filteredTicksLabels.length; i += (iBeyond + 1)) {
              item = filteredTicksLabels[i];
              if (i !== 0) {
                previousIndex = i - (iBeyond + 1);

                if (filteredTicksLabels[i].x1 <= filteredTicksLabels[previousIndex].x2 || allLabelsLocation[iBeyond][1] === allLabelsLocation[iBeyond][0]) {
                  isDrawable = false;
                  break;
                }
              }

              if (item.width > fullWidth) {
                break;
              }

              ticksLabelsToDraw.push(item);
              allLabels[item.originalIndex].drawLabel = true;
            }
            if (isDrawable) {
              break;
            } else {
              ticksLabelsToDraw = [];
            }
          }
        } else {

          for (previousIndex = iBeyond = (allTicksLabels.length - 1); iBeyond >= 0; iBeyond--) {
            item = allTicksLabels[iBeyond];

            if (previousIndex === iBeyond && allLabelsLocation[iBeyond][1] !== allLabelsLocation[iBeyond][0]) {
              if (isMultilayer && item.x1 > allLabelsLocation[iBeyond][0] && item.x2 < allLabelsLocation[iBeyond][1]) {
                ticksLabelsToDraw.push(item);
                allLabels[item.originalIndex].drawLabel = true;
              } else if (!isMultilayer) {
                if (item.width <= fullWidth) {
                  ticksLabelsToDraw.push(item);
                  allLabels[item.originalIndex].drawLabel = true;
                }
              }
            } else {
              if (item.x2 <= allTicksLabels[previousIndex].x1 && allLabelsLocation[iBeyond][1] !== allLabelsLocation[iBeyond][0]) {
                if (isMultilayer) {
                  //if have more than one layers, need to detecte whether the label is between gridlines
                  if (item.x1 > allLabelsLocation[iBeyond][0] && item.x2 < allLabelsLocation[iBeyond][1]) {
                    ticksLabelsToDraw.push(item);
                    allLabels[item.originalIndex].drawLabel = true;
                    previousIndex = iBeyond;
                  }
                } else {
                  //if have only one layer , just need to detecte whether overlap is exist
                  ticksLabelsToDraw.push(item);
                  allLabels[item.originalIndex].drawLabel = true;
                  previousIndex = iBeyond;
                }
              }
            }
          }
          //for greedy situation, we must filter it after because each cell has different width/height.

          for (i = ticksLabelsToDraw.length - 1; i > -1; --i) {
            if (allLabelsLocation[0] && allLabelsLocation.length &&
              (ticksLabelsToDraw[i].x2 > allLabelsLocation[allLabelsLocation.length - 1][1] || ticksLabelsToDraw[i].x1 < allLabelsLocation[0][0])) {
              allLabels[ticksLabelsToDraw[i].originalIndex].drawLabel = false;
              ticksLabelsToDraw.splice(i, 1);
            }
          }
        }

        return ticksLabelsToDraw;
      };

      var drawTopBottomLabels = function(selection, labelsToDraw, lastLevelHeight, maxTextHeight, axDomain, isVertical, isHierarchical) {
        if (labelsToDraw === undefined) {
          return;
        }

        for (var i = 0; i < labelsToDraw.length; i++) {
          var label = TypeUtils.isExist(labelsToDraw[i].text) ? labelsToDraw[i].text : '';
          var axLabels;
          if (m_props.label.visible) {
            if (angle) {
              var labelAreaOffset = 2;

              var aAngle = angle * Math.PI / 180;
              var cosAngle = Math.cos(aAngle);
              var sinAngle = (45 === angle) ? cosAngle : Math.sin(aAngle);
              var tAngle = tickAngle * Math.PI / 180;
              var cosTAngle = Math.cos(tAngle);
              var sinTAngle = Math.sin(tAngle);

              var tickStartX = labelsToDraw[i].x * sinAngle;
              var tickStartY = -labelsToDraw[i].x * cosAngle;

              var labelTextX = tickStartX + (m_tickSize + m_textOffset) * cosTAngle;
              var labelTextY = tickStartY + lastLevelHeight + (m_textOffset + m_tickSize) * sinTAngle;

              var labelAreaX = labelTextX - labelAreaOffset;
              var labelAreaY = labelTextY - labelsToDraw[i].width / 2 - labelAreaOffset;
              var labelAreaWidth = labelsToDraw[i].height + 2 * labelAreaOffset; //the text is vertical
              var labelAreaHeight = labelsToDraw[i].width + 2 * labelAreaOffset;

              //for debug
              if (tickAngle > 90) {
                labelAreaX -= (labelAreaWidth - 2 * labelAreaOffset);
              }

              //label G
              axLabels = selection.append("g");
              axLabels.each(function() {
                this.setAttribute("fill", m_style.defaultStyle.label.fill);
                this.setAttribute("class", m_axisLabelClassCombined);
                this.setAttribute("font-size", m_style.defaultStyle.label['font-size']);
                this.setAttribute("font-weight", m_style.defaultStyle.label['font-weight']);
                this.setAttribute("font-family", m_style.defaultStyle.label['font-family']);
              });

              //draw labelArea
              var labelArea = axLabels.append("rect");
              labelArea.each(function() {
                this.setAttribute("x", labelAreaX);
                this.setAttribute("y", labelAreaY);
                this.setAttribute("width", labelAreaWidth);
                this.setAttribute("height", labelAreaHeight);
                this.setAttribute("opacity", 0);
                this.setAttribute("class", "v-labelarea");
              });
              labelArea.node().labelContexts = labelsToDraw[i].labelContexts;

              //draw label text
              var axLabelText = axLabels.append("text").text(label);
              axLabelText.each(function() {
                this.setAttribute("x", labelTextX);
                this.setAttribute("y", labelTextY);
                this.setAttribute("dominant-baseline", "middle"); //"auto")//"hanging")//"central")
                this.setAttribute("text-anchor", 'start'); // text-align
                this.setAttribute("pointer-events", "none");
              });


              if (tickAngle > 90) {
                axLabelText.attr("text-anchor", 'end');
                axLabels.attr('transform', 'rotate( ' + (tickAngle - 180) + ' ' + labelTextX + ' ' + labelTextY + ')');
              } else {
                axLabels.attr('transform', 'rotate( ' + (tickAngle) + ' ' + labelTextX + ' ' + labelTextY + ')');
              }
            } else {
              var labelG = selection;
              var offsetForBorder = 1, isTextSize, rect;
              if (m_position === "bottom") {

                isTextSize = m_props.forceLabelArea || labelsToDraw[i].width > labelsToDraw[i].rectWidth;
                rect = labelG.append("rect");
                if (isTextSize) {
                  rect.each(function() {
                    this.setAttribute("x", labelsToDraw[i].x - labelsToDraw[i].width / 2 - offsetForBorder);
                    this.setAttribute("y", lastLevelHeight + maxTextHeight / 2 - offsetForBorder - m_textOffset / 2);
                    this.setAttribute("width", labelsToDraw[i].width + 2 * offsetForBorder);
                    this.setAttribute("height", labelsToDraw[i].height + 2 * offsetForBorder);
                    this.setAttribute("opacity", 0);
                    this.setAttribute("class", "v-labelarea");
                  });
                } else {
                  rect.each(function() {
                    this.setAttribute("x", labelsToDraw[i].startX);
                    this.setAttribute("y", lastLevelHeight + offsetForBorder);
                    this.setAttribute("width", labelsToDraw[i].rectWidth);
                    this.setAttribute("height", maxTextHeight + 2 * m_textOffset - offsetForBorder);
                    this.setAttribute("opacity", 0);
                    this.setAttribute("class", "v-labelarea");
                  });
                }
                rect.node().labelContexts = labelsToDraw[i].labelContexts;
              } else if (m_position === "top") {
                if (labelsToDraw[i].labelContexts.length > 0) {

                  isTextSize = m_props.forceLabelArea || labelsToDraw[i].width > labelsToDraw[i].rectWidth;
                  rect = labelG.append("rect");
                  if (isTextSize) {
                    rect.each(function() {
                      this.setAttribute("x", labelsToDraw[i].x - labelsToDraw[i].width / 2 - offsetForBorder);
                      this.setAttribute("y", lastLevelHeight + maxTextHeight / 2 + m_textOffset / 2 - offsetForBorder);
                      this.setAttribute("width", labelsToDraw[i].width + 2 * offsetForBorder);
                      this.setAttribute("height", labelsToDraw[i].height + 2 * offsetForBorder);
                      this.setAttribute("opacity", 0);
                      this.setAttribute("class", "v-labelarea");
                    });
                  } else {
                    rect.each(function() {
                      this.setAttribute("x", labelsToDraw[i].startX);
                      this.setAttribute("y", lastLevelHeight);
                      this.setAttribute("width", labelsToDraw[i].rectWidth);
                      this.setAttribute("height", maxTextHeight + 2 * m_textOffset);
                      this.setAttribute("opacity", 0);
                      this.setAttribute("class", "v-labelarea");
                    });
                  }

                  rect.node().labelContexts = labelsToDraw[i].labelContexts;
                }
              }

              axLabels = labelG.append("g");
              axLabels.each(function() {
                this.setAttribute("fill", m_style.defaultStyle.label.fill);
                this.setAttribute("class", m_axisLabelClassCombined);
                this.setAttribute("font-size", m_style.defaultStyle.label['font-size']);
                this.setAttribute("font-weight", m_style.defaultStyle.label['font-weight']);
                this.setAttribute("font-family", m_style.defaultStyle.label['font-family']);
              });
              var axTexts = axLabels.append("text").text(label);
              axTexts.each(function() {

                this.setAttribute("pointer-events", "none");
                this.setAttribute("x", labelsToDraw[i].x);
                this.setAttribute("y", lastLevelHeight + maxTextHeight / 2 + m_textOffset);
                this.setAttribute("dominant-baseline", "middle"); //"auto")//"hanging")//"central")
                this.setAttribute("text-anchor", "middle"); // text-align
              });


              if (isVertical) {
                if (!isHierarchical) {
                  if (m_position === 'top') {
                    axTexts.attr('text-anchor', 'start')
                      .attr("y", lastLevelHeight + maxTextHeight + m_textOffset);
                  } else if (m_position === 'bottom') {
                    axTexts.attr("y", lastLevelHeight + m_textOffset).attr('text-anchor', 'end');
                  }
                }

                var ac = "-90";
                axTexts.attr("transform", "rotate( " + ac + " " + axTexts.attr("x") + " " + axTexts.attr("y") + " )");

              }
              adjustLabelForIE(axTexts);
            }
          }
        }
      };

      axis.mouseover = function(target) {
        //high light the target
        target.setAttribute("opacity", 1);
        target.setAttribute("class", "v-labelarea v-hovershadow");
        target.setAttribute("fill", m_labelAreaMouseOverColor);
      };

      axis.mouseout = function(target) {
        //un high light all the label areas
        target.setAttribute("class", "v-labelarea");
        target.setAttribute("opacity", 0);
      };

      axis.cleanLabelAreas = function() {
        if (m_selection) {
          m_selection.selectAll(".v-labelarea")
            .attr("class", "v-labelarea")
            .attr("opacity", 0);
        }
      };

      axis.setTitle = function(_) {
        m_title = _;
        return axis;
      };
        
      axis.mouseup = function(target) {
        //un high light the target
        target.setAttribute("opacity", 1);
        target.setAttribute("class", "v-labelarea v-hovershadow");
        target.setAttribute("fill", m_labelAreaMouseOverColor);
      };

      axis.mousedown = function(target) {
        //high light the target
        target.setAttribute("opacity", 1);
        target.setAttribute("class", "v-labelarea v-hovershadow-mousedown");
        target.setAttribute("fill", m_labelAreaMouseDownColor);
      };

      axis.position = function(_position) {
        if (!arguments.length){
          return m_position;
        }
        m_position = _position;
        return axis;
      };

      axis.properties = function(_properties) {
        if (arguments.length === 0){
          return m_props;
        }

        m_props = Objects.extend(true, m_props, _properties);
        return axis;
      };

      axis.style = function(_style) {
        if (arguments.length === 0){
          return m_style;
        }
        m_style = Objects.extend(true, m_style, _style);
        return axis;
      };

      axis.axScale = function(_axScale) {
        if (!arguments.length){
          return m_axScale;
        }
        m_axScale = _axScale;
        return axis;
      };

      axis.getPreferredSize = function() {

        var scaleToDraw = adjustScale();

        var axisWidth = 0;
        var axisHeight = 0;

        var axisSpacings = [];
        var minTruncateSize = 0;

        for (var i = 0; i < scaleToDraw.length; i++) {
          if (!m_props.label.visible && i !== (scaleToDraw.length - 1)) {
            continue;
          }

          var axDomain = scaleToDraw[i].domain; //["a", "b"]
          var axRange = scaleToDraw[i].range; //[[0, 100], [100. 200], ...]

          if (axDomain.length === 0 || axRange.length === 0) {
            continue;
          }

          if (m_position === "bottom" || m_position === "top") {
            axisWidth = Math.abs(axRange[axRange.length - 1][1] - axRange[0][0]) + m_styleLineSrokeWidth;

            var offsetHeight = 0;
            if (m_props.label.visible) {
              var maxHeight;
              if (i === 0) {
                maxHeight = maxLabelTextHeight(axDomain, axRange, undefined, true);
                minTruncateSize = maxHeight.minTruncateSize;
              } else {
                maxHeight = maxLabelTextHeight(axDomain, axRange);
              }
              offsetHeight += maxHeight.maxLabelTextHeight;
            }

            offsetHeight = offsetHeight > 0 ? offsetHeight + 2 * m_textOffset : offsetHeight;
            axisHeight += offsetHeight;

            axisSpacings.push(offsetHeight);
          } else if (m_position === "left" || m_position === "right") {
            var offsetWidth = 0;

            if (m_props.label.visible) {
              var maxWidth;
              if (i === 0) {
                maxWidth = maxLabelTextWidth(axDomain, axRange, true);
                minTruncateSize = maxWidth.minTruncateSize;
              } else {
                maxWidth = maxLabelTextWidth(axDomain, axRange);
              }
              offsetWidth += maxWidth.maxLabelTextWidth;
            }
            offsetWidth = offsetWidth > 0 ? offsetWidth + 2 * m_textOffset : offsetWidth;

            axisWidth += offsetWidth;
            axisSpacings.push(offsetWidth);

            axisHeight = Math.abs(axRange[axRange.length - 1][1] - axRange[0][0]) + m_styleLineSrokeWidth;
          }
        }

        //--------------
        if (m_spaceLimit >= 0) {
          var spacings = axisSpacings;
          var spaceLeft = m_spaceLimit;

          var spacingToDraw = 0;


          for (i = 0; i < spacings.length; i++) {
            if (spaceLeft >= spacings[i]) {
              spacingToDraw += spacings[i];
              spaceLeft -= spacings[i];
              spaceLeft = NumberUtils.precise(spaceLeft);
            } else {
              break;
            }
          }

          if (spacingToDraw === 0 && spacings.length > 0) {
            if (minTruncateSize && minTruncateSize + 2 * m_textOffset < m_spaceLimit) {
              spacingToDraw = m_spaceLimit;
            } else {
              spacingToDraw += spacings[0];
            }
          }


          if (m_position === "bottom" || m_position === "top") {
            axisHeight = spacingToDraw;
          } else if (m_position === "left" || m_position === "right") {
            axisWidth = spacingToDraw;
          }
        }

        //------------------------------------
        if (!m_props.isTruncateAvailable) {
          minTruncateSize = 0;
        } else if (minTruncateSize > 0) {
          minTruncateSize += 2 * m_textOffset;
        }

        return {
          width: axisWidth,
          height: axisHeight,
          spacings: axisSpacings,
          minTruncateSize: minTruncateSize
        };
      };

      axis.matrix = function(_) {
        if (!arguments.length) {
          return m_matrix;
        }
        m_matrix = _;
        return axis;
      };

      axis.labelAngle = function(_) {
        if (!arguments.length) {
          return labelAngle;
        }
        labelAngle = _;
        return axis;
      };

      axis.tickAngle = function(_) {
        if (!arguments.length) {
          return tickAngle;
        }
        tickAngle = _;
        return axis;
      };

      axis.angle = function(_) {
        if (!arguments.length) {
          return angle;
        }
        angle = _;
        return axis;
      };

      axis.labelAlign = function(_) {
        if (!arguments.length) {
          return labelAlign;
        }
        labelAlign = _;
        return axis;
      };

      axis.destroy = function() {
        m_selection = null;
        //Jimmy: its name is confuse, makes people think it's a d3 scale
        m_axScale = null;
      };

      var resolveMaxAndMinInDomain = function(domain, rangeArray, checkEach, checkTruncate) {
        var heightArray = [];
        var widthArray = [];
        var isVerticalFont = false;
        var minTruncateSize = 0;
        for (var i = 0; i < domain.length; i++) {
          var tHeight = 0;
          var tWidth = 0;

          if (domain[i].drawLabel || checkEach) {
            var originalStr = getCustomlabelText(domain[i]);
            var tSize = fastMeasure(originalStr, m_style.realStyle.label);

            tHeight = tSize.height;
            tWidth = tSize.width;
            var interval = rangeArray[i][1] - rangeArray[i][0];

            if (checkTruncate) {
              var truncateSize;
              if (originalStr.length > 3) {
                truncateSize = fastMeasure(originalStr.slice(0, 3).concat('...'), m_style.realStyle.label).width;
                truncateSize = truncateSize > tSize.width ? tSize.width : truncateSize;
              } else {
                truncateSize = tSize.width;
              }

              minTruncateSize = truncateSize > minTruncateSize ? truncateSize : minTruncateSize;
            }

            if ((tHeight < tWidth) && interval !== 0 && tWidth > interval) {
              if (m_position === "top" || m_position === "bottom") {
                isVerticalFont = true;
              }
            }
          }

          heightArray.push(tHeight);
          widthArray.push(tWidth);
        }

        return {
          'heights': heightArray,
          'widths': widthArray,
          'isVerticalFont': isVerticalFont,
          'minTruncateSize': minTruncateSize
        };
      };

      var maxLabelTextHeight = function(domain, rangeArray, checkEach, checkTruncate) {
        //Jimmy/10/26/2012 we extend domain from string array to object to support customlabel
        var re = {
          "maxLabelTextHeight": 0,
          "isVertical": false
        };
        var maxTextHeight = 0;
        var isVerticalFont = false;
        var sizes = resolveMaxAndMinInDomain(domain, rangeArray, checkEach, checkTruncate);
        isVerticalFont = m_props.forceVerticalFont === true ? true : sizes.isVerticalFont;

        for (var i = 0; i < domain.length; i++) {
          if (domain[i].drawLabel || checkEach) {
            if (isVerticalFont) {
              if (maxTextHeight < sizes.widths[i]) {
                maxTextHeight = sizes.widths[i];
              }
            } else {
              if (maxTextHeight < sizes.heights[i]) {
                maxTextHeight = sizes.heights[i];
              }
            }
          }
        }
        re.maxLabelTextHeight = maxTextHeight;
        re.isVertical = isVerticalFont;
        re.minTruncateSize = re.isVertical ? sizes.minTruncateSize : -1;
        return re;
      };

      var maxLabelTextWidth = function(domain, rangeArray, checkTruncate) {
        var re = {
          "maxLabelTextWidth": 0,
          "isVertical": false
        };
        var maxTextWidth = 0;
        var isVerticalFont = false;
        var sizes = resolveMaxAndMinInDomain(domain, rangeArray, undefined, checkTruncate);
        isVerticalFont = m_props.forceVerticalFont === true ? true : sizes.isVerticalFont;

        for (var i = 0; i < domain.length; i++) {
          if (domain[i].drawLabel) {
            if (isVerticalFont) {
              if (maxTextWidth < sizes.heights[i]) {
                maxTextWidth = sizes.heights[i];
              }
            } else {
              if (maxTextWidth < sizes.widths[i]) {
                maxTextWidth = sizes.widths[i];
              }
            }
          }
        }

        re.maxLabelTextWidth = maxTextWidth;
        re.isVertical = isVerticalFont;
        re.minTruncateSize = sizes.minTruncateSize;
        return re;
      };

      var maxLabelTextSize = function(labels, isVertical) {
        var maxWidth = 0,
          maxHeight = 0;
        for (var i = 0; i < labels.length; i++) {
          var tSize = fastMeasure(labels[i].text, m_style.realStyle.label);
          maxWidth = tSize.width > maxWidth ? tSize.width : maxWidth;
          maxHeight = tSize.height > maxHeight ? tSize.height : maxHeight;
        }
        return {
          maxWidth: isVertical ? maxHeight : maxWidth,
          maxHeight: isVertical ? maxWidth : maxHeight
        };
      };

      var fastMeasure = function(_text, _style) {
        return TextUtils.superFastMeasure(_text, _style['font-size'],
          _style['font-weight'],
          _style['font-family']);
      };

      var isInvalidString = function(str) {
        if (typeof(str) !== "string" && NumberUtils.isNoValue(str)) {
          return true;
        }
        return false;
      };

      return axis;
    };

    return ret;
  });
define('sap/viz/modules/axis/BaseCategory',['sap/viz/base/utils/oo',
'sap/viz/modules/Base',
'sap/viz/modules/dispatch',
'sap/viz/modules/axis/baseCategoryHelper',
'sap/viz/modules/axis/baseCategoryCore'],
function Setup(oo, Base, dispatch, baseCategoryHelper, baseCategoryCore) {
    var axis = function(manifest, ctx) {
        axis.superclass.constructor.apply(this,arguments);

        this._axis_baseCategoryHelperModule = baseCategoryHelper(manifest, ctx);

        axis.prototype.initCustomFunList(axis);
        axis.prototype.initBaseCategoryHelper(this._axis_baseCategoryHelperModule, axis);

        //apply the core module. You may need to replace it to your own core.
        axis.prototype.setCoreModule(baseCategoryCore);
    };

    axis.prototype.initCustomFunList = function()
    {
        if(axis.prototype._axis_customFunList)
        {
            return;
        }
        else
        {
            axis.prototype._axis_customFunList = [];
            var propFunction;
            for (propFunction in this)
            {
                if( this.hasOwnProperty( propFunction ) ) 
                {
                    if(typeof(this[propFunction]) === "function")
                    {
                        axis.prototype._axis_customFunList.push(propFunction);
                    }
                } 
            }
        }
    };

    axis.prototype.initBaseCategoryHelper = function(baseCategoryHelper, self)
    {
        var propFunction;        
        for (propFunction in baseCategoryHelper)
        {
            if( baseCategoryHelper.hasOwnProperty( propFunction ) ) 
            {
                if(typeof(baseCategoryHelper[propFunction]) === "function")
                {
                    if( axis.prototype._axis_customFunList &&
                        axis.prototype._axis_customFunList.indexOf(propFunction) < 0)
                    {
                        self.prototype[propFunction] = baseCategoryHelper[propFunction];
                    }
                }
            } 
        }
    };
    
    //the start point
    oo.extend(axis,Base);

    //functions here have higher Priority than functions in initBaseCategoryHelper
    axis.prototype.render = function(selection)
    {
        return this._axis_baseCategoryHelperModule.apply(this, arguments);
    };
    
    //sample overwritten fun
    //axis.prototype.data = function(selection)
    //{
    //    return null;
    //};

    return axis;
});

define('sap/viz/modules/axis/trellisTopCore',['jquery','sap/viz/modules/Constants','sap/viz/util/TextUtils','sap/viz/util/NumberUtils','sap/viz/base/utils/Objects','sap/viz/lang/langManager',
'sap/viz/base/utils/TypeUtils','sap/viz/modules/threeD/Point','sap/viz/modules/threeD/matrix',
'sap/viz/format/FormatManager', 'sap/viz/base/UADetector'],
function Setup(jQuery, ModuleConstants, TextUtils, NumberUtils, Objects, langManager, TypeUtils, Point, matrix, FormatManager, UADetector) {

  var ret = function() {
        
        var m_position;
        var m_axScale;
        var m_selection;
        var m_titleSelection;

        var m_textOffset;
        var m_tickSize = 5;
        
        var m_styleLineSrokeWidth = 1;
        var m_styleGridLineColor = "#d8d8d8";
        var m_axLabelClassName = "viz-axis-label";   
        
        var m_labelAreaMouseOverColor = "#cccccc";
        var m_labelAreaMouseDownColor = "#808080";

        var m_disableSpaceLimit = false;
        
        var m_style = null; //used to hold style passed from axis
        var m_props = 
        { 
            "title": {"visible": false, "text": undefined},
            "gridline": {"visible": false, "color": m_styleGridLineColor, "showFirstLine": false, "length": 0, "showLastLine": false, "type":"line"},
            "type" : "value",
            "visible" : true,
            "label": {"visible": true, "formatString": "", hideStrategy : '' },
            "position": "left",
            "color": "#333333",
            "forceLabelArea": false,
            "shapeRendering": true,
            "forceVerticalFont": false
        }; 

        var m_vClassNames = 
        {
            axis:"v-axis",
            axisBody:"v-body",
            axisTitle:"v-title",
            axisLabel:"v-label",
            axisLine: "v-categoryaxisline",
            gridLine: "v-gridline",
            morphableLabel:ModuleConstants.CSS.CLASS.MORPHABLELABEL
        };
        
        var m_axisLabelClassCombined = m_vClassNames.axisLabel + ' ' + m_axLabelClassName + ' ' + m_vClassNames.morphableLabel;

        var m_matrix = matrix(), labelAngle = null, labelAlign=null, angle = null, tickAngle = null;
        
        var m_spaceLimit = -1;
        var m_titleTextArray = [];
        axis.spaceLimit = function(_spaceLimit)
        {
            if (!arguments.length) 
                return m_spaceLimit;

            if(!m_disableSpaceLimit)
            {
                m_spaceLimit = _spaceLimit;
            }

            return axis;
        };

        axis.setTitle = function(_)
        {
            m_titleTextArray = _;
            return axis;
        };

        var adjustScale = function(spaceLimit)
        {
            //we have to adjust the scale because we may not draw all the levels.
            var scaleToDraw = [];
            var isMultilayer = m_axScale.length > 1 ? true : false;
            m_textOffset= 45/2;
            
            for(var iScale = 0; iScale < m_axScale.length; iScale++)
            {
                var axDomain = m_axScale[iScale].domain;//["a", "b"]
                var axRange = m_axScale[iScale].range;//[[0, 100], [100. 200], ...]

                //count the max text size
                var re = maxLabelTextHeight(axDomain, axRange, true);
                var isVertical = re.isVertical;

                m_axScale[iScale].labelsToDraw = buildTopBottomToDrawLabels(axDomain, axRange, isVertical, isMultilayer, spaceLimit);
                
                if(iScale === 0){
                  scaleToDraw.push(m_axScale[iScale]);
                  if (spaceLimit >= 0) {
                      break;
                  }
                }
                else if(m_axScale[iScale].labelsToDraw.length == m_axScale[iScale].domain.length)
                {
                  scaleToDraw.push(m_axScale[iScale]);
                }
                //for mekko chart ,the scale is not equal. So if a label can be draw, we should draw the whole layer.
                else if(m_axScale[iScale].labelsToDraw.length > 0 && TypeUtils.isExist(m_axScale.noEqual)&&m_axScale.noEqual === true )
                {
                  scaleToDraw.push(m_axScale[iScale]);
                }
            }
            return scaleToDraw;
        };
        
        var drawGridLine = function(selection, x1, y1, x2, y2){
          var gridline = selection.append("line")
          .attr("class", m_vClassNames.gridLine)
                          .attr("y1", y1)
                          .attr("y2", y2)
                          .attr("x1", x1)
                          .attr("x2", x2)
                          .attr("stroke", m_props.gridline.color)
                          .attr("stroke-width", m_props.gridline.size)
                          .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
          if(m_props.gridline.type == "dotted")
          {
               gridline.attr("stroke-dasharray", "3, 2");
          }                        
        };

        function axis(selection)
        {
            m_selection = selection;

            m_baseOffset = 95;

            //make or use a title selection
            var titleClassName = "v-trellisTopAxisTitle";
            var currentDOM = selection.node().parentNode;
			
            var parentDOM = currentDOM.parentNode;
            var titleSelection = d3.select(parentDOM).select("." + titleClassName);
            if(titleSelection.empty())
            {
                titleSelection = d3.select(parentDOM).append("div");
                titleSelection.attr("class", titleClassName);
            }
            titleSelection.select("*").remove();

            //set div style
            var titleStyle = titleSelection.node().style;
            titleStyle.width = currentDOM.style.width;
            titleStyle.position = currentDOM.style.position;
            titleStyle.overflow = "visible";
            titleStyle.height = m_baseOffset/2 + "px";
            titleStyle.left = currentDOM.style.left;
            titleStyle.top = "0px";

            titleSelection = titleSelection.append("svg");
            m_titleSelection = titleSelection;


            //we have to adjust the scale
            var scaleToDraw = adjustScale();
            var isTruncated = false;

            //---we should dicide show or hide somethings because of the spaceLimit
            if(m_spaceLimit >= 0)
            {
                var scaleToAdjust = [];
                var preferredSize = axis.getPreferredSize();
                var spacings = preferredSize.spacings;
                var minTruncateSize = preferredSize.minTruncateSize;
                var spaceLeft = m_spaceLimit;


                for(var i = 0; i < spacings.length; i++)
                {
                    if(spaceLeft >= spacings[i])
                    {
                        scaleToAdjust.push(scaleToDraw[i]);
                        spaceLeft -= spacings[i];spaceLeft = NumberUtils.precise(spaceLeft);
                    }
                    else
                    {
                        if (i === 0 && minTruncateSize > 0 && spaceLeft >= minTruncateSize) {
                            isTruncated = true;
                        }
                        break;
                    }
                }

                if(scaleToAdjust.length == 0 && scaleToDraw.length > 0 && !isTruncated)
                {
                    //scaleToAdjust.push(scaleToDraw[0]);//always draw one
                    var lastDomain = [];
                    for (var i = 0; i < scaleToDraw[0].domain.length; i++) {
                        lastDomain.push('');
                    }
                    scaleToAdjust.push({
                            domain : lastDomain, 
                            range : scaleToDraw[0].range
                        });
                }

                scaleToDraw = scaleToAdjust;
                if (isTruncated) {
                    scaleToDraw = adjustScale(m_spaceLimit);
                }
            }
            var isMultilayer = scaleToDraw.length > 1 ? true : false;
            if(m_position == "top")
            {
                var lastLevelHeight = 0;
                
                for(var iScale = 0; iScale < scaleToDraw.length; iScale++)
                {
                    if(!m_props.label.visible && iScale != (scaleToDraw.length-1))
                    {
                        continue;
                    }

                    var axDomain = scaleToDraw[iScale].domain;//["a", "b"]
                    var axRange = scaleToDraw[iScale].range;//[[0, 100], [100. 200], ...]

                    //count the max text size
                    var re = maxLabelTextHeight(axDomain, axRange);
                    var isVertical = re.isVertical;
                    var maxTextHeight = isTruncated ? maxLabelTextSize(scaleToDraw[iScale].labelsToDraw, isVertical).maxHeight : re.maxLabelTextHeight;

                     var lineOffset = 0 + 2 * m_textOffset;
                    if(!m_props.label.visible)
                    {
                        maxTextHeight = 0;
                        lineOffset = 0;
                    }
                    
                    var lineOffset = isTruncated ? m_spaceLimit : lineOffset;

                    if(iScale == (scaleToDraw.length-1))
                    {
                        if(m_props.gridline.showFirstLine)
                        {
                            drawGridLine(selection,
                                  axRange[0][0],  
                                  lineOffset + lastLevelHeight, 
                                  axRange[0][0],
                                  lineOffset + lastLevelHeight+m_props.gridline.length
                                  );
                        }

                        if(m_props.gridline.showLastLine)
                        {
                            drawGridLine(selection,
                                  axRange[axRange.length-1][1],  
                                  lineOffset + lastLevelHeight, 
                                  axRange[axRange.length-1][1],
                                  lineOffset + lastLevelHeight+m_props.gridline.length
                                  );
                        }
                    }

                    if( (scaleToDraw.length == 1) )
                    {
                        var x1 = axRange[0][0];
                        var x2 = axRange[axRange.length-1][1];
                        var y1 = lineOffset + lastLevelHeight;
                        var y2 = lineOffset + lastLevelHeight;

                        var dPath  = "M" + x1 + " " + (y1-m_tickSize);
                            dPath += "L" + x1 + " " + y1;
                            dPath += "L" + x2 + " " + y2;
                            dPath += "L" + x2 + " " + (y2-m_tickSize);

                        var axLine = selection.append("path")
                        .attr("class", m_vClassNames.axisLine)
                                    .attr("d", dPath)
                                    .attr("fill", "none")
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                    }
                    else if( scaleToDraw.length >= 2 && (iScale == scaleToDraw.length-1) )
                    {
                        var axLine = selection.append("line")
                        .attr("class", m_vClassNames.axisLine)
                                    .attr("x1", axRange[0][0])
                                    .attr("x2", axRange[axRange.length-1][1])
                                    .attr("y1", lineOffset + lastLevelHeight)
                                    .attr("y2", lineOffset + lastLevelHeight)
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                    }

                    if(scaleToDraw.length >= 2 && m_props.label.visible)
                    {
                         selection.append("line")
                         .attr("class", m_vClassNames.axisLine)
                        .attr("x1", axRange[0][0])
                        .attr("x2", axRange[axRange.length-1][1])
                        .attr("y1", lastLevelHeight)
                        .attr("y2", lastLevelHeight)
                        .attr("stroke", m_props.color)
                        .attr("stroke-width", m_props.lineSize)
                        .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                    }
                    
                    //draw gridline in the last scaleToDraw///////////////////////
                    if(m_props.gridline.visible && iScale == (scaleToDraw.length-1)){
                      for(var i = 0; i < axDomain.length; i++)
                      {
                        drawGridLine(selection,
                                axRange[i][0],
                                lastLevelHeight + lineOffset,
                                axRange[i][0],
                                lastLevelHeight + lineOffset + m_props.gridline.length 
                                );
                        if((i == (axDomain.length - 1)) || (axRange[i][1] != axRange[i+1][0])){
                          drawGridLine(selection,
                                axRange[i][1],
                                lastLevelHeight + lineOffset, 
                                axRange[i][1],
                                lastLevelHeight + lineOffset + m_props.gridline.length 
                                );
                        }
                      }
                      //we need an extra line to close the gridline area, otherwise, if we have only one axis, the gridline area will be kept open
                      drawGridLine(selection,
                                axRange[0][0],
                                lastLevelHeight + lineOffset + m_props.gridline.length, 
                                axRange[i - 1][1],
                                lastLevelHeight + lineOffset + m_props.gridline.length 
                                );
                    }
                    //end draw gridline in the last scaleToDraw///////////////////////

                    for(var i = 0; i < axDomain.length; i++)
                    {
                        if(scaleToDraw.length == 1 || (scaleToDraw.length != 1 && !m_props.label.visible))//draw ticks
                        {
                            if(i > 0 && (axRange[i][0] != axRange[i-1][1]))
                            {
                                var axTick1 = selection.append("line")
                                .attr("class", m_vClassNames.axisLine)
                                            .attr("x1", axRange[i][0])
                                            .attr("x2", axRange[i][0])
                                            .attr("y1", lineOffset)
                                            .attr("y2", lineOffset-m_tickSize)
                                            .attr("stroke", m_props.color)
                                            .attr("stroke-width", m_props.lineSize)
                                            .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                            }
                            
                            ////////////////in single case, first and last tick is already drawn in path, ignore them here////////
                          if(i != (axDomain.length - 1)){
                            var axTick2 = selection.append("line")
                            .attr("class", m_vClassNames.axisLine)
                                        .attr("x1", axRange[i][1])
                                        .attr("x2", axRange[i][1])
                                        .attr("y1", lineOffset)
                                        .attr("y2", lineOffset-m_tickSize)
                                        .attr("stroke", m_props.color)
                                        .attr("stroke-width", m_props.lineSize)
                                        .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                          }
                        }
                                      
                        if(scaleToDraw.length >= 2 && m_props.label.visible)
                        {
                             selection.append("line")
                             .attr("class", m_vClassNames.axisLine)
                            .attr("x1", axRange[i][0])
                            .attr("x2", axRange[i][0])
                            .attr("y1", lastLevelHeight)
                            .attr("y2", lastLevelHeight + lineOffset)
                            .attr("stroke", m_props.color)
                            .attr("stroke-width", m_props.lineSize)
                            .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                             
                            //Jimmy/9/22/2012 to @Catkin, in which scenario axRange[i][1] will not be equal with axRange[i+1][0]?
                            if((i == (axDomain.length - 1)) || (axRange[i][1] != axRange[i+1][0])){
                               selection.append("line")
                               .attr("class", m_vClassNames.axisLine)
                              .attr("x1", axRange[i][1])
                              .attr("x2", axRange[i][1])
                              .attr("y1", lastLevelHeight)
                              .attr("y2", lastLevelHeight + lineOffset)
                              .attr("stroke", m_props.color)
                              .attr("stroke-width", m_props.lineSize)
                              .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                            }
                        }
                    }

                    var labelsToDraw = scaleToDraw[iScale].labelsToDraw;
                    drawTopBottomLabels(selection, labelsToDraw, lastLevelHeight, maxTextHeight, axDomain, isVertical, scaleToDraw.length != 1, iScale);
                    lastLevelHeight += (0 + 2*m_textOffset);
                }
            }

        };

        var adjustLabelForIE = function(text)
        {
            if( UADetector.isIE() )
            {
                //dominant-baseline does not work
                var textHeight = m_style.realStyle.label['font-size'].toString();
                var indexPX = textHeight.indexOf("px");
                if(indexPX >= 0)
                {
                    textHeight = textHeight.substr(0, indexPX);
                }

                //textHeight = fastMeasure(text, m_style.realStyle.label).height;
                var y = text.attr("y");
                text.attr("y", Number(y) + textHeight/2);
                text.attr("dominant-baseline", "auto");
            }
        };

        //get customlabel text from from the rawObj, if the type is url, return the original text
        var getCustomlabelText = function(rawObj){
          var ret;
          if(rawObj.info){
            var clobj = rawObj.info.customlabel;
            if(clobj){
              if(clobj.type === 'url'){
                ret = rawObj.val;
              }else if(clobj.type === 'string'){
                ret = clobj.val;
              }
            }else{
              ret = rawObj.val;
            }
          }else{
            ret = rawObj.val;
          }
          if(ret === ''){
            ret = ' ';
          }
          //so we will first resolve customlabel and then do format
          ret = isInvalidString(ret) ? langManager.get('IDS_ISNOVALUE'): ret;
          ret = FormatManager.format(ret, m_props.label.formatString);
          return ret;
        };
        
        var getCustomlabelCfg = function(rawObj){
          if(rawObj.info && rawObj.info.customlabel){
            return rawObj.info.customlabel;
          }
        };
        
        var getTruncatedText = function(text, limit) {
            var style = 'font-weight: ' + m_style.realStyle.label['font-weight'] +'; font-family: ' + m_style.realStyle.label['font-family'] + '; font-size: '+m_style.realStyle.label['font-size']+';';
            return TextUtils.ellipsis(text, undefined, limit, style);
        };
        
        var buildTopBottomToDrawLabels = function(allLabels, allLabelsLocation, isVertical, isMultilayer, spaceLimit) {

            var fullWidth = 0;
            var allTicksLabels = [];
            for(var i = 0; i < allLabels.length; i++) {
                var item = {};
                item.text = getCustomlabelText(allLabels[i]);
                item.custom = getCustomlabelCfg(allLabels[i]);
                item.labelContexts = allLabels[i].labelContexts;
                
                if (spaceLimit >= 0) {
                    item.text = getTruncatedText(item.text, spaceLimit - 2 * m_textOffset);
                }
                
                //count x1 and x2
                var itemMeasure = fastMeasure (item.text, m_style.realStyle.label);
                if(isVertical) {
                    item.width = itemMeasure.height;
                    item.height = itemMeasure.width;
                }
                else {
                    item.width = itemMeasure.width;
                    item.height = itemMeasure.height;
                }

                var centerX = allLabelsLocation[i][0] + (allLabelsLocation[i][1] - allLabelsLocation[i][0])/2;
                var leftX = allLabelsLocation[i][0] + 0;

                var offset = 20;
                item.x = leftX + item.width/2 + offset;
                item.x1 = item.x - item.width/2;
                item.x2 = item.x + item.width/2;

                item.startX = allLabelsLocation[i][0];
                item.rectWidth = allLabelsLocation[i][1] - allLabelsLocation[i][0];
                item.originalIndex = i;
                allLabels[i].drawLabel = false;
                
                allTicksLabels.push(item);

                fullWidth += item.rectWidth;
            }

            //now we should decide which label to draw.
            //iBeyond = 0:0,1,2,3,4,5,6,...
            //iBeyond = 1:0, ,2, ,4, ,6,...
            //iBeyond = 2:0, , ,3, , ,6,...
            //...
            //iBeyond = (allTicksLabels.length - 1):0
            var ticksLabelsToDraw = [];
            //we must filter those labels which have already overflown the border.
            var filteredTicksLabels = allTicksLabels.concat();
            for (var i = filteredTicksLabels.length - 1; i > -1; --i){
            if (allLabelsLocation[0] && allLabelsLocation.length && 
                (filteredTicksLabels[i].x2 > allLabelsLocation[allLabelsLocation.length - 1][1] 
                || filteredTicksLabels[i].x1 < allLabelsLocation[0][0])){
              filteredTicksLabels.splice(i, 1);
            }
            }
            for(var iBeyond = 0; iBeyond <= (filteredTicksLabels.length - 1); iBeyond++) {
              var isDrawable = true;
              for(var i = 0; i < filteredTicksLabels.length; i+=(iBeyond+1)) {   
                  var item = filteredTicksLabels[i];
                  if(i != 0) {
                      var previousIndex = i - (iBeyond+1);
                      if(filteredTicksLabels[i].x1 <= filteredTicksLabels[previousIndex].x2 || allLabelsLocation[iBeyond][1] === allLabelsLocation[iBeyond][0])
                      {
                          isDrawable = false;
                          break;
                      }
                  }
                  
                  if(item.width > fullWidth) {
                      break;
                  }
                  
                  ticksLabelsToDraw.push(item);
                  allLabels[item.originalIndex].drawLabel = true;
              }
              if(isDrawable) {
                  break;
              } else {
                  ticksLabelsToDraw = [];
              }
            }            

            return ticksLabelsToDraw;
        };

        var drawTopBottomLabels = function(selection, labelsToDraw, lastLevelHeight, maxTextHeight, axDomain, isVertical, isHierarchical, iLevel)
        {
            if (labelsToDraw === undefined) {
              return;
            }

            for(var i = 0; i < labelsToDraw.length; i++) {
              var label = TypeUtils.isExist(labelsToDraw[i].text)? labelsToDraw[i].text:'';
                if(m_props.label.visible) {
                   
                    var labelG = selection;
                    var offsetForBorder = 1;
                    if(labelsToDraw[i].labelContexts.length > 0) {
                       
                      var isTextSize = m_props.forceLabelArea || labelsToDraw[i].width > labelsToDraw[i].rectWidth;
                      var rect = isTextSize ? 
                        labelG.append("rect")
                        .attr("x", labelsToDraw[i].x - labelsToDraw[i].width / 2 - offsetForBorder)
                        .attr("y", lastLevelHeight + 0 + m_textOffset / 2 - offsetForBorder)
                        .attr("width", labelsToDraw[i].width + 2 * offsetForBorder)
                        .attr("height", labelsToDraw[i].height + 2 * offsetForBorder)
                        .attr("opacity", 0)
                        .attr("class","v-labelarea")
                        : labelG.append("rect")
                          .attr("x", labelsToDraw[i].startX + offsetForBorder)
                          .attr("y", lastLevelHeight)
                          .attr("width", labelsToDraw[i].rectWidth)
                          .attr("height", 0 + 2*m_textOffset)
                          .attr("opacity", 0)
                          .attr("class","v-labelarea");

                        rect.node().labelContexts = labelsToDraw[i].labelContexts;
                    }

                    var axLabels = labelG
                                    .append("g")
                                    .attr("fill", m_style.defaultStyle.label.fill)
                                    .attr("class", m_axisLabelClassCombined)
                                    .attr("font-size", m_style.defaultStyle.label['font-size'])
                                    .attr("font-weight", m_style.defaultStyle.label['font-weight'])
                                    .attr("font-family", m_style.defaultStyle.label['font-family'])                        
                                    .append("text")
                                    .attr("pointer-events","none")
                                    .attr("x", labelsToDraw[i].x)
                                    .attr("y", lastLevelHeight + 1.5*m_textOffset)
                                    .attr("dominant-baseline", "middle")//"auto")//"hanging")//"central")
                                    .attr("text-anchor", "middle") // text-align
                                    .text(label);
                      
                      if(isVertical) {
                          if(!isHierarchical){
                            if(m_position == 'top'){
                              axLabels.attr('text-anchor', 'start')
                              .attr("y", lastLevelHeight + 0 + m_textOffset);
                            }else if(m_position == 'bottom'){
                              axLabels.attr("y", lastLevelHeight + m_textOffset).attr('text-anchor', 'end');
                            }
                          }
                          
                          var ac = "-90";
                          axLabels.attr("transform","rotate( " + ac + " " + axLabels.attr("x") + " "  + axLabels.attr("y") + " )");
                         
                      }
                      adjustLabelForIE(axLabels);
                  
                }
            }
            

            //draw title
            var titleWidth = fastMeasure (m_titleTextArray[iLevel], m_style.realStyle.title).width;
            var titleOffset = 20; 

            m_titleSelection
            .append("g")
            .attr("fill", m_style.defaultStyle.title.fill)
            .attr("font-size", m_style.defaultStyle.label['font-size'])
            .attr("font-weight", "bold")
            .attr("font-family", m_style.defaultStyle.label['font-family'])                        
            .append("text")
            .attr("pointer-events","none")
            .attr("x", titleOffset + titleWidth/2)
            .attr("y", lastLevelHeight + 0.6*m_textOffset)
            .attr("dominant-baseline", "middle")//"auto")//"hanging")//"central")
            .attr("text-anchor", "middle") // text-align
            .text(m_titleTextArray[iLevel]);
        };
        
        axis.mouseover = function(target){
            //high light the target
            target.setAttribute("opacity", 1);
            target.setAttribute("class", "v-labelarea v-hovershadow");
            target.setAttribute("fill", m_labelAreaMouseOverColor);
        };
        
        axis.mouseout = function(target){
            //un high light all the label areas
            target.setAttribute("class", "v-labelarea");
            target.setAttribute("opacity", 0); 
        };   
        
        axis.cleanLabelAreas = function()
        {
            if(m_selection)
            {
                m_selection.selectAll(".v-labelarea")
                           .attr("class", "v-labelarea")
                           .attr("opacity", 0);
            }
        };

        axis.mouseup = function(target){
            //un high light the target
            target.setAttribute("opacity", 1);
            target.setAttribute("class", "v-labelarea v-hovershadow");            
            target.setAttribute("fill", m_labelAreaMouseOverColor); 
        };
        
        axis.mousedown = function(target){
            //high light the target
            target.setAttribute("opacity", 1); 
            target.setAttribute("class", "v-labelarea v-hovershadow-mousedown");
            target.setAttribute("fill", m_labelAreaMouseDownColor);
        };      

        axis.position = function(_position) {
            if (!arguments.length) 
                return m_position;
            m_position = _position;
            return axis;
        };

        axis.properties = function(_properties) {
            if (arguments.length == 0)
                return m_props;

            m_props = Objects.extend(true, m_props, _properties);
            return axis;
        };
        
        axis.style = function(_style) {
          if(arguments.length == 0)
            return m_style;
          m_style = Objects.extend(true, m_style, _style);
          return axis;
        };

        axis.axScale = function(_axScale) {
            if (!arguments.length) 
                return m_axScale;
            m_axScale = _axScale;
            return axis;
        };

        axis.getPreferredSize = function() {

            var scaleToDraw = adjustScale();

            var axisWidth = 0;
            var axisHeight = 0;

            var axisSpacings = [];
            var minTruncateSize = 0;

            for(var i = 0; i < scaleToDraw.length; i++)
            {
                if(!m_props.label.visible && i != (scaleToDraw.length-1))
                {
                    continue;
                }

                var axDomain = scaleToDraw[i].domain;//["a", "b"]
                var axRange = scaleToDraw[i].range;//[[0, 100], [100. 200], ...]

                if(axDomain.length === 0 || axRange.length === 0)
                {
                    continue;
                }

                axisWidth = Math.abs(axRange[axRange.length-1][1] - axRange[0][0]) + m_styleLineSrokeWidth;
                
                var offsetHeight = 0;
                if(m_props.label.visible)
                {
                    var maxHeight;
                    if (i === 0) {
                        maxHeight = maxLabelTextHeight(axDomain, axRange, undefined, true);
                        minTruncateSize = maxHeight.minTruncateSize;
                    } else {
                        maxHeight = maxLabelTextHeight(axDomain, axRange);
                    }
                    offsetHeight += maxHeight.maxLabelTextHeight;
                }

                offsetHeight = offsetHeight > 0 ? 0 + 2*m_textOffset : offsetHeight;
                axisHeight += offsetHeight;

                axisSpacings.push(offsetHeight);
            }

            //--------------
            if(m_spaceLimit >= 0)
            {
                var spacings = axisSpacings;
                var spaceLeft = m_spaceLimit;

                var spacingToDraw = 0;


                for(var i = 0; i < spacings.length; i++)
                {
                    if(spaceLeft >= spacings[i])
                    {
                        spacingToDraw += spacings[i];
                        spaceLeft -= spacings[i];spaceLeft = NumberUtils.precise(spaceLeft);
                    }
                    else
                    {
                        break;
                    }
                }

                if(spacingToDraw == 0 && spacings.length > 0)
                {
                    if (minTruncateSize && minTruncateSize + 2 * m_textOffset < m_spaceLimit) {
                        spacingToDraw = m_spaceLimit;
                    } else {
                        spacingToDraw += spacings[0];
                    }
                }


                if(m_position == "bottom" || m_position == "top")
                {
                    axisHeight = spacingToDraw;
                }
                else if(m_position == "left" || m_position == "right")
                {
                    axisWidth = spacingToDraw;
                }
            }

            //------------------------------------
            if (!m_props.isTruncateAvailable) {
                minTruncateSize = 0;
            } else if (minTruncateSize > 0) {
                minTruncateSize += 2 * m_textOffset;
            }

            return {
                width : axisWidth,
                height : axisHeight,
                spacings : axisSpacings,
                minTruncateSize : minTruncateSize
            };
        };

        axis.matrix = function(_){
          if(!arguments.length){
            return m_matrix;
          }
          m_matrix = _;
          return axis;
        };
        
        axis.labelAngle = function(_){
          if(!arguments.length){
            return labelAngle;
          }
          labelAngle = _;
          return axis;
        };
        
        axis.tickAngle = function(_){
          if(!arguments.length){
            return tickAngle;
          }
          tickAngle = _;
          return axis;
        };
        
        axis.angle = function(_){
          if(!arguments.length){
            return angle;
          }
          angle = _;
          return axis;
        };
        
        axis.labelAlign = function(_){
          if(!arguments.length){
            return labelAlign;
          }
          labelAlign = _;
          return axis;
        };
        
        axis.destroy = function() {
          m_selection = null;
          //Jimmy: its name is confuse, makes people think it's a d3 scale
          m_axScale = null;
        };
        
        var resolveMaxAndMinInDomain = function(domain, rangeArray, checkEach, checkTruncate){
          var heightArray = [];
          var widthArray = [];
          var isVerticalFont = false;
          var minTruncateSize = 0;
          for(var i = 0; i < domain.length; i++)
          {
              var tHeight = 0;
              var tWidth = 0;

              if(domain[i].drawLabel || checkEach)
              {
                  var originalStr = getCustomlabelText(domain[i]);
                  var tSize = fastMeasure( originalStr , m_style.realStyle.label);

                  tHeight = tSize.height;
                  tWidth = tSize.width;
                  var interval = rangeArray[i][1]-rangeArray[i][0];
                  
                  if (checkTruncate) {
                      var truncateSize;
                      if (originalStr.length > 3) {
                          truncateSize = fastMeasure(originalStr.slice(0, 3).concat('...'), m_style.realStyle.label).width;
                          truncateSize = truncateSize > tSize.width ? tSize.width : truncateSize;
                      } else {
                          truncateSize = tSize.width;
                      }
                      
                      minTruncateSize = truncateSize > minTruncateSize ? truncateSize : minTruncateSize;
                  }

                  if((tHeight < tWidth) && interval!=0 && tWidth > interval )
                  {
                      if(m_position == "top" || m_position == "bottom")
                      {
                          isVerticalFont = true;
                      }
                  }
              }

              heightArray.push(tHeight);
              widthArray.push(tWidth);
          }
          
          return {
            'heights' : heightArray,
            'widths' : widthArray,
            'isVerticalFont' : isVerticalFont,
            'minTruncateSize' : minTruncateSize
          };
        };
        
        var maxLabelTextHeight = function (domain, rangeArray, checkEach, checkTruncate)
        {
          //Jimmy/10/26/2012 we extend domain from string array to object to support customlabel
            var re = {"maxLabelTextHeight": 0, "isVertical": false};
            var maxTextHeight = 0;
            var isVerticalFont = false;
            var sizes = resolveMaxAndMinInDomain(domain, rangeArray, checkEach, checkTruncate);
            isVerticalFont = m_props.forceVerticalFont === true ? true: sizes.isVerticalFont;
            
            for(var i = 0; i < domain.length; i++)
            {
                if(domain[i].drawLabel || checkEach)
                {
                    if(isVerticalFont)
                    {
                        if(maxTextHeight < sizes.widths[i])
                        {
                            maxTextHeight = sizes.widths[i];
                        }
                    }
                    else
                    {
                        if(maxTextHeight < sizes.heights[i])
                        {
                            maxTextHeight = sizes.heights[i];
                        }
                    }
                }
            }
            re.maxLabelTextHeight = maxTextHeight;
            re.isVertical = isVerticalFont;
            re.minTruncateSize = re.isVertical ? sizes.minTruncateSize : -1;
            return re;
        };

        var maxLabelTextWidth = function (domain, rangeArray, checkTruncate)
        {
            var re = {"maxLabelTextWidth": 0, "isVertical": false};
            var maxTextWidth = 0;
            var isVerticalFont = false;
            var sizes = resolveMaxAndMinInDomain(domain, rangeArray, undefined, checkTruncate);
            isVerticalFont = m_props.forceVerticalFont === true ? true: sizes.isVerticalFont;
            
            for(var i = 0; i < domain.length; i++)
            {
                if(domain[i].drawLabel)
                {
                    if(isVerticalFont)
                    {
                        if(maxTextWidth < sizes.heights[i])
                        {
                            maxTextWidth = sizes.heights[i];
                        }
                    }
                    else
                    {
                        if(maxTextWidth < sizes.widths[i])
                        {
                            maxTextWidth = sizes.widths[i];
                        }
                    }
                }
            }

            re.maxLabelTextWidth = maxTextWidth;
            re.isVertical = isVerticalFont;
            re.minTruncateSize = sizes.minTruncateSize;
            return re;
        };
        
        var maxLabelTextSize = function(labels, isVertical) {
            var maxWidth = 0, maxHeight = 0;
            for (var i = 0; i < labels.length; i++) {
                var tSize = fastMeasure(labels[i].text , m_style.realStyle.label);
                maxWidth = tSize.width > maxWidth ? tSize.width : maxWidth;
                maxHeight = tSize.height > maxHeight ? tSize.height : maxHeight;
            }
            return {
                maxWidth : isVertical ? maxHeight : maxWidth,
                maxHeight : isVertical ? maxWidth : maxHeight
            };
        };
        
        var fastMeasure = function(_text, _style)
        {
            return TextUtils.superFastMeasure(_text, _style['font-size'],
                                                _style['font-weight'],
                                                _style['font-family']);
        };
        
        var isInvalidString = function(str){
           if( typeof (str) != "string" && NumberUtils.isNoValue(str))
             {
                   return true;
             }
           return false;
        };

        return axis;
    };

  return ret;
});
  

define('sap/viz/modules/axis/TrellisTop',['sap/viz/base/utils/oo',
'sap/viz/modules/axis/BaseCategory',
'sap/viz/modules/dispatch',
'sap/viz/modules/axis/trellisTopCore'],
function Setup(oo, BaseCategory, dispatch, trellisTopCore) {
    var axis = function(manifest, ctx) {
        axis.superclass.constructor.apply(this,arguments);

        //apply the core module. You may need to replace it to your own core.
        axis.prototype.setCoreModule(trellisTopCore);
    };

    //the start point
    oo.extend(axis,BaseCategory);
    
    //sample overwritten fun
    //axis.prototype.data = function(selection)
    //{
    //    return null;
    //};

    axis.prototype.render = function(selection)
    {
        return axis.superclass.render.call(this, selection, true);
    };

    return axis;
});

define('sap/viz/modules/manifests/axis/TrellisTop',['sap/viz/modules/manifests/Module','sap/viz/modules/Constants',
'sap/viz/modules/axis/TrellisTop'],
function Setup(Manifest, Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.axis.TrellisTop',
    'type' : Constants.Type.Supplementary,
    'name' : 'TrellisTop',
    'base' : "sap.viz.modules.axis",
    'properties' : {
    },
    'css' : {
      '.v-title' : {
        'description' : 'Define style for the title.',
        'value' : {
          'fill' : '#333333',
          'font-family' : "Helvetica Neue, Helvetica, Arial, sans-serif",
          'font-size' : '12px',
          'font-weight' : 'bold'
        }
      },
      '.v-label' : {
        'description' : 'Define style for the label.',
        'value' : {
          'fill' : '#333333',
          'font-family' : "Helvetica Neue, Helvetica, Arial, sans-serif",
          'font-size' : '12px',
          'font-weight' : 'normal'
        }
      }    
    },
    'configure' : null,
    fn : fn
  };
  Manifest.register(module);
});

define('sap/viz/modules/axis/trellisLeftCore',['jquery','sap/viz/modules/Constants','sap/viz/util/TextUtils','sap/viz/util/NumberUtils','sap/viz/base/utils/Objects','sap/viz/lang/langManager',
'sap/viz/base/utils/TypeUtils','sap/viz/modules/threeD/Point','sap/viz/modules/threeD/matrix',
'sap/viz/format/FormatManager', 'sap/viz/base/UADetector'],
function Setup(jQuery, ModuleConstants, TextUtils, NumberUtils, Objects, langManager, TypeUtils, Point, matrix, FormatManager, UADetector) {

  var ret = function() {

        var m_titleTextArray = [];

        var m_baseOffset = 95;

        
        var m_position;
        var m_axScale;
        var m_selection;

        var m_textOffset;
        var m_tickSize = 5;
        
        var m_styleLineSrokeWidth = 1;
        var m_styleGridLineColor = "#d8d8d8";
        var m_axLabelClassName = "viz-axis-label";   
        
        var m_labelAreaMouseOverColor = "#cccccc";
        var m_labelAreaMouseDownColor = "#808080";

        var m_disableSpaceLimit = false;
        
        var m_style = null; //used to hold style passed from axis
        var m_props = 
        { 
            "title": {"visible": false, "text": undefined},
            "gridline": {"visible": false, "color": m_styleGridLineColor, "showFirstLine": false, "length": 0, "showLastLine": false, "type":"line"},
            "type" : "value",
            "visible" : true,
            "label": {"visible": true, "formatString": "", hideStrategy : '' },
            "position": "left",
            "color": "#333333",
            "forceLabelArea": false,
            "shapeRendering": true,
            "forceVerticalFont": false
        }; 

        var m_vClassNames = 
        {
            axis:"v-axis",
            axisBody:"v-body",
            axisTitle:"v-title",
            axisLabel:"v-label",
            axisLine: "v-categoryaxisline",
            gridLine: "v-gridline",
            morphableLabel:ModuleConstants.CSS.CLASS.MORPHABLELABEL
        };
        
        var m_axisLabelClassCombined = m_vClassNames.axisLabel + ' ' + m_axLabelClassName + ' ' + m_vClassNames.morphableLabel;

        var m_matrix = matrix(), labelAngle = null, labelAlign=null, angle = null, tickAngle = null;
        
        var m_spaceLimit = -1;
        axis.spaceLimit = function(_spaceLimit)
        {
            if (!arguments.length) 
                return m_spaceLimit;

            if(!m_disableSpaceLimit)
            {
                m_spaceLimit = _spaceLimit;
            }

            return axis;
        };

        var adjustScale = function(spaceLimit)
        {
            //we have to adjust the scale because we may not draw all the levels.
            var scaleToDraw = [];
            var isMultilayer = m_axScale.length > 1 ? true : false;
            if(isMultilayer){
                m_textOffset= 6;
            }else{
                m_textOffset= 11;
            }
            
            for(var iScale = 0; iScale < m_axScale.length; iScale++)
            {
                var axDomain = m_axScale[iScale].domain;//["a", "b"]
                var axRange = m_axScale[iScale].range;//[[0, 100], [100. 200], ...]

                //count the max text size
                var re = maxLabelTextHeight(axDomain, axRange, true);
                var isVertical = re.isVertical;

                m_axScale[iScale].labelsToDraw = buildLeftRightToDrawLabels(axDomain, axRange, isMultilayer, spaceLimit);
                
                if(iScale === 0){
                  scaleToDraw.push(m_axScale[iScale]);
                  if (spaceLimit >= 0) {
                      break;
                  }
                }
                else if(m_axScale[iScale].labelsToDraw.length == m_axScale[iScale].domain.length)
                {
                  scaleToDraw.push(m_axScale[iScale]);
                }
                //for mekko chart ,the scale is not equal. So if a label can be draw, we should draw the whole layer.
                else if(m_axScale[iScale].labelsToDraw.length > 0 && TypeUtils.isExist(m_axScale.noEqual)&&m_axScale.noEqual === true )
                {
                  scaleToDraw.push(m_axScale[iScale]);
                }
            }
            return scaleToDraw;
        };
        
        var drawGridLine = function(selection, x1, y1, x2, y2){
          var gridline = selection.append("line")
          .attr("class", m_vClassNames.gridLine)
                          .attr("y1", y1)
                          .attr("y2", y2)
                          .attr("x1", x1)
                          .attr("x2", x2)
                          .attr("stroke", m_props.gridline.color)
                          .attr("stroke-width", m_props.gridline.size)
                          .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
          if(m_props.gridline.type == "dotted")
          {
               gridline.attr("stroke-dasharray", "3, 2");
          }                        
        };

        function axis(selection)
        {
            m_selection = selection;

            //make or use a title selection
            var titleClassName = "v-trellisLeftAxisTitle";
            var currentDOM = selection.node().parentNode;
			
            var parentDOM = currentDOM.parentNode;
            var titleSelection = d3.select(parentDOM).select("." + titleClassName);
            if(titleSelection.empty())
            {
                titleSelection = d3.select(parentDOM).append("div");
                titleSelection.attr("class", titleClassName);
            }
            titleSelection.select("*").remove();

            //set div style
            var titleStyle = titleSelection.node().style;
            titleStyle.width = currentDOM.style.width;
            titleStyle.position = currentDOM.style.position;
            titleStyle.overflow = "visible";
            titleStyle.height = m_baseOffset/2 + "px";
            titleStyle.left = currentDOM.style.left;
            titleStyle.top = m_baseOffset/5 + "px";

            titleSelection = titleSelection.append("svg");

            //we have to adjust the scale
            var scaleToDraw = adjustScale();
            var isTruncated = false;

            //---we should dicide show or hide somethings because of the spaceLimit
            if(m_spaceLimit >= 0)
            {
                var scaleToAdjust = [];
                var preferredSize = axis.getPreferredSize();
                var spacings = preferredSize.spacings;
                var minTruncateSize = preferredSize.minTruncateSize;
                var spaceLeft = m_spaceLimit;


                for(var i = 0; i < spacings.length; i++)
                {
                    if(spaceLeft >= spacings[i])
                    {
                        scaleToAdjust.push(scaleToDraw[i]);
                        spaceLeft -= spacings[i];spaceLeft = NumberUtils.precise(spaceLeft);
                    }
                    else
                    {
                        if (i === 0 && minTruncateSize > 0 && spaceLeft >= minTruncateSize) {
                            isTruncated = true;
                        }
                        break;
                    }
                }

                if(scaleToAdjust.length == 0 && scaleToDraw.length > 0 && !isTruncated)
                {
                    //scaleToAdjust.push(scaleToDraw[0]);//always draw one
                    var lastDomain = [];
                    for (var i = 0; i < scaleToDraw[0].domain.length; i++) {
                        lastDomain.push('');
                    }
                    scaleToAdjust.push({
                            domain : lastDomain, 
                            range : scaleToDraw[0].range
                        });
                }

                scaleToDraw = scaleToAdjust;
                if (isTruncated) {
                    scaleToDraw = adjustScale(m_spaceLimit);
                }
            }
            //------------------------------------------------------
            var isMultilayer = scaleToDraw.length > 1 ? true : false;
            if(m_position == "left")
            {
                var lastLevelWidth = 0;
                
                for(var iScale = 0; iScale < scaleToDraw.length; iScale++)
                {
                    if(!m_props.label.visible && iScale != (scaleToDraw.length-1))
                    {
                        continue;
                    }

                    var axDomain = scaleToDraw[iScale].domain;//["a", "b"]
                    var axRange = scaleToDraw[iScale].range;//[[0, 100], [100. 200], ...]

                    //count the max text size
                    var re = maxLabelTextWidth(axDomain, axRange);
                    var maxTextWidth = isTruncated ? maxLabelTextSize(scaleToDraw[iScale].labelsToDraw, false).maxWidth : re.maxLabelTextWidth;

                    var lineOffset = maxTextWidth + 2 * m_textOffset;
                    if(!m_props.label.visible)
                    {
                        maxTextWidth = 0;
                        lineOffset = 0;
                    }
                    
                    var lineOffset = isTruncated ? m_spaceLimit : lineOffset;
                      

                    if(iScale == (scaleToDraw.length-1))
                    {
                        if(m_props.gridline.showFirstLine)
                        {
                            drawGridLine(selection,
                                  lastLevelWidth + lineOffset, 
                                  axRange[axRange.length-1][1], 
                                  lastLevelWidth + lineOffset + m_props.gridline.length, 
                                  axRange[axRange.length-1][1]);
                        }

                        if(m_props.gridline.showLastLine)
                        {
                            drawGridLine(selection,
                                  lastLevelWidth + lineOffset, 
                                  axRange[0][0], 
                                  lastLevelWidth + lineOffset + m_props.gridline.length, 
                                  axRange[0][0]);
                        }
                    }

                    ///////////////drawing the most inner vertical line////////////////
                    if( scaleToDraw.length == 1 ) {
                        ////////////////in single case, also include the first and last tick////////
                        //<path d="M150 0 L75 200 L225 200 Z" />
                        var x1 = lastLevelWidth + lineOffset;
                       
                        var x2 = lastLevelWidth + lineOffset;
                        var y1 = axRange[0][0];
                        var y2 = axRange[axRange.length-1][1];
                        if(m_props.axisline.visible){
                        var dPath  = "M" + (x1-m_tickSize) + " " + y1;
                            dPath += "L" + x1 + " " + y1;
                            dPath += "L" + x2 + " " + y2;
                            dPath += "L" + (x2-m_tickSize) + " " + y2;

                        var axLine = selection.append("path")
                        .attr("class", m_vClassNames.axisLine)
                                    .attr("d", dPath)
                                    .attr("fill", "none")
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                        }

                    }else if(scaleToDraw.length >= 2 && (iScale == scaleToDraw.length -1)) {

                        
                        var axLine = selection.append("line")
                                    .attr("x1", lastLevelWidth + m_baseOffset)
                                    .attr("x2", lastLevelWidth + m_baseOffset)
                                    .attr("y1", axRange[0][0])
                                    .attr("y2", axRange[axRange.length-1][1])
                                    .attr("class", m_vClassNames.axisLine + " " + "domain")
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                    }
                    /////////////// end of drawing the most inner vertical line////////////////


                    ///////////////drawing vertical line for each level, based on lastLevelWidth///// 
                    if(scaleToDraw.length >= 2 && m_props.label.visible)
                    {
                         selection.append("line")
                         
                        .attr("x1", lastLevelWidth)
                        .attr("x2", lastLevelWidth)
                        .attr("y1", axRange[0][0])
                        .attr("y2", axRange[axRange.length-1][1])
                        .attr("class", m_vClassNames.axisLine + " " + "domain")
                        .attr("stroke", m_props.color)
                        .attr("stroke-width", m_props.lineSize)
                        .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                    }
                    ///////////////end of drawing vertical line for each level, based on lastLevelWidth/////

                    //draw gridline in the last scaleToDraw///////////////////////
                    //FIXME Jimmy/9/22/2012 currently the grid line only used for
                    //multi charts. we have a bug for the last gridline here, if for example
                    //we draw gridline for yaxis on [i][1], then the last gridline
                    //will override xaxis. so we have to seperate last gridline
                    if(m_props.gridline.visible && iScale == (scaleToDraw.length-1)){
                      for(var i = 0; i < axDomain.length; i++)
                      {
                        drawGridLine(selection,
                                lastLevelWidth + m_baseOffset, 
                                axRange[i][0], 
                                lastLevelWidth + m_baseOffset + m_props.gridline.length, 
                                axRange[i][0]);
                        if((i == (axDomain.length - 1)) || (axRange[i][1] != axRange[i+1][0])){
                          drawGridLine(selection,
                                lastLevelWidth + m_baseOffset, 
                                axRange[i][1], 
                                lastLevelWidth + m_baseOffset + m_props.gridline.length, 
                                axRange[i][1]);
                        }
                      }
                      //we need an extra line to close the gridline area, otherwise, if we have only one axis, the gridline area will be kept open
                      drawGridLine(selection,
                                lastLevelWidth + m_baseOffset + m_props.gridline.length,
                                axRange[0][0], 
                                lastLevelWidth + m_baseOffset + m_props.gridline.length,
                                axRange[i - 1][1]
                                );
                    }
                    //end draw gridline in the last scaleToDraw///////////////////////


                    for(var i = 0; i < axDomain.length; i++)
                    {
                        /////////////////////////////draw tick for single case, horizontal line for multi case////////
                        if(scaleToDraw.length == 1 || (scaleToDraw.length != 1 && !m_props.label.visible))//draw ticks
                        {

                          //Jimmy/9/22/2012 to @Catkin, in which scenario axRange[i][0] will not be equal with axRange[i-1][1]?
                          if(i > 0 && (axRange[i][0] != axRange[i-1][1]))
                          {
                              var axTick1 = selection.append("line")
                              .attr("class", m_vClassNames.axisLine)
                                          .attr("x1", lineOffset - m_tickSize)
                                          .attr("x2", lineOffset)
                                          .attr("y1", axRange[i][0])
                                          .attr("y2", axRange[i][0])
                                          .attr("stroke", m_props.color)
                                          .attr("stroke-width", m_props.lineSize)
                                          .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");

                          }
                          
                          ////////////////in single case, first and last tick is already drawn in path, ignore them here////////
                          if(i != (axDomain.length - 1)){
                            var axTick2 = selection.append("line")
                            .attr("class", m_vClassNames.axisLine)
                                        .attr("x1", lineOffset - m_tickSize)
                                        .attr("x2", lineOffset)
                                        .attr("y1", axRange[i][1])
                                        .attr("y2", axRange[i][1])
                                        .attr("stroke", m_props.color)
                                        .attr("stroke-width", m_props.lineSize)
                                        .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                          }
                        }
                                      
                        if(scaleToDraw.length >= 2 && m_props.label.visible)
                        {
                             selection.append("line")
                             .attr("class", m_vClassNames.axisLine)
                            .attr("x1", lastLevelWidth)
                            .attr("x2", lastLevelWidth + m_baseOffset)
                            .attr("y1", axRange[i][0])
                            .attr("y2", axRange[i][0])
                            .attr("stroke", m_props.color)
                            .attr("stroke-width", m_props.lineSize)
                            .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                            
                            //Jimmy/9/22/2012 to @Catkin, in which scenario axRange[i][1] will not be equal with axRange[i+1][0]?
                            if((i == (axDomain.length - 1)) || (axRange[i][1] != axRange[i+1][0])){
                               selection.append("line")
                               .attr("class", m_vClassNames.axisLine)
                              .attr("x1", lastLevelWidth)
                              .attr("x2", lastLevelWidth + m_baseOffset)
                              .attr("y1", axRange[i][1])
                              .attr("y2", axRange[i][1])
                              .attr("stroke", m_props.color)
                              .attr("stroke-width", m_props.lineSize)
                              .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto"); 
                            }
                        }
                        /////////////////////////////draw tick for single case, horizontal line for multi case////////
                    }

                    var labelsToDraw = scaleToDraw[iScale].labelsToDraw;
                    var customlabelCfg;
                    for(var i = 0; i < labelsToDraw.length; i++) {
                      customlabelCfg = labelsToDraw[i].custom;
                      if(customlabelCfg && customlabelCfg.type === 'url'){
                        //draw as an icon, same size as text
                      }else{
                        var m_label = TypeUtils.isExist(labelsToDraw[i].text)? labelsToDraw[i].text:'';
                        if(m_props.label.visible)
                        {
                            var labelG = selection;
                            
                            var offsetForBorder = 1;
                            var labelRectX = lastLevelWidth + offsetForBorder;
                           
                            var isTextSize = m_props.forceLabelArea || labelsToDraw[i].height > labelsToDraw[i].rectHeight;
                            var rect = labelG.append("rect").attr("x", labelRectX)
                              .attr("y", labelsToDraw[i].startY + offsetForBorder)
                              .attr("width", m_baseOffset)
                              .attr("height", (labelsToDraw[i].rectHeight - offsetForBorder) < 0 ? 0 : (labelsToDraw[i].rectHeight - offsetForBorder))
                              .attr("opacity", 0)
                              .attr("class","v-labelarea");

                            rect.node().labelContexts = labelsToDraw[i].labelContexts;

                            //selection.append("circle").attr("cx", lastLevelWidth + maxTextWidth - m_textOffset).attr("cy", axRange[i][0] + (axRange[i][1] - axRange[i][0])/2). attr("r", 3);
                            var axLabels = labelG
                                          .append("g")                          
                                          .attr("fill", m_style.defaultStyle.label.fill)
                                          .attr("class", m_axisLabelClassCombined)
                                          .attr("font-size", m_style.defaultStyle.label['font-size'])
                                          .attr("font-weight", m_style.defaultStyle.label['font-weight'])
                                          .attr("font-family", m_style.defaultStyle.label['font-family'])
                                          .append("text")
                                          .attr("pointer-events","none")
                                          .attr("x", lastLevelWidth + 2*m_textOffset)
                                          .attr("y", labelsToDraw[i].y)
                                          .attr("dominant-baseline", "middle")//"auto")//"hanging")//"central")
                                          .attr("text-anchor", "start") // text-align
                                          .text(m_label);

                            adjustLabelForIE(axLabels);
                        }   
                      }
                    }

                    //draw title
                    var titleWidth = fastMeasure (m_titleTextArray[iScale], m_style.realStyle.title).width;
                    var titleOffset = 20; 

                    titleSelection
                    .append("g")
                    .attr("fill", m_style.defaultStyle.title.fill)
                    .attr("font-size", m_style.defaultStyle.label['font-size'])
                    .attr("font-weight", "bold")
                    .attr("font-family", m_style.defaultStyle.label['font-family'])                        
                    .append("text")
                    .attr("pointer-events","none")
                    .attr("x", lastLevelWidth + 2*m_textOffset)
                    .attr("y", 2*m_textOffset)
                    .attr("dominant-baseline", "middle")//"auto")//"hanging")//"central")
                    .attr("text-anchor", "start") // text-align
                    .text(m_titleTextArray[iScale]);


                    lastLevelWidth += m_baseOffset;

                }
            }
        };

        var adjustLabelForIE = function(text)
        {
            if( UADetector.isIE() )
            {
                //dominant-baseline does not work
                var textHeight = m_style.realStyle.label['font-size'].toString();
                var indexPX = textHeight.indexOf("px");
                if(indexPX >= 0)
                {
                    textHeight = textHeight.substr(0, indexPX);
                }

                //textHeight = fastMeasure(text, m_style.realStyle.label).height;
                var y = text.attr("y");
                text.attr("y", Number(y) + textHeight/2);
                text.attr("dominant-baseline", "auto");
            }
        };

        //get customlabel text from from the rawObj, if the type is url, return the original text
        var getCustomlabelText = function(rawObj){
          var ret;
          if(rawObj.info){
            var clobj = rawObj.info.customlabel;
            if(clobj){
              if(clobj.type === 'url'){
                ret = rawObj.val;
              }else if(clobj.type === 'string'){
                ret = clobj.val;
              }
            }else{
              ret = rawObj.val;
            }
          }else{
            ret = rawObj.val;
          }
          if(ret === ''){
            ret = ' ';
          }
          //so we will first resolve customlabel and then do format
          ret = isInvalidString(ret) ? langManager.get('IDS_ISNOVALUE'): ret;
          ret = FormatManager.format(ret, m_props.label.formatString);
          return ret;
        };
        
        var getCustomlabelCfg = function(rawObj){
          if(rawObj.info && rawObj.info.customlabel){
            return rawObj.info.customlabel;
          }
        };
        
        var getTruncatedText = function(text, limit) {
            var style = 'font-weight: ' + m_style.realStyle.label['font-weight'] +'; font-family: ' + m_style.realStyle.label['font-family'] + '; font-size: '+m_style.realStyle.label['font-size']+';';
            return TextUtils.ellipsis(text, undefined, limit, style);
        };
        
        var buildLeftRightToDrawLabels = function(allLabels, allLabelsLocation, isMultilayer, spaceLimit)
        {
          //Jimmy/12/26/2012 extend allLabels from stringArray to objectArray to support customlabel
            //we always draw the bottom label for yAxis.

            //build the "todraw" array
            //count all the labels y1 and y2, and save them.
            var fullHeight = 0;
            var allTicksLabels = [];
            for(var i = 0; i < allLabels.length; i++) {
                var item = {};
                item.text = getCustomlabelText(allLabels[i]);
                item.custom = getCustomlabelCfg(allLabels[i]);
                item.labelContexts = allLabels[i].labelContexts;
                if (spaceLimit >= 0) {
                    item.text = getTruncatedText(item.text, spaceLimit - 2 * m_textOffset);
                }
                //count y1 and y2
                var itemMeasure = fastMeasure (item.text, m_style.realStyle.label);
                var centerY = allLabelsLocation[i][0] + (allLabelsLocation[i][1] - allLabelsLocation[i][0])/2;
                item.width = itemMeasure.width;
                item.height = itemMeasure.height;
                item.startY = allLabelsLocation[i][0];
                item.rectHeight = allLabelsLocation[i][1] - allLabelsLocation[i][0];
                item.y = centerY;
                item.y1 = centerY - item.height/2;
                item.y2 = centerY + item.height/2;
                item.originalIndex = i;
                allLabels[i].drawLabel = false;
                allTicksLabels.push(item);

                fullHeight += item.rectHeight;
            }

            
            //now we should decide which label to draw.
            //iBeyond = 0:0,1,2,3,4,5,6,...
            //iBeyond = 1:0, ,2, ,4, ,6,...
            //iBeyond = 2:0, , ,3, , ,6,...
            //...
            //iBeyond = (allTicksLabels.length - 1):0
            var ticksLabelsToDraw = [];
            if(m_props.label.hideStrategy != 'greedy'){
              //we must filter those labels which have already overflown the border.
              var filteredTicksLabels = allTicksLabels.concat();
              for (var i = filteredTicksLabels.length - 1; i > -1; --i){
                if (allLabelsLocation[0] && allLabelsLocation.length && 
                    (filteredTicksLabels[i].y2 > allLabelsLocation[allLabelsLocation.length - 1][1] 
                    || filteredTicksLabels[i].y1 < allLabelsLocation[0][0])){
                  filteredTicksLabels.splice(i, 1);
                }
              }

              for(var iBeyond = 0; iBeyond <= (filteredTicksLabels.length - 1); iBeyond++) {
                var isDrawable = true;
                for(var i = (filteredTicksLabels.length - 1); i >= 0 ; i-=(iBeyond+1)) {   
                  var item = filteredTicksLabels[i];
                  if(i != (filteredTicksLabels.length - 1)) {
                    var previousIndex = i + (iBeyond+1);

                    if(filteredTicksLabels[i].y2 >= filteredTicksLabels[previousIndex].y1) {
                      isDrawable = false;
                      break;
                    }
                  }
                  if(item.height > fullHeight) {
                    break;
                  }

                  ticksLabelsToDraw.push(item);
                  allLabels[item.originalIndex].drawLabel = true;
                }
                if(isDrawable) {
                  break;
                } else {
                  ticksLabelsToDraw = [];
                }
              }
            } else {
                
              for(var previousIndex = iBeyond = (allTicksLabels.length - 1); iBeyond >=0; iBeyond--){
                    var item = allTicksLabels[iBeyond];
                     
                     if(previousIndex === iBeyond&&allLabelsLocation[iBeyond][1]!=allLabelsLocation[iBeyond][0]){
                          if(isMultilayer && item.y1>allLabelsLocation[iBeyond][0]&&item.y2<allLabelsLocation[iBeyond][1]){
                            ticksLabelsToDraw.push(item);
                            allLabels[item.originalIndex].drawLabel = true;
                          } else if (!isMultilayer) {
                            if(item.height <= fullHeight) {
                                ticksLabelsToDraw.push(item);
                                allLabels[item.originalIndex].drawLabel = true;
                            }
                          }
                     } else {
                        if(item.y2 <= allTicksLabels[previousIndex].y1&&allLabelsLocation[iBeyond][1]!=allLabelsLocation[iBeyond][0]){
                            if(isMultilayer) {
                              //if have more than one layers, need to detecte whether the label is between gridlines
                              if(item.y1>allLabelsLocation[iBeyond][0]&&item.y2<allLabelsLocation[iBeyond][1]) {
                                ticksLabelsToDraw.push(item);
                                allLabels[item.originalIndex].drawLabel = true;
                                previousIndex = iBeyond;
                              }
                            } else {
                            //if have only one layer , just need to detecte whether overlap is exist
                              ticksLabelsToDraw.push(item);
                              allLabels[item.originalIndex].drawLabel = true;
                              previousIndex = iBeyond;
                            }
                        }
                     }
                  }
              //for greedy situation, we must filter it after because each cell has different width/height.
              for (var i = ticksLabelsToDraw.length - 1; i > -1; --i){
                if (allLabelsLocation[0] && allLabelsLocation.length && 
                    (ticksLabelsToDraw[i].y2 > allLabelsLocation[allLabelsLocation.length - 1][1] 
                    || ticksLabelsToDraw[i].y1 < allLabelsLocation[0][0])){
                  allLabels[ticksLabelsToDraw[i].originalIndex].drawLabel = false;
                  ticksLabelsToDraw.splice(i, 1);
                }
              }
              
            }
            return ticksLabelsToDraw;
        };

        var drawTopBottomLabels = function(selection, labelsToDraw, lastLevelHeight, maxTextHeight, axDomain, isVertical, isHierarchical)
        {
            if (labelsToDraw === undefined) {
              return;
            }

            for(var i = 0; i < labelsToDraw.length; i++) {
              var label = TypeUtils.isExist(labelsToDraw[i].text)? labelsToDraw[i].text:'';
                if(m_props.label.visible) {
                  if(angle){
                    var labelAreaOffset = 2;

                    var aAngle = angle * Math.PI /180;
                    var cosAngle = Math.cos(aAngle);
                    var sinAngle = (45 === angle) ? cosAngle : Math.sin(aAngle);
                    var tAngle = tickAngle * Math.PI / 180;
                    var cosTAngle = Math.cos(tAngle);
                    var sinTAngle = Math.sin(tAngle);
                    
                    var tickStartX = labelsToDraw[i].x * sinAngle;
                    tickStartY = - labelsToDraw[i].x * cosAngle;

                    var labelTextX = tickStartX + ( m_tickSize + m_textOffset ) * cosTAngle;
                    var labelTextY = tickStartY + lastLevelHeight + ( m_textOffset + m_tickSize ) * sinTAngle;

                    var labelAreaX = labelTextX - labelAreaOffset;
                    var labelAreaY = labelTextY - labelsToDraw[i].width/2 - labelAreaOffset;
                    var labelAreaWidth = labelsToDraw[i].height + 2*labelAreaOffset;//the text is vertical
                    var labelAreaHeight = labelsToDraw[i].width + 2*labelAreaOffset;

                    //for debug
                    if(tickAngle > 90) {
                        labelAreaX -= (labelAreaWidth - 2*labelAreaOffset);
                    }

                    //label G
                    var axLabels = selection
                            .append("g")
                            .attr("fill", m_style.defaultStyle.label.fill)
                            .attr("class", m_axisLabelClassCombined)
                            .attr("font-size", m_style.defaultStyle.label['font-size'])
                            .attr("font-weight", m_style.defaultStyle.label['font-weight'])
                            .attr("font-family", m_style.defaultStyle.label['font-family']);

                    //draw labelArea
                    var labelArea = axLabels.append("rect")
                                  .attr("x", labelAreaX)
                                  .attr("y", labelAreaY)
                                  .attr("width",labelAreaWidth)
                                  .attr("height", labelAreaHeight)
                                  .attr("opacity", 0)
                                  .attr("class","v-labelarea");
                    labelArea.node().labelContexts = labelsToDraw[i].labelContexts;

                    //draw label text
                    var axLabelText = axLabels.append("text")
                            .attr("x", labelTextX)
                            .attr("y", labelTextY)
                            .attr("dominant-baseline", "middle")//"auto")//"hanging")//"central")
                            .attr("text-anchor", 'start') // text-align
                            .attr("pointer-events","none")
                            .text(label);
                            
                    if(tickAngle > 90) {
                      axLabelText.attr("text-anchor", 'end');
                      axLabels.attr('transform', 'rotate( ' + (tickAngle - 180) + ' ' + labelTextX + ' ' + labelTextY + ')');
                    } else {
                    axLabels.attr('transform', 'rotate( ' + (tickAngle) + ' ' + labelTextX + ' ' + labelTextY + ')');
                    }
                  } else {
                    var labelG = selection;
                    var offsetForBorder = 1;
                     if(m_position === "bottom") {
                       
                       var isTextSize = m_props.forceLabelArea || labelsToDraw[i].width > labelsToDraw[i].rectWidth;
                        var rect = isTextSize ? 
                            labelG.append("rect")
                            .attr("x", labelsToDraw[i].x - labelsToDraw[i].width / 2 - offsetForBorder)
                            .attr("y", lastLevelHeight + maxTextHeight/2 - offsetForBorder - m_textOffset / 2)
                            .attr("width", labelsToDraw[i].width + 2 * offsetForBorder)
                            .attr("height", labelsToDraw[i].height + 2 * offsetForBorder)
                            .attr("opacity", 0)
                            .attr("class","v-labelarea")
                            :labelG.append("rect")
                          .attr("x", labelsToDraw[i].startX)
                          .attr("y", lastLevelHeight + offsetForBorder)
                          .attr("width", labelsToDraw[i].rectWidth)
                          .attr("height", maxTextHeight + 2*m_textOffset - offsetForBorder)
                          .attr("opacity", 0)
                          .attr("class","v-labelarea");

                        rect.node().labelContexts = labelsToDraw[i].labelContexts;
                    }
                    else if(m_position === "top") {
                        if(labelsToDraw[i].labelContexts.length > 0) {
                           
                          var isTextSize = m_props.forceLabelArea || labelsToDraw[i].width > labelsToDraw[i].rectWidth;
                          var rect = isTextSize ? 
                            labelG.append("rect")
                            .attr("x", labelsToDraw[i].x - labelsToDraw[i].width / 2 - offsetForBorder)
                            .attr("y", lastLevelHeight + maxTextHeight/2 + m_textOffset / 2 - offsetForBorder)
                            .attr("width", labelsToDraw[i].width + 2 * offsetForBorder)
                            .attr("height", labelsToDraw[i].height + 2 * offsetForBorder)
                            .attr("opacity", 0)
                            .attr("class","v-labelarea")
                            : labelG.append("rect")
                              .attr("x", labelsToDraw[i].startX)
                              .attr("y", lastLevelHeight)
                              .attr("width", labelsToDraw[i].rectWidth)
                              .attr("height", maxTextHeight + 2*m_textOffset)
                              .attr("opacity", 0)
                              .attr("class","v-labelarea");

                            rect.node().labelContexts = labelsToDraw[i].labelContexts;
                        }
                    }

                    var axLabels = labelG
                                    .append("g")
                                    .attr("fill", m_style.defaultStyle.label.fill)
                                    .attr("class", m_axisLabelClassCombined)
                                    .attr("font-size", m_style.defaultStyle.label['font-size'])
                                    .attr("font-weight", m_style.defaultStyle.label['font-weight'])
                                    .attr("font-family", m_style.defaultStyle.label['font-family'])                        
                                    .append("text")
                                    .attr("pointer-events","none")
                                    .attr("x", labelsToDraw[i].x)
                                    .attr("y", lastLevelHeight + maxTextHeight/2 + m_textOffset)
                                    .attr("dominant-baseline", "middle")//"auto")//"hanging")//"central")
                                    .attr("text-anchor", "middle") // text-align
                                    .text(label);
                      
                      if(isVertical) {
                          if(!isHierarchical){
                            if(m_position == 'top'){
                              axLabels.attr('text-anchor', 'start')
                              .attr("y", lastLevelHeight + maxTextHeight + m_textOffset);
                            }else if(m_position == 'bottom'){
                              axLabels.attr("y", lastLevelHeight + m_textOffset).attr('text-anchor', 'end');
                            }
                          }
                          
                          var ac = "-90";
                          axLabels.attr("transform","rotate( " + ac + " " + axLabels.attr("x") + " "  + axLabels.attr("y") + " )");
                         
                      }
                      adjustLabelForIE(axLabels);
                  }
                }
            }
        };
        
        axis.mouseover = function(target){
            //high light the target
            target.setAttribute("opacity", 1);
            target.setAttribute("class", "v-labelarea v-hovershadow");
            target.setAttribute("fill", m_labelAreaMouseOverColor);
        };
        
        axis.mouseout = function(target){
            //un high light all the label areas
            target.setAttribute("class", "v-labelarea");
            target.setAttribute("opacity", 0); 
        };   
        
        axis.cleanLabelAreas = function()
        {
            if(m_selection)
            {
                m_selection.selectAll(".v-labelarea")
                           .attr("class", "v-labelarea")
                           .attr("opacity", 0);
            }
        };

        axis.setTitle = function(_)
        {
            m_titleTextArray = _;
            return axis;
        };

        axis.mouseup = function(target){
            //un high light the target
            target.setAttribute("opacity", 1);
            target.setAttribute("class", "v-labelarea v-hovershadow");            
            target.setAttribute("fill", m_labelAreaMouseOverColor); 
        };
        
        axis.mousedown = function(target){
            //high light the target
            target.setAttribute("opacity", 1); 
            target.setAttribute("class", "v-labelarea v-hovershadow-mousedown");
            target.setAttribute("fill", m_labelAreaMouseDownColor);
        };      

        axis.position = function(_position) {
            if (!arguments.length) 
                return m_position;
            m_position = _position;
            return axis;
        };

        axis.properties = function(_properties) {
            if (arguments.length == 0)
                return m_props;

            m_props = Objects.extend(true, m_props, _properties);
            return axis;
        };
        
        axis.style = function(_style) {
          if(arguments.length == 0)
            return m_style;
          m_style = Objects.extend(true, m_style, _style);
          return axis;
        };

        axis.axScale = function(_axScale) {
            if (!arguments.length) 
                return m_axScale;
            m_axScale = _axScale;
            return axis;
        };

        axis.getPreferredSize = function() {

            var scaleToDraw = adjustScale();

            var axisWidth = 0;
            var axisHeight = 0;

            var axisSpacings = [];
            var minTruncateSize = 0;

            for(var i = 0; i < scaleToDraw.length; i++)
            {
                if(!m_props.label.visible && i != (scaleToDraw.length-1))
                {
                    continue;
                }

                var axDomain = scaleToDraw[i].domain;//["a", "b"]
                var axRange = scaleToDraw[i].range;//[[0, 100], [100. 200], ...]

                if(axDomain.length === 0 || axRange.length === 0)
                {
                    continue;
                }

                var offsetWidth = 0;
                offsetWidth += m_baseOffset;

                axisWidth += offsetWidth;
                axisSpacings.push(offsetWidth);

                axisHeight = Math.abs(axRange[axRange.length-1][1] - axRange[0][0]) + m_styleLineSrokeWidth;
            }
            axisWidth = scaleToDraw.length*m_baseOffset;

            //--------------
            if(m_spaceLimit >= 0)
            {
                var spacings = axisSpacings;
                var spaceLeft = m_spaceLimit;

                var spacingToDraw = 0;


                for(var i = 0; i < spacings.length; i++)
                {
                    if(spaceLeft >= spacings[i])
                    {
                        spacingToDraw += spacings[i];
                        spaceLeft -= spacings[i];spaceLeft = NumberUtils.precise(spaceLeft);
                    }
                    else
                    {
                        break;
                    }
                }

                if(spacingToDraw == 0 && spacings.length > 0)
                {
                    if (minTruncateSize && minTruncateSize + 2 * m_textOffset < m_spaceLimit) {
                        spacingToDraw = m_spaceLimit;
                    } else {
                        spacingToDraw += spacings[0];
                    }
                }


                if(m_position == "bottom" || m_position == "top")
                {
                    axisHeight = spacingToDraw;
                }
                else if(m_position == "left" || m_position == "right")
                {
                    axisWidth = spacingToDraw;
                }
            }

            //------------------------------------
            if (!m_props.isTruncateAvailable) {
                minTruncateSize = 0;
            } else if (minTruncateSize > 0) {
                minTruncateSize += 2 * m_textOffset;
            }

            return {
                width : axisWidth,
                height : axisHeight,
                spacings : axisSpacings,
                minTruncateSize : minTruncateSize
            };
        };

        axis.matrix = function(_){
          if(!arguments.length){
            return m_matrix;
          }
          m_matrix = _;
          return axis;
        };
        
        axis.labelAngle = function(_){
          if(!arguments.length){
            return labelAngle;
          }
          labelAngle = _;
          return axis;
        };
        
        axis.tickAngle = function(_){
          if(!arguments.length){
            return tickAngle;
          }
          tickAngle = _;
          return axis;
        };
        
        axis.angle = function(_){
          if(!arguments.length){
            return angle;
          }
          angle = _;
          return axis;
        };
        
        axis.labelAlign = function(_){
          if(!arguments.length){
            return labelAlign;
          }
          labelAlign = _;
          return axis;
        };
        
        axis.destroy = function() {
          m_selection = null;
          //Jimmy: its name is confuse, makes people think it's a d3 scale
          m_axScale = null;
        };
        
        var resolveMaxAndMinInDomain = function(domain, rangeArray, checkEach, checkTruncate){
          var heightArray = [];
          var widthArray = [];
          var isVerticalFont = false;
          var minTruncateSize = 0;
          for(var i = 0; i < domain.length; i++)
          {
              var tHeight = 0;
              var tWidth = 0;

              if(domain[i].drawLabel || checkEach)
              {
                  var originalStr = getCustomlabelText(domain[i]);
                  var tSize = fastMeasure( originalStr , m_style.realStyle.label);

                  tHeight = tSize.height;
                  tWidth = tSize.width;
                  var interval = rangeArray[i][1]-rangeArray[i][0];
                  
                  if (checkTruncate) {
                      var truncateSize;
                      if (originalStr.length > 3) {
                          truncateSize = fastMeasure(originalStr.slice(0, 3).concat('...'), m_style.realStyle.label).width;
                          truncateSize = truncateSize > tSize.width ? tSize.width : truncateSize;
                      } else {
                          truncateSize = tSize.width;
                      }
                      
                      minTruncateSize = truncateSize > minTruncateSize ? truncateSize : minTruncateSize;
                  }

                  if((tHeight < tWidth) && interval!=0 && tWidth > interval )
                  {
                      if(m_position == "top" || m_position == "bottom")
                      {
                          isVerticalFont = true;
                      }
                  }
              }

              heightArray.push(tHeight);
              widthArray.push(tWidth);
          }
          
          return {
            'heights' : heightArray,
            'widths' : widthArray,
            'isVerticalFont' : isVerticalFont,
            'minTruncateSize' : minTruncateSize
          };
        };
        
        var maxLabelTextHeight = function (domain, rangeArray, checkEach, checkTruncate)
        {
          //Jimmy/10/26/2012 we extend domain from string array to object to support customlabel
            var re = {"maxLabelTextHeight": 0, "isVertical": false};
            var maxTextHeight = 0;
            var isVerticalFont = false;
            var sizes = resolveMaxAndMinInDomain(domain, rangeArray, checkEach, checkTruncate);
            isVerticalFont = m_props.forceVerticalFont === true ? true: sizes.isVerticalFont;
            
            for(var i = 0; i < domain.length; i++)
            {
                if(domain[i].drawLabel || checkEach)
                {
                    if(isVerticalFont)
                    {
                        if(maxTextHeight < sizes.widths[i])
                        {
                            maxTextHeight = sizes.widths[i];
                        }
                    }
                    else
                    {
                        if(maxTextHeight < sizes.heights[i])
                        {
                            maxTextHeight = sizes.heights[i];
                        }
                    }
                }
            }
            re.maxLabelTextHeight = maxTextHeight;
            re.isVertical = isVerticalFont;
            re.minTruncateSize = re.isVertical ? sizes.minTruncateSize : -1;
            return re;
        };

        var maxLabelTextWidth = function (domain, rangeArray, checkTruncate)
        {
            var re = {"maxLabelTextWidth": 0, "isVertical": false};
            var maxTextWidth = 0;
            var isVerticalFont = false;
            var sizes = resolveMaxAndMinInDomain(domain, rangeArray, undefined, checkTruncate);
            isVerticalFont = m_props.forceVerticalFont === true ? true: sizes.isVerticalFont;
            
            for(var i = 0; i < domain.length; i++)
            {
                if(domain[i].drawLabel)
                {
                    if(isVerticalFont)
                    {
                        if(maxTextWidth < sizes.heights[i])
                        {
                            maxTextWidth = sizes.heights[i];
                        }
                    }
                    else
                    {
                        if(maxTextWidth < sizes.widths[i])
                        {
                            maxTextWidth = sizes.widths[i];
                        }
                    }
                }
            }

            re.maxLabelTextWidth = maxTextWidth;
            re.isVertical = isVerticalFont;
            re.minTruncateSize = sizes.minTruncateSize;
            return re;
        };
        
        var maxLabelTextSize = function(labels, isVertical) {
            var maxWidth = 0, maxHeight = 0;
            for (var i = 0; i < labels.length; i++) {
                var tSize = fastMeasure(labels[i].text , m_style.realStyle.label);
                maxWidth = tSize.width > maxWidth ? tSize.width : maxWidth;
                maxHeight = tSize.height > maxHeight ? tSize.height : maxHeight;
            }
            return {
                maxWidth : isVertical ? maxHeight : maxWidth,
                maxHeight : isVertical ? maxWidth : maxHeight
            };
        };
        
        var fastMeasure = function(_text, _style)
        {
            return TextUtils.superFastMeasure(_text, _style['font-size'],
                                                _style['font-weight'],
                                                _style['font-family']);
        };
        
        var isInvalidString = function(str){
           if( typeof (str) != "string" && NumberUtils.isNoValue(str))
             {
                   return true;
             }
           return false;
        };

        return axis;
    };

  return ret;
});
  

define('sap/viz/modules/axis/TrellisLeft',['sap/viz/base/utils/oo',
'sap/viz/modules/axis/BaseCategory',
'sap/viz/modules/dispatch',
'sap/viz/modules/axis/trellisLeftCore'],
function Setup(oo, BaseCategory, dispatch, trellisLeftCore) {
    var axis = function(manifest, ctx) {
        axis.superclass.constructor.apply(this,arguments);

        //apply the core module. You may need to replace it to your own core.
        axis.prototype.setCoreModule(trellisLeftCore);
    };

    //the start point
    oo.extend(axis,BaseCategory);
    
    //overwritten fun
    axis.prototype.render = function(selection)
    {
        axis.superclass.render.call(this, selection, true);
        return this;
    };

    return axis;
});

define('sap/viz/modules/manifests/axis/TrellisLeft',['sap/viz/modules/manifests/Module','sap/viz/modules/Constants',
'sap/viz/modules/axis/TrellisLeft'],
function Setup(Manifest, Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.axis.TrellisLeft',
    'type' : Constants.Type.Supplementary,
    'name' : 'TrellisLeft',
    'base' : "sap.viz.modules.axis",
    'properties' : {
    },
    'css' : {
      '.v-title' : {
        'description' : 'Define style for the title.',
        'value' : {
          'fill' : '#333333',
          'font-family' : "Helvetica Neue, Helvetica, Arial, sans-serif",
          'font-size' : '12px',
          'font-weight' : 'bold'
        }
      },
      '.v-label' : {
        'description' : 'Define style for the label.',
        'value' : {
          'fill' : '#333333',
          'font-family' : "Helvetica Neue, Helvetica, Arial, sans-serif",
          'font-size' : '12px',
          'font-weight' : 'normal'
        }
      }    
    },
    'configure' : null,
    fn : fn
  };
  Manifest.register(module);
});

define('sap/viz/manifests/trellis/BaseTrellisChart',['sap/viz/manifests/Viz', 'sap/viz/modules/manifests/RootContainer', 
'sap/viz/modules/manifests/Title', 'sap/viz/modules/manifests/DivContainer', 
'sap/viz/modules/manifests/Legend', 'sap/viz/modules/manifests/DataLabel', 
'sap/viz/modules/manifests/legend/Common', 'sap/viz/modules/manifests/PlotContainer',
'sap/viz/modules/manifests/axis/TrellisTop',
'sap/viz/modules/manifests/axis/TrellisLeft'], 
function Setup(Manifest) {
  var chart = {
    id : 'viz/base/trellis',
    name : 'IDS_BASETRELLISCHART',
    base : 'riv/base',
    'abstract' : true,

    modules : {
      root : {
        id : 'sap.viz.modules.divcontainer',
        configure : {
          propertyCategory : 'root'
        },
        modules : {
          main : {
            id : 'sap.viz.modules.trelliscontainer',
            configure : {
              propertyCategory : 'multiLayout',
              properties : {
                mergeDataRange : ['primary'],
                layout : {
                  position : 'center',
                  priority : 1
                }
              }
            },
            modules : {
              trellisXAxis : {
                id : 'sap.viz.modules.axis.TrellisTop',
                configure : {
                  'description' : 'Settings for the column axis of multiple charts.',
                  propertyCategory : 'columnAxis',
                  properties : {
                    title : {
                      visible : false
                    },
                    gridline : {
                      visible : true
                    },
                    color : '#d8d8d8',
                    type : 'category',
                    position : 'top'
                  },
                  propertiesOverride : {
                    label : {
                      isExported : false
                    },
                    axisline : {
                      isExported : false
                    },
                    gridline : {
                      isExported : false,
                      color : {
                        isExported : false
                      },
                      size : {
                        isExported : false
                      }
                    },
                    scale : {
                      fixedRange : {
                        isExported : false
                      },
                      minValue : {
                        isExported : false
                      },
                      maxValue : {
                        isExported : false
                      },
                      isExported : false
                    }
                  }
                }
              },
              trellisYAxis : {
                id : 'sap.viz.modules.axis.TrellisLeft',
                configure : {
                  description : 'Settings for the row axis of multiple charts.',
                  propertyCategory : 'rowAxis',
                  properties : {
                    type : 'category',
                    position : 'left',
                    title : {
                      visible : false
                    },
                    color : '#d8d8d8',
                    gridline : {
                      visible : true
                    }
                  },
                  propertiesOverride : {
                    label : {
                      isExported : false
                    },
                    axisline : {
                      isExported : false
                    },
                    gridline : {
                      isExported : false,
                      color : {
                        isExported : false
                      },
                      size : {
                        isExported : false
                      }
                    },
                    scale : {
                      fixedRange : {
                        isExported : false
                      },
                      minValue : {
                        isExported : false
                      },
                      maxValue : {
                        isExported : false
                      },
                      isExported : false
                    }
                  }
                }
              },
              plot : { id : 'sap.viz.modules.plotContainer' }
            }

          }
        }
      }
    },
    feeds : {},
    dependencies : {}
  };

  Manifest.register(chart);
});

define('sap/viz/modules/trelliscontainer',['sap/viz/base/utils/TypeUtils','sap/viz/base/utils/Objects','sap/viz/base/utils/FunctionUtils',
'sap/viz/modules/layout','sap/viz/modules/util/DimensionalInfoHandler','sap/viz/data/handler/MultiChartDataHandler',
'sap/viz/modules/manifests/Module','sap/viz/data/MultiAxesDataAdapter',
'sap/viz/modules/dispatch','sap/viz/modules/util/BoundUtil','sap/viz/util/ignite',
'sap/viz/util/fn/createContext','sap/viz/modules/util/dataUtil', 'sap/viz/base/UADetector'],
function Setup ( TypeUtils, Objects, Functions, layout, DIHandler, MCHandler, 
  Manifest, MultiAxesDataAdapter,dispatch, boundUtil, ignite, createContext, dataUtil, UADetector ) {
  
  var retfn =  function (manifest, ctx) {
    var width = 0, 
        height = 0,
        centerWidth = 0, //size for the real table area without table headers
        centerHeight = 0, 
        properties = {},
        //for containers we use properties to hold any properties we have to pass to sub
        //then we use this internalProps to hold properties for container itself
        internalProps = manifest.props(null),
        internalRange = {}, //used for data range merge
        multiData = {
          
        },//used to save raw data process result
        subModuleNames = [], //used to update sub modules while data updating
        subControllerNames = [], //used to update controllers while data updating  
        data = null,
        config = {},
        modules = {},
        selections = {},
        parent = null, // a d3 selection
        rows = 3,
        columns = 2,
        xCategoryScale = d3.scale.ordinal(),
        yCategoryScale = d3.scale.ordinal(),
        eDispatch = new dispatch('initialized', 'showTooltip', 'hideTooltip'), avaPlotCount = 0, avaModulesCount = 0,
        plotManifest, plotContext,
        
        MINPLOTHEIGHT = 95, 
        MINPLOTWIDTH = 184,
        FIXEDCOLUMNHEIGHT = 45,
        FIXEDROWWIDTH = 95;
    
    //for container, we won't extract properties exactly for it. so we have to
    //get property by ourselves. the property category should be consistent with
    //module definition
    var PROPERTYCATEGORY = 'multiLayout';
    var initializedPlots = 0;

    //Alex Su: we need to hold a copy of animation flag settings to control animation flow.
    // var plotAnimation = {
      // dataLoading: true,
      // dataUpdating:true,
      // resizing:true
    // };
    var bFirstCreation = true, bDataChanged = false;
    
    var PLOTAREAPROPCATE = 'plotArea';
    
    function setAnimationFlag(back){
      //Alex Su: FIXME hard coded here, need to be resolved in the future.
      var props = {};
      var propcate = (props[PLOTAREAPROPCATE] = {});
      // var animation = (propcate.animation = {});
      // Objects.extend(animation, plotAnimation);
      // if (!back && bDataChanged){
        // animation.dataLoading = plotAnimation.dataUpdating;
      // }
    }
    
    function clearInternalRange(){
      for(var i in internalRange){
        if(internalRange.hasOwnProperty(i)){
          delete internalRange[i];
        }
      }
    }
    
    function initialize() {
      if ( TypeUtils.isEmptyObject(config) ) {
        Functions.error('Container configuration missing');
      }
      
      processRawData();
      avaPlotCount = 0, avaModulesCount = 0;
      var singleData = multiData.dataHandler.getSubDataAdapter(multiData.contexts[0][0]);
      
      initAxis(config, 'trellisXAxis', multiData.columnData);
      initAxis(config, 'trellisYAxis', multiData.rowData);
      initAxis(config, 'xAxis', singleData);
      initAxis(config, 'yAxis', singleData);
      
      initializePlot();
      updateProperties("plot");
      updateProperties("trellisXAxis");
      updateProperties("trellisYAxis");
      updatePlotData();
      initializePlotElements();
      
      avaModulesCount = avaModulesCount + avaPlotCount;
    }
    
    function processRawData() {
      delete multiData.contexts;
      delete multiData.columnData;
      delete multiData.rowData;
      delete multiData.dataHandler;
      //get dimensional info
      //FIXME jimmy/8/8/2012, we assume to use dimensional layout by default
      //we may need support other layouts
      //FIXME jimmy/8/8/2012, how to know which feed is for multiplier?
      var dih = DIHandler({ 
        'numberOfDimensionsInColumn' : internalProps.numberOfDimensionsInColumn
      }, data.getAnalysisAxisDataByIdx(0));//data['sap.viz.multiplier']);
      
      dih.process();
      
      var rowD = dih.getRowDimensionData();
      var columnD = dih.getColumnDimensionData();
      var contexts = dih.getContexts();
      rows = contexts.length;
      columns = rows > 0 ? contexts[0].length : columns;
      
      var columnData = new MultiAxesDataAdapter();
      columnData.addAnalysisAxis({key:columnData.key, index : 0, values: columnD.values});
      var rowData = new MultiAxesDataAdapter();
      rowData.addAnalysisAxis({key:rowD.key, index : 0, values: rowD.values});

      //row data has no contexts. we have to add ctx to rowData and columnData
      var rowAAData;
      var colAAData;
      if(rowData.getAnalysisAxisDataByIdx)
      {
        rowAAData = rowData.getAnalysisAxisDataByIdx(0);
      }
      if(columnData.getAnalysisAxisDataByIdx)
      {
        colAAData = columnData.getAnalysisAxisDataByIdx(0);
      }

      var i;
      var j;

      var colNum = 0;
      var rowNum = contexts.length;
      if(rowNum > 0)
      {
          colNum = contexts[0].length;
      }

      var initContexts = function(aaDataValues, index)
      {
          var i;
          for(i = 0; i < aaDataValues.length; i++)
          {
              aaDataValues[i].rows[index].contexts = [];
          }
      };

      var pushContexts = function(aaDataValues, index, ctx)
      {
          var i;
          for(i = 0; i < aaDataValues.length; i++)
          {
              aaDataValues[i].rows[index].contexts.push(ctx);
          }
      };

      //for rowData
      for(i = 0; i < rowNum; i++)
      {
        initContexts(rowAAData.values, i);
        for(j = 0; j < colNum; j++)
        {
            pushContexts(rowAAData.values, i, contexts[i][j]);
        }
      }

      //for colData
      for(i = 0; i < colNum; i++)
      {
          if(colAAData.values.length > 0)
          {
            initContexts(colAAData.values, i);
            for(j = 0; j < rowNum; j++)
            {
                pushContexts(colAAData.values, i, contexts[j][i]);
            }
          }
      }
      
      multiData.contexts = contexts;
      multiData.columnData = columnData;
      multiData.rowData = rowData;
      multiData.dataHandler = new MCHandler(data);
    }
    
    function initAxis( config, id , axisData) {
      if ( !config.modules[id] ) {
        return;
      }
      
      var axisConfig = config.modules[id],
          axis = modules[id] = ignite(axisConfig.id, ctx, 'v-m-' + id); // Saves references to axis function.
      
      updateAxisData(id, axisData);
          
      var props = {}, usrProps, sysProps;
      if ( axisConfig.configure ) {
        usrProps = properties[axisConfig.configure.propertyCategory] || {};
        sysProps = axisConfig.configure.properties || {};
        Objects.extend( true, props, sysProps, usrProps );
        axis.properties(props);
      }
      
      if(axis.dispatch && axis.dispatch()['initialized']){
        avaModulesCount++;
        axis.dispatch().on('initialized.trelliscontainer', initialized);
      }
      
      selections[id] = parent.append('div').attr('class', 'v-m-' + id);
    }
    
    function updateAxisData (id, axisData) {
      if(modules[id] && axisData){
        modules[id].data(axisData);
      }
    }
    
    function initializePlot() {
      var plotConfig = config.modules.plot;
      if ( !plotConfig ) {
        return;
      }      
      
      cleanSubControllers();
      cleanSubModules();
      
      if (!plotManifest || !plotContext) {
        plotManifest = Manifest.get(plotConfig.id);
        plotContext = createContext(plotManifest, ctx, "v-m-plot");
      }
      
      if(!modules.plot){
          modules.plot = ignite(plotManifest, plotContext);
          modules.plot.config(plotConfig); 
          selections.plot = parent.append('div').attr('class', 'v-m-plot');
          modules.plot.parentDiv(selections.plot);
      } else {
          modules.plot.reset();
      }
    }
    
    function updatePlotProperties() {
      var plot = modules.plot;
      if(plot){
        var plotConfig = config.modules.plot;
        if ( !plotConfig ) {
          return;
        }
        //Jimmy/8/23/2012 pay attention to the property structure, for container we will pass
        //all properties instead of properties under propsCat only.
        //FIXME currently it's hard coded here we assume the plot is container, actually we should
        //check the plot type
        var props = null, usrProps, sysProps;
        var nodeConfig = plotConfig.configure;
        if ( nodeConfig ) {
          sysProps = {};
          if ( nodeConfig.propertyCategory ) {
            sysProps[nodeConfig.propertyCategory]  = nodeConfig.properties;
          }
          usrProps = properties;
          props = {};
          Objects.extend( true, props, sysProps, usrProps ); 
        }else{
          props = properties;
        }
        
        if(props){
            plot.properties(props);
        }
      }
    }
    //TO FIX: remove this work around.
    function updateProperties(moduleId){
      if (moduleId === 'plot'){
        updatePlotProperties();
      }
      else{
        var module = modules[moduleId];
        if(module){
          var moduleConfig = config.modules[moduleId];
          if ( !moduleConfig ) {
            return;
          }
          var props;
          var nodeConfig = moduleConfig.configure;
          if ( nodeConfig ) {
            props = Objects.extend(true, {}, properties[ nodeConfig.propertyCategory ]);
          }else{
            props = properties;
          }
         module.properties(props); 
        }
      }
    }
    
    function updatePlotData() {
        modules.plot.rowCount(rows);
        modules.plot.columnCount(columns);        
        modules.plot.data(multiData);        
    }
    
    function initializePlotElements() {
      var plotConfig = config.modules.plot;
      if ( !plotConfig ) {
        return;
      }
           
      var plot = modules.plot;
      if(plot.modules){
        var subModules = plot.modules();
        dataUtil().updateAxisFormatString(subModules, 'xAxis', properties, plot);
        dataUtil().updateAxisFormatString(subModules, 'yAxis', properties, plot);
      }
    }
    
    function cleanSubControllers() {
      //clean all current submodules
      for(var i = 0, len = subControllerNames.length; i < len; i++){
        delete modules[subControllerNames[i]];
      }
      subControllerNames = [];
    }
    
    function cleanSubModules () {
      //clean all current submodules
      for(var i = 0, len = subModuleNames.length; i < len; i++){
        delete modules[subModuleNames[i]];
      }
      subModuleNames = [];
      
      if ( plotContext ) {
        plotContext.styleManager.cleanChildren();
      }
    }
    
    function getScrollbarSize() {
      var temp1 = parent.append('div');
      var temp2 = parent.append('div').style('overflow', 'scroll');
      var result;
      if (UADetector.isIE()) {
        temp2.style('width', temp1.style('width'));
        var width1 = temp1.style('width');
        var width2 = temp2.style('width');
        width1 = width1.indexOf('px') > 0 ? width1.slice(0, width1.indexOf('px')) : width1;
        width2 = width2.indexOf('px') > 0 ? width2.slice(0, width2.indexOf('px')) : width2;
        result = width1 - width2;
      } else {
        result = temp1.node().clientWidth - temp2.node().clientWidth;
      }
       
      temp1.remove();
      temp2.remove();
      return result;
    }

    function relayout() {
      if ( TypeUtils.isEmptyObject(modules) || !width || !height ) {
        return;
      }
      
      var trellisXAxis = {}, 
          trellisYAxis = {}, 
          xAxis = {}, 
          yAxis = {}, 
          plot = {},
          singlePlotSize = {},
          scrollable = {
            vertical : false,
            horzontal : false,
            xaxisVertical : false
          },
          scrollsize = getScrollbarSize(),
          // keep scroll bar space
          view = {
            width : width - scrollsize,
            height : height - scrollsize
          };
      
      var rowData = multiData.rowData.getAnalysisAxisDataByIdx(0);
      var columnData = multiData.columnData.getAnalysisAxisDataByIdx(0);
      var singleData = multiData.dataHandler.getSubDataAdapter(multiData.contexts[0][0]).getAnalysisAxisDataByIdx(0);
      trellisXAxis.pref = {
          width : 0,
          height : columnData.values.length * FIXEDCOLUMNHEIGHT
      };
      trellisXAxis.size = {
          width : 0,
          height : columnData.values.length * FIXEDCOLUMNHEIGHT
      };
      
      trellisYAxis.pref = {
          width : rowData.values.length * FIXEDROWWIDTH,
          height : 0
      };
      trellisYAxis.size = {
          width : rowData.values.length * FIXEDROWWIDTH,
          height : 0
      };
      
      xAxis.pref = {
        width : 0,
        height : singleData.values.length * FIXEDCOLUMNHEIGHT
      };
      xAxis.size = {
        width : 0,
        height : (singleData.values.length > 2 ? 2 : singleData.values.length) * FIXEDCOLUMNHEIGHT
      };
      scrollable.xaxisVertical = (singleData.values.length > 2);
      
      plot.size = {
        width : 0,
        height : view.height - trellisXAxis.size.height - xAxis.size.height
      };
      
      if (MINPLOTHEIGHT * rows <= plot.size.height) {
        singlePlotSize.height = plot.size.height / rows;
      } else {
        singlePlotSize.height = plot.size.height / Math.floor(plot.size.height / MINPLOTHEIGHT);
        scrollable.vertical = true;
      }
      //singlePlotSize.height -= 1;
      
      plot.pref = {
        width : 0,
        height : singlePlotSize.height * rows
      };
      
      yAxis.pref = {
        width : 0,
        height : plot.pref.height
      };
      yAxis.size = {
        width : 0,
        height : plot.size.height
      };
      
      modules.plot.cellSize({
        width : singlePlotSize.width,
        height : singlePlotSize.height
      });
      
      modules.yAxis.axisnumber(rows);
      var p = modules.yAxis.getPreferredSize();
      yAxis.size.width = p.realWidth ? p.realWidth : 0;
      yAxis.pref.width = p.realWidth ? p.realWidth : 0;
      
      plot.size.width = view.width - trellisYAxis.size.width - yAxis.size.width;
      
      if (MINPLOTWIDTH * columns <= plot.size.width) {
        singlePlotSize.width = plot.size.width / columns;
      } else {
        singlePlotSize.width = plot.size.width / Math.floor(plot.size.width / MINPLOTWIDTH);
        scrollable.horzontal = true;
      }

      plot.pref.width = singlePlotSize.width * columns;
      
      modules.plot.cellSize({
        width : singlePlotSize.width,
        height : singlePlotSize.height
      });
      
      trellisXAxis.pref.width = plot.pref.width;
      trellisXAxis.size.width = plot.size.width;
      trellisYAxis.size.height = plot.size.height;
      trellisYAxis.pref.height = yAxis.pref.height;
      xAxis.pref.width = plot.pref.width;
      xAxis.size.width = plot.size.width;
      
      xAxis.pref.height -= 3;
      
      
      if (scrollable.vertical) {
        plot.size.width += scrollsize;
      }
      if (scrollable.horzontal) {
        xAxis.size.height += scrollsize;
      }
      if (scrollable.xaxisVertical) {
        xAxis.size.width += scrollsize;
      }
      
      trellisXAxis.selection = selections.trellisXAxis;
      trellisYAxis.selection = selections.trellisYAxis;
      xAxis.selection = selections.xAxis;
      yAxis.selection = selections.yAxis;
      plot.selection = selections.plot;
      
      
      
      var west = {
        width : 0,
        height : 0
      },
      north = {
        width : 0,
        height : 0
      },
      south = {
        width : 0,
        height : 0
      };
      if (trellisYAxis.pref) {
        west.width += trellisYAxis.pref.width;
      }
      if (yAxis.pref) {
        west.width += yAxis.pref.width;
      }
      if (trellisXAxis.pref) {
        north.height += trellisXAxis.pref.height;
      }
      if (xAxis.pref) {
        south.height += xAxis.pref.height;
      }
      
      trellisXAxis.pos = {
        left : west.width,
        top : 0
      };
      
      trellisYAxis.pos = {
        left : 0,
        top : north.height
      };
      
      xAxis.pos = {
        left : west.width,
        top : trellisXAxis.size.height + trellisYAxis.size.height
      };
      
      yAxis.pos = {
        left : trellisYAxis.size.width,
        top : north.height
      };
      
      plot.pos = {
        left : yAxis.size.width + trellisYAxis.size.width,
        top : trellisXAxis.size.height
      };
      
      trellisXAxis.selection.style('position', 'absolute').style('overflow', 'hidden')
          .style('width', trellisXAxis.size.width + 'px').style('height', trellisXAxis.size.height + 'px')
          .style('left', trellisXAxis.pos.left + 'px').style('top', trellisXAxis.pos.top + 'px');
      
      trellisYAxis.selection.style('position', 'absolute').style('overflow', 'hidden')
          .style('width', trellisYAxis.size.width + 'px').style('height', trellisYAxis.size.height + 'px')
          .style('left', trellisYAxis.pos.left + 'px').style('top', trellisYAxis.pos.top + 'px');
          
      xAxis.selection.style('position', 'absolute').style('overflow', 'auto')
          .style('width', xAxis.size.width + 'px').style('height', xAxis.size.height + 'px')
          .style('left', xAxis.pos.left + 'px').style('top', xAxis.pos.top + 'px');
          
      yAxis.selection.style('position', 'absolute').style('overflow', 'hidden')
          .style('width', yAxis.size.width + 'px').style('height', yAxis.size.height + 'px')
          .style('left', yAxis.pos.left + 'px').style('top', yAxis.pos.top + 'px');
          
      var plotOverflow = scrollable.vertical ? 'auto' : 'hidden';
      plot.selection.style('position', 'absolute').style('overflow-x', 'hidden').style('overflow-y', plotOverflow)
          .style('width', plot.size.width + 'px').style('height', plot.size.height + 'px')
          .style('left', plot.pos.left + 'px').style('top', plot.pos.top + 'px');
      
      
          
      centerWidth = plot.pref.width;
      centerHeight = plot.pref.height;
      xCategoryScale.rangeBands([0, centerWidth]);
      yCategoryScale.rangeBands([0, centerHeight]);
      
      modules.plot.width(plot.size.width).height(plot.size.height);
      modules.yAxis.width(yAxis.pref.width).height(yAxis.pref.height);
      modules.xAxis.width(xAxis.pref.width).height(xAxis.pref.height);
    }
    
    
    function dataRange(type) {
        return function(range) {
            if (!arguments.length) {
                return internalRange[type];
            } else {
                if (!internalRange[type]) {
                    internalRange[type] = range;
                } else {
                    var currentRange = internalRange[type];
                    if (range.distinctValuesObj) {
                        for (var i in range.distinctValuesObj) {
                            if (range.distinctValuesObj.hasOwnProperty(i)){
                              currentRange.distinctValuesObj[i] = range.distinctValuesObj[i];
                            }
                        }
                    }
                    
                    if (range.min < currentRange.min) {
                        currentRange.min = range.min;
                    }
                    if (range.max > currentRange.max) {
                        currentRange.max = range.max;
                    }
                    
                    if (range.hasNoValue) {
                      currentRange.hasNoValue = true;
                    }

                }
            }
        };
    }

    
    function resolveMergeDataRange (types){
      //for each type we will generate a function to set/get data range
      for(var i = 0, len = types.length; i < len; i++){
        container[types[i] + 'DataRange'] = dataRange(types[i]);
      }
    }
    
    function parseProperties (props){
      properties = props;
      // if (properties[PLOTAREAPROPCATE]){
        // Objects.extend(plotAnimation, properties[PLOTAREAPROPCATE].animation);
      // }
      if(props[PROPERTYCATEGORY]){
        if(props[PROPERTYCATEGORY].mergeDataRange){
          internalProps.mergeDataRange = props[PROPERTYCATEGORY].mergeDataRange;
          resolveMergeDataRange(internalProps.mergeDataRange);
        }
        var formerDimsInCol = internalProps.numberOfDimensionsInColumn;
        Objects.extend(true, internalProps, props[PROPERTYCATEGORY]);
        if (modules.plot && formerDimsInCol !== internalProps.numberOfDimensionsInColumn){
          processRawData();
          clearInternalRange();
          updateAxisData('xAxis', multiData.columnData);
          updateAxisData('yAxis', multiData.rowData);
          updateAxisData('xAxis2', multiData.columnData);
          updateAxisData('yAxis2', multiData.rowData);
          updatePlotData();
        }
      }
    }
    
    function buildXCateScale(){
      var domain = [];
      for (var i = 0; i < columns; i++){
         domain.push(i);
      }

      xCategoryScale.domain(domain).rangeBands([0, centerWidth]);
    }
    
    function buildYCateScale(){
      var domain = [];
      for (var i = 0; i < rows; i++){
         domain.push(i);
      }

      yCategoryScale.domain(domain).rangeBands([0, centerHeight]);
    }

    function container( selection ) {
      relayout();
      selection.each(function ( data ) {
        //Alex Su: if detected data changing, we set sub plot's dataLoading with container's dataUpdating to control its animation
        if (!bFirstCreation && bDataChanged){
          setAnimationFlag();
        }
        initializedPlots = 0;
        parent = selection;
        boundUtil.drawBound(selection, width, height);
        if(selections.plotRoot){
          boundUtil.drawBound(selections.plotRoot, centerWidth, centerHeight);
        }
        if ( TypeUtils.isEmptyObject(modules) ){ 
          initialize();
        }
        render();
        //Alex Su: and set animation flags back after rendering.
        if (!bFirstCreation && bDataChanged){
          setAnimationFlag(true);
        }
      });
      
      selections.xAxis.node().onscroll = function() {
        var scrollLeft = selections.xAxis.node().scrollLeft;          
        selections.trellisXAxis.node().scrollLeft = selections.plot.node().scrollLeft = scrollLeft;        
        modules.plot.scrollLeft(scrollLeft);
        
        var scrollTop = selections.xAxis.node().scrollTop;
        var xAxisTitle = modules.xAxis.getTitleSelection(selections.xAxis);
        xAxisTitle.node().scrollTop = scrollTop;
      };
      selections.plot.node().onscroll = function() {
        var scrollTop = selections.plot.node().scrollTop;          
        selections.trellisYAxis.node().scrollTop = selections.yAxis.node().scrollTop = scrollTop;        
        modules.plot.scrollTop(scrollTop);
      };
      
      bFirstCreation = false, bDataChanged = false;
      return container;
    }
    
    container.width = function (_) {
      if ( !arguments.length ) {
        return width;
      }
      width = _;
      clearInternalRange();//Alex Su: internal data range needs reset, too.
      //Jimmy,8/20/2012, as a container, you don't know whether your
      //sub elements need relayout even if the container size remains
      //the same. so here we just give a chance to sub elements to relayout
      relayout();
      return container;
    };
    
    container.height = function (_) {
      if ( !arguments.length ) {
        return height;
      }
      height = _;
      //see @width
      clearInternalRange();
      relayout();
      return container;
    };
    
    container.size = function(_) {
      if ( !arguments.length ) {
        return {
          'width' : width,
          'height' : height
        };
      }
      height = _.height;
      width = _.width;
      //see @width
      clearInternalRange();
      relayout();
      return container;
    };
    
    container.data = function (_) {
      if ( !arguments.length ) {
        return data;
      }
      bDataChanged = true;
      var bDataSchmaChanged = false;
      if (! dataUtil().hasSameSchema(data, _)){
        bDataSchmaChanged = true;
      }
       data = _;
      
      //clean internal data range
       clearInternalRange();      
       
      if(!TypeUtils.isEmptyObject(modules)){
        processRawData();

        if (bDataSchmaChanged){
          avaModulesCount = avaModulesCount - avaPlotCount;
          updateAxisData('xAxis', multiData.columnData);
          updateAxisData('yAxis', multiData.rowData);
          updateAxisData('xAxis2', multiData.columnData);
          updateAxisData('yAxis2', multiData.rowData);
          
          avaPlotCount = 0;
          //Jimmy/9/13/2012 we may have chance to split data update and data
          //schema update in the future
          //done by Alex Su
          initializePlot();
          updateProperties("plot");
          updateProperties("xAxis2");
          updateProperties("yAxis");        
          updatePlotData();
          initializePlotElements();
          
          avaModulesCount = avaModulesCount + avaPlotCount;
          
        } else {
          updateAxisData('xAxis', multiData.columnData);
          updateAxisData('yAxis', multiData.rowData);
          updateAxisData('xAxis2', multiData.columnData);
          updateAxisData('yAxis2', multiData.rowData);
          updatePlotData();
        }
          
      }
      return container;
    };
    
    container.properties = function (_) {
      if ( !arguments.length ) {
        //Alex Su: for a container, it accept a full list properties including its submodules' but return its private ones.
        return internalProps;
      }
      //FIXME JIMMY/8/8/2012, columns/rows may be different with different properties
      if(!TypeUtils.isEmptyObject(_)){
        parseProperties(_);
      }
      
      //update properties of sub plots
      if(!TypeUtils.isEmptyObject(modules)){
        ///*Jimmy/9/19/2012, we may need deal with internalProps.numberOfDimensionsInColumn update
        //we don't need recreate plots but we need rearrange plots and change data*/
        //^^ fixed by Alex Su
        updateProperties("plot");
        updateProperties("xAxis2");
        updateProperties("yAxis");        
      }
      return container;
    };
    
    container.config = function (_) {
      if ( !arguments.length ) {
        return config;
      }
      config = _;
      return container;
    };
    
    container.xCategoryScale = function (_) {
      if ( !arguments.length ) {
        buildXCateScale();
        return xCategoryScale;
      }
      xCategoryScale = _;
      return container;
    };
    
    container.yCategoryScale = function (_) {
      if ( !arguments.length ) {
        buildYCateScale();
        return yCategoryScale;
      }
      yCategoryScale = _;
      return container;
    };
    
    container.modules = function (_) {
      if ( !arguments.length ) {
        if ( TypeUtils.isEmptyObject(modules) ) {
          initialize();
        } 
        return modules;
      }
      modules = _;
      return container;
    };
    
    container.parent = function (_) {
      if ( !arguments.length ) {
        return parent;
      }
      parent = _;
      return container;
    };
    
    container.dispatch = function(_){
      if( !arguments.length){
        return eDispatch;
      }
      eDispatch = _;
      return container;
    };

    container.infoForSizeLegend = function() {
      var plot;
      for ( var i = -1, j = modules.plot.length; ++i < j;) {
        plot = modules.plot[i];
        if (plot){
          break;
        }
      }
      return {
        space : plot ? (width - centerWidth + plot.infoForSizeLegend().space * columns) : 0,
        number : columns,
        plotHeight : plot ? plot.height() : 0
      };
    };
    
    container.plotRegion = function () {
      return {
        selection: selections.plotRoot,
        width: centerWidth,
        height: centerHeight
      };
    };
    
    container.destroy = function(){
        
        if(xCategoryScale){
          xCategoryScale.domain([0,1]).range([0,1]);
        }
        if(yCategoryScale){
          yCategoryScale.domain([0,1]).range([0,1]);
        }
        
        xCategoryScale = null;
        yCategoryScale = null;
        
        modules = null;
        data = null;
      //destroy ctx
      if(ctx){
        ctx.destroy();
        ctx = null;
      }
    };
    
    function renderAxis ( id ) {
      if(selections[id]){
        parent.select('.v-m-' + id).datum(modules[id].data()).call(modules[id]);
      }
    }
    
    function render() {
      renderAxis('trellisXAxis');
      renderAxis('trellisYAxis');
      renderAxis('yAxis');
      renderAxis('xAxis');
      
      if(selections.plot){
        selections.plot.datum(modules.plot.data()).call(modules.plot);
      }
    }
    
    function initialized(){
      if(++initializedPlots === avaModulesCount){
        initializedPlots = 0;
        eDispatch.initialized();
      }
    }
    
    function showTooltip(evt){
      eDispatch.showTooltip(evt);
    }
    
    function hideTooltip(evt){
      eDispatch.hideTooltip(evt);
    }
    
    return container;
  };
  
  return retfn;
  
});

define('sap/viz/modules/manifests/TrellisContainer',['sap/viz/modules/manifests/Module','sap/viz/modules/Constants','sap/viz/modules/trelliscontainer',
'sap/viz/data/feed/Constants'],
function Setup(Manifest, moduleConstants, fn, feedConstants) {
    var multiplierFeed = {
    'id' : 'multiplier',
    'name' : 'Chart Multiplier',
    'type' : feedConstants.Type.Dimension,
    'min' : 1,
    'max' : 1,
    'aaIndex' : 1,
    'acceptMND' : 0
  };

  var module = {
    'id' : 'sap.viz.modules.trelliscontainer',
    'type' : moduleConstants.Type.Container,
    'name' : 'trellis container',
    'renderto' : moduleConstants.RenderTo.DIV,
    'description': 'Settings for the subcharts layout of trellis charts.',
    'properties' : {
      'mergeDataRange' : {
        'name' : 'mergeDataRange',
        'supportedValueType' : 'String',
        'supportedValues' : ['ANY DATA RANGE NAME'],
        'defaultValue' : null,
        'description' : 'Set mergeDataRange. Specify names of data range you want to merge, we will generate corresponding functions in this module to do the real merge. for example, if \'primary\' and \'second\' are specified here, two functions will be generated: \'primaryDataRange\' and \'secondDataRange\'. the function name is the range name plus \'DataRange\'. these generated functions support both getter and setter, for setter, you can pass any number of ranges {min:NUM, max:NUM} to it to merge, then you can get the merged result through the getter.',
        'isExported' : false
      },
      'numberOfDimensionsInColumn' : {
        'name' : 'numberOfDimensionsInColumn',
        'supportedValueType' : 'PositiveInt',
        'defaultValue' : 1,
        'description' : 'Set the specified number of dimensions, retrieved from the end of the dimension list in multiplier, will be put in column when doing multiple layout.'
      }
    },
  'events' : {
   },
    'css' : null,
    'feeds' : [multiplierFeed],
    'fn' : fn
  };
  Manifest.register(module);
});
define('sap/viz/modules/axis/baseValueHelper',['jquery', 'sap/viz/util/TextUtils','sap/viz/base/utils/TypeUtils','sap/viz/util/Objects','sap/viz/base/utils/Objects','sap/viz/modules/axis/valueAxisCore','sap/viz/modules/axis/categoryAxisCore',
'sap/viz/lang/langManager','sap/viz/util/NumberUtils',
'sap/viz/modules/dispatch','sap/viz/format/FormatManager','sap/viz/modules/threeD/matrix',
'sap/viz/modules/util/BoundUtil', 'sap/viz/base/UADetector'],
function Setup(jQuery, TextUtils, TypeUtils,VizObjects, Objects, valueAxisCore, categoryAxisCore, langManager, NumberUtils, dispatch, FormatManager, matrix, BoundUtil, UADetector) {

  var ret = function(manifest, ctx) {
        //we should build the axis Data Module, and then draw the axis.
        var m_coreModule = null;

        var m_AxisDM = null;
        var m_axisCore;

        var parent = null;
        var m_width = 0;
        var m_height = 0;

        var m_isDrawBody = true;

        var m_spaceLimit = -1;

        var m_axClassName = "viz-axis";
        var m_axBodyClassName = "viz-axis-body";
        var m_axTitleClassName = "viz-axis-title";

        var m_vClassNames = 
        {
            axis:"v-axis",
            axisBody:"v-body",
            axisTitle:"v-title",
            axisLabel:"v-label"
        };

        var m_titleOffset = 11;

        var m_data = { };
        var m_dataAxis = { };
        
        var m_isTitleVisible = true;
        
        var m_props = manifest.props(null);
        
        var m_drawable = true;

        var eDispatch = new dispatch('initialized');
        
        var m_defaultColor = m_props.color;

        var m_scale = null;

        var m_effectManager;
        if(ctx)
        {
           m_effectManager = ctx.effectManager;
        }
        
        var m_title = null;
        
        var m_style = {
            "realStyle": {},
            "defaultStyle": {}
        };
        
        var getThemeStyleDef = function () {
          if(ctx)  {
              m_style.realStyle.title = Objects.extend(true, {}, ctx.styleManager.query(m_vClassNames.axisTitle));
              m_style.realStyle.label = Objects.extend(true, {}, ctx.styleManager.query(m_vClassNames.axisLabel));

              m_style.defaultStyle.title = Objects.extend(true, {}, ctx.styleManager.queryDefault(m_vClassNames.axisTitle));
              m_style.defaultStyle.label = Objects.extend(true, {}, ctx.styleManager.queryDefault(m_vClassNames.axisLabel));

              m_style.realStyle.titleString = ctx.styleManager.query(m_vClassNames.axisTitle).toString();
              m_style.realStyle.labelString = ctx.styleManager.query(m_vClassNames.axisLabel).toString();

              m_style.defaultStyle.titleString = ctx.styleManager.queryDefault(m_vClassNames.axisTitle).toString();
              m_style.defaultStyle.labelString = ctx.styleManager.queryDefault(m_vClassNames.axisLabel).toString();

              if (m_props.title.applyAxislineColor){
                m_style.realStyle.title.fill = m_props.color;
                m_style.defaultStyle.title.fill = m_props.color;
              }
          }
        };

        var m_matrix = matrix(), labelAngle = null, labelAlign = null, angle = null, tickAngle = null;
        
        var drawAll = function()
        {
            if(!m_drawable)
            {
                //do not draw bacause of smart layout
                return false;
            }
            else
            {
                if(!drawBody() && !drawTitle())
                {
                    return false;
                }
            }

            return true;
        };

        var drawTitle = function() 
        {
            return m_props.title.visible && m_props.visible;
        };

        var drawBody = function() 
        {
            if(!m_isDrawBody)
            {
                return false;
            }

            var rangeArray = m_scale.range();
            var domainArray = m_scale.domain();
            var rangeBand = null;
            if(m_props.type === "category")
            {
                rangeBand = m_scale.rangeBand();
            }

            var hasData = false;
            if(!m_props.isIndependentMode)
            {
                if(m_dataAxis)
                {
                    hasData = true;
                }
            }
            else
            {
                if(m_data)
                {
                    hasData = true;
                }
            }

            return !(!m_props.visible ||
                   (rangeArray[0] === 0 && rangeArray[rangeArray.length-1] === 0 && rangeArray.length >=2 ) ||
                   (rangeArray.length === 1 && rangeArray[0] === 0 &&
                    domainArray.length === 1 && domainArray[0] === 0 && m_props.type === "value") ||
                   ((!rangeBand || !hasData) && rangeArray.length === 1 && rangeArray[0] === 0 &&
                     domainArray.length === 1 && domainArray[0] === 0 && m_props.type === "category")    
                );
        };
        

        var buildAxisTitle = function() {
            //build axis title Text
            var title = [];
            if (m_props.title.text !== undefined && m_props.title.text !== null) {
                title = m_props.title.text;
            } else {
                var dataset = [];
                if (m_props.isIndependentMode) {
                    if (m_data) {
                        for (var dataObj in m_data) {
                            if (m_data.hasOwnProperty(dataObj)) {
                                dataset = m_data[dataObj].values;
                                break;
                            }
                        }
                    }
                } else {
                    if (m_dataAxis) {
                        dataset = m_dataAxis.values;
                    }
                }

                if(dataset)
                {
                    for (var k = 0; k < dataset.length; k++) {
                        if (dataset[k].type) {
                            if (dataset[k].type === "MND")
                            {
                                title.push(langManager.get('IDS_DEFAULTMND'));
                            }
                        } else {
                            if (dataset[k].col.val) {
                                title.push(dataset[k].col.val);
                            } else {
                                title.push(langManager.get('IDS_ISNOVALUE'));
                            }

                        }
                    }
                }
            }
            m_title = title;
            return title;
        }; 

        var axis = function (selection, isNewSVG) {

                if(isNewSVG)
                {
                    selection = selection.append("svg");
                }

                var pre = axis.getPreferredSize();
                var basicWidth = (m_width < pre.width) ? m_width : pre.width;
                var basicHeight = (m_height < pre.height) ? m_height : pre.height;
                BoundUtil.drawBound(selection, basicWidth, basicHeight);
	  
                parent = selection;
                //in axis, we cannot use data driven way like
                //        var e = selectDIV.selectAll("p")
                //.data(pdata,function(d){return d;});
             
                //e.enter().append("p")
                //.text(function(d){return d;});

                //e.exit().remove();
                //to control the redraw, because axis is not based on data, but based on scale

                //there should be only one axis Class
                var axisClass = selection.select("." + m_axClassName);

                var rangeArray = m_scale.range();
                var domainArray = m_scale.domain();
                if(!drawAll())
                {
                    //remove all the axis 
                    //to improve the performance, we should remove as less elements as possible.
                    axisClass.remove();
                }
                else
                {
                    //---we should dicide show or hide somethings because of the spaceLimit
                    var spacings = axis.getPreferredSize().spacings;

                    var titleSpace = spacings[0];
                    var bodySpace = 0;
                    for(var i = 1; i < spacings.length; i++)
                    {
                        bodySpace += spacings[i];
                    }

                    if(m_spaceLimit >= 0 && m_spaceLimit < (titleSpace + bodySpace))
                    {
                        m_isTitleVisible = false;
                    }

                    prepareProperties();

                    var core;
                    var coreScale;
                    var re = getCoreAndScale();
                    core = re.core;
                    coreScale = re.coreScale;
                    
                    var title = m_title;
                    
                    //the axis body
                    m_axisCore = core()
                                .setTitle(title)
                                .properties(m_props)
                                .style(m_style)
                                .position(m_props.position)
                                .axScale(coreScale)
                                .spaceLimit(m_spaceLimit)
                                .matrix(m_matrix)
                                .labelAngle(labelAngle)
                                .labelAlign(labelAlign)
                                .angle(angle)
                                .tickAngle(tickAngle);

                    var axisBody;
                    if(axisClass.empty())
                    {
                        axisClass = selection.append("g")
                                 .attr("class", m_axClassName + " "+ m_vClassNames.axis);

                        axisBody = axisClass.append("g")
                                  .attr("class", m_axBodyClassName + " " + m_vClassNames.axisBody);
                    }
                    else
                    {
                        //redraw axis body
                        var e=axisClass.select("." + m_axBodyClassName).remove();

                        axisBody = axisClass.append("g")
                                  .attr("class", m_axBodyClassName + " "+ m_vClassNames.axisBody);

                        axisBody = axisClass.select("." + m_axBodyClassName);
                    }

                    if(drawBody())
                    {
                        axisBody.call(m_axisCore);
                    }



                    //redraw axis title
                    var titleOffset = m_titleOffset;
                    axisClass.select("." + m_axTitleClassName).remove();

                    if(drawTitle())
                    {
                        if(m_props.title.visible && m_isTitleVisible)
                        {  
                            var pSize = m_axisCore.getPreferredSize();
                            var axTitle = axisClass.append("g")
                                  .attr("class", m_axTitleClassName + " " + m_vClassNames.axisTitle)
                                  .attr("text-anchor", "middle")
                                  .attr("fill", m_style.defaultStyle.title.fill)
                                  .attr("font-size", m_style.defaultStyle.title['font-size'])
                                  .attr("font-weight", m_style.defaultStyle.title['font-weight'])
                                  .attr("font-family", m_style.defaultStyle.title['font-family'])
                                  .append("text"); // text-align
                                  
                            if(m_props.position === "bottom")
                            {
                                if(!drawBody())
                                {
                                    pSize.height = 0;
                                }
                                  axTitle.attr("x", pSize.width/2)
                                         .attr("y", pSize.height + titleOffset)
                                         .attr("dominant-baseline", "hanging");//"auto")//"hanging")//"central");
                                    
                                  if(UADetector.isIE())
                                  {
                                      //dominant-baseline does not work
                                      var textHeight = m_style.realStyle.title['font-size'].toString();
                                      var indexPX = textHeight.indexOf("px");
                                      if(indexPX >= 0)
                                      {
                                          textHeight = textHeight.substr(0, indexPX);
                                      }
                                      axTitle.attr("y", Number(axTitle.attr("y")) + textHeight/2);
                                      axTitle.attr("dominant-baseline", "auto");
                                  }

                                TextUtils.ellipsis(title, axTitle.node(), pSize.width, m_style.realStyle.titleString);
                                
                               if(angle){
                                    var aAngle = angle * Math.PI /180;
                                    var cosAngle = Math.cos(aAngle);
                                    var sinAngle = (45 === angle) ? cosAngle : Math.sin(aAngle);
                                    var tAngle = tickAngle * Math.PI / 180;
                                    var cosTAngle = Math.cos(tAngle);
                                    var sinTAngle = Math.sin(tAngle);
                    
                                    var aaAngle = angle - 90;
                                    if( aaAngle > 90 ){
                                        aaAngle -= 180;
                                    }else if( aaAngle < -90 )(
                                        aaAngle += 180
                                    )
                                    
                                    var size = fastMeasure(title, m_style.realStyle.title)
                                    var x = ( pSize.width)/2 * sinAngle;
                                    var y = - ( pSize.width )/2 * cosAngle;
                                    
                                    x += (pSize.height + titleOffset) * cosTAngle;
                                    y += (pSize.height + titleOffset) * sinTAngle;
                                   
                                    var rotateStr ;
                                    rotateStr = 'rotate( ' + ( aaAngle) + ' ' + x + ' ' + y + ')';
                                    
                                    if(UADetector.isIE()){
                                      var textHeight = m_style.realStyle.title['font-size'].toString();
                                      var indexPX = textHeight.indexOf("px");
                                      if(indexPX >= 0)
                                      {
                                          textHeight = textHeight.substr(0, indexPX);
                                      }
                                      rotateStr += 'translate(0  '+ (textHeight) +')';
                                    }
                                    
                                    axTitle.attr('x', x).attr('y', y).attr('transform', rotateStr);
                                }
                            }
                            else if(m_props.position === "top")
                            {
                                if(!drawBody())
                                {
                                    pSize.height = 0;
                                }

                                titleHieght = fastMeasure(title, m_style.realStyle.title).height;
                                var transOffset = (title !== undefined && title !== null && title !== '' ? titleHieght + titleOffset : 0);

                                axisBody.attr("transform", "translate(0, " + transOffset + ")");

                                axTitle.attr("x", pSize.width/2)
                                  .attr("y", titleHieght)
                                  .attr("dx", "0") // padding-right
                                  .attr("dy", "0") // vertical-align: middle?
                                  .attr("dominant-baseline", "auto");//"auto")//"hanging")//"central")
                                
                                TextUtils.ellipsis(title, axTitle.node(), pSize.width, m_style.realStyle.titleString);
                            }
                            else if(m_props.position === "left")
                            {
                                if(!drawBody())
                                {
                                    pSize.width = 0;
                                }

                                //title is vertical
                                titleWidth = fastMeasure(title, m_style.realStyle.title).height;
                                var transOffset = (title !== undefined && title !== null && title !== '' ? titleWidth + titleOffset : 0);

                                axisBody.attr("transform", "translate(" + transOffset + ", " + 0 + ")");

                                var centerX = titleWidth;
                                var centerY = pSize.height/2;
                                var ac = "-90";

                                //axisClass.append("circle").attr("cx", centerX).attr("cy", centerY). attr("r", 5);
                                axTitle.attr("transform","rotate( " + ac + " " + centerX + " "  + centerY + " )")
                                  .attr("x", centerX)
                                  .attr("y", centerY)
                                  .attr("dominant-baseline", "auto");//"auto")//"hanging")//"central")
                                
                                TextUtils.ellipsis(title, axTitle.node(), pSize.height, m_style.realStyle.titleString);
                            }
                            else// if(m_props.position == "right")
                            {
                                if(!drawBody())
                                {
                                    pSize.width = 0;
                                }

                                //title is vertical
                                titleWidth = fastMeasure(title, m_style.realStyle.title).height;
                                
                                centerX = pSize.width + titleWidth/2 + titleOffset;
                                centerY = pSize.height/2;
                                var ac = "-90";

                                
                                axTitle.attr("transform","rotate( " + ac + " " + centerX + " "  + centerY + " )")
                                  .attr("x", centerX)
                                  .attr("y", centerY - titleWidth/2)
                                  .attr("dominant-baseline", "hanging")//"auto")//"hanging")//"central")

                                if(UADetector.isIE() )
                                {
                                    //dominant-baseline does not work
                                    var textHeight = m_style.realStyle.title['font-size'].toString();
                                    var indexPX = textHeight.indexOf("px");
                                    if(indexPX >= 0)
                                    {
                                        textHeight = textHeight.substr(0, indexPX);
                                    }

                                    centerY = Number(pSize.height/2) + textHeight/2;
                                    axTitle.attr("y", centerY);
                                    axTitle.attr("dominant-baseline", "auto");
                                }

                                TextUtils.ellipsis(title, axTitle.node(), pSize.height, m_style.realStyle.titleString);
                            }
                        }
                    }
                    m_isTitleVisible = true;
                }
                
            eDispatch.initialized();
            
            return axis;
        };
        
        axis.matrix = function(_){
          if(!arguments.length){
            return m_matrix;
          }
          m_matrix = _;
          return axis;
        };

        axis.style = function(_){
          if(!arguments.length){
            return m_style;
          }
          m_style = _;
          return axis;
        };

        axis.setCoreModule = function(_){
          m_coreModule = _;
          return axis;
        };
        
        axis.labelAngle = function(_){
          if(!arguments.length){
            return labelAngle;
          }
          labelAngle = pmod( _, 360);
          return axis;
        };
        
        axis.tickAngle = function(_){
          if(!arguments.length){
            return tickAngle;
          }
          tickAngle =pmod( _, 360);
          return axis;
        };
        
        axis.angle = function(_){
          if(!arguments.length){
            return angle;
          }
          angle = pmod( _, 360);
          return axis;
        };
        
        function pmod(a,m)
        {
          var ret = a % m;
          if (0 > ret)
            ret += m;
          return ret;
        }
        
        axis.labelAlign = function(_){
          if(!arguments.length){
            return labelAlign;
          }
          labelAlign = _;
          return axis;
        };
        
        axis.parent = function (_) {
          if ( !arguments.length ) return parent;
          parent = _;
          return axis;
        };

        axis.width = function(_width) {
            if (arguments.length == 0) {
                return m_width;
            }
            else {
                m_width = _width;

                if(m_props.position == "bottom" || m_props.position == "top")
                {
                    if(m_height)
                    {
                        m_spaceLimit = m_height;

                    }
                }
                else if(m_props.position == "left" || m_props.position == "right")
                {
                    if(m_width)
                    {
                        m_spaceLimit = m_width;
                    }
                }

                return axis;
            }
        };

        axis.height = function(_height) {
            if (arguments.length == 0)
                return m_height;
            
            m_height = _height;
            if(m_props.position == "bottom" || m_props.position == "top")
            {
                if(m_height)
                {
                    m_spaceLimit = m_height;

                }
            }
            else if(m_props.position == "left" || m_props.position == "right")
            {
                if(m_width)
                {
                    m_spaceLimit = m_width;
                }
            }

            
            return axis;
        };

        axis.gridlineLength = function(_gridlineLength) {
            if (arguments.length == 0)
                return m_props.gridline.length;
            m_props.gridline.length = _gridlineLength;
            return axis;
        };

        axis.startPadding = function() {
            var padding = 0;
            if(m_props.type == "value")
            {
                padding = valueAxisCore()
                         .properties(m_props)
                         .style(m_style)
                         .position(m_props.position)
                         .axScale(m_scale)
                         .startPadding();
            }
            return padding;
        };

        axis.endPadding = function() {
            var padding = 0;
            if(m_props.type == "value")
            {
                padding = valueAxisCore()
                         .properties(m_props)
                         .style(m_style)
                         .position(m_props.position)
                         .axScale(m_scale)
                         .endPadding();
            }
            return padding;
        };

        axis.mouseover = function(target){
            if(m_props.enableLabelSelection && m_props.type !== "value")
            {
                m_axisCore.mouseover(target);
            }
        };

        axis.mouseout = function(target){
            if(m_props.enableLabelSelection && m_props.type !== "value")
            {
                m_axisCore.mouseout(target);
            }
        };
        
        axis.cleanLabelAreas = function()
        {
            if(m_props.enableLabelSelection && m_props.type !== "value"
               && m_axisCore
               && m_axisCore.cleanLabelAreas)
            {
                m_axisCore.cleanLabelAreas();
            }
        };

        axis.mouseup = function(target){
            if(m_props.enableLabelSelection && m_props.type !== "value")
            {
                m_axisCore.mouseup(target);
            }
        };
        
        axis.mousedown = function(target){
            if(m_props.enableLabelSelection && m_props.type !== "value")
            {
                m_axisCore.mousedown(target);
            }
        };
                        
        axis.size = function(_size) {
            if (arguments.length == 0)
                return {
                           "width" : m_width,
                           "height": m_height,
                       };
            m_width = _size.width;
            m_height = _size.height;
            return axis;
        };
        
        /*
         * Jimmy/9/22/2012 if axis works under independentMode(boxplot for now)
         * it doesn't rely on the data passed through this API from container, instead, boxplot
         * will pass calculated data through dependency 
         */
        axis.independentData = function(_data) {
          if(m_props.isIndependentMode) {
            if (arguments.length == 0)
                return m_data;
            m_data = _data;
          }
        },

        axis.data = function(_data) {
            if (arguments.length == 0)
                return m_data;
            
            if(!m_props.isIndependentMode)
            {
              m_data = _data;
              if(_data.getAnalysisAxisDataByIdx)
              {
                m_dataAxis = m_data.getAnalysisAxisDataByIdx(0);
              }
            }
            return axis;
        };

        axis.title = function(_title) {
            if (arguments.length == 0)
                return m_title;
            m_title = _title;
            return axis;
        };

        axis.properties = function(_properties) {
            if (arguments.length == 0){
                return m_props;
            }
            var scaleRangeMinNaN = false,
                scaleRangeMaxNaN = false;
            if (_properties.scale && _properties.scale.fixedRange) {
                scaleRangeMinNaN = isNaN(Number(_properties.scale.minValue));
                scaleRangeMaxNaN = isNaN(Number(_properties.scale.maxValue));
            }

            Objects.extend(true, m_props, _properties);

            if (scaleRangeMinNaN) {
                m_props.scale.minValue = NaN;
            }
            if (scaleRangeMaxNaN) {
                m_props.scale.maxValue = NaN;
            }

            if(_properties.color)
            {
                m_props.customizedColor = _properties.color;
            }

            if (_properties.label && _properties.label.formatString && TypeUtils.isArray(_properties.label.formatString)) {
              if (TypeUtils.isArray(_properties.label.formatString[0])) {
                m_props.label.formatString = _properties.label.formatString[0][0];
              }
            }
            return axis;
        };

        axis.range = function() {
            var range = null,
                max = Number(m_props.scale.maxValue),
                min = Number(m_props.scale.minValue);
            if ((m_props.type === "value") && (m_props.scale.fixedRange)) {
                if (isNaN(max) || isNaN(min) || max>min) {
                    range = {
                        max : max,
                        min : min,
                        from : 'axis'
                    }; 
                }
            }
            return range;
        }

        axis.scale = function(_scale) {
            if (arguments.length == 0)
                return m_scale;

            m_scale = _scale;
            return axis;
        };

        axis.isDrawBody = function(_isDrawBody) {
            if (arguments.length == 0)
                return m_isDrawBody;

            m_isDrawBody = _isDrawBody;
            return axis;
        };

        axis.color = function(_color) {
          if (arguments.length == 0)
              return m_props.color;
          if (_color !== undefined){
            m_props.isAxisColorFixed = true;
          }
          if (m_props.customizedColor){
            _color = m_props.customizedColor;              
          }
          if(!_color){
              _color = m_defaultColor;
          }

          m_props = Objects.extend(true, m_props, {"color":_color});

          if (m_props.title.applyAxislineColor && _color) {
            m_style.realStyle.title.fill = _color;
            m_style.defaultStyle.title.fill = _color;
          }

          return axis;
        };

        axis.drawable = function(_drawable) {
            //drawable or not because of smart layout
            if (arguments.length == 0)
                return m_drawable;

            m_drawable = _drawable;

            return axis;
        };

        axis.getPreferredSize = function() {
            getThemeStyleDef();
            var rangeArray = [0];
            var domainArray = [0];
            if(m_scale)
            {
                rangeArray = m_scale.range();
                domainArray = m_scale.domain();
            }

            if(!m_scale || (!drawAll()) )            
            {
                return {
                    width : 0,
                    height : 0,
                    manual: false,
                };
            }
            else {
                //body size && title size
                var reCS = getCoreAndScale();
                
                var title = buildAxisTitle();
                var axisCore = (reCS.core)()
                              .setTitle(title)
                              .properties(m_props)
                              .style(m_style)
                              .position(m_props.position)
                              .axScale(reCS.coreScale)
                              .spaceLimit(m_spaceLimit);

                var resultSize;
                
                
                var titleHeight = 0;
                var titleWidth = 0;
                var titleOffset = 0;
                var axisSpacings = [];

                var sizeCore = axisCore.getPreferredSize();

                
                if(m_props.position == "bottom" || m_props.position == "top")
                {
                    if(!drawBody())
                    {
                        sizeCore.height = 0;
                        sizeCore.spacings = [];
                    }

                    if(m_props.title.visible && m_props.visible)
                    {
                        //title is vertical
                        if(title !== undefined && title !== null && title !== '') {
                            titleHeight = fastMeasure(title, m_style.realStyle.title).height;
                        } else {
                            titleHeight = 0;
                        }
                        titleOffset = titleHeight == 0 ? 0 : m_titleOffset;
                    }

                    var titleSpace = titleHeight + titleOffset;
                    axisSpacings = axisSpacings.concat([titleSpace]);
                    axisSpacings = axisSpacings.concat(sizeCore.spacings);

                    var bodySpace = 0;
                    for(var i = 1; i < axisSpacings.length; i++)
                    {
                        bodySpace += axisSpacings[i];
                    }

                    var fullHeight = titleSpace + bodySpace;
                    var realHeight = fullHeight;
                    
                    if(m_spaceLimit >= 0 && m_spaceLimit < fullHeight)
                    {
                        realHeight = sizeCore.height;//no title
                    }

                    resultSize = {
                        maxSizeConstant : 1 / 3,
                        width: sizeCore.width,
                        height: fullHeight,
                        realHeight: realHeight,
                        spacings: axisSpacings,
                        manual: false,
                        minTruncateSize : sizeCore.minTruncateSize
                    }
                }
                else if(m_props.position == "left" || m_props.position == "right")
                {
                    if(!drawBody())
                    {
                        sizeCore.width = 0;
                        sizeCore.spacings = [];
                    }

                    if(m_props.title.visible && m_props.visible)
                    {
                        //title is vertical
                        if(title !== undefined && title !== null && title !== '') {
                            titleWidth = fastMeasure(title, m_style.realStyle.title).height;
                        } else {
                            titleWidth = 0;
                        }
                        titleOffset = titleWidth == 0 ? 0 : m_titleOffset;
                    }

                    var titleSpace = titleWidth + titleOffset;
                    axisSpacings = axisSpacings.concat([titleSpace]);
                    axisSpacings = axisSpacings.concat(sizeCore.spacings);

                    var bodySpace = 0;
                    for(var i = 1; i < axisSpacings.length; i++)
                    {
                        bodySpace += axisSpacings[i];
                    }

                    var fullWidth = bodySpace + titleSpace;
                    var realWidth = fullWidth;
                    
                    if(m_spaceLimit >= 0 && m_spaceLimit < fullWidth)
                    {
                        realWidth = sizeCore.width;//no title
                    }
                    

                    resultSize = {
                        maxSizeConstant : 1 / 3,
                        width: fullWidth,
                        realWidth: realWidth,
                        height: sizeCore.height,
                        spacings: axisSpacings,
                        manual: false,
                        minTruncateSize : sizeCore.minTruncateSize
                    }
                }
                if ((m_props.type == 'category') && (m_props.layoutInfo.width > 0) && (m_props.layoutInfo.height > 0) ) {
                    resultSize.width = m_props.layoutInfo.width;
                    resultSize.realWidth = m_props.layoutInfo.width;
                    resultSize.height = m_props.layoutInfo.height;
                    resultSize.realHeight = m_props.layoutInfo.height;
                    resultSize.manual = true;
                }
                
                VizObjects.normalizeNumbersCeil(resultSize);
                return resultSize;
            }
        };

        axis.dispatch = function(_){
          if(!arguments.length)
            return eDispatch;
          eDispatch = _;return axis;
        };
        
        axis.destroy = function() {
            //destroy ctx
            if(ctx){
              ctx.destroy();
              ctx = null;
            }
            //sub destroy
            if(m_axisCore && m_axisCore.destroy){
              m_axisCore.destroy();
            }
            m_vClassNames = null;
            m_matrix.destroy();
            m_matrix = null;
            //self destroy
            parent = null;
            m_axisCore = null;
            m_dataAxis = null;
            m_data = null;
            if(m_scale){
              m_scale.domain([0,1]).range([0,1]);
            }
            m_scale = null;
        };
        
        var fastMeasure = function(_text, _style)
        {
            return TextUtils.superFastMeasure(_text, _style['font-size'],
                                                _style['font-weight'],
                                                _style['font-family']);
        };

        //Alex Su: to build a hierarchical structure basing on raw data.
        function hasMND(data){
          if (data[0].type === 'MND' || data[data.length - 1].type === 'MND'){
            return true;
          } else {
            return false;
          }
        }
        
        function hasOnlyMND(data){
          if (data.length === 1 && data[0].type === 'MND'){
            return true;
          } else {
            return false;
          }
        }
        
        function isMNDBefore(data){
          if (data[0].type === 'MND'){
            return true;
          } else {
            return false;
          }
        }
        
        function getMNDData(data){
          if (! hasMND(data)){
            return;
          }
          if (isMNDBefore(data)){
            return data[0];
          } else {
            return data[data.length - 1];
          }
        }
        
        function processRawData(data){
          if (! hasMND(data) || hasOnlyMND(data)){
            return data;
          }
          var newData = [];
          var i, j, k;
          for (i = 0; i < data.length; ++i){
            newData.push({
              col: data[i].col,
              rows: []
            });
          }
          var mndData = getMNDData(data);
          var mndLength = mndData.rows.length;
          var cateLength;
          if (isMNDBefore(data)){
            cateLength = data[1].rows.length;
            for (i = 0; i < mndLength; ++i){
              for (j = 0; j < cateLength; ++j){
                newData[0].rows.push(data[0].rows[i]);
              }
            }
            for (i = 1; i < data.length; ++i){
              for (j = 0; j < mndLength; ++j){
                //deep copy objects
                for(k = 0; k < data[i].rows.length; k++){
                  var itemDeepCopy = Objects.extend(true, {}, data[i].rows[k]);
                  newData[i].rows.push(itemDeepCopy);
                }
              }
            }
            //add the parent ctx to newData items
            for (i = 1; i < newData.length; ++i){
              for (j = 0; j < newData[i].rows.length; ++j){
                var parentCtx = newData[0].rows[j].ctx;
                var selfCtx = newData[i].rows[j].ctx;

                //merge ctx
                selfCtx = Objects.extend(true, selfCtx, parentCtx);
                newData[i].rows[j].ctx = selfCtx;
              }
            }
          } else {
            cateLength = data[0].rows.length;
            for (i = 0; i < cateLength; ++i){
                var iItem;
                var mNum = data[data.length - 1].rows.length;
                for(iItem = 0; iItem < mNum; iItem++)
                {
                    newData[newData.length - 1].rows.push(Objects.extend(true, {}, data[data.length - 1].rows[iItem]));

                    //add the parent ctx to rows items
                    if(data.length >= 2)
                    {
                        var parentCtx = data[data.length - 2].rows[i].ctx;
                        var selfCtx = Objects.extend(true, {}, data[data.length - 1].rows[iItem].ctx);

                        //merge ctx with data[data.length - 2].rows[i]
                        selfCtx = Objects.extend(true, selfCtx, parentCtx);
                        newData[newData.length - 1].rows[i*mNum + iItem].ctx = selfCtx;
                    }
                }
            }

            for (i = 0; i < data.length - 1; ++i){
              for (j = 0; j < cateLength; ++j){
                for (k = 0; k < mndLength; ++k){
                  newData[i].rows.push(data[i].rows[j]);
                }
              }
            }
          }
          return newData;
        }
        
        function buildHierarchicalData(data){
          var i,j;
          var categoryHierarchicalData = [];
          var rowData, cellData, spaceCount;
          var tempCellCount, tempSpaceCount;
          for (i = 0; i < data.length; ++i){
            rowData = [];
            spaceCount = 0;
            tempSpaceCount = 0;
            tempCellCount = 0;
            var tempLabelContexts = [];
            for (j = 0; j < data[i].rows.length; ++j){
              cellData = {};
              if (i === data.length - 1){
                cellData.value = data[i].rows[j];
                cellData.space = 1;
              } else {
                ++spaceCount;
                ++tempSpaceCount;
                if (i > 0 && tempSpaceCount >= categoryHierarchicalData[i - 1][tempCellCount].space){
                  cellData.value = data[i].rows[j];
                  cellData.space = spaceCount;
                  spaceCount = 0;
                  tempSpaceCount = 0;
                  ++tempCellCount;
                }
                else {
                  if (j + 1 < data[i].rows.length && data[i].rows[j].val === data[i].rows[j + 1].val){

                    if(data[i].rows[j].ctx)
                    {
                        tempLabelContexts.push(data[i].rows[j].ctx);
                    }

                    if(data[i].rows[j].contexts)
                    {
                        tempLabelContexts = tempLabelContexts.concat(data[i].rows[j].contexts);
                    }
                    continue;
                  }
                  else {
                    cellData.value = data[i].rows[j];
                    cellData.space = spaceCount;
                    spaceCount = 0;                  
                  }
                }                
              }

              if(data[i].rows[j].ctx)
              {
                tempLabelContexts.push(data[i].rows[j].ctx);
              }

              if(data[i].rows[j].contexts)
              {
                  tempLabelContexts = tempLabelContexts.concat(data[i].rows[j].contexts);
              }

              cellData.value.labelContexts = tempLabelContexts;
              rowData.push(cellData);
              tempLabelContexts = [];
            }
            categoryHierarchicalData.push(rowData);
          }
          return categoryHierarchicalData;
        }
                
        function processData(data){
          var newData = processRawData(data);
          var hierarchicalData = buildHierarchicalData(newData);
          return hierarchicalData;
        }
        
        function reverseHierarchicalData(hData){
          for (var i = 0; i < hData.length; ++i){
            hData[i].reverse();
          }
        }
        
        var getCoreAndScale = function()
        {
            var re = { };
            var core;
            var coreScale;
            if(m_props.type == "category") //a new scale is required
            {
                coreScale = [];
                //build labels (domain)
                var dataset = [];
                if(m_props.isIndependentMode) {
                    for(dataObj in m_data) {
                        dataset = m_data[dataObj].values;
                    }
                } else {
                    if(m_dataAxis) {
                        dataset = m_dataAxis.values;
                    }
                }
                var hierarchicalData = [];
                if (dataset && dataset.length){
                  hierarchicalData = processData(dataset);
                }
                //reverse domain or not,
                var oRange = m_scale.range();
                //by yuanhao 2012-12-17 ,
                if(oRange[0] > oRange[oRange.length -1 ])
                {
                    reverseHierarchicalData(hierarchicalData);
                }
                //if orRangeBand is 0, which means module do not use ordinal scale like normal, the scale is not equal every unit.
                var dataCount = hierarchicalData.length === 0 ? 0 : hierarchicalData[hierarchicalData.length - 1].length;
                var orRangeBand = m_scale.rangeBand(), orRangeBands = [];
                
                //Alex Su. Handling for boxplot.
                var isBoxPlotWithSingleAAFeed = false;
                if (dataset && dataset.length > 0 && dataset[0].rows.length === 0){
                  isBoxPlotWithSingleAAFeed = true;
                  dataCount = 1;
                  var cellData = {
                      value: {},
                      space: 1
                  };
                  
                  //add ctxs
                  var ctxs = [];
                  if(m_dataAxis.values)
                  {
                      var iItem;
                      for(iItem = 0; iItem < m_dataAxis.values[0].rows.length; iItem++)
                      {
                          ctxs.push(m_dataAxis.values[0].rows[iItem].ctx);
                      }
                  }

                  cellData.value = {
                      val: !m_dataAxis.values ? null : m_dataAxis.values[0].col.val,
                      labelContexts: ctxs
                  };
                  
                  hierarchicalData = [[cellData]];
                }
                
                var di;
                if(!m_scale.noEqual){
                  if (! hasOnlyMND(dataset) && ! isBoxPlotWithSingleAAFeed){
                    for(di = 0; di < dataCount; di++){
                        orRangeBands[di] = orRangeBand;
                    }
                  } else {
                    var tickSpace = parseInt(oRange.length / dataCount, 10);
                    for(di = 0; di < dataCount; di++){
                      orRangeBands[di] = orRangeBand * tickSpace;
                    }
                  }
                }else{
                  for(di = 0; di < dataCount; di++){
                      orRangeBands[di] = Math.abs(oRange[di] - oRange[di+1]);
                  }
                }
                
                function getRangeEnd(rangeStart, startIndex, spaceCount){
                    var sum = rangeStart;
                    for(var ix = 0; ix < spaceCount; ix++){
                        sum +=orRangeBands[startIndex + ix];
                    }
                    return sum;
                }
                var coreScaleItem = {};
                var cgDomain = [];
                var cgRange = [];
                var i, j, spaceCount = 0;
                var startIndex;
                var rangeStart, rangeEnd;
                for (i = 0; i < hierarchicalData.length; ++i){
                  cgDomain = [];
                  cgRange = [];
                  spaceCount = 0;
                  startIndex = 0;
                  for (j = 0; j < hierarchicalData[i].length; ++j){
                    spaceCount = 0;
                    cgDomain.push(hierarchicalData[i][j].value);
                    
                    spaceCount += hierarchicalData[i][j].space;
                    rangeStart = j > 0 ? cgRange[j - 1][1] : 0;
                    rangeEnd = getRangeEnd(rangeStart, startIndex, spaceCount);
                    startIndex += spaceCount;

                    cgRange.push([rangeStart, rangeEnd]);
                  }
                  var coreScaleItem = { 
                      "domain": cgDomain, 
                      "range":  cgRange,
                   };
       
                  coreScale.push(coreScaleItem);//add to the latest
                }
                
                core = m_coreModule;
            }
            else //value axis
            {   
                core = m_coreModule;
                coreScale = m_scale;
            }
            re.core = core;
            re.coreScale = coreScale;
            re.coreScale.noEqual = m_scale.noEqual;
            return re;
        }
        
        function prepareProperties()
        {
            if (!m_effectManager) return;

            if(m_props.customizedColor) {
                m_props.color = m_props.customizedColor;
            }
            var parameter = {
                    drawingEffect : 'normal',
                    fillColor : m_props.color,
            };
            m_props.color = m_effectManager.register(parameter);

            parameter = {
                drawingEffect : 'normal',
                fillColor : m_props.gridline.color,
            };
            m_props.gridline.color = m_effectManager.register(parameter);
            
            parameter = {
                    drawingEffect : 'normal',
                    fillColor : m_style.defaultStyle.label.fill,
            };
            m_style.defaultStyle.label.fill = m_effectManager.register(parameter);

            parameter = {
                    drawingEffect : 'normal',
                    fillColor : m_style.defaultStyle.title.fill,
            };
            m_style.defaultStyle.title.fill = m_effectManager.register(parameter);
        }

        return axis;
    };
  return ret;
});

define('sap/viz/modules/axis/baseValueCore',['jquery', 'sap/viz/modules/Constants', 'sap/viz/util/TextUtils','sap/viz/util/NumberUtils','sap/viz/base/utils/Objects','sap/viz/format/FormatManager',
'sap/viz/modules/threeD/Point','sap/viz/modules/threeD/matrix', 'sap/viz/base/UADetector'],
function Setup(jQuery, ModuleConstants, TextUtils, NumberUtils, Objects, FormatManager, Point, matrix, UADetector) {

  var ret = function() {
   
        var m_position;
        var m_axScale = null;

        var m_tickSize = 5;
        var m_textOffset = 6;

        var m_axDefaultTickNum = 7;

        var m_styleLineSrokeWidth = 1;
        var m_styleAxisColor = "#6c6c6c";
        var m_styleGridLineColor = "#d8d8d8";
        var m_styleGridIncisedLineColor = "#ffffff";
        var m_styleAxisLabelColor = "#333333";
        
        var m_axLabelClassName = "viz-axis-label";        
        
        var m_style = null;
        var m_props = { 
            "title": {"visible": false, "text": undefined,},
            "gridline": {"visible": true, "color": m_styleGridLineColor, "showFirstLine": false, "length": 0, "showLastLine": false, "type":"line"},
            "type" : "value",
            "visible" : true,
            "label": {"visible": true, "numberFormat" : "","formatString": "", },
            "position": "left",
            "color": m_styleAxisColor,
            "axisline" : {"visible": true},
            "shapeRendering": true
        };

        var m_vClassNames = 
        {
            axis:"v-axis",
            axisBody:"v-body",
            axisTitle:"v-title",
            axisLabel:"v-label",
            axisLine: "v-valueaxisline",
            gridLine: "v-gridline",
            incisedGridLine: "v-incised-gridline",
            fixedAxisLine: "v-fixed-valueaxisline",
            morphableLabel:ModuleConstants.CSS.CLASS.MORPHABLELABEL
        };
        
        var m_axisLabelClassCombined = m_vClassNames.axisLabel + ' ' + m_axLabelClassName + ' ' + m_vClassNames.morphableLabel;

        var m_matrix = matrix(), labelAngle = null, labelAlign = null, angle = null, tickAngle = null;
        
        var m_spaceLimit = -1;
        axis.spaceLimit = function(_spaceLimit)
        {
            if (!arguments.length) 
                return m_spaceLimit;
            m_spaceLimit = _spaceLimit;
            return axis;
        }

        function axis(selection) {
                
                var axRange = m_axScale.range();//[0, 500]
                var axDomain = m_axScale.domain();//[-100, 2000]

                if(axRange[0] == 0 && axRange[1] == 0)
                {
                    return;//do not draw value axis
                }

                var axTicksLabels = getTicksLabel();

                if(m_position == "bottom")
                {
                    var maxTextHeight = 0;
                    if(m_props.label.visible) {
                        var textArray = [];
                        for(var i = 0; i < axTicksLabels.length; i++)
                        {
                            textArray.push(axTicksLabels[i].text);
                        }
                        maxTextHeight = maxLabelTextHeight(textArray);
                    }
                    if  ((m_spaceLimit != -1) && (maxTextHeight + m_tickSize + 2*m_textOffset + m_styleLineSrokeWidth/2 > m_spaceLimit)) {
                        axTicksLabels = [];
                        maxTextHeight = 0;
                    }

                    for(var i = 0; i < axTicksLabels.length; i++)
                    {
                        var axTick = selection.append("line")
                        .attr("class", m_props.isAxisColorFixed ? m_vClassNames.fixedAxisLine : m_vClassNames.axisLine)
                                    .attr("x1", m_axScale(axTicksLabels[i].value))
                                    .attr("x2", m_axScale(axTicksLabels[i].value))
                                    .attr("y1", 0)
                                    .attr("y2", m_tickSize + 1)//line contains the first but not the last point
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");

                        if(angle){
                            var aAngle = angle * Math.PI /180;
                            var cosAngle = Math.cos(aAngle);
                            var sinAngle = (45 === angle) ? cosAngle : Math.sin(aAngle);
                            var tAngle = tickAngle * Math.PI / 180;
                            var cosTAngle = Math.cos(tAngle);
                            var sinTAngle = Math.sin(tAngle);
                            
                            var tickStartX  =   m_axScale(axTicksLabels[i].value) * sinAngle;
                            tickStartY =  -m_axScale(axTicksLabels[i].value) * cosAngle;
                            var x2 = tickStartX + ( m_tickSize + 1) * cosTAngle,
                              y2 = tickStartY + ( m_tickSize + 1) * sinTAngle;
                              
                            axTick.attr('x1', tickStartX).attr('y1', tickStartY).attr('x2', x2).attr('y2', y2);  
                          }
                        
                        var drawLine = function()
                        {
                             var line = selection.append("line")
                             .attr("class", m_vClassNames.gridLine)
                            .attr("x1", m_axScale(axTicksLabels[i].value))
                            .attr("x2", m_axScale(axTicksLabels[i].value))
                            .attr("y1", -m_props.gridline.length)
                            .attr("y2", 0)
                            .attr("stroke", m_props.gridline.color)
                            .attr("stroke-width", m_props.gridline.size)
                            .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");

                            if(m_props.gridline.type == "dotted")
                            {
                                 line.attr("stroke-dasharray", "3, 2");
                            }
                            
                            if(m_props.gridline.type == "incised")
                            {
                                var line = selection.append("line")
                                .attr("class", m_vClassNames.incisedGridLine)
                                .attr("x1", m_axScale(axTicksLabels[i].value)-1)
                                .attr("x2", m_axScale(axTicksLabels[i].value)-1)
                                .attr("y1", -m_props.gridline.length)
                                .attr("y2", 0)
                                .attr("stroke", m_styleGridIncisedLineColor)
                                .attr("stroke-width", m_props.gridline.size)
                                .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");
                            }
                        };

                        if( i == 0 && m_props.gridline.showFirstLine)
                        {
                             drawLine();
                        }
                        else if ( i == (axTicksLabels.length - 1) && m_props.gridline.showLastLine)
                        {
                             drawLine();
                        }
                        else if ( (i != (axTicksLabels.length - 1))
                               && (i != 0)
                               && m_props.gridline.visible )
                        {
                             drawLine();
                        }
                    }

                    if(m_props.label.visible)
                    {
                        drawTopBottomLabels(selection, "bottom", axTicksLabels, maxTextHeight);
                    }

                    if (m_props.axisline.visible) {
                        var x1 = axRange[0];
                        var x2 = axRange[1];
                        var y1 = 0;
                        var y2 = 0;

                        var endSize = 0;//m_tickSize

                        var dPath  = "M" + x1 + " " + (y1 + endSize);
                            dPath += "L" + x1 + " " + y1;
                            dPath += "L" + x2 + " " + y2;
                            dPath += "L" + x2 + " " + (y2 + endSize);

                        var axLine = selection.append("path")
                                    .attr("class", m_props.isAxisColorFixed ? m_vClassNames.fixedAxisLine : m_vClassNames.axisLine)
                                    .attr("d", dPath)
                                    .attr("fill", "none")
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");
                        
                        if( angle ){
                            var aAngle = angle * Math.PI /180;
                            var cosAngle = Math.cos(aAngle);
                            var sinAngle = (45 == angle)? cosAngle: Math.sin(aAngle); 
                            dPath = 'M ' + axRange[0] + ' ' + y1;
                            dPath += 'L' + (axRange[0] + axRange[1] * sinAngle) + ' ' + (y2 - axRange[1] * cosAngle);
                            dPath += 'Z';
                            
                            axLine.attr('d', dPath);
                        }
                    }
                }
                else if(m_position == "top")
                {
                    var maxTextHeight = 0;
                    if(m_props.label.visible) {
                        var textArray = [];
                        for(var i = 0; i < axTicksLabels.length; i++)
                        {
                            textArray.push(axTicksLabels[i].text);
                        }
                        maxTextHeight = maxLabelTextHeight(textArray);
                    }
                    if ((m_spaceLimit != -1) && (maxTextHeight + m_tickSize + 2*m_textOffset + m_styleLineSrokeWidth/2 > m_spaceLimit)) {
                        axTicksLabels = [];
                        maxTextHeight = 0;
                    }
                    
                    var nOffset = 1;
                    if(m_props.label.visible)
                    {
                        nOffset = 2;
                    }

                    for(var i = 0; i < axTicksLabels.length; i++)
                    {
                        var axTick = selection.append("line")
                        .attr("class", m_props.isAxisColorFixed ? m_vClassNames.fixedAxisLine : m_vClassNames.axisLine)
                                    .attr("x1", m_axScale(axTicksLabels[i].value))
                                    .attr("x2", m_axScale(axTicksLabels[i].value))
                                    .attr("y1", maxTextHeight + nOffset*m_textOffset)
                                    .attr("y2", maxTextHeight + nOffset*m_textOffset + m_tickSize)
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");

                        var drawLine = function()
                        {
                            var gridline = selection.append("line")
                            .attr("class", m_vClassNames.gridLine)
                                        .attr("x1", m_axScale(axTicksLabels[i].value))
                                        .attr("x2", m_axScale(axTicksLabels[i].value))
                                        .attr("y1", maxTextHeight + m_tickSize + nOffset*m_textOffset)
                                        .attr("y2", maxTextHeight + m_tickSize + nOffset*m_textOffset + m_props.gridline.length)
                                        .attr("stroke", m_props.gridline.color)
                                        .attr("stroke-width", m_props.gridline.size)
                                        .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");

                            if(m_props.gridline.type == "dotted")
                            {
                                 gridline.attr("stroke-dasharray", "3, 2");
                            }

                            if(m_props.gridline.type == "incised")
                            {
                                var gridline = selection.append("line")
                                .attr("class", m_vClassNames.incisedGridLine)
                                .attr("x1", m_axScale(axTicksLabels[i].value)-1)
                                .attr("x2", m_axScale(axTicksLabels[i].value)-1)
                                .attr("y1", maxTextHeight + m_tickSize + nOffset*m_textOffset)
                                .attr("y2", maxTextHeight + m_tickSize + nOffset*m_textOffset + m_props.gridline.length)
                                .attr("stroke", m_styleGridIncisedLineColor)
                                .attr("stroke-width", m_props.gridline.size)
                                .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");
                            }
                        };

                        if( i == 0 && m_props.gridline.showFirstLine)
                        {
                             drawLine();
                        }
                        else if ( i == (axTicksLabels.length - 1) && m_props.gridline.showLastLine)
                        {
                             drawLine();
                        }
                        else if ( (i != (axTicksLabels.length - 1))
                               && (i != 0)
                               && m_props.gridline.visible )
                        {
                             drawLine();
                        }
                    }

                    if(m_props.label.visible)
                    {
                        drawTopBottomLabels(selection, "top", axTicksLabels, maxTextHeight);
                    }

                    if (m_props.axisline.visible) {
                        var x1 = axRange[0];
                        var x2 = axRange[1];
                        var y1 = maxTextHeight + m_tickSize + nOffset*m_textOffset;
                        var y2 = maxTextHeight + m_tickSize + nOffset*m_textOffset;

                        var endSize = 0;//m_tickSize
                        var dPath  = "M" + x1 + " " + (y1 - endSize);
                            dPath += "L" + x1 + " " + y1;
                            dPath += "L" + x2 + " " + y2;
                            dPath += "L" + x2 + " " + (y2 - endSize);

                        var axLine = selection.append("path")
                        .attr("class", m_props.isAxisColorFixed ? m_vClassNames.fixedAxisLine : m_vClassNames.axisLine)
                                    .attr("d", dPath)
                                    .attr("fill", "none")
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");
                    }

                }
                else if(m_position == "left")
                {
                    //we must change axTicksLabels, remove some lable array items for label management
                    //console.log(axTicksLabels);
                    axTicksLabels = buildToDrawLabels(axTicksLabels, m_position);

                    //count the max text width
                    var maxTextWidth = 0;
                    if(m_props.label.visible) {
                        var textArray = [];
                        for(var i = 0; i < axTicksLabels.length; i++)
                        {
                            textArray.push(axTicksLabels[i].text);
                        }
                        maxTextWidth = maxLabelTextWidth(textArray);
                    }
                    if ((m_spaceLimit != -1) && (maxTextWidth + m_tickSize + 2*m_textOffset + m_styleLineSrokeWidth/2 > m_spaceLimit)) {
                        axTicksLabels = [];
                        maxTextWidth = 0;
                    }

                    var nOffset = 1;
                    if(m_props.label.visible)
                    {
                        nOffset = 2;
                    }

                    for(var i = 0; i < axTicksLabels.length; i++)
                    {
                        var axTick = selection.append("line")
                                    .attr("class", m_props.isAxisColorFixed ? m_vClassNames.fixedAxisLine : m_vClassNames.axisLine)
                                    .attr("x1", maxTextWidth + nOffset*m_textOffset)
                                    .attr("x2", maxTextWidth + nOffset*m_textOffset + m_tickSize)
                                    .attr("y1", m_axScale(axTicksLabels[i].value))
                                    .attr("y2", m_axScale(axTicksLabels[i].value))
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");

                        var drawLine = function()
                        {
                            var gridline = selection.append("line")
                            .attr("class", m_vClassNames.gridLine)
                                        .attr("y1", m_axScale(axTicksLabels[i].value))
                                        .attr("y2", m_axScale(axTicksLabels[i].value))
                                        .attr("x1", maxTextWidth + nOffset*m_textOffset + m_tickSize)
                                        .attr("x2", maxTextWidth + nOffset*m_textOffset + m_tickSize + m_props.gridline.length)
                                        .attr("stroke", m_props.gridline.color)
                                        .attr("stroke-width", m_props.gridline.size)
                                        .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");

                            if(m_props.gridline.type == "dotted")
                            {
                                 gridline.attr("stroke-dasharray", "3, 2");
                            }

                            if(m_props.gridline.type == "incised")
                            {
                                var gridline = selection.append("line")
                                .attr("class", m_vClassNames.incisedGridLine)
                                .attr("y1", m_axScale(axTicksLabels[i].value)+1)
                                .attr("y2", m_axScale(axTicksLabels[i].value)+1)
                                .attr("x1", maxTextWidth + nOffset*m_textOffset + m_tickSize)
                                .attr("x2", maxTextWidth + nOffset*m_textOffset + m_tickSize + m_props.gridline.length)
                                .attr("stroke", m_styleGridIncisedLineColor)
                                .attr("stroke-width", m_props.gridline.size)
                                .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");
                            }
                            
                        };

                        if( i == 0 && m_props.gridline.showFirstLine)
                        {
                             drawLine();
                        }
                        else if ( i == (axTicksLabels.length - 1) && m_props.gridline.showLastLine)
                        {
                             drawLine();
                        }
                        else if ( (i != (axTicksLabels.length - 1))
                               && (i != 0)
                               && m_props.gridline.visible )
                        {
                             drawLine();
                        }
                        
                        //selection.append("circle").attr("cx", maxTextWidth).attr("cy", m_axScale(axTicksLabels.value[i])). attr("r", 3);
                        if(m_props.label.visible)
                        {
                            var text = selection
						   .append("g")
                           .attr("fill", m_style.defaultStyle.label.fill)
                           .attr("class", m_axisLabelClassCombined)
                           .attr("font-size", m_style.defaultStyle.label['font-size'])
                           .attr("font-weight", m_style.defaultStyle.label['font-weight'])
                           .attr("font-family", m_style.defaultStyle.label['font-family'])                                
                           .append("text")
                           .attr("x", maxTextWidth + m_textOffset)
                           .attr("y", m_axScale(axTicksLabels[i].value))
                           .attr("dominant-baseline", "middle")//"auto")//"hanging")//"central")
                           .attr("text-anchor", "end") // text-align
                           .text(axTicksLabels[i].text);

                            adjustLabelForIE(text);
                        }
                    }

                    if (m_props.axisline.visible) {
                        var x1 = maxTextWidth + nOffset*m_textOffset + m_tickSize;
                        var x2 = maxTextWidth + nOffset*m_textOffset + m_tickSize;
                        var y1 = axRange[0];
                        var y2 = axRange[1];

                        var endSize = 0;//m_tickSizes
                        var dPath  = "M" + (x1 - endSize) + " " + y1;
                            dPath += "L" + x1 + " " + y1;
                            dPath += "L" + x2 + " " + y2;
                            dPath += "L" + (x2 - endSize) + " " + y2;
                        
                        var axLine = selection.append("path")
                        .attr("class", m_props.isAxisColorFixed ? m_vClassNames.fixedAxisLine : m_vClassNames.axisLine)
                                    .attr("d", dPath)
                                    .attr("fill", "none")
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");
                    }
                }
                else if(m_position == "right")
                {
                    //we must change axTicksLabels, remove some lable array items for label management
                    //console.log(axTicksLabels);
                    axTicksLabels = buildToDrawLabels(axTicksLabels, m_position);
                    if(m_props.label.visible) {
                        var textArray = [];
                        for(var i = 0; i < axTicksLabels.length; i++)
                        {
                            textArray.push(axTicksLabels[i].text);
                        }
                        maxTextWidth = maxLabelTextWidth(textArray);
                    }
                    if ((m_spaceLimit != -1) && (maxTextWidth + m_tickSize + 2*m_textOffset + m_styleLineSrokeWidth/2 > m_spaceLimit)) {
                        axTicksLabels = [];
                        maxTextWidth = 0;
                    }

                    for(var i = 0; i < axTicksLabels.length; i++)
                    {
                        var axTick = selection.append("line")
                        .attr("class", m_props.isAxisColorFixed ? m_vClassNames.fixedAxisLine : m_vClassNames.axisLine)
                                    .attr("x1", 0)
                                    .attr("x2", m_tickSize)
                                    .attr("y1", m_axScale(axTicksLabels[i].value))
                                    .attr("y2", m_axScale(axTicksLabels[i].value))
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");

                        var drawLine = function()
                        {
                            var gridline = selection.append("line")
                            .attr("class", m_vClassNames.gridLine)
                                        .attr("y1", m_axScale(axTicksLabels[i].value))
                                        .attr("y2", m_axScale(axTicksLabels[i].value))
                                        .attr("x1", -m_props.gridline.length)
                                        .attr("x2", 0)
                                        .attr("stroke", m_props.gridline.color)
                                        .attr("stroke-width", m_props.gridline.size)
                                        .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");

                            if(m_props.gridline.type == "dotted")
                            {
                                 gridline.attr("stroke-dasharray", "3, 2");
                            }
                            if(m_props.gridline.type == "incised")
                            {
                                var gridline = selection.append("line")
                                .attr("class", m_vClassNames.incisedGridLine)
                                .attr("y1", m_axScale(axTicksLabels[i].value)+1)
                                .attr("y2", m_axScale(axTicksLabels[i].value)+1)
                                .attr("x1", -m_props.gridline.length)
                                .attr("x2", 0)
                                .attr("stroke", m_styleGridIncisedLineColor)
                                .attr("stroke-width", m_props.gridline.size)
                                .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");
                            }
                        };

                        if( i == 0 && m_props.gridline.showFirstLine)
                        {
                             drawLine();
                        }
                        else if ( i == (axTicksLabels.length - 1) && m_props.gridline.showLastLine)
                        {
                             drawLine();
                        }
                        else if ( (i != (axTicksLabels.length - 1))
                               && (i != 0)
                               && m_props.gridline.visible )
                        {
                             drawLine();
                        }

                        //selection.append("circle").attr("cx", m_tickSize + m_textOffset).attr("cy", m_axScale(axTicksLabels.value[i])). attr("r", 3);
                        if(m_props.label.visible)
                        {
                            var text = selection
						    .append("g")							
                            .attr("fill", m_style.defaultStyle.label.fill)
                            .attr("class", m_axisLabelClassCombined)
                            .attr("font-size", m_style.defaultStyle.label['font-size'])
                            .attr("font-weight", m_style.defaultStyle.label['font-weight'])
                            .attr("font-family", m_style.defaultStyle.label['font-family'])                                
                            .append("text")
                            .attr("x", m_tickSize + m_textOffset)
                            .attr("y", m_axScale(axTicksLabels[i].value))
                            .attr("dominant-baseline", "middle")//"auto")//"hanging")//"central")
                            .attr("text-anchor", "start") // text-align
                            .text(axTicksLabels[i].text);

                            adjustLabelForIE(text);
                        }
                    }

                    if (m_props.axisline.visible) {
                        var x1 = 0;
                        var x2 = 0;
                        var y1 = axRange[0];
                        var y2 = axRange[1];

                        var endSize = 0;//m_tickSizes
                        var dPath  = "M" + (x1 + endSize) + " " + y1;
                            dPath += "L" + x1 + " " + y1;
                            dPath += "L" + x2 + " " + y2;
                            dPath += "L" + (x2 + endSize) + " " + y2;

                        var axLine = selection.append("path")
                        .attr("class", m_props.isAxisColorFixed ? m_vClassNames.fixedAxisLine : m_vClassNames.axisLine)
                                .attr("d", dPath)
                                .attr("fill", "none")
                                .attr("stroke", m_props.color)
                                .attr("stroke-width", m_props.lineSize)
                                .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");
                    }
                }
            };

        var adjustLabelForIE = function(text)
        {
            if( UADetector.isIE())
            {
                //dominant-baseline does not work
                var textHeight = m_style.realStyle.label['font-size'].toString();
                var indexPX = textHeight.indexOf("px");
                if(indexPX >= 0)
                {
                    textHeight = textHeight.substr(0, indexPX);
                }

                //textHeight = fastMeasure(text, m_style.realStyle.label).height;
                var y = text.attr("y");
                text.attr("y", Number(y) + textHeight/2);
                text.attr("dominant-baseline", "auto");
            }
        }

        axis.matrix = function(_){
          if(!arguments.length){
            return m_matrix;
          }
          m_matrix = _;
          return axis;
        };
        
        axis.labelAngle = function(_){
          if(!arguments.length){
            return labelAngle;
          }
          labelAngle = _;
          return axis;
        };
        
        axis.tickAngle = function(_){
          if(!arguments.length){
            return tickAngle;
          }
          tickAngle = _;
          return axis;
        };
        
        axis.angle = function(_){
          if(!arguments.length){
            return angle;
          }
          angle = _;
          return axis;
        };
        
        axis.labelAlign = function(_){
          if(!arguments.length){
            return labelAlign;
          }
          labelAlign = _;
          return axis;
        };
        
        axis.position = function(_position) {
            if (!arguments.length) 
                return m_position;
            m_position = _position;
            return axis;
        };
        
        axis.style = function(_style) {
          if(arguments.length == 0)
            return m_style;
          m_style = Objects.extend(true, m_style, _style);
          return axis;
        };

        axis.properties = function(_properties) {
            if (arguments.length == 0)
                return m_props;

            m_props = extendObj(m_props, _properties);
            return axis;
        };

        axis.axScale = function(_axScale) {
            if (!arguments.length) 
                return m_axScale;
            m_axScale = _axScale;
            return axis;
        };

        axis.startPadding = function() {
            if(m_axScale)
            {
                var axTicksLabels = buildToDrawLabels(getTicksLabel(), m_position);
                
                var labelSize = 0;
                if(axTicksLabels.length > 0)
                {
                    labelSize = fastMeasure(axTicksLabels[0].text, m_style.realStyle.label);
                }
                if(labelSize == 0){
                  return 0;
                }
                if(m_position == "top" || m_position == "bottom")
                {
                    return labelSize.width/2;
                }
                else
                {
                    return labelSize.height/2;
                }
            }
            else
            {
                return 0;
            }
        };

        axis.endPadding = function() {
            if(m_axScale)
            {
                var axTicksLabels = buildToDrawLabels(getTicksLabel(), m_position);

                var labelSize = 0;

                if(axTicksLabels.length > 0)
                {
                    labelSize = fastMeasure(axTicksLabels[axTicksLabels.length-1].text, m_style.realStyle.label);
                }
                if(labelSize == 0){
                  return 0;
                }
                if(m_position == "top" || m_position == "bottom")
                {
                    return labelSize.width/2;
                }
                else
                {
                    return labelSize.height/2;
                }
            }
            else
            {
                return 0;
            }
        };

        axis.getPreferredSize = function() {

            var axDomain = m_axScale.domain();//[0, 100]
            var axRange = m_axScale.range();//[0, 200]

            var axisWidth = 0;
            var axisHeight = 0;

            var axisSpacings = [];

            if( !(axRange[0] == 0 && axRange[1] == 0) )
            {

                var absRange = Math.abs(axRange[0] - axRange[1]);
                
                if(m_position == "bottom" || m_position == "top")
                {
                    axisWidth = absRange + m_styleLineSrokeWidth;
                    if(m_props.label.visible)
                    {
						var axTicksLabels = buildToDrawLabels(getTicksLabel(), m_position);
                        var textArray = [];
                        for(var i = 0; i < axTicksLabels.length; i++)
                        {
                            textArray.push(axTicksLabels[i].text);
                        }
                        axisHeight = maxLabelTextHeight(textArray) + m_tickSize + 2*m_textOffset + m_styleLineSrokeWidth/2;
                    }
                    else
                    {
                        axisHeight = m_tickSize + m_textOffset + m_styleLineSrokeWidth/2;
                    }
                    axisSpacings.push(axisHeight);
                }
                else if(m_position == "left" || m_position == "right")
                {
                    if(m_props.label.visible)
                    {
                        var axTicksLabels = buildToDrawLabels(getTicksLabel(), m_position);
                        var textArray = [];
                        for(var i = 0; i < axTicksLabels.length; i++)
                        {
                            textArray.push(axTicksLabels[i].text);
                        }
                        
                        if( fastMeasure(textArray[0], m_style.realStyle.label).height > absRange ){
                            axisWidth = m_tickSize + 2*m_textOffset;
                        }else{
                            axisWidth =  maxLabelTextWidth(textArray) + m_tickSize + 2*m_textOffset + m_styleLineSrokeWidth/2;;
                        }
                    }
                    else
                    {
                        axisWidth = m_tickSize + m_textOffset + m_styleLineSrokeWidth/2;
                    }
                    axisSpacings.push(axisWidth);

                    axisHeight = absRange + m_styleLineSrokeWidth;
                }
            }

            return {
                width : axisWidth,
                height : axisHeight,
                spacings : axisSpacings,

            };
        };
        
        axis.destroy = function() {
          m_selection = null;
          m_axScale = null;
        };

        var buildToDrawLabels = function(axTicksLabels, type)
        {
            if(axTicksLabels.length > 0)
            {
                if(m_axScale (axTicksLabels[0].value) > m_axScale (axTicksLabels[axTicksLabels.length-1].value))
                {
                    axTicksLabels.reverse();
                }
            }
            //build the "todraw" array
            //count all the labels y1 and y2, and save them.
            var allTicksLabels = [];
            for(var i = 0; i < axTicksLabels.length; i++)
            {   
              if(!NumberUtils.isNoValue(axTicksLabels[i].value)){
                var item = {};
                item.value = axTicksLabels[i].value;
                item.text = axTicksLabels[i].text;

                //count y1 and y2
                var itemSize = fastMeasure (item.text, m_style.realStyle.label);
                var center = m_axScale (item.value);

                if (type == 'left' || type == 'right') {
                    item.start =  center - itemSize.height/2;
                    item.end =   center + itemSize.height/2;
                } else {
                    item.start = center - itemSize.width/2;
                    item.end = center + itemSize.width/2;
                }
                
                allTicksLabels.push(item);
              }
            }
            //console.log(allTicksLabels);

            var ticksLabelsToDraw = [];
            ticksLabelsToDraw = calculateLabelsToDraw(allTicksLabels);

            //console.log(ticksLabelsToDraw);
            return ticksLabelsToDraw;
        };

        var drawTopBottomLabels = function(selection, type, ticksLabels, maxTextHeight)
        {
            if(ticksLabels.length == 0)
            {
                return;
            }
            var ticksLabelsToDraw = buildToDrawLabels(ticksLabels, type);

            //console.log(ticksLabelsToDraw);
            for(var i = 0; i < ticksLabelsToDraw.length; i++)
            {
              if(angle){
                var aAngle = angle * Math.PI /180;
                var cosAngle = Math.cos(aAngle);
                var sinAngle = (45 === angle) ? cosAngle : Math.sin(aAngle);
                var tAngle = tickAngle * Math.PI / 180;
                var cosTAngle = Math.cos(tAngle);
                var sinTAngle = Math.sin(tAngle);
                
                var tickStartX  =    m_axScale(ticksLabelsToDraw[i].value) * sinAngle;
                tickStartY =  -  m_axScale(ticksLabelsToDraw[i].value) * cosAngle;
                
                var item = selection
			      .append("g")				
                  .attr("fill", m_style.defaultStyle.label.fill)
                  .attr("class", m_axisLabelClassCombined)
                  .attr("font-size", m_style.defaultStyle.label['font-size'])
                  .attr("font-weight", m_style.defaultStyle.label['font-weight'])
                  .attr("font-family", m_style.defaultStyle.label['font-family'])                    
                  .append('text')
                  .attr('x', tickStartX + ( m_textOffset + m_tickSize) * cosTAngle)
                  .attr('y', tickStartY + ( m_textOffset + m_tickSize) * sinTAngle)
                  .attr("dominant-baseline", "middle")//"auto")//"hanging")//"central")
                  .attr("text-anchor", 'start') // text-align
                  .text(ticksLabelsToDraw[i].text);
          
                  if(tickAngle > 90){
                    item.attr("text-anchor", 'end').attr('transform', 'rotate( ' + (tickAngle - 180) + ' ' +item.attr("x") + ' ' +item.attr("y") + ')');
                  }else{
                    item.attr('transform', 'rotate( ' + (tickAngle) + ' ' +item.attr("x") + ' ' +item.attr("y") + ')');
                  }
              }else{
              //selection.append("circle").attr("cx", m_axScale(axTicksLabels.value[i])).attr("cy", m_textOffset + m_tickSize). attr("r", 3);
                var item = selection
				 .append("g")				
                 .attr("fill", m_style.defaultStyle.label.fill)
                 .attr("class", m_axisLabelClassCombined)
                 .attr("font-size", m_style.defaultStyle.label['font-size'])
                 .attr("font-weight", m_style.defaultStyle.label['font-weight'])
                 .attr("font-family", m_style.defaultStyle.label['font-family'])                    
                 .append("text")
                 .attr("x", m_axScale(ticksLabelsToDraw[i].value))
                 .attr("y", m_textOffset + m_tickSize)
                 .attr("dominant-baseline", "hanging")//"auto")//"hanging")//"central")
                 .attr("text-anchor", "middle") // text-align
                 .text(ticksLabelsToDraw[i].text);

                //IE does not support dominant-baseline
                item.attr("dominant-baseline", "auto");
                item.attr("y", maxTextHeight + m_textOffset);
              }
            }
        };

        var calculateLabelsToDraw = function(allTicksLabels)
        {
            var labelsToDraw = [];
            
            if(allTicksLabels.length > 0)
            {
                //split allTicksLabels if it is required.
                if( !(allTicksLabels[0].value >= 0 && allTicksLabels[allTicksLabels.length - 1].value >= 0) 
                  &&!(allTicksLabels[0].value <= 0 && allTicksLabels[allTicksLabels.length - 1].value <= 0)
                  )
                {
                    var negativeArray = [];
                    var positiveArray = [];
                    for(var i = 0; i < allTicksLabels.length; i++)
                    {
                        if(allTicksLabels[i].value <= 0) {
                            negativeArray.push(allTicksLabels[i]);
                        }

                        if(allTicksLabels[i].value >= 0) {
                            positiveArray.push(allTicksLabels[i]);
                        }
                    }

                    var head;
                    var nal = negativeArray.length;
                    if (negativeArray[0].value <= negativeArray[nal-1].value) {
                        head = negativeArray[0];
                    } else {
                        head = negativeArray[nal-1];
                    }
                    var tail;
                    var pal = positiveArray.length;
                    if (positiveArray[0].value <= positiveArray[pal -1].value) {
                        tail = positiveArray[pal -1];
                    } else {
                        tail = positiveArray[0];
                    }

                    negativeArray = calculateLabelsToDrawHelper(negativeArray);
                    positiveArray = calculateLabelsToDrawHelper(positiveArray);

                    if (negativeArray[0].value > negativeArray[negativeArray.length-1].value) {
                        negativeArray.reverse();
                    }
                    if (positiveArray[0].value > positiveArray[positiveArray.length-1].value) {
                        positiveArray.reverse();
                    }

                    if( negativeArray[negativeArray.length -1].value == 0
                        && positiveArray[0].value == 0)
                    {
                        negativeArray.pop();
                    }

                    var labelsToDrawTemp = negativeArray.concat(positiveArray);
                    if (head.value !== labelsToDrawTemp[0].value) {
                        labelsToDrawTemp.splice(0, 0, head);
                    }
                    if (tail.value !== labelsToDrawTemp[labelsToDrawTemp.length-1].value) {
                        labelsToDrawTemp.push(tail);
                    }
                    if (labelsToDrawTemp[0].start > labelsToDrawTemp[labelsToDrawTemp.length-1].start) {
                        labelsToDrawTemp.reverse();
                    }
                    labelsToDraw = calculateLabelsToDrawHelper(labelsToDrawTemp);
                }
                else
                {
                    labelsToDraw = calculateLabelsToDrawHelper(allTicksLabels);
                }
            }

            //BITVIZA-454 [label management] When the height/width of 
            //vertical/horizontal axis is small that can only hold one axis label, the label 
            //should be hidden.
            if(labelsToDraw.length <= 1)
            {
                labelsToDraw = [];
            }

            return labelsToDraw;
        }

        var calculateLabelsToDrawHelper = function(allTicksLabels)
        {
            //allTicksLabels:
            //[0, X]
            //[-X, 0]
            //[X1, X2] (X1>0, X2>0)
            //[X1, X2] (X1<0, X2<0)

            //now we should decide which label to draw.
            //iBeyond = 0:0,1,2,3,4,5,6,...
            //iBeyond = 1:0, ,2, ,4, ,6,...
            //iBeyond = 2:0, , ,3, , ,6,...
            //...
            //iBeyond = (allTicksLabels.length - 1):0
            var ticksLabelsToDraw = [];

            for(var iBeyond = 0; iBeyond <= (allTicksLabels.length - 1); iBeyond++)
            {
                var isDrawable = true;
                for(var i = 0; i < allTicksLabels.length-1; i+=(iBeyond+1))
                {
                    var item = allTicksLabels[i];
                    if(i != 0)
                    {
                        var previousItem = ticksLabelsToDraw[ticksLabelsToDraw.length-1];
                        if (allTicksLabels[i].start <= previousItem.end)
                        {
                            //for [0.9,1,2,3....], if cannot draw second axis label, just ignore second, then continue
                            if (ticksLabelsToDraw.length > 1) {
                                isDrawable = false;
                                break;
                            }
                        } else {
                            ticksLabelsToDraw.push(item);
                        }
                    } else {
                        //add the first axis tick label
                        ticksLabelsToDraw.push(item);
                    }
                }
                //for [.....5,5.1], always draw the last axis tick label
                var lastItem = allTicksLabels[allTicksLabels.length-1];
                if (lastItem.start < ticksLabelsToDraw[ticksLabelsToDraw.length-1].end) {
                    ticksLabelsToDraw.pop();
                }
                ticksLabelsToDraw.push(lastItem);
                
                if(isDrawable) {//find the labels
                    break;
                } else {
                    ticksLabelsToDraw = [];
                }
            }
            
            return ticksLabelsToDraw;
        }

        var getTicksLabel = function ()
        {
            var axDomain = m_axScale.domain();//[-100, 2000]

            var tickNum = m_axDefaultTickNum;
            if(m_axScale.tickHint)//after perfect
            {
                tickNum = m_axScale.tickHint;
            }

            var axTicksLabels = m_axScale.ticks(tickNum);//[0, 2000, 4000, ...]
            // [21-Sep-2012 Nick ] FIXME Comment out this part to fix bug BITVIZA-383, any particular reason to filter ticks?
            // if it is yes, what kind of criteria should be taken?
//            if(axTicksLabels.length > 20)
//            {
//                //too many ticks. filter some ticks
//                var tempTicks = [];
//                for(var i = 0; i < axTicksLabels.length; i++)
//                {
//                    if(axTicksLabels[i].toString().substr(0,1) == "1"
//                      || axTicksLabels[i].toString().substr(0,1) == "2"
//                      || axTicksLabels[i].toString().substr(0,1) == "5")
//                    {
//                        tempTicks.push(axTicksLabels[i]);
//                    }
//                }
//                axTicksLabels = tempTicks;
//            }

            for(var i=0; i < axTicksLabels.length; i++){
              axTicksLabels[i] = NumberUtils.precise( axTicksLabels[i]);
            }
            var beginLabel;
            var endLabel;
            if(axDomain[0] <= axDomain[axDomain.length -1])
            {
                beginLabel = axDomain[0];
                endLabel = axDomain[axDomain.length -1];
            }
            else
            {
                beginLabel = axDomain[axDomain.length -1];
                endLabel = axDomain[0];
            }

            if(axTicksLabels.length > 0)
            {
                if(axTicksLabels[0] != beginLabel) {
                    //the first label is not the first doamin. Add it.
                    axTicksLabels.unshift(beginLabel);
                }
                
                if(axTicksLabels[axTicksLabels.length -1] != endLabel) {
                    //the last label is not the end. Add it.
                    axTicksLabels.push(endLabel);
                }
            }

            var ticks = [];
            for(var i = 0; i < axTicksLabels.length; i++)
            {
                var tickItem = {};
                tickItem.value = axTicksLabels[i];
                if(m_props.isPercentMode)
                {
                    tickItem.text = NumberUtils.precise(axTicksLabels[i]*100).toString();
                }
                else
                {
                    tickItem.text = NumberUtils.precise(axTicksLabels[i]).toString();
                }
                ticks.push(tickItem);
            }

          //format value label by d3
            if(m_props.label)
            {
                if(!m_props.label.formatString && m_props.label.numberFormat){
                    for(var i = 0; i < axTicksLabels.length; i++)
                    {
                        var formatFun = d3.format(m_props.label.numberFormat);
                        ticks[i].text = (formatFun(axTicksLabels[i]));
                    }
                }else if(m_props.label.formatString){
                    var formatString = m_props.label.formatString;
                    for(var i = 0; i < axTicksLabels.length; i++)
                    {
                        ticks[i].text = (FormatManager.format(axTicksLabels[i], formatString));
                    }
                }
                
            }
            
            return ticks;
        }

        var maxLabelTextHeight = function (textArray)
        {
            var isVerticalFont = m_props.forceVerticalFont === true ? true: false;
            var maxTextHeight = 0;
            for(var i = 0; i <  textArray.length; i++)
            {
                var tLen =  0 ;
                if( isVerticalFont ){
                  tLen =  fastMeasure(textArray[i], m_style.realStyle.label).width;
                }else{
                  tLen = fastMeasure(textArray[i], m_style.realStyle.label).height;
                }
                if(maxTextHeight < tLen)
                {
                    maxTextHeight = tLen;
                }
            }
            return maxTextHeight;
        }

        var maxLabelTextWidth = function (textArray)
        {
            var isVerticalFont = m_props.forceVerticalFont === true ? true: false;
            var maxTextWidth = 0;
            for(var i = 0; i <  textArray.length; i++)
            {
                var tLen = 0; 
                if( isVerticalFont ){
                  tLen = fastMeasure(textArray[i], m_style.realStyle.label).height;
                } else {
                  tLen = fastMeasure(textArray[i], m_style.realStyle.label).width;
                }
                
                if(maxTextWidth < tLen)
                {
                    maxTextWidth = tLen;
                }
            }
            return maxTextWidth;
        }
        
        var fastMeasure = function(_text, _style)
        {
            return TextUtils.superFastMeasure(_text, _style['font-size'],
                                                _style['font-weight'],
                                                _style['font-family']);
        }        

        var extendObj = function(target, source)
        {
            for(var prop in source)
            {
                if(typeof(source[prop]) === "object")
                {
                    if(target[prop])
                    {
                        target[prop] = extendObj(target[prop], source[prop]);
                    }
                    else
                    {
                        target[prop] = source[prop];
                    }
                }
                else
                {
                    target[prop] = source[prop];
                }
            }
            return target;
        };
        
        return axis;
    };
  return ret;
});

define('sap/viz/modules/axis/BaseValue',['sap/viz/base/utils/oo',
'sap/viz/modules/Base',
'sap/viz/modules/dispatch',
'sap/viz/modules/axis/baseValueHelper',
'sap/viz/modules/axis/baseValueCore'],
function Setup(oo, Base, dispatch, baseValueHelper, baseValueCore) {
    var axis = function(manifest, ctx) {
        axis.superclass.constructor.apply(this,arguments);

        this._axis_baseValueHelperModule = baseValueHelper(manifest, ctx);

        axis.prototype.initCustomFunList(axis);
        axis.prototype.initBaseValueHelper(this._axis_baseValueHelperModule, axis);

        //apply the core module. You may need to replace it to your own core.
        axis.prototype.setCoreModule(baseValueCore);
    };

    axis.prototype.initCustomFunList = function()
    {
        if(!axis.prototype._axis_customFunList)
        {
            axis.prototype._axis_customFunList = [];
            var propFunction;
            for (propFunction in this)
            {
                if( this.hasOwnProperty( propFunction ) ) 
                {
                    if(typeof(this[propFunction]) === "function")
                    {
                        axis.prototype._axis_customFunList.push(propFunction);
                    }
                } 
            }
        }
        return this;
    };

    axis.prototype.initBaseValueHelper = function(baseValueHelper, self)
    {
        var propFunction;        
        for (propFunction in baseValueHelper)
        {
            if( baseValueHelper.hasOwnProperty( propFunction ) ) 
            {
                if(typeof(baseValueHelper[propFunction]) === "function")
                {
                    if( axis.prototype._axis_customFunList &&
                        axis.prototype._axis_customFunList.indexOf(propFunction) < 0)
                    {
                        self.prototype[propFunction] = baseValueHelper[propFunction];
                    }
                }
            } 
        }
    };
    
    //the start point
    oo.extend(axis,Base);

    //functions here have higher Priority than functions in initBaseValueHelper
    axis.prototype.render = function(selection, isNewSVG)
    {
        this._axis_baseValueHelperModule.apply(this, arguments);
        return this;
    };
    
    //sample overwritten fun
    //axis.prototype.data = function(selection)
    //{
    //    return null;
    //};

    return axis;
});

define('sap/viz/modules/axis/simpleValueCore',['jquery', 'sap/viz/modules/Constants', 'sap/viz/util/TextUtils','sap/viz/util/NumberUtils','sap/viz/base/utils/Objects','sap/viz/format/FormatManager',
'sap/viz/modules/threeD/Point','sap/viz/modules/threeD/matrix', 'sap/viz/base/UADetector'],
function Setup(jQuery, ModuleConstants, TextUtils, NumberUtils, Objects, FormatManager, Point, matrix, UADetector) {

  var ret = function() {
   
        var m_position;
        var m_title;
        
        var m_axScale = null;

        var m_tickSize = 5;
        var m_textOffset = 6;

        var m_axDefaultTickNum = 7;

        var m_styleLineSrokeWidth = 1;
        var m_styleAxisColor = "#6c6c6c";
        var m_styleGridLineColor = "#d8d8d8";
        var m_styleGridIncisedLineColor = "#ffffff";
        var m_styleAxisLabelColor = "#333333";
        
        var m_axLabelClassName = "viz-axis-label";        
        
        var m_style = null;
        var m_props = { 
            "title": {"visible": false, "text": undefined,},
            "gridline": {"visible": true, "color": m_styleGridLineColor, "showFirstLine": false, "length": 0, "showLastLine": false, "type":"line"},
            "type" : "value",
            "visible" : true,
            "label": {"visible": true, "numberFormat" : "","formatString": "", },
            "position": "left",
            "color": m_styleAxisColor,
            "axisline" : {"visible": true},
            "shapeRendering": true
        };

        var m_vClassNames = 
        {
            axis:"v-axis",
            axisBody:"v-body",
            axisTitle:"v-title",
            axisLabel:"v-label",
            axisLine: "v-valueaxisline",
            gridLine: "v-gridline",
            incisedGridLine: "v-incised-gridline",
            fixedAxisLine: "v-fixed-valueaxisline",
            morphableLabel:ModuleConstants.CSS.CLASS.MORPHABLELABEL
        };
        
        var m_axisLabelClassCombined = m_vClassNames.axisLabel + ' ' + m_axLabelClassName + ' ' + m_vClassNames.morphableLabel;

        var m_matrix = matrix(), labelAngle = null, labelAlign = null, angle = null, tickAngle = null;
        
        var m_spaceLimit = -1;
        axis.spaceLimit = function(_spaceLimit)
        {
            if (!arguments.length) 
                return m_spaceLimit;
            m_spaceLimit = _spaceLimit;
            return axis;
        }

        function axis(selection) {
                
                var axRange = m_axScale.range();//[0, 500]
                var axDomain = m_axScale.domain();//[-100, 2000]

                if(axRange[0] == 0 && axRange[1] == 0)
                {
                    return;//do not draw value axis
                }

                var axTicksLabels = getTicksLabel();

                if(m_position == "bottom")
                {
                    var maxTextHeight = 0;
                    if(m_props.label.visible) {
                        var textArray = [];
                        for(var i = 0; i < axTicksLabels.length; i++)
                        {
                            textArray.push(axTicksLabels[i].text);
                        }
                        maxTextHeight = maxLabelTextHeight(textArray);
                    }
                    if  ((m_spaceLimit != -1) && (maxTextHeight + m_tickSize + 2*m_textOffset + m_styleLineSrokeWidth/2 > m_spaceLimit)) {
                        axTicksLabels = [];
                        maxTextHeight = 0;
                    }

                    for(var i = 0; i < axTicksLabels.length; i++)
                    {
                        var axTick = selection.append("line")
                        .attr("class", m_props.isAxisColorFixed ? m_vClassNames.fixedAxisLine : m_vClassNames.axisLine)
                                    .attr("x1", m_axScale(axTicksLabels[i].value))
                                    .attr("x2", m_axScale(axTicksLabels[i].value))
                                    .attr("y1", 0)
                                    .attr("y2", m_tickSize + 1)//line contains the first but not the last point
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");

                        if(angle){
                            var aAngle = angle * Math.PI /180;
                            var cosAngle = Math.cos(aAngle);
                            var sinAngle = (45 === angle) ? cosAngle : Math.sin(aAngle);
                            var tAngle = tickAngle * Math.PI / 180;
                            var cosTAngle = Math.cos(tAngle);
                            var sinTAngle = Math.sin(tAngle);
                            
                            var tickStartX  =   m_axScale(axTicksLabels[i].value) * sinAngle;
                            tickStartY =  -m_axScale(axTicksLabels[i].value) * cosAngle;
                            var x2 = tickStartX + ( m_tickSize + 1) * cosTAngle,
                              y2 = tickStartY + ( m_tickSize + 1) * sinTAngle;
                              
                            axTick.attr('x1', tickStartX).attr('y1', tickStartY).attr('x2', x2).attr('y2', y2);  
                          }
                        
                        var drawLine = function()
                        {
                             var line = selection.append("line")
                             .attr("class", m_vClassNames.gridLine)
                            .attr("x1", m_axScale(axTicksLabels[i].value))
                            .attr("x2", m_axScale(axTicksLabels[i].value))
                            .attr("y1", -m_props.gridline.length)
                            .attr("y2", 0)
                            .attr("stroke", m_props.gridline.color)
                            .attr("stroke-width", m_props.gridline.size)
                            .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");

                            if(m_props.gridline.type == "dotted")
                            {
                                 line.attr("stroke-dasharray", "3, 2");
                            }
                            
                            if(m_props.gridline.type == "incised")
                            {
                                var line = selection.append("line")
                                .attr("class", m_vClassNames.incisedGridLine)
                                .attr("x1", m_axScale(axTicksLabels[i].value)-1)
                                .attr("x2", m_axScale(axTicksLabels[i].value)-1)
                                .attr("y1", -m_props.gridline.length)
                                .attr("y2", 0)
                                .attr("stroke", m_styleGridIncisedLineColor)
                                .attr("stroke-width", m_props.gridline.size)
                                .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");
                            }
                        };

                        if( i == 0 && m_props.gridline.showFirstLine)
                        {
                             drawLine();
                        }
                        else if ( i == (axTicksLabels.length - 1) && m_props.gridline.showLastLine)
                        {
                             drawLine();
                        }
                        else if ( (i != (axTicksLabels.length - 1))
                               && (i != 0)
                               && m_props.gridline.visible )
                        {
                             drawLine();
                        }
                    }

                    if(m_props.label.visible)
                    {
                        drawTopBottomLabels(selection, "bottom", axTicksLabels, maxTextHeight);
                    }

                    if (m_props.axisline.visible) {
                        var x1 = axRange[0];
                        var x2 = axRange[1];
                        var y1 = 0;
                        var y2 = 0;

                        var endSize = 0;//m_tickSize

                        var dPath  = "M" + x1 + " " + (y1 + endSize);
                            dPath += "L" + x1 + " " + y1;
                            dPath += "L" + x2 + " " + y2;
                            dPath += "L" + x2 + " " + (y2 + endSize);

                        var axLine = selection.append("path")
                                    .attr("class", m_props.isAxisColorFixed ? m_vClassNames.fixedAxisLine : m_vClassNames.axisLine)
                                    .attr("d", dPath)
                                    .attr("fill", "none")
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");
                        
                        if( angle ){
                            var aAngle = angle * Math.PI /180;
                            var cosAngle = Math.cos(aAngle);
                            var sinAngle = (45 == angle)? cosAngle: Math.sin(aAngle); 
                            dPath = 'M ' + axRange[0] + ' ' + y1;
                            dPath += 'L' + (axRange[0] + axRange[1] * sinAngle) + ' ' + (y2 - axRange[1] * cosAngle);
                            dPath += 'Z';
                            
                            axLine.attr('d', dPath);
                        }
                    }
                }
                else if(m_position == "top")
                {
                    var maxTextHeight = 0;
                    if(m_props.label.visible) {
                        var textArray = [];
                        for(var i = 0; i < axTicksLabels.length; i++)
                        {
                            textArray.push(axTicksLabels[i].text);
                        }
                        maxTextHeight = maxLabelTextHeight(textArray);
                    }
                    if ((m_spaceLimit != -1) && (maxTextHeight + m_tickSize + 2*m_textOffset + m_styleLineSrokeWidth/2 > m_spaceLimit)) {
                        axTicksLabels = [];
                        maxTextHeight = 0;
                    }
                    
                    var nOffset = 1;
                    if(m_props.label.visible)
                    {
                        nOffset = 2;
                    }

                    for(var i = 0; i < axTicksLabels.length; i++)
                    {
                        var axTick = selection.append("line")
                        .attr("class", m_props.isAxisColorFixed ? m_vClassNames.fixedAxisLine : m_vClassNames.axisLine)
                                    .attr("x1", m_axScale(axTicksLabels[i].value))
                                    .attr("x2", m_axScale(axTicksLabels[i].value))
                                    .attr("y1", maxTextHeight + nOffset*m_textOffset)
                                    .attr("y2", maxTextHeight + nOffset*m_textOffset + m_tickSize)
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");

                        var drawLine = function()
                        {
                            var gridline = selection.append("line")
                            .attr("class", m_vClassNames.gridLine)
                                        .attr("x1", m_axScale(axTicksLabels[i].value))
                                        .attr("x2", m_axScale(axTicksLabels[i].value))
                                        .attr("y1", maxTextHeight + m_tickSize + nOffset*m_textOffset)
                                        .attr("y2", maxTextHeight + m_tickSize + nOffset*m_textOffset + m_props.gridline.length)
                                        .attr("stroke", m_props.gridline.color)
                                        .attr("stroke-width", m_props.gridline.size)
                                        .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");

                            if(m_props.gridline.type == "dotted")
                            {
                                 gridline.attr("stroke-dasharray", "3, 2");
                            }

                            if(m_props.gridline.type == "incised")
                            {
                                var gridline = selection.append("line")
                                .attr("class", m_vClassNames.incisedGridLine)
                                .attr("x1", m_axScale(axTicksLabels[i].value)-1)
                                .attr("x2", m_axScale(axTicksLabels[i].value)-1)
                                .attr("y1", maxTextHeight + m_tickSize + nOffset*m_textOffset)
                                .attr("y2", maxTextHeight + m_tickSize + nOffset*m_textOffset + m_props.gridline.length)
                                .attr("stroke", m_styleGridIncisedLineColor)
                                .attr("stroke-width", m_props.gridline.size)
                                .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");
                            }
                        };

                        if( i == 0 && m_props.gridline.showFirstLine)
                        {
                             drawLine();
                        }
                        else if ( i == (axTicksLabels.length - 1) && m_props.gridline.showLastLine)
                        {
                             drawLine();
                        }
                        else if ( (i != (axTicksLabels.length - 1))
                               && (i != 0)
                               && m_props.gridline.visible )
                        {
                             drawLine();
                        }
                    }

                    if(m_props.label.visible)
                    {
                        drawTopBottomLabels(selection, "top", axTicksLabels, maxTextHeight);
                    }

                    if (m_props.axisline.visible) {
                        var x1 = axRange[0];
                        var x2 = axRange[1];
                        var y1 = maxTextHeight + m_tickSize + nOffset*m_textOffset;
                        var y2 = maxTextHeight + m_tickSize + nOffset*m_textOffset;

                        var endSize = 0;//m_tickSize
                        var dPath  = "M" + x1 + " " + (y1 - endSize);
                            dPath += "L" + x1 + " " + y1;
                            dPath += "L" + x2 + " " + y2;
                            dPath += "L" + x2 + " " + (y2 - endSize);

                        var axLine = selection.append("path")
                        .attr("class", m_props.isAxisColorFixed ? m_vClassNames.fixedAxisLine : m_vClassNames.axisLine)
                                    .attr("d", dPath)
                                    .attr("fill", "none")
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");
                    }

                }
                else if(m_position == "left")
                {
                    //we must change axTicksLabels, remove some lable array items for label management
                    //console.log(axTicksLabels);
                    axTicksLabels = buildToDrawLabels(axTicksLabels, m_position);

                    //count the max text width
                    var maxTextWidth = 0;
                    if(m_props.label.visible) {
                        var textArray = [];
                        for(var i = 0; i < axTicksLabels.length; i++)
                        {
                            textArray.push(axTicksLabels[i].text);
                        }
                        maxTextWidth = maxLabelTextWidth(textArray);
                    }
                    if ((m_spaceLimit != -1) && (maxTextWidth + m_tickSize + 2*m_textOffset + m_styleLineSrokeWidth/2 > m_spaceLimit)) {
                        axTicksLabels = [];
                        maxTextWidth = 0;
                    }

                    var nOffset = 1;
                    if(m_props.label.visible)
                    {
                        nOffset = 2;
                    }

                    for(var i = 0; i < axTicksLabels.length; i++)
                    {
                        var axTick = selection.append("line")
                                    .attr("class", m_props.isAxisColorFixed ? m_vClassNames.fixedAxisLine : m_vClassNames.axisLine)
                                    .attr("x1", maxTextWidth + nOffset*m_textOffset)
                                    .attr("x2", maxTextWidth + nOffset*m_textOffset + m_tickSize)
                                    .attr("y1", m_axScale(axTicksLabels[i].value))
                                    .attr("y2", m_axScale(axTicksLabels[i].value))
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");

                        var drawLine = function()
                        {
                            var gridline = selection.append("line")
                            .attr("class", m_vClassNames.gridLine)
                                        .attr("y1", m_axScale(axTicksLabels[i].value))
                                        .attr("y2", m_axScale(axTicksLabels[i].value))
                                        .attr("x1", maxTextWidth + nOffset*m_textOffset + m_tickSize)
                                        .attr("x2", maxTextWidth + nOffset*m_textOffset + m_tickSize + m_props.gridline.length)
                                        .attr("stroke", m_props.gridline.color)
                                        .attr("stroke-width", m_props.gridline.size)
                                        .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");

                            if(m_props.gridline.type == "dotted")
                            {
                                 gridline.attr("stroke-dasharray", "3, 2");
                            }

                            if(m_props.gridline.type == "incised")
                            {
                                var gridline = selection.append("line")
                                .attr("class", m_vClassNames.incisedGridLine)
                                .attr("y1", m_axScale(axTicksLabels[i].value)+1)
                                .attr("y2", m_axScale(axTicksLabels[i].value)+1)
                                .attr("x1", maxTextWidth + nOffset*m_textOffset + m_tickSize)
                                .attr("x2", maxTextWidth + nOffset*m_textOffset + m_tickSize + m_props.gridline.length)
                                .attr("stroke", m_styleGridIncisedLineColor)
                                .attr("stroke-width", m_props.gridline.size)
                                .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");
                            }
                            
                        };

                        if( i == 0 && m_props.gridline.showFirstLine)
                        {
                             drawLine();
                        }
                        else if ( i == (axTicksLabels.length - 1) && m_props.gridline.showLastLine)
                        {
                             drawLine();
                        }
                        else if ( (i != (axTicksLabels.length - 1))
                               && (i != 0)
                               && m_props.gridline.visible )
                        {
                             drawLine();
                        }
                        
                        //selection.append("circle").attr("cx", maxTextWidth).attr("cy", m_axScale(axTicksLabels.value[i])). attr("r", 3);
                        if(m_props.label.visible)
                        {
                            var text = selection
						   .append("g")
                           .attr("fill", m_style.defaultStyle.label.fill)
                           .attr("class", m_axisLabelClassCombined)
                           .attr("font-size", m_style.defaultStyle.label['font-size'])
                           .attr("font-weight", m_style.defaultStyle.label['font-weight'])
                           .attr("font-family", m_style.defaultStyle.label['font-family'])                                
                           .append("text")
                           .attr("x", maxTextWidth + m_textOffset)
                           .attr("y", m_axScale(axTicksLabels[i].value))
                           .attr("dominant-baseline", "middle")//"auto")//"hanging")//"central")
                           .attr("text-anchor", "end") // text-align
                           .text(axTicksLabels[i].text);

                            adjustLabelForIE(text);
                        }
                    }

                    if (m_props.axisline.visible) {
                        var x1 = maxTextWidth + nOffset*m_textOffset + m_tickSize;
                        var x2 = maxTextWidth + nOffset*m_textOffset + m_tickSize;
                        var y1 = axRange[0];
                        var y2 = axRange[1];

                        var endSize = 0;//m_tickSizes
                        var dPath  = "M" + (x1 - endSize) + " " + y1;
                            dPath += "L" + x1 + " " + y1;
                            dPath += "L" + x2 + " " + y2;
                            dPath += "L" + (x2 - endSize) + " " + y2;
                        
                        var axLine = selection.append("path")
                        .attr("class", m_props.isAxisColorFixed ? m_vClassNames.fixedAxisLine : m_vClassNames.axisLine)
                                    .attr("d", dPath)
                                    .attr("fill", "none")
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");
                    }
                }
                else if(m_position == "right")
                {
                    //we must change axTicksLabels, remove some lable array items for label management
                    //console.log(axTicksLabels);
                    axTicksLabels = buildToDrawLabels(axTicksLabels, m_position);
                    if(m_props.label.visible) {
                        var textArray = [];
                        for(var i = 0; i < axTicksLabels.length; i++)
                        {
                            textArray.push(axTicksLabels[i].text);
                        }
                        maxTextWidth = maxLabelTextWidth(textArray);
                    }
                    if ((m_spaceLimit != -1) && (maxTextWidth + m_tickSize + 2*m_textOffset + m_styleLineSrokeWidth/2 > m_spaceLimit)) {
                        axTicksLabels = [];
                        maxTextWidth = 0;
                    }

                    for(var i = 0; i < axTicksLabels.length; i++)
                    {
                        var axTick = selection.append("line")
                        .attr("class", m_props.isAxisColorFixed ? m_vClassNames.fixedAxisLine : m_vClassNames.axisLine)
                                    .attr("x1", 0)
                                    .attr("x2", m_tickSize)
                                    .attr("y1", m_axScale(axTicksLabels[i].value))
                                    .attr("y2", m_axScale(axTicksLabels[i].value))
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");

                        var drawLine = function()
                        {
                            var gridline = selection.append("line")
                            .attr("class", m_vClassNames.gridLine)
                                        .attr("y1", m_axScale(axTicksLabels[i].value))
                                        .attr("y2", m_axScale(axTicksLabels[i].value))
                                        .attr("x1", -m_props.gridline.length)
                                        .attr("x2", 0)
                                        .attr("stroke", m_props.gridline.color)
                                        .attr("stroke-width", m_props.gridline.size)
                                        .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");

                            if(m_props.gridline.type == "dotted")
                            {
                                 gridline.attr("stroke-dasharray", "3, 2");
                            }
                            if(m_props.gridline.type == "incised")
                            {
                                var gridline = selection.append("line")
                                .attr("class", m_vClassNames.incisedGridLine)
                                .attr("y1", m_axScale(axTicksLabels[i].value)+1)
                                .attr("y2", m_axScale(axTicksLabels[i].value)+1)
                                .attr("x1", -m_props.gridline.length)
                                .attr("x2", 0)
                                .attr("stroke", m_styleGridIncisedLineColor)
                                .attr("stroke-width", m_props.gridline.size)
                                .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");
                            }
                        };

                        if( i == 0 && m_props.gridline.showFirstLine)
                        {
                             drawLine();
                        }
                        else if ( i == (axTicksLabels.length - 1) && m_props.gridline.showLastLine)
                        {
                             drawLine();
                        }
                        else if ( (i != (axTicksLabels.length - 1))
                               && (i != 0)
                               && m_props.gridline.visible )
                        {
                             drawLine();
                        }

                        //selection.append("circle").attr("cx", m_tickSize + m_textOffset).attr("cy", m_axScale(axTicksLabels.value[i])). attr("r", 3);
                        if(m_props.label.visible)
                        {
                            var text = selection
						    .append("g")							
                            .attr("fill", m_style.defaultStyle.label.fill)
                            .attr("class", m_axisLabelClassCombined)
                            .attr("font-size", m_style.defaultStyle.label['font-size'])
                            .attr("font-weight", m_style.defaultStyle.label['font-weight'])
                            .attr("font-family", m_style.defaultStyle.label['font-family'])                                
                            .append("text")
                            .attr("x", m_tickSize + m_textOffset)
                            .attr("y", m_axScale(axTicksLabels[i].value))
                            .attr("dominant-baseline", "middle")//"auto")//"hanging")//"central")
                            .attr("text-anchor", "start") // text-align
                            .text(axTicksLabels[i].text);

                            adjustLabelForIE(text);
                        }
                    }

                    if (m_props.axisline.visible) {
                        var x1 = 0;
                        var x2 = 0;
                        var y1 = axRange[0];
                        var y2 = axRange[1];

                        var endSize = 0;//m_tickSizes
                        var dPath  = "M" + (x1 + endSize) + " " + y1;
                            dPath += "L" + x1 + " " + y1;
                            dPath += "L" + x2 + " " + y2;
                            dPath += "L" + (x2 + endSize) + " " + y2;

                        var axLine = selection.append("path")
                        .attr("class", m_props.isAxisColorFixed ? m_vClassNames.fixedAxisLine : m_vClassNames.axisLine)
                                .attr("d", dPath)
                                .attr("fill", "none")
                                .attr("stroke", m_props.color)
                                .attr("stroke-width", m_props.lineSize)
                                .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");
                    }
                }
            };

        var adjustLabelForIE = function(text)
        {
            if( UADetector.isIE())
            {
                //dominant-baseline does not work
                var textHeight = m_style.realStyle.label['font-size'].toString();
                var indexPX = textHeight.indexOf("px");
                if(indexPX >= 0)
                {
                    textHeight = textHeight.substr(0, indexPX);
                }

                //textHeight = fastMeasure(text, m_style.realStyle.label).height;
                var y = text.attr("y");
                text.attr("y", Number(y) + textHeight/2);
                text.attr("dominant-baseline", "auto");
            }
        }

        axis.matrix = function(_){
          if(!arguments.length){
            return m_matrix;
          }
          m_matrix = _;
          return axis;
        };
        
        axis.labelAngle = function(_){
          if(!arguments.length){
            return labelAngle;
          }
          labelAngle = _;
          return axis;
        };
        
        axis.tickAngle = function(_){
          if(!arguments.length){
            return tickAngle;
          }
          tickAngle = _;
          return axis;
        };
        
        axis.angle = function(_){
          if(!arguments.length){
            return angle;
          }
          angle = _;
          return axis;
        };
        
        axis.labelAlign = function(_){
          if(!arguments.length){
            return labelAlign;
          }
          labelAlign = _;
          return axis;
        };
        
        axis.position = function(_position) {
            if (!arguments.length) 
                return m_position;
            m_position = _position;
            return axis;
        };
        
        axis.style = function(_style) {
          if(arguments.length == 0)
            return m_style;
          m_style = Objects.extend(true, m_style, _style);
          return axis;
        };

        axis.properties = function(_properties) {
            if (arguments.length == 0)
                return m_props;

            m_props = extendObj(m_props, _properties);
            return axis;
        };

        axis.axScale = function(_axScale) {
            if (!arguments.length) 
                return m_axScale;
            m_axScale = _axScale;
            return axis;
        };

        axis.startPadding = function() {
            if(m_axScale)
            {
                var axTicksLabels = buildToDrawLabels(getTicksLabel(), m_position);
                
                var labelSize = 0;
                if(axTicksLabels.length > 0)
                {
                    labelSize = fastMeasure(axTicksLabels[0].text, m_style.realStyle.label);
                }
                if(labelSize == 0){
                  return 0;
                }
                if(m_position == "top" || m_position == "bottom")
                {
                    return labelSize.width/2;
                }
                else
                {
                    return labelSize.height/2;
                }
            }
            else
            {
                return 0;
            }
        };
        
        axis.setTitle = function(_)
        {
            m_title = _;
            return axis;
        };        

        axis.endPadding = function() {
            if(m_axScale)
            {
                var axTicksLabels = buildToDrawLabels(getTicksLabel(), m_position);

                var labelSize = 0;

                if(axTicksLabels.length > 0)
                {
                    labelSize = fastMeasure(axTicksLabels[axTicksLabels.length-1].text, m_style.realStyle.label);
                }
                if(labelSize == 0){
                  return 0;
                }
                if(m_position == "top" || m_position == "bottom")
                {
                    return labelSize.width/2;
                }
                else
                {
                    return labelSize.height/2;
                }
            }
            else
            {
                return 0;
            }
        };

        axis.getPreferredSize = function() {

            var axDomain = m_axScale.domain();//[0, 100]
            var axRange = m_axScale.range();//[0, 200]

            var axisWidth = 0;
            var axisHeight = 0;

            var axisSpacings = [];

            if( !(axRange[0] == 0 && axRange[1] == 0) )
            {

                var absRange = Math.abs(axRange[0] - axRange[1]);
                
                if(m_position == "bottom" || m_position == "top")
                {
                    axisWidth = absRange + m_styleLineSrokeWidth;
                    if(m_props.label.visible)
                    {
						var axTicksLabels = buildToDrawLabels(getTicksLabel(), m_position);
                        var textArray = [];
                        for(var i = 0; i < axTicksLabels.length; i++)
                        {
                            textArray.push(axTicksLabels[i].text);
                        }
                        axisHeight = maxLabelTextHeight(textArray) + m_tickSize + 2*m_textOffset + m_styleLineSrokeWidth/2;
                    }
                    else
                    {
                        axisHeight = m_tickSize + m_textOffset + m_styleLineSrokeWidth/2;
                    }
                    axisSpacings.push(axisHeight);
                }
                else if(m_position == "left" || m_position == "right")
                {
                    if(m_props.label.visible)
                    {
                        var axTicksLabels = buildToDrawLabels(getTicksLabel(), m_position);
                        var textArray = [];
                        for(var i = 0; i < axTicksLabels.length; i++)
                        {
                            textArray.push(axTicksLabels[i].text);
                        }
                        
                        if( fastMeasure(textArray[0], m_style.realStyle.label).height > absRange ){
                            axisWidth = m_tickSize + 2*m_textOffset;
                        }else{
                            axisWidth =  maxLabelTextWidth(textArray) + m_tickSize + 2*m_textOffset + m_styleLineSrokeWidth/2;;
                        }
                    }
                    else
                    {
                        axisWidth = m_tickSize + m_textOffset + m_styleLineSrokeWidth/2;
                    }
                    axisSpacings.push(axisWidth);

                    axisHeight = absRange + m_styleLineSrokeWidth;
                }
            }

            return {
                width : axisWidth,
                height : axisHeight,
                spacings : axisSpacings,

            };
        };
        
        axis.destroy = function() {
          m_selection = null;
          m_axScale = null;
        };

        var buildToDrawLabels = function(axTicksLabels, type)
        {
            if(axTicksLabels.length > 0)
            {
                if(m_axScale (axTicksLabels[0].value) > m_axScale (axTicksLabels[axTicksLabels.length-1].value))
                {
                    axTicksLabels.reverse();
                }
            }
            //build the "todraw" array
            //count all the labels y1 and y2, and save them.
            var allTicksLabels = [];
            for(var i = 0; i < axTicksLabels.length; i++)
            {   
              if(!NumberUtils.isNoValue(axTicksLabels[i].value)){
                var item = {};
                item.value = axTicksLabels[i].value;
                item.text = axTicksLabels[i].text;

                //count y1 and y2
                var itemSize = fastMeasure (item.text, m_style.realStyle.label);
                var center = m_axScale (item.value);

                if (type == 'left' || type == 'right') {
                    item.start =  center - itemSize.height/2;
                    item.end =   center + itemSize.height/2;
                } else {
                    item.start = center - itemSize.width/2;
                    item.end = center + itemSize.width/2;
                }
                
                allTicksLabels.push(item);
              }
            }
            //console.log(allTicksLabels);

            var ticksLabelsToDraw = [];
            ticksLabelsToDraw = calculateLabelsToDraw(allTicksLabels);

            //console.log(ticksLabelsToDraw);
            return ticksLabelsToDraw;
        };

        var drawTopBottomLabels = function(selection, type, ticksLabels, maxTextHeight)
        {
            if(ticksLabels.length == 0)
            {
                return;
            }
            var ticksLabelsToDraw = buildToDrawLabels(ticksLabels, type);

            //console.log(ticksLabelsToDraw);
            for(var i = 0; i < ticksLabelsToDraw.length; i++)
            {
              if(angle){
                var aAngle = angle * Math.PI /180;
                var cosAngle = Math.cos(aAngle);
                var sinAngle = (45 === angle) ? cosAngle : Math.sin(aAngle);
                var tAngle = tickAngle * Math.PI / 180;
                var cosTAngle = Math.cos(tAngle);
                var sinTAngle = Math.sin(tAngle);
                
                var tickStartX  =    m_axScale(ticksLabelsToDraw[i].value) * sinAngle;
                tickStartY =  -  m_axScale(ticksLabelsToDraw[i].value) * cosAngle;
                
                var item = selection
			      .append("g")				
                  .attr("fill", m_style.defaultStyle.label.fill)
                  .attr("class", m_axisLabelClassCombined)
                  .attr("font-size", m_style.defaultStyle.label['font-size'])
                  .attr("font-weight", m_style.defaultStyle.label['font-weight'])
                  .attr("font-family", m_style.defaultStyle.label['font-family'])                    
                  .append('text')
                  .attr('x', tickStartX + ( m_textOffset + m_tickSize) * cosTAngle)
                  .attr('y', tickStartY + ( m_textOffset + m_tickSize) * sinTAngle)
                  .attr("dominant-baseline", "middle")//"auto")//"hanging")//"central")
                  .attr("text-anchor", 'start') // text-align
                  .text(ticksLabelsToDraw[i].text);
          
                  if(tickAngle > 90){
                    item.attr("text-anchor", 'end').attr('transform', 'rotate( ' + (tickAngle - 180) + ' ' +item.attr("x") + ' ' +item.attr("y") + ')');
                  }else{
                    item.attr('transform', 'rotate( ' + (tickAngle) + ' ' +item.attr("x") + ' ' +item.attr("y") + ')');
                  }
              }else{
              //selection.append("circle").attr("cx", m_axScale(axTicksLabels.value[i])).attr("cy", m_textOffset + m_tickSize). attr("r", 3);
                var item = selection
				 .append("g")				
                 .attr("fill", m_style.defaultStyle.label.fill)
                 .attr("class", m_axisLabelClassCombined)
                 .attr("font-size", m_style.defaultStyle.label['font-size'])
                 .attr("font-weight", m_style.defaultStyle.label['font-weight'])
                 .attr("font-family", m_style.defaultStyle.label['font-family'])                    
                 .append("text")
                 .attr("x", m_axScale(ticksLabelsToDraw[i].value))
                 .attr("y", m_textOffset + m_tickSize)
                 .attr("dominant-baseline", "hanging")//"auto")//"hanging")//"central")
                 .attr("text-anchor", "middle") // text-align
                 .text(ticksLabelsToDraw[i].text);

                //IE does not support dominant-baseline
                item.attr("dominant-baseline", "auto");
                item.attr("y", maxTextHeight + m_textOffset);
              }
            }
        };

        var calculateLabelsToDraw = function(allTicksLabels)
        {
            var labelsToDraw = [];
            
            if(allTicksLabels.length > 0)
            {
                //split allTicksLabels if it is required.
                if( !(allTicksLabels[0].value >= 0 && allTicksLabels[allTicksLabels.length - 1].value >= 0) 
                  &&!(allTicksLabels[0].value <= 0 && allTicksLabels[allTicksLabels.length - 1].value <= 0)
                  )
                {
                    var negativeArray = [];
                    var positiveArray = [];
                    for(var i = 0; i < allTicksLabels.length; i++)
                    {
                        if(allTicksLabels[i].value <= 0) {
                            negativeArray.push(allTicksLabels[i]);
                        }

                        if(allTicksLabels[i].value >= 0) {
                            positiveArray.push(allTicksLabels[i]);
                        }
                    }

                    var head;
                    var nal = negativeArray.length;
                    if (negativeArray[0].value <= negativeArray[nal-1].value) {
                        head = negativeArray[0];
                    } else {
                        head = negativeArray[nal-1];
                    }
                    var tail;
                    var pal = positiveArray.length;
                    if (positiveArray[0].value <= positiveArray[pal -1].value) {
                        tail = positiveArray[pal -1];
                    } else {
                        tail = positiveArray[0];
                    }

                    negativeArray = calculateLabelsToDrawHelper(negativeArray);
                    positiveArray = calculateLabelsToDrawHelper(positiveArray);

                    if (negativeArray[0].value > negativeArray[negativeArray.length-1].value) {
                        negativeArray.reverse();
                    }
                    if (positiveArray[0].value > positiveArray[positiveArray.length-1].value) {
                        positiveArray.reverse();
                    }

                    if( negativeArray[negativeArray.length -1].value == 0
                        && positiveArray[0].value == 0)
                    {
                        negativeArray.pop();
                    }

                    var labelsToDrawTemp = negativeArray.concat(positiveArray);
                    if (head.value !== labelsToDrawTemp[0].value) {
                        labelsToDrawTemp.splice(0, 0, head);
                    }
                    if (tail.value !== labelsToDrawTemp[labelsToDrawTemp.length-1].value) {
                        labelsToDrawTemp.push(tail);
                    }
                    if (labelsToDrawTemp[0].start > labelsToDrawTemp[labelsToDrawTemp.length-1].start) {
                        labelsToDrawTemp.reverse();
                    }
                    labelsToDraw = calculateLabelsToDrawHelper(labelsToDrawTemp);
                }
                else
                {
                    labelsToDraw = calculateLabelsToDrawHelper(allTicksLabels);
                }
            }

            //BITVIZA-454 [label management] When the height/width of 
            //vertical/horizontal axis is small that can only hold one axis label, the label 
            //should be hidden.
            if(labelsToDraw.length <= 1)
            {
                labelsToDraw = [];
            }

            return labelsToDraw;
        }

        var calculateLabelsToDrawHelper = function(allTicksLabels)
        {
            //allTicksLabels:
            //[0, X]
            //[-X, 0]
            //[X1, X2] (X1>0, X2>0)
            //[X1, X2] (X1<0, X2<0)

            //now we should decide which label to draw.
            //iBeyond = 0:0,1,2,3,4,5,6,...
            //iBeyond = 1:0, ,2, ,4, ,6,...
            //iBeyond = 2:0, , ,3, , ,6,...
            //...
            //iBeyond = (allTicksLabels.length - 1):0
            var ticksLabelsToDraw = [];

            for(var iBeyond = 0; iBeyond <= (allTicksLabels.length - 1); iBeyond++)
            {
                var isDrawable = true;
                for(var i = 0; i < allTicksLabels.length-1; i+=(iBeyond+1))
                {
                    var item = allTicksLabels[i];
                    if(i != 0)
                    {
                        var previousItem = ticksLabelsToDraw[ticksLabelsToDraw.length-1];
                        if (allTicksLabels[i].start <= previousItem.end)
                        {
                            //for [0.9,1,2,3....], if cannot draw second axis label, just ignore second, then continue
                            if (ticksLabelsToDraw.length > 1) {
                                isDrawable = false;
                                break;
                            }
                        } else {
                            ticksLabelsToDraw.push(item);
                        }
                    } else {
                        //add the first axis tick label
                        ticksLabelsToDraw.push(item);
                    }
                }
                //for [.....5,5.1], always draw the last axis tick label
                var lastItem = allTicksLabels[allTicksLabels.length-1];
                if (lastItem.start < ticksLabelsToDraw[ticksLabelsToDraw.length-1].end) {
                    ticksLabelsToDraw.pop();
                }
                ticksLabelsToDraw.push(lastItem);
                
                if(isDrawable) {//find the labels
                    break;
                } else {
                    ticksLabelsToDraw = [];
                }
            }
            
            return ticksLabelsToDraw;
        }

        var getTicksLabel = function ()
        {
            var axDomain = m_axScale.domain();//[-100, 2000]

            var tickNum = m_axDefaultTickNum;
            if(m_axScale.tickHint)//after perfect
            {
                tickNum = m_axScale.tickHint;
            }

            var axTicksLabels = m_axScale.ticks(tickNum);//[0, 2000, 4000, ...]
            // [21-Sep-2012 Nick ] FIXME Comment out this part to fix bug BITVIZA-383, any particular reason to filter ticks?
            // if it is yes, what kind of criteria should be taken?
//            if(axTicksLabels.length > 20)
//            {
//                //too many ticks. filter some ticks
//                var tempTicks = [];
//                for(var i = 0; i < axTicksLabels.length; i++)
//                {
//                    if(axTicksLabels[i].toString().substr(0,1) == "1"
//                      || axTicksLabels[i].toString().substr(0,1) == "2"
//                      || axTicksLabels[i].toString().substr(0,1) == "5")
//                    {
//                        tempTicks.push(axTicksLabels[i]);
//                    }
//                }
//                axTicksLabels = tempTicks;
//            }

            for(var i=0; i < axTicksLabels.length; i++){
              axTicksLabels[i] = NumberUtils.precise( axTicksLabels[i]);
            }
            var beginLabel;
            var endLabel;
            if(axDomain[0] <= axDomain[axDomain.length -1])
            {
                beginLabel = axDomain[0];
                endLabel = axDomain[axDomain.length -1];
            }
            else
            {
                beginLabel = axDomain[axDomain.length -1];
                endLabel = axDomain[0];
            }

            if(axTicksLabels.length > 0)
            {
                if(axTicksLabels[0] != beginLabel) {
                    //the first label is not the first doamin. Add it.
                    axTicksLabels.unshift(beginLabel);
                }
                
                if(axTicksLabels[axTicksLabels.length -1] != endLabel) {
                    //the last label is not the end. Add it.
                    axTicksLabels.push(endLabel);
                }
            }

            var ticks = [];
            for(var i = 0; i < axTicksLabels.length; i++)
            {
                var tickItem = {};
                tickItem.value = axTicksLabels[i];
                if(m_props.isPercentMode)
                {
                    tickItem.text = NumberUtils.precise(axTicksLabels[i]*100).toString();
                }
                else
                {
                    tickItem.text = NumberUtils.precise(axTicksLabels[i]).toString();
                }
                ticks.push(tickItem);
            }

          //format value label by d3
            if(m_props.label)
            {
                if(!m_props.label.formatString && m_props.label.numberFormat){
                    for(var i = 0; i < axTicksLabels.length; i++)
                    {
                        var formatFun = d3.format(m_props.label.numberFormat);
                        ticks[i].text = (formatFun(axTicksLabels[i]));
                    }
                }else if(m_props.label.formatString){
                    var formatString = m_props.label.formatString;
                    for(var i = 0; i < axTicksLabels.length; i++)
                    {
                        ticks[i].text = (FormatManager.format(axTicksLabels[i], formatString));
                    }
                }
                
            }
            
            return ticks;
        }

        var maxLabelTextHeight = function (textArray)
        {
            var isVerticalFont = m_props.forceVerticalFont === true ? true: false;
            var maxTextHeight = 0;
            for(var i = 0; i <  textArray.length; i++)
            {
                var tLen =  0 ;
                if( isVerticalFont ){
                  tLen =  fastMeasure(textArray[i], m_style.realStyle.label).width;
                }else{
                  tLen = fastMeasure(textArray[i], m_style.realStyle.label).height;
                }
                if(maxTextHeight < tLen)
                {
                    maxTextHeight = tLen;
                }
            }
            return maxTextHeight;
        }

        var maxLabelTextWidth = function (textArray)
        {
            var isVerticalFont = m_props.forceVerticalFont === true ? true: false;
            var maxTextWidth = 0;
            for(var i = 0; i <  textArray.length; i++)
            {
                var tLen = 0; 
                if( isVerticalFont ){
                  tLen = fastMeasure(textArray[i], m_style.realStyle.label).height;
                } else {
                  tLen = fastMeasure(textArray[i], m_style.realStyle.label).width;
                }
                
                if(maxTextWidth < tLen)
                {
                    maxTextWidth = tLen;
                }
            }
            return maxTextWidth;
        }
        
        var fastMeasure = function(_text, _style)
        {
            return TextUtils.superFastMeasure(_text, _style['font-size'],
                                                _style['font-weight'],
                                                _style['font-family']);
        }        

        var extendObj = function(target, source)
        {
            for(var prop in source)
            {
                if(typeof(source[prop]) === "object")
                {
                    if(target[prop])
                    {
                        target[prop] = extendObj(target[prop], source[prop]);
                    }
                    else
                    {
                        target[prop] = source[prop];
                    }
                }
                else
                {
                    target[prop] = source[prop];
                }
            }
            return target;
        };
        
        return axis;
    };
  return ret;
});

define('sap/viz/modules/axis/SimpleValue',['sap/viz/base/utils/oo',
'sap/viz/modules/axis/BaseValue',
'sap/viz/modules/dispatch',
'sap/viz/modules/axis/simpleValueCore'],
function Setup(oo, BaseValue, dispatch, simpleValueCore) {
    var axis = function(manifest, ctx) {
        axis.superclass.constructor.apply(this,arguments);

        axis.prototype.setCoreModule(simpleValueCore);
    };

    //the start point
    oo.extend(axis,BaseValue);
    
    //overwritten fun
    axis.prototype.render = function(selection, isNewSVG)
    {
        return axis.superclass.render.call(this, selection, isNewSVG);
    };    

    return axis;
});

define('sap/viz/modules/axis/simpleValueLeftCore',['jquery', 'sap/viz/modules/Constants', 'sap/viz/util/TextUtils','sap/viz/util/NumberUtils','sap/viz/base/utils/Objects','sap/viz/format/FormatManager',
'sap/viz/modules/threeD/Point','sap/viz/modules/threeD/matrix', 'sap/viz/base/UADetector'],
function Setup(jQuery, ModuleConstants, TextUtils, NumberUtils, Objects, FormatManager, Point, matrix, UADetector) {

  var ret = function() {
   
        var m_position;
        var m_title;
        
        var m_axScale = null;

        var m_tickSize = 5;
        var m_textOffset = 6;

        var m_axDefaultTickNum = 7;

        var m_styleLineSrokeWidth = 1;
        var m_styleAxisColor = "#6c6c6c";
        var m_styleGridLineColor = "#d8d8d8";
        var m_styleGridIncisedLineColor = "#ffffff";
        var m_styleAxisLabelColor = "#333333";
        
        var m_axLabelClassName = "viz-axis-label";        
        
        var m_style = null;
        var m_props = { 
            "title": {"visible": false, "text": undefined,},
            "gridline": {"visible": true, "color": m_styleGridLineColor, "showFirstLine": false, "length": 0, "showLastLine": false, "type":"line"},
            "type" : "value",
            "visible" : true,
            "label": {"visible": true, "numberFormat" : "","formatString": "", },
            "position": "left",
            "color": m_styleAxisColor,
            "axisline" : {"visible": true},
            "shapeRendering": true
        };

        var m_vClassNames = 
        {
            axis:"v-axis",
            axisBody:"v-body",
            axisTitle:"v-title",
            axisLabel:"v-label",
            axisLine: "v-valueaxisline",
            gridLine: "v-gridline",
            incisedGridLine: "v-incised-gridline",
            fixedAxisLine: "v-fixed-valueaxisline",
            morphableLabel:ModuleConstants.CSS.CLASS.MORPHABLELABEL
        };
        
        var m_axisLabelClassCombined = m_vClassNames.axisLabel + ' ' + m_axLabelClassName + ' ' + m_vClassNames.morphableLabel;

        var m_matrix = matrix(), labelAngle = null, labelAlign = null, angle = null, tickAngle = null;
        
        var m_spaceLimit = -1;
        axis.spaceLimit = function(_spaceLimit)
        {
            if (!arguments.length) 
                return m_spaceLimit;
            m_spaceLimit = _spaceLimit;
            return axis;
        }

        function axis(selection) {
                
                var axRange = m_axScale.range();//[0, 500]
                var axDomain = m_axScale.domain();//[-100, 2000]

                if(axRange[0] == 0 && axRange[1] == 0)
                {
                    return;//do not draw value axis
                }

                var axTicksLabels = getTicksLabel();

                if(m_position == "left")
                {
                    //we must change axTicksLabels, remove some lable array items for label management
                    //console.log(axTicksLabels);
                    axTicksLabels = buildToDrawLabels(axTicksLabels, m_position);

                    //count the max text width
                    var maxTextWidth = 0;
                    if(m_props.label.visible) {
                        var textArray = [];
                        for(var i = 0; i < axTicksLabels.length; i++)
                        {
                            textArray.push(axTicksLabels[i].text);
                        }
                        maxTextWidth = maxLabelTextWidth(textArray);
                    }
                    if ((m_spaceLimit != -1) && (maxTextWidth + m_tickSize + 2*m_textOffset + m_styleLineSrokeWidth/2 > m_spaceLimit)) {
                        axTicksLabels = [];
                        maxTextWidth = 0;
                    }

                    var nOffset = 1;
                    if(m_props.label.visible)
                    {
                        nOffset = 2;
                    }

                    for(var i = 0; i < axTicksLabels.length; i++)
                    {
                        var axTick = selection.append("line")
                                    .attr("class", m_props.isAxisColorFixed ? m_vClassNames.fixedAxisLine : m_vClassNames.axisLine)
                                    .attr("x1", maxTextWidth + nOffset*m_textOffset)
                                    .attr("x2", maxTextWidth + nOffset*m_textOffset + m_tickSize)
                                    .attr("y1", m_axScale(axTicksLabels[i].value))
                                    .attr("y2", m_axScale(axTicksLabels[i].value))
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");

                        var drawLine = function()
                        {
                            var gridline = selection.append("line")
                            .attr("class", m_vClassNames.gridLine)
                                        .attr("y1", m_axScale(axTicksLabels[i].value))
                                        .attr("y2", m_axScale(axTicksLabels[i].value))
                                        .attr("x1", maxTextWidth + nOffset*m_textOffset + m_tickSize)
                                        .attr("x2", maxTextWidth + nOffset*m_textOffset + m_tickSize + m_props.gridline.length)
                                        .attr("stroke", m_props.gridline.color)
                                        .attr("stroke-width", m_props.gridline.size)
                                        .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");

                            if(m_props.gridline.type == "dotted")
                            {
                                 gridline.attr("stroke-dasharray", "3, 2");
                            }

                            if(m_props.gridline.type == "incised")
                            {
                                var gridline = selection.append("line")
                                .attr("class", m_vClassNames.incisedGridLine)
                                .attr("y1", m_axScale(axTicksLabels[i].value)+1)
                                .attr("y2", m_axScale(axTicksLabels[i].value)+1)
                                .attr("x1", maxTextWidth + nOffset*m_textOffset + m_tickSize)
                                .attr("x2", maxTextWidth + nOffset*m_textOffset + m_tickSize + m_props.gridline.length)
                                .attr("stroke", m_styleGridIncisedLineColor)
                                .attr("stroke-width", m_props.gridline.size)
                                .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");
                            }
                            
                        };

                        if( i == 0 && m_props.gridline.showFirstLine)
                        {
                             drawLine();
                        }
                        else if ( i == (axTicksLabels.length - 1) && m_props.gridline.showLastLine)
                        {
                             drawLine();
                        }
                        else if ( (i != (axTicksLabels.length - 1))
                               && (i != 0)
                               && m_props.gridline.visible )
                        {
                             drawLine();
                        }
                        
                        //selection.append("circle").attr("cx", maxTextWidth).attr("cy", m_axScale(axTicksLabels.value[i])). attr("r", 3);
                        if(m_props.label.visible)
                        {
                            var text = selection
						   .append("g")
                           .attr("fill", m_style.defaultStyle.label.fill)
                           .attr("class", m_axisLabelClassCombined)
                           .attr("font-size", m_style.defaultStyle.label['font-size'])
                           .attr("font-weight", m_style.defaultStyle.label['font-weight'])
                           .attr("font-family", m_style.defaultStyle.label['font-family'])                                
                           .append("text")
                           .attr("x", maxTextWidth + m_textOffset)
                           .attr("y", m_axScale(axTicksLabels[i].value))
                           .attr("dominant-baseline", "middle")//"auto")//"hanging")//"central")
                           .attr("text-anchor", "end") // text-align
                           .text(axTicksLabels[i].text);

                            adjustLabelForIE(text);
                        }
                    }

                    if (m_props.axisline.visible) {
                        var x1 = maxTextWidth + nOffset*m_textOffset + m_tickSize;
                        var x2 = maxTextWidth + nOffset*m_textOffset + m_tickSize;
                        var y1 = axRange[0];
                        var y2 = axRange[1];

                        var endSize = 0;//m_tickSizes
                        var dPath  = "M" + (x1 - endSize) + " " + y1;
                            dPath += "L" + x1 + " " + y1;
                            dPath += "L" + x2 + " " + y2;
                            dPath += "L" + (x2 - endSize) + " " + y2;
                        
                        var axLine = selection.append("path")
                        .attr("class", m_props.isAxisColorFixed ? m_vClassNames.fixedAxisLine : m_vClassNames.axisLine)
                                    .attr("d", dPath)
                                    .attr("fill", "none")
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");
                    }
                }
            };

        var adjustLabelForIE = function(text)
        {
            if( UADetector.isIE())
            {
                //dominant-baseline does not work
                var textHeight = m_style.realStyle.label['font-size'].toString();
                var indexPX = textHeight.indexOf("px");
                if(indexPX >= 0)
                {
                    textHeight = textHeight.substr(0, indexPX);
                }

                //textHeight = fastMeasure(text, m_style.realStyle.label).height;
                var y = text.attr("y");
                text.attr("y", Number(y) + textHeight/2);
                text.attr("dominant-baseline", "auto");
            }
        }

        axis.matrix = function(_){
          if(!arguments.length){
            return m_matrix;
          }
          m_matrix = _;
          return axis;
        };
        
        axis.labelAngle = function(_){
          if(!arguments.length){
            return labelAngle;
          }
          labelAngle = _;
          return axis;
        };
        
        axis.tickAngle = function(_){
          if(!arguments.length){
            return tickAngle;
          }
          tickAngle = _;
          return axis;
        };
        
        axis.angle = function(_){
          if(!arguments.length){
            return angle;
          }
          angle = _;
          return axis;
        };
        
        axis.labelAlign = function(_){
          if(!arguments.length){
            return labelAlign;
          }
          labelAlign = _;
          return axis;
        };
        
        axis.position = function(_position) {
            if (!arguments.length) 
                return m_position;
            m_position = _position;
            return axis;
        };
        
        axis.style = function(_style) {
          if(arguments.length == 0)
            return m_style;
          m_style = Objects.extend(true, m_style, _style);
          return axis;
        };

        axis.properties = function(_properties) {
            if (arguments.length == 0)
                return m_props;

            m_props = extendObj(m_props, _properties);
            return axis;
        };

        axis.axScale = function(_axScale) {
            if (!arguments.length) 
                return m_axScale;
            m_axScale = _axScale;
            return axis;
        };

        axis.startPadding = function() {
            if(m_axScale)
            {
                var axTicksLabels = buildToDrawLabels(getTicksLabel(), m_position);
                
                var labelSize = 0;
                if(axTicksLabels.length > 0)
                {
                    labelSize = fastMeasure(axTicksLabels[0].text, m_style.realStyle.label);
                }
                if(labelSize == 0){
                  return 0;
                }
                if(m_position == "top" || m_position == "bottom")
                {
                    return labelSize.width/2;
                }
                else
                {
                    return labelSize.height/2;
                }
            }
            else
            {
                return 0;
            }
        };
        
        axis.setTitle = function(_)
        {
            m_title = _;
            return axis;
        };        

        axis.endPadding = function() {
            if(m_axScale)
            {
                var axTicksLabels = buildToDrawLabels(getTicksLabel(), m_position);

                var labelSize = 0;

                if(axTicksLabels.length > 0)
                {
                    labelSize = fastMeasure(axTicksLabels[axTicksLabels.length-1].text, m_style.realStyle.label);
                }
                if(labelSize == 0){
                  return 0;
                }
                if(m_position == "top" || m_position == "bottom")
                {
                    return labelSize.width/2;
                }
                else
                {
                    return labelSize.height/2;
                }
            }
            else
            {
                return 0;
            }
        };

        axis.getPreferredSize = function() {

            var axDomain = m_axScale.domain();//[0, 100]
            var axRange = m_axScale.range();//[0, 200]

            var axisWidth = 0;
            var axisHeight = 0;

            var axisSpacings = [];

            if( !(axRange[0] == 0 && axRange[1] == 0) )
            {

                var absRange = Math.abs(axRange[0] - axRange[1]);
                
                if(m_position == "bottom" || m_position == "top")
                {
                    axisWidth = absRange + m_styleLineSrokeWidth;
                    if(m_props.label.visible)
                    {
						var axTicksLabels = buildToDrawLabels(getTicksLabel(), m_position);
                        var textArray = [];
                        for(var i = 0; i < axTicksLabels.length; i++)
                        {
                            textArray.push(axTicksLabels[i].text);
                        }
                        axisHeight = maxLabelTextHeight(textArray) + m_tickSize + 2*m_textOffset + m_styleLineSrokeWidth/2;
                    }
                    else
                    {
                        axisHeight = m_tickSize + m_textOffset + m_styleLineSrokeWidth/2;
                    }
                    axisSpacings.push(axisHeight);
                }
                else if(m_position == "left" || m_position == "right")
                {
                    if(m_props.label.visible)
                    {
                        var axTicksLabels = buildToDrawLabels(getTicksLabel(), m_position);
                        var textArray = [];
                        for(var i = 0; i < axTicksLabels.length; i++)
                        {
                            textArray.push(axTicksLabels[i].text);
                        }
                        
                        if( fastMeasure(textArray[0], m_style.realStyle.label).height > absRange ){
                            axisWidth = m_tickSize + 2*m_textOffset;
                        }else{
                            axisWidth =  maxLabelTextWidth(textArray) + m_tickSize + 2*m_textOffset + m_styleLineSrokeWidth/2;;
                        }
                    }
                    else
                    {
                        axisWidth = m_tickSize + m_textOffset + m_styleLineSrokeWidth/2;
                    }
                    axisSpacings.push(axisWidth);

                    axisHeight = absRange + m_styleLineSrokeWidth;
                }
            }

            return {
                width : axisWidth,
                height : axisHeight,
                spacings : axisSpacings,

            };
        };
        
        axis.destroy = function() {
          m_selection = null;
          m_axScale = null;
        };

        var buildToDrawLabels = function(axTicksLabels, type)
        {
            if(axTicksLabels.length > 0)
            {
                if(m_axScale (axTicksLabels[0].value) > m_axScale (axTicksLabels[axTicksLabels.length-1].value))
                {
                    axTicksLabels.reverse();
                }
            }
            //build the "todraw" array
            //count all the labels y1 and y2, and save them.
            var allTicksLabels = [];
            for(var i = 0; i < axTicksLabels.length; i++)
            {   
              if(!NumberUtils.isNoValue(axTicksLabels[i].value)){
                var item = {};
                item.value = axTicksLabels[i].value;
                item.text = axTicksLabels[i].text;

                //count y1 and y2
                var itemSize = fastMeasure (item.text, m_style.realStyle.label);
                var center = m_axScale (item.value);

                if (type == 'left' || type == 'right') {
                    item.start =  center - itemSize.height/2;
                    item.end =   center + itemSize.height/2;
                } else {
                    item.start = center - itemSize.width/2;
                    item.end = center + itemSize.width/2;
                }
                
                allTicksLabels.push(item);
              }
            }
            //console.log(allTicksLabels);

            var ticksLabelsToDraw = [];
            ticksLabelsToDraw = calculateLabelsToDraw(allTicksLabels);

            //console.log(ticksLabelsToDraw);
            return ticksLabelsToDraw;
        };

        var drawTopBottomLabels = function(selection, type, ticksLabels, maxTextHeight)
        {
            if(ticksLabels.length == 0)
            {
                return;
            }
            var ticksLabelsToDraw = buildToDrawLabels(ticksLabels, type);

            //console.log(ticksLabelsToDraw);
            for(var i = 0; i < ticksLabelsToDraw.length; i++)
            {
              if(angle){
                var aAngle = angle * Math.PI /180;
                var cosAngle = Math.cos(aAngle);
                var sinAngle = (45 === angle) ? cosAngle : Math.sin(aAngle);
                var tAngle = tickAngle * Math.PI / 180;
                var cosTAngle = Math.cos(tAngle);
                var sinTAngle = Math.sin(tAngle);
                
                var tickStartX  =    m_axScale(ticksLabelsToDraw[i].value) * sinAngle;
                tickStartY =  -  m_axScale(ticksLabelsToDraw[i].value) * cosAngle;
                
                var item = selection
			      .append("g")				
                  .attr("fill", m_style.defaultStyle.label.fill)
                  .attr("class", m_axisLabelClassCombined)
                  .attr("font-size", m_style.defaultStyle.label['font-size'])
                  .attr("font-weight", m_style.defaultStyle.label['font-weight'])
                  .attr("font-family", m_style.defaultStyle.label['font-family'])                    
                  .append('text')
                  .attr('x', tickStartX + ( m_textOffset + m_tickSize) * cosTAngle)
                  .attr('y', tickStartY + ( m_textOffset + m_tickSize) * sinTAngle)
                  .attr("dominant-baseline", "middle")//"auto")//"hanging")//"central")
                  .attr("text-anchor", 'start') // text-align
                  .text(ticksLabelsToDraw[i].text);
          
                  if(tickAngle > 90){
                    item.attr("text-anchor", 'end').attr('transform', 'rotate( ' + (tickAngle - 180) + ' ' +item.attr("x") + ' ' +item.attr("y") + ')');
                  }else{
                    item.attr('transform', 'rotate( ' + (tickAngle) + ' ' +item.attr("x") + ' ' +item.attr("y") + ')');
                  }
              }else{
              //selection.append("circle").attr("cx", m_axScale(axTicksLabels.value[i])).attr("cy", m_textOffset + m_tickSize). attr("r", 3);
                var item = selection
				 .append("g")				
                 .attr("fill", m_style.defaultStyle.label.fill)
                 .attr("class", m_axisLabelClassCombined)
                 .attr("font-size", m_style.defaultStyle.label['font-size'])
                 .attr("font-weight", m_style.defaultStyle.label['font-weight'])
                 .attr("font-family", m_style.defaultStyle.label['font-family'])                    
                 .append("text")
                 .attr("x", m_axScale(ticksLabelsToDraw[i].value))
                 .attr("y", m_textOffset + m_tickSize)
                 .attr("dominant-baseline", "hanging")//"auto")//"hanging")//"central")
                 .attr("text-anchor", "middle") // text-align
                 .text(ticksLabelsToDraw[i].text);

                //IE does not support dominant-baseline
                item.attr("dominant-baseline", "auto");
                item.attr("y", maxTextHeight + m_textOffset);
              }
            }
        };

        var calculateLabelsToDraw = function(allTicksLabels)
        {
            var labelsToDraw = [];
            
            if(allTicksLabels.length > 0)
            {
                //split allTicksLabels if it is required.
                if( !(allTicksLabels[0].value >= 0 && allTicksLabels[allTicksLabels.length - 1].value >= 0) 
                  &&!(allTicksLabels[0].value <= 0 && allTicksLabels[allTicksLabels.length - 1].value <= 0)
                  )
                {
                    var negativeArray = [];
                    var positiveArray = [];
                    for(var i = 0; i < allTicksLabels.length; i++)
                    {
                        if(allTicksLabels[i].value <= 0) {
                            negativeArray.push(allTicksLabels[i]);
                        }

                        if(allTicksLabels[i].value >= 0) {
                            positiveArray.push(allTicksLabels[i]);
                        }
                    }

                    var head;
                    var nal = negativeArray.length;
                    if (negativeArray[0].value <= negativeArray[nal-1].value) {
                        head = negativeArray[0];
                    } else {
                        head = negativeArray[nal-1];
                    }
                    var tail;
                    var pal = positiveArray.length;
                    if (positiveArray[0].value <= positiveArray[pal -1].value) {
                        tail = positiveArray[pal -1];
                    } else {
                        tail = positiveArray[0];
                    }

                    negativeArray = calculateLabelsToDrawHelper(negativeArray);
                    positiveArray = calculateLabelsToDrawHelper(positiveArray);

                    if (negativeArray[0].value > negativeArray[negativeArray.length-1].value) {
                        negativeArray.reverse();
                    }
                    if (positiveArray[0].value > positiveArray[positiveArray.length-1].value) {
                        positiveArray.reverse();
                    }

                    if( negativeArray[negativeArray.length -1].value == 0
                        && positiveArray[0].value == 0)
                    {
                        negativeArray.pop();
                    }

                    var labelsToDrawTemp = negativeArray.concat(positiveArray);
                    if (head.value !== labelsToDrawTemp[0].value) {
                        labelsToDrawTemp.splice(0, 0, head);
                    }
                    if (tail.value !== labelsToDrawTemp[labelsToDrawTemp.length-1].value) {
                        labelsToDrawTemp.push(tail);
                    }
                    if (labelsToDrawTemp[0].start > labelsToDrawTemp[labelsToDrawTemp.length-1].start) {
                        labelsToDrawTemp.reverse();
                    }
                    labelsToDraw = calculateLabelsToDrawHelper(labelsToDrawTemp);
                }
                else
                {
                    labelsToDraw = calculateLabelsToDrawHelper(allTicksLabels);
                }
            }

            //BITVIZA-454 [label management] When the height/width of 
            //vertical/horizontal axis is small that can only hold one axis label, the label 
            //should be hidden.
            if(labelsToDraw.length <= 1)
            {
                labelsToDraw = [];
            }

            return labelsToDraw;
        }

        var calculateLabelsToDrawHelper = function(allTicksLabels)
        {
            //allTicksLabels:
            //[0, X]
            //[-X, 0]
            //[X1, X2] (X1>0, X2>0)
            //[X1, X2] (X1<0, X2<0)

            //now we should decide which label to draw.
            //iBeyond = 0:0,1,2,3,4,5,6,...
            //iBeyond = 1:0, ,2, ,4, ,6,...
            //iBeyond = 2:0, , ,3, , ,6,...
            //...
            //iBeyond = (allTicksLabels.length - 1):0
            var ticksLabelsToDraw = [];

            for(var iBeyond = 0; iBeyond <= (allTicksLabels.length - 1); iBeyond++)
            {
                var isDrawable = true;
                for(var i = 0; i < allTicksLabels.length-1; i+=(iBeyond+1))
                {
                    var item = allTicksLabels[i];
                    if(i != 0)
                    {
                        var previousItem = ticksLabelsToDraw[ticksLabelsToDraw.length-1];
                        if (allTicksLabels[i].start <= previousItem.end)
                        {
                            //for [0.9,1,2,3....], if cannot draw second axis label, just ignore second, then continue
                            if (ticksLabelsToDraw.length > 1) {
                                isDrawable = false;
                                break;
                            }
                        } else {
                            ticksLabelsToDraw.push(item);
                        }
                    } else {
                        //add the first axis tick label
                        ticksLabelsToDraw.push(item);
                    }
                }
                //for [.....5,5.1], always draw the last axis tick label
                var lastItem = allTicksLabels[allTicksLabels.length-1];
                if (lastItem.start < ticksLabelsToDraw[ticksLabelsToDraw.length-1].end) {
                    ticksLabelsToDraw.pop();
                }
                ticksLabelsToDraw.push(lastItem);
                
                if(isDrawable) {//find the labels
                    break;
                } else {
                    ticksLabelsToDraw = [];
                }
            }
            
            return ticksLabelsToDraw;
        }

        var getTicksLabel = function ()
        {
            var axDomain = m_axScale.domain();//[-100, 2000]

            var tickNum = m_axDefaultTickNum;
            if(m_axScale.tickHint)//after perfect
            {
                tickNum = m_axScale.tickHint;
            }

            var axTicksLabels = m_axScale.ticks(tickNum);//[0, 2000, 4000, ...]
            // [21-Sep-2012 Nick ] FIXME Comment out this part to fix bug BITVIZA-383, any particular reason to filter ticks?
            // if it is yes, what kind of criteria should be taken?
//            if(axTicksLabels.length > 20)
//            {
//                //too many ticks. filter some ticks
//                var tempTicks = [];
//                for(var i = 0; i < axTicksLabels.length; i++)
//                {
//                    if(axTicksLabels[i].toString().substr(0,1) == "1"
//                      || axTicksLabels[i].toString().substr(0,1) == "2"
//                      || axTicksLabels[i].toString().substr(0,1) == "5")
//                    {
//                        tempTicks.push(axTicksLabels[i]);
//                    }
//                }
//                axTicksLabels = tempTicks;
//            }

            for(var i=0; i < axTicksLabels.length; i++){
              axTicksLabels[i] = NumberUtils.precise( axTicksLabels[i]);
            }
			
			//do not add the first and last ticks.

            var ticks = [];
            for(var i = 0; i < axTicksLabels.length; i++)
            {
                var tickItem = {};
                tickItem.value = axTicksLabels[i];
                if(m_props.isPercentMode)
                {
                    tickItem.text = NumberUtils.precise(axTicksLabels[i]*100).toString();
                }
                else
                {
                    tickItem.text = NumberUtils.precise(axTicksLabels[i]).toString();
                }
                ticks.push(tickItem);
            }

          //format value label by d3
            if(m_props.label)
            {
                if(!m_props.label.formatString && m_props.label.numberFormat){
                    for(var i = 0; i < axTicksLabels.length; i++)
                    {
                        var formatFun = d3.format(m_props.label.numberFormat);
                        ticks[i].text = (formatFun(axTicksLabels[i]));
                    }
                }else if(m_props.label.formatString){
                    var formatString = m_props.label.formatString;
                    for(var i = 0; i < axTicksLabels.length; i++)
                    {
                        ticks[i].text = (FormatManager.format(axTicksLabels[i], formatString));
                    }
                }
                
            }
            
            return ticks;
        }

        var maxLabelTextHeight = function (textArray)
        {
            var isVerticalFont = m_props.forceVerticalFont === true ? true: false;
            var maxTextHeight = 0;
            for(var i = 0; i <  textArray.length; i++)
            {
                var tLen =  0 ;
                if( isVerticalFont ){
                  tLen =  fastMeasure(textArray[i], m_style.realStyle.label).width;
                }else{
                  tLen = fastMeasure(textArray[i], m_style.realStyle.label).height;
                }
                if(maxTextHeight < tLen)
                {
                    maxTextHeight = tLen;
                }
            }
            return maxTextHeight;
        }

        var maxLabelTextWidth = function (textArray)
        {
            var isVerticalFont = m_props.forceVerticalFont === true ? true: false;
            var maxTextWidth = 0;
            for(var i = 0; i <  textArray.length; i++)
            {
                var tLen = 0; 
                if( isVerticalFont ){
                  tLen = fastMeasure(textArray[i], m_style.realStyle.label).height;
                } else {
                  tLen = fastMeasure(textArray[i], m_style.realStyle.label).width;
                }
                
                if(maxTextWidth < tLen)
                {
                    maxTextWidth = tLen;
                }
            }
            return maxTextWidth;
        }
        
        var fastMeasure = function(_text, _style)
        {
            return TextUtils.superFastMeasure(_text, _style['font-size'],
                                                _style['font-weight'],
                                                _style['font-family']);
        }        

        var extendObj = function(target, source)
        {
            for(var prop in source)
            {
                if(typeof(source[prop]) === "object")
                {
                    if(target[prop])
                    {
                        target[prop] = extendObj(target[prop], source[prop]);
                    }
                    else
                    {
                        target[prop] = source[prop];
                    }
                }
                else
                {
                    target[prop] = source[prop];
                }
            }
            return target;
        };
        
        return axis;
    };
  return ret;
});

define('sap/viz/modules/axis/SimpleValueLeft',['sap/viz/base/utils/oo',
'sap/viz/modules/axis/SimpleValue',
'sap/viz/modules/dispatch',
'sap/viz/modules/axis/simpleValueLeftCore'],
function Setup(oo, SimpleValue, dispatch, simpleValueLeftCore) {
    var axis = function(manifest, ctx) {
        axis.superclass.constructor.apply(this,arguments);

        axis.prototype.setCoreModule(simpleValueLeftCore);
    };

    //the start point
    oo.extend(axis,SimpleValue);

    return axis;
});

define('sap/viz/modules/axis/MultipleValueLeft',['sap/viz/base/utils/oo',
'sap/viz/modules/axis/SimpleValueLeft',
'sap/viz/modules/dispatch',
'sap/viz/util/TextUtils'],
function Setup(oo, SimpleValueLeft, dispatch, TextUtils) {
    var axis = function(manifest, ctx) {
        axis.superclass.constructor.apply(this,arguments);
        this._multipleValue_axisNumber = 3;
        this._multipleValue_className = "v-multiValue";
        this._multipleValue_axisGap = {};
    };

    //the start point
    oo.extend(axis,SimpleValueLeft);

    //overwritten fun
    axis.prototype.getAxisGap = function()
    {
        var m_style = axis.superclass.style.call(this);
        var fontHeight = m_style.realStyle.label["font-size"];
        fontHeight = parseFloat(fontHeight.substring(0, fontHeight.length - 2));

        this._multipleValue_axisGap.startGap = fontHeight/2;

        return this._multipleValue_axisGap;
    };

    axis.prototype.render = function(selection)
    {

        var originalSelection = selection;
        //count the height
        var rangeArray = axis.prototype.scale().range();
        var axisItemHeight = Math.abs(rangeArray[rangeArray.length - 1] - rangeArray[0]);

        var axisClass = selection.select("*");
        axisClass.remove();
        selection = selection.append("svg");
        var size = this._axis_baseValueHelperModule.size();
        selection.attr('width', size.width).attr('height', size.height);
        selection = selection.append("g").attr("class", this._multipleValue_className);

        var titleText = axis.prototype.title() + "";
        var pSize = axis.superclass.getPreferredSize.apply(this, arguments);
        var coreWidth = parseFloat(pSize.width);
        var m_style = axis.superclass.style.call(this);
        var titleWidth = fastMeasure(titleText, m_style.realStyle.title).width;
        if((coreWidth > 0) && (titleWidth > coreWidth))
        {
            //move the axis to the right
            selection.attr("transform",'translate('+ (titleWidth - coreWidth) +', 0)');
        }

        var i;
        for(i = 0; i < this._multipleValue_axisNumber; i++)
        {
            var sItem = selection.append("g");
            sItem.attr("class", "v-subaxis" + (i + 1));
            sItem.attr('transform', 'translate(' + (0) + ',' + (i*axisItemHeight) + ')');

            axis.superclass.render.call(this, sItem, false);
        }

        axis.prototype.titleRender(originalSelection);
        return this;
    };

    axis.prototype.titleRender = function(originalSelection)
    {
        //draw the title
        //make or use a title selection
        var titleClassName = "v-multipleValueLeftAxisTitle";
        var currentDOM = originalSelection.node();
        
        var parentDOM = currentDOM.parentNode;
        var titleSelection = d3.select(parentDOM).select("." + titleClassName);
        if(titleSelection.empty())
        {
            titleSelection = d3.select(parentDOM).append("div");
            titleSelection.attr("class", titleClassName);
        }
        titleSelection.select("*").remove();

        var titleText = axis.prototype.title() + "";
        var m_style = axis.superclass.style.call(this);
        var titleWidth = fastMeasure(titleText, m_style.realStyle.title).width;

        //set div style
        var m_baseOffset = 95;
        var titleStyle = titleSelection.node().style;
        titleStyle.width = titleWidth*2 + "px";//currentDOM.style.width;
        titleStyle.position = currentDOM.style.position;
        titleStyle.overflow = "visible";
        titleStyle.height = m_baseOffset/2 + "px";

        var startLeft = currentDOM.style.left;
        startLeft = parseFloat(startLeft.substring(0,startLeft.length-2));

        titleStyle.left = (startLeft) + "px";
        titleStyle.top = "0px";

        titleSelection = titleSelection.append("svg");

        var title = axis.prototype.title();

        //draw title
        var m_textOffset = 2;
        
        titleSelection
        .append("g")
        .attr("fill", m_style.defaultStyle.title.fill)
        .attr("font-size", m_style.defaultStyle.label['font-size'])
        .attr("font-weight", "bold")
        .attr("font-family", m_style.defaultStyle.label['font-family'])                        
        .append("text")
        .attr("pointer-events","none")
        .attr("x", 2*m_textOffset)
        .attr("y", 15*m_textOffset)
        .attr("dominant-baseline", "middle")//"auto")//"hanging")//"central")
        .attr("text-anchor", "start") // text-align
        .text(title);
    };

    axis.prototype.axisnumber = function(_)
    {
        if(!arguments.length)
        {
            return this._multipleValue_axisNumber;
        }

        this._multipleValue_axisNumber = _;
        return this;
    };

    axis.prototype.height = function(_)
    {
        if(_)//set
        {
            return axis.superclass.height.call(this, _/this._multipleValue_axisNumber);
        }
        else//get
        {
            var oneItemHeight = axis.superclass.height.apply(this, arguments);
            return oneItemHeight * this._multipleValue_axisNumber;
        }
    };

    axis.prototype.getPreferredSize = function(_)
    {
        var titleText = axis.prototype.title() + "";

        var pSize = axis.superclass.getPreferredSize.apply(this, arguments);
        var coreWidth = parseFloat(pSize.width);

        var m_style = axis.superclass.style.call(this);
        var titleWidth = fastMeasure(titleText, m_style.realStyle.title).width;

        var axisWidth = coreWidth;
        if((coreWidth > 0) && (titleWidth > coreWidth))
        {
            axisWidth = titleWidth;
        }

        if(axisWidth)
        {
            //set back to pSize
            pSize.width = axisWidth;
            pSize.realWidth = axisWidth;
            if(pSize.axisSpacings)
            {
                pSize.axisSpacings[1] = axisWidth;
            }
        }
        return pSize;
    };

    axis.prototype.startPadding = function()
    {
        return 0;
    };

    axis.prototype.endPadding = function()
    {
        return 0;
    };

    axis.prototype.size = function(_)
    {
        if(_)//set
        {
            _.height = _.height/this._multipleValue_axisNumber;
            axis.superclass.height.call(this, _);
            return this;
        }
        else//get
        {
            var allSize = axis.superclass.height.apply(this, arguments);
            allSize.height *= this._multipleValue_axisNumber;
            return allSize;
        }
    };

    var fastMeasure = function(_text, _style)
    {
        return TextUtils.superFastMeasure(_text, _style['font-size'],
                                            _style['font-weight'],
                                            _style['font-family']);
    };

    return axis;
});

define('sap/viz/modules/manifests/axis/MultipleValueLeft',['sap/viz/modules/manifests/Module','sap/viz/modules/Constants',
'sap/viz/modules/axis/MultipleValueLeft'],
function Setup(Manifest, Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.axis.MultipleValueLeft',
    'type' : Constants.Type.Supplementary,
    'name' : 'MultipleValueLeft',
    'base' : "sap.viz.modules.axis",
    'properties' : {
    },
    'css' : {
      '.v-title' : {
        'description' : 'Define style for the title.',
        'value' : {
          'fill' : '#333333',
          'font-family' : "Helvetica Neue, Helvetica, Arial, sans-serif",
          'font-size' : '12px',
          'font-weight' : 'bold'
        }
      },
      '.v-label' : {
        'description' : 'Define style for the label.',
        'value' : {
          'fill' : '#333333',
          'font-family' : "Helvetica Neue, Helvetica, Arial, sans-serif",
          'font-size' : '12px',
          'font-weight' : 'normal'
        }
      }    
    },
    'configure' : null,
    fn : fn
  };
  Manifest.register(module);
});

define('sap/viz/modules/axis/simpleCategoryCore',['jquery', 'sap/viz/modules/Constants', 'sap/viz/util/TextUtils', 'sap/viz/util/NumberUtils', 'sap/viz/base/utils/Objects', 'sap/viz/lang/langManager',
    'sap/viz/base/utils/TypeUtils', 'sap/viz/modules/threeD/Point', 'sap/viz/modules/threeD/matrix',
    'sap/viz/format/FormatManager', 'sap/viz/base/UADetector'],
  function Setup(jQuery, ModuleConstants, TextUtils, NumberUtils, Objects, langManager, TypeUtils, Point, matrix, FormatManager, UADetector) {

    var ret = function() {

      var m_title = [];

      var m_position;
      var m_axScale;
      var m_selection;

      var m_textOffset;
      var m_tickSize = 5;

      var m_styleLineSrokeWidth = 1;
      var m_styleGridLineColor = "#d8d8d8";
      var m_axLabelClassName = "viz-axis-label";

      var m_labelAreaMouseOverColor = "#cccccc";
      var m_labelAreaMouseDownColor = "#808080";

      var m_disableSpaceLimit = false;

      var m_style = null; //used to hold style passed from axis
      var m_props = {
        "title": {
          "visible": false,
          "text": undefined
        },
        "gridline": {
          "visible": false,
          "color": m_styleGridLineColor,
          "showFirstLine": false,
          "length": 0,
          "showLastLine": false,
          "type": "line"
        },
        "type": "value",
        "visible": true,
        "label": {
          "visible": true,
          "formatString": "",
          hideStrategy: ''
        },
        "position": "left",
        "color": "#333333",
        "forceLabelArea": false,
        "shapeRendering": true,
        "forceVerticalFont": false
      };

      var m_vClassNames = {
        axis: "v-axis",
        axisBody: "v-body",
        axisTitle: "v-title",
        axisLabel: "v-label",
        axisLine: "v-categoryaxisline",
        gridLine: "v-gridline",
        morphableLabel: ModuleConstants.CSS.CLASS.MORPHABLELABEL
      };

      var m_axisLabelClassCombined = m_vClassNames.axisLabel + ' ' + m_axLabelClassName + ' ' + m_vClassNames.morphableLabel;

      var m_matrix = matrix(),
        labelAngle = null,
        labelAlign = null,
        angle = null,
        tickAngle = null;

      var m_spaceLimit = -1;

      var adjustScale = function(spaceLimit) {
        //we have to adjust the scale because we may not draw all the levels.
        var scaleToDraw = [];
        var isMultilayer = m_axScale.length > 1 ? true : false;
        if (isMultilayer) {
          m_textOffset = 6;
        } else {
          m_textOffset = 11;
        }

        for (var iScale = 0; iScale < m_axScale.length; iScale++) {
          var axDomain = m_axScale[iScale].domain; //["a", "b"]
          var axRange = m_axScale[iScale].range; //[[0, 100], [100. 200], ...]

          //count the max text size
          var re = maxLabelTextHeight(axDomain, axRange, true);
          var isVertical = re.isVertical;

          if (m_position === "left" || m_position === "right") {
            m_axScale[iScale].labelsToDraw = buildLeftRightToDrawLabels(axDomain, axRange, isMultilayer, spaceLimit);
          } else {
            m_axScale[iScale].labelsToDraw = buildTopBottomToDrawLabels(axDomain, axRange, isVertical, isMultilayer, spaceLimit);
          }

          if (iScale === 0) {
            scaleToDraw.push(m_axScale[iScale]);
            if (spaceLimit >= 0) {
              break;
            }
          } else if (m_axScale[iScale].labelsToDraw.length === m_axScale[iScale].domain.length) {
            scaleToDraw.push(m_axScale[iScale]);
          }
          //for mekko chart ,the scale is not equal. So if a label can be draw, we should draw the whole layer.
          else if (m_axScale[iScale].labelsToDraw.length > 0 && TypeUtils.isExist(m_axScale.noEqual) && m_axScale.noEqual === true) {
            scaleToDraw.push(m_axScale[iScale]);
          }
        }
        return scaleToDraw;
      };

      var drawGridLine = function(selection, x1, y1, x2, y2) {
        var gridline = selection.append("line")
          .attr("class", m_vClassNames.gridLine)
          .attr("y1", y1)
          .attr("y2", y2)
          .attr("x1", x1)
          .attr("x2", x2)
          .attr("stroke", m_props.gridline.color)
          .attr("stroke-width", m_props.gridline.size)
          .attr("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
        if (m_props.gridline.type === "dotted") {
          gridline.attr("stroke-dasharray", "3, 2");
        }
      };

      function axis(selection) {
        m_selection = selection;
        //we have to adjust the scale
        var scaleToDraw = adjustScale();
        var isTruncated = false;

        var i;
        //---we should dicide show or hide somethings because of the spaceLimit
        if (m_spaceLimit >= 0) {
          var scaleToAdjust = [];
          var preferredSize = axis.getPreferredSize();
          var spacings = preferredSize.spacings;
          var minTruncateSize = preferredSize.minTruncateSize;
          var spaceLeft = m_spaceLimit;


          for (i = 0; i < spacings.length; i++) {
            if (spaceLeft >= spacings[i]) {
              scaleToAdjust.push(scaleToDraw[i]);
              spaceLeft -= spacings[i];
              spaceLeft = NumberUtils.precise(spaceLeft);
            } else {
              if (i === 0 && minTruncateSize > 0 && spaceLeft >= minTruncateSize) {
                isTruncated = true;
              }
              break;
            }
          }

          if (scaleToAdjust.length === 0 && scaleToDraw.length > 0 && !isTruncated) {
            //scaleToAdjust.push(scaleToDraw[0]);//always draw one
            var lastDomain = [];
            for (i = 0; i < scaleToDraw[0].domain.length; i++) {
              lastDomain.push('');
            }
            scaleToAdjust.push({
              domain: lastDomain,
              range: scaleToDraw[0].range
            });
          }

          scaleToDraw = scaleToAdjust;
          if (isTruncated) {
            scaleToDraw = adjustScale(m_spaceLimit);
          }
        }
        //------------------------------------------------------
        var isMultilayer = scaleToDraw.length > 1 ? true : false;
        var lastLevelWidth, lastLevelHeight;
        var iScale, axDomain, axRange;
        var re, maxTextWidth, lineOffset, isVertical, maxTextHeight;
        var x1, x2, y1, y2, dPath;
        var axLine, axTick1, axTick2;
        var labelsToDraw, customlabelCfg, m_label, labelG, axLabels, axTexts;
        if (m_position === "left") {
          lastLevelWidth = 0;

          for (iScale = 0; iScale < scaleToDraw.length; iScale++) {
            if (!m_props.label.visible && iScale !== (scaleToDraw.length - 1)) {
              continue;
            }

            axDomain = scaleToDraw[iScale].domain; //["a", "b"]
            axRange = scaleToDraw[iScale].range; //[[0, 100], [100. 200], ...]

            //count the max text size
            re = maxLabelTextWidth(axDomain, axRange);
            maxTextWidth = isTruncated ? maxLabelTextSize(scaleToDraw[iScale].labelsToDraw, false).maxWidth : re.maxLabelTextWidth;

            lineOffset = maxTextWidth + 2 * m_textOffset;
            if (!m_props.label.visible) {
              maxTextWidth = 0;
              lineOffset = 0;
            }

           lineOffset = isTruncated ? m_spaceLimit : lineOffset;

            if (iScale === (scaleToDraw.length - 1)) {
              if (m_props.gridline.showFirstLine) {
                drawGridLine(selection,
                  lastLevelWidth + lineOffset,
                  axRange[axRange.length - 1][1],
                  lastLevelWidth + lineOffset + m_props.gridline.length,
                  axRange[axRange.length - 1][1]);
              }

              if (m_props.gridline.showLastLine) {
                drawGridLine(selection,
                  lastLevelWidth + lineOffset,
                  axRange[0][0],
                  lastLevelWidth + lineOffset + m_props.gridline.length,
                  axRange[0][0]);
              }
            }

            ///////////////drawing the most inner vertical line////////////////
            if (scaleToDraw.length === 1) {
              ////////////////in single case, also include the first and last tick////////
              //<path d="M150 0 L75 200 L225 200 Z" />
              x1 = lastLevelWidth + lineOffset;
              x2 = lastLevelWidth + lineOffset;
              y1 = axRange[0][0];
              y2 = axRange[axRange.length - 1][1];
              if (m_props.axisline.visible) {
                dPath = "M" + (x1 - m_tickSize) + " " + y1;
                dPath += "L" + x1 + " " + y1;
                dPath += "L" + x2 + " " + y2;
                dPath += "L" + (x2 - m_tickSize) + " " + y2;

                axLine = selection.append("path");
                axLine.each(function() {
                  this.setAttribute("class", m_vClassNames.axisLine);
                  this.setAttribute("d", dPath);
                  this.setAttribute("fill", "none");
                  this.setAttribute("stroke", m_props.color);
                  this.setAttribute("stroke-width", m_props.lineSize);
                  this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");

                });
              }

            } else if (scaleToDraw.length >= 2 && (iScale === scaleToDraw.length - 1)) {
              axLine = selection.append("line");
              axLine.each(function() {
                this.setAttribute("x1", lastLevelWidth + lineOffset);
                this.setAttribute("x2", lastLevelWidth + lineOffset);
                this.setAttribute("y1", axRange[0][0]);
                this.setAttribute("y2", axRange[axRange.length - 1][1]);
                this.setAttribute("class", m_vClassNames.axisLine + " " + "domain");
                this.setAttribute("stroke", m_props.color);
                this.setAttribute("stroke-width", m_props.lineSize);
                this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
              });

            }
            /////////////// end of drawing the most inner vertical line////////////////


            ///////////////drawing vertical line for each level, based on lastLevelWidth///// 
            if (scaleToDraw.length >= 2 && m_props.label.visible) {
              axLine = selection.append("line");
              axLine.each(function() {
                this.setAttribute("x1", lastLevelWidth);
                this.setAttribute("x2", lastLevelWidth);
                this.setAttribute("y1", axRange[0][0]);
                this.setAttribute("y2", axRange[axRange.length - 1][1]);
                this.setAttribute("class", m_vClassNames.axisLine + " " + "domain");
                this.setAttribute("stroke", m_props.color);
                this.setAttribute("stroke-width", m_props.lineSize);
                this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
              });


            }
            ///////////////end of drawing vertical line for each level, based on lastLevelWidth/////

            //draw gridline in the last scaleToDraw///////////////////////
            //FIXME Jimmy/9/22/2012 currently the grid line only used for
            //multi charts. we have a bug for the last gridline here, if for example
            //we draw gridline for yaxis on [i][1], then the last gridline
            //will override xaxis. so we have to seperate last gridline
            if (m_props.gridline.visible && iScale === (scaleToDraw.length - 1)) {
              for (i = 0; i < axDomain.length; i++) {
                drawGridLine(selection,
                  lastLevelWidth + lineOffset,
                  axRange[i][0],
                  lastLevelWidth + lineOffset + m_props.gridline.length,
                  axRange[i][0]);
                if ((i === (axDomain.length - 1)) || (axRange[i][1] !== axRange[i + 1][0])) {
                  drawGridLine(selection,
                    lastLevelWidth + lineOffset,
                    axRange[i][1],
                    lastLevelWidth + lineOffset + m_props.gridline.length,
                    axRange[i][1]);
                }
              }
              //we need an extra line to close the gridline area, otherwise, if we have only one axis, the gridline area will be kept open
              drawGridLine(selection,
                lastLevelWidth + lineOffset + m_props.gridline.length,
                axRange[0][0],
                lastLevelWidth + lineOffset + m_props.gridline.length,
                axRange[i - 1][1]
              );
            }
            //end draw gridline in the last scaleToDraw///////////////////////


            for (i = 0; i < axDomain.length; i++) {
              /////////////////////////////draw tick for single case, horizontal line for multi case////////
              if (scaleToDraw.length === 1 || (scaleToDraw.length !== 1 && !m_props.label.visible)) //draw ticks
              {

                //Jimmy/9/22/2012 to @Catkin, in which scenario axRange[i][0] will not be equal with axRange[i-1][1]?
                if (i > 0 && (axRange[i][0] !== axRange[i - 1][1])) {
                  axTick1 = selection.append("line");
                  axTick1.each(function() {
                    this.setAttribute("class", m_vClassNames.axisLine);
                    this.setAttribute("x1", lineOffset - m_tickSize);
                    this.setAttribute("x2", lineOffset);
                    this.setAttribute("y1", axRange[i][0]);
                    this.setAttribute("y2", axRange[i][0]);
                    this.setAttribute("stroke", m_props.color);
                    this.setAttribute("stroke-width", m_props.lineSize);
                    this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                  });

                }

                ////////////////in single case, first and last tick is already drawn in path, ignore them here////////
                if (i !== (axDomain.length - 1)) {
                  axTick2 = selection.append("line");
                  axTick2.each(function() {
                    this.setAttribute("class", m_vClassNames.axisLine);
                    this.setAttribute("x1", lineOffset - m_tickSize);
                    this.setAttribute("x2", lineOffset);
                    this.setAttribute("y1", axRange[i][1]);
                    this.setAttribute("y2", axRange[i][1]);
                    this.setAttribute("stroke", m_props.color);
                    this.setAttribute("stroke-width", m_props.lineSize);
                    this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                  });
                }
              }

              if (scaleToDraw.length >= 2 && m_props.label.visible) {
                axLine = selection.append("line");
                axLine.each(function() {
                  this.setAttribute("class", m_vClassNames.axisLine);
                  this.setAttribute("x1", lastLevelWidth);
                  this.setAttribute("x2", lastLevelWidth + lineOffset);
                  this.setAttribute("y1", axRange[i][0]);
                  this.setAttribute("y2", axRange[i][0]);
                  this.setAttribute("stroke", m_props.color);
                  this.setAttribute("stroke-width", m_props.lineSize);
                  this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                });

                //Jimmy/9/22/2012 to @Catkin, in which scenario axRange[i][1] will not be equal with axRange[i+1][0]?
                if ((i === (axDomain.length - 1)) || (axRange[i][1] !== axRange[i + 1][0])) {
                  axLine = selection.append("line");
                  axLine.each(function() {
                    this.setAttribute("class", m_vClassNames.axisLine);
                    this.setAttribute("x1", lastLevelWidth);
                    this.setAttribute("x2", lastLevelWidth + lineOffset);
                    this.setAttribute("y1", axRange[i][1]);
                    this.setAttribute("y2", axRange[i][1]);
                    this.setAttribute("stroke", m_props.color);
                    this.setAttribute("stroke-width", m_props.lineSize);
                    this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                  });
                }
              }
              /////////////////////////////draw tick for single case, horizontal line for multi case////////
            }

            labelsToDraw = scaleToDraw[iScale].labelsToDraw;
            for (i = 0; i < labelsToDraw.length; i++) {
              customlabelCfg = labelsToDraw[i].custom;
              if (!(customlabelCfg && customlabelCfg.type === 'url')) {
                m_label = TypeUtils.isExist(labelsToDraw[i].text) ? labelsToDraw[i].text : '';
                if (m_props.label.visible) {
                  labelG = selection;

                  var offsetForBorder = 1;
                  var labelRectX = lastLevelWidth + offsetForBorder;

                  var isTextSize = m_props.forceLabelArea || labelsToDraw[i].height > labelsToDraw[i].rectHeight;
                  var rect = labelG.append("rect");
                  if (isTextSize) {
                    rect.each(function() {
                      this.setAttribute("x", lastLevelWidth + maxTextWidth - labelsToDraw[i].width + m_textOffset - offsetForBorder);
                      this.setAttribute("y", labelsToDraw[i].y - labelsToDraw[i].height / 2 - offsetForBorder);
                      this.setAttribute("width", labelsToDraw[i].width + 2 * offsetForBorder);
                      this.setAttribute("height", labelsToDraw[i].height + 2 * offsetForBorder);
                      this.setAttribute("opacity", 0);
                      this.setAttribute("class", "v-labelarea");
                    });
                  } else {
                    rect.each(function() {
                      this.setAttribute("x", labelRectX);
                      this.setAttribute("y", labelsToDraw[i].startY + offsetForBorder);
                      this.setAttribute("width", lineOffset - offsetForBorder);
                      this.setAttribute("height", (labelsToDraw[i].rectHeight - offsetForBorder) < 0 ? 0 : (labelsToDraw[i].rectHeight - offsetForBorder));
                      this.setAttribute("opacity", 0);
                      this.setAttribute("class", "v-labelarea");
                    });
                  }
                  rect.node().labelContexts = labelsToDraw[i].labelContexts;

                  axLabels = labelG.append("g");
                  axLabels.each(function() {
                    this.setAttribute("fill", m_style.defaultStyle.label.fill);
                    this.setAttribute("class", m_axisLabelClassCombined);
                    this.setAttribute("font-size", m_style.defaultStyle.label['font-size']);
                    this.setAttribute("font-weight", m_style.defaultStyle.label['font-weight']);
                    this.setAttribute("font-family", m_style.defaultStyle.label['font-family']);
                  });
                  axTexts = axLabels.append("text").text(m_label);
                  axTexts.each(function() {
                    this.setAttribute("pointer-events", "none");
                    this.setAttribute("x", lastLevelWidth + maxTextWidth + m_textOffset);
                    this.setAttribute("y", labelsToDraw[i].y);
                    this.setAttribute("dominant-baseline", "middle"); //"auto")//"hanging")//"central")
                    this.setAttribute("text-anchor", "end"); // text-align
                  });

                  adjustLabelForIE(axTexts);
                }
              }
              //else{ //draw as an icon, same size as text }
            }

            lastLevelWidth += (maxTextWidth + 2 * m_textOffset);
          }
        } else if (m_position === "right") {
          lastLevelWidth = 0;

          for (iScale = (scaleToDraw.length - 1); iScale >= 0; iScale--) {
            if (!m_props.label.visible && iScale !== (scaleToDraw.length - 1)) {
              continue;
            }

            axDomain = scaleToDraw[iScale].domain; //["a", "b"]
            axRange = scaleToDraw[iScale].range; //[[0, 100], [100. 200], ...]

            //count the max text size
            re = maxLabelTextWidth(axDomain, axRange);
            maxTextWidth = isTruncated ? maxLabelTextSize(scaleToDraw[iScale].labelsToDraw, false).maxWidth : re.maxLabelTextWidth;

            lineOffset = maxTextWidth + 2 * m_textOffset;
            if (!m_props.label.visible) {
              maxTextWidth = 0;
              lineOffset = 0;
            }

            lineOffset = isTruncated ? m_spaceLimit : lineOffset;

            if (iScale === (scaleToDraw.length - 1)) {
              if (m_props.gridline.showFirstLine) {
                drawGridLine(selection,
                  lastLevelWidth,
                  axRange[axRange.length - 1][1],
                  lastLevelWidth - m_props.gridline.length,
                  axRange[axRange.length - 1][1]);
              }

              if (m_props.gridline.showLastLine) {
                drawGridLine(selection,
                  lastLevelWidth,
                  axRange[0][0],
                  lastLevelWidth - m_props.gridline.length,
                  axRange[0][0]);
              }
            }

            if ((scaleToDraw.length === 1)) {
              //<path d="M150 0 L75 200 L225 200 Z" />
              x1 = lastLevelWidth;
              x2 = lastLevelWidth;
              y1 = axRange[0][0];
              y2 = axRange[axRange.length - 1][1];

              dPath = "M" + (x1 + m_tickSize) + " " + y1;
              dPath += "L" + x1 + " " + y1;
              dPath += "L" + x2 + " " + y2;
              dPath += "L" + (x1 + m_tickSize) + " " + y2;

              axLine = selection.append("path");
              axLine.each(function() {
                this.setAttribute("class", m_vClassNames.axisLine);
                this.setAttribute("d", dPath);
                this.setAttribute("fill", "none");
                this.setAttribute("stroke", m_props.color);
                this.setAttribute("stroke-width", m_props.lineSize);
                this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
              });

            } else if (scaleToDraw.length >= 2 && (iScale === (scaleToDraw.length - 1))) {
              axLine = selection.append("line");
              axLine.each(function() {
                this.setAttribute("class", m_vClassNames.axisLine);
                this.setAttribute("x1", lastLevelWidth);
                this.setAttribute("x2", lastLevelWidth);
                this.setAttribute("y1", axRange[0][0]);
                this.setAttribute("y2", axRange[axRange.length - 1][1]);
                this.setAttribute("stroke", m_props.color);
                this.setAttribute("stroke-width", m_props.lineSize);
                this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
              });

            }

            if (scaleToDraw.length >= 2 && m_props.label.visible) {
              axLine = selection.append("line");
              axLine.each(function() {
                this.setAttribute("class", m_vClassNames.axisLine);
                this.setAttribute("x1", lastLevelWidth + lineOffset);
                this.setAttribute("x2", lastLevelWidth + lineOffset);
                this.setAttribute("y1", axRange[0][0]);
                this.setAttribute("y2", axRange[axRange.length - 1][1]);
                this.setAttribute("stroke", m_props.color);
                this.setAttribute("stroke-width", m_props.lineSize);
                this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
              });

            }

            if (m_props.gridline.visible && iScale === (scaleToDraw.length - 1)) {
              for (i = 0; i < axDomain.length; i++) {
                drawGridLine(selection,
                  lastLevelWidth + lineOffset,
                  axRange[i][0],
                  lastLevelWidth + lineOffset + m_props.gridline.length,
                  axRange[i][0]);
                if ((i === (axDomain.length - 1)) || (axRange[i][1] !== axRange[i + 1][0])) {
                  drawGridLine(selection,
                    lastLevelWidth + lineOffset,
                    axRange[i][1],
                    lastLevelWidth + lineOffset + m_props.gridline.length,
                    axRange[i][1]);
                }
              }

            }

            for (i = 0; i < axDomain.length; i++) {
              if (scaleToDraw.length === 1 || (scaleToDraw.length !== 1 && !m_props.label.visible)) //draw ticks
              {
                if (i > 0 && (axRange[i][0] !== axRange[i - 1][1])) {
                  axTick1 = selection.append("line");
                  axTick1.each(function() {
                    this.setAttribute("class", m_vClassNames.axisLine);
                    this.setAttribute("x1", 0);
                    this.setAttribute("x2", m_tickSize);
                    this.setAttribute("y1", axRange[i][0]);
                    this.setAttribute("y2", axRange[i][0]);
                    this.setAttribute("stroke", m_props.color);
                    this.setAttribute("stroke-width", m_props.lineSize);
                    this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                  });
                }
                if (i !== (axDomain.length - 1)) {
                  axTick2 = selection.append("line");
                  axTick2.each(function() {
                    this.setAttribute("class", m_vClassNames.axisLine);
                    this.setAttribute("x1", 0);
                    this.setAttribute("x2", m_tickSize);
                    this.setAttribute("y1", axRange[i][1]);
                    this.setAttribute("y2", axRange[i][1]);
                    this.setAttribute("stroke", m_props.color);
                    this.setAttribute("stroke-width", m_props.lineSize);
                    this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                  });
                }
              }

              if (scaleToDraw.length >= 2 && m_props.label.visible) {
                axLine = selection.append("line");
                axLine.each(function() {
                  this.setAttribute("class", m_vClassNames.axisLine);
                  this.setAttribute("x1", lastLevelWidth);
                  this.setAttribute("x2", lastLevelWidth + lineOffset);
                  this.setAttribute("y1", axRange[i][0]);
                  this.setAttribute("y2", axRange[i][0]);
                  this.setAttribute("stroke", m_props.color);
                  this.setAttribute("stroke-width", 1);
                  this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                });

                if ((i === (axDomain.length - 1)) || (axRange[i][1] !== axRange[i + 1][0])) {
                  axLine = selection.append("line");
                  axLine.each(function() {
                    this.setAttribute("class", m_vClassNames.axisLine);
                    this.setAttribute("x1", lastLevelWidth);
                    this.setAttribute("x2", lastLevelWidth + lineOffset);
                    this.setAttribute("y1", axRange[i][1]);
                    this.setAttribute("y2", axRange[i][1]);
                    this.setAttribute("stroke", m_props.color);
                    this.setAttribute("stroke-width", m_props.lineSize);
                    this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                  });
                }
              }
            }

            labelsToDraw = scaleToDraw[iScale].labelsToDraw;
            for (i = 0; i < labelsToDraw.length; i++) {
              customlabelCfg = labelsToDraw[i].custom;
              if (!(customlabelCfg && customlabelCfg.type === 'url')) {
                m_label = TypeUtils.isExist(labelsToDraw[i].text) ? labelsToDraw[i].text : '';
                if (m_props.label.visible) {
                  labelG = selection;

                  axLabels = labelG.append("g");
                  axLabels.each(function() {
                    this.setAttribute("fill", m_style.defaultStyle.label.fill);
                    this.setAttribute("class", m_axisLabelClassCombined);
                    this.setAttribute("font-size", m_style.defaultStyle.label['font-size']);
                    this.setAttribute("font-weight", m_style.defaultStyle.label['font-weight']);
                    this.setAttribute("font-family", m_style.defaultStyle.label['font-family']);
                  });
                  axTexts = axLabels.append("text").text(m_label);
                  axTexts.each(function() {
                    this.setAttribute("x", lastLevelWidth + m_textOffset);
                    this.setAttribute("y", labelsToDraw[i].y);
                    this.setAttribute("text-anchor", "start"); // text-align
                    this.setAttribute("dominant-baseline", "middle"); //"auto")//"hanging")//"central")
                  });


                  adjustLabelForIE(axTexts);
                }
              }
              // else {//draw as an icon, same size as text}
            }

            lastLevelWidth += (maxTextWidth + 2 * m_textOffset);
          }
        } else if (m_position === "bottom") {
          lastLevelHeight = 0;

          for (iScale = (scaleToDraw.length - 1); iScale >= 0; iScale--) {
            if (!m_props.label.visible && iScale !== (scaleToDraw.length - 1)) {
              continue;
            }

            axDomain = scaleToDraw[iScale].domain; //["a", "b"]
            axRange = scaleToDraw[iScale].range; //[[0, 100], [100. 200], ...]

            //count the max text size
            re = maxLabelTextHeight(axDomain, axRange);
            isVertical = re.isVertical;
            maxTextHeight = isTruncated ? maxLabelTextSize(scaleToDraw[iScale].labelsToDraw, isVertical).maxHeight : re.maxLabelTextHeight;

            lineOffset = maxTextHeight + 2 * m_textOffset;
            if (!m_props.label.visible) {
              maxTextHeight = 0;
              lineOffset = 0;
            }

            lineOffset = isTruncated ? m_spaceLimit : lineOffset;

            if (iScale === (scaleToDraw.length - 1)) {
              if (m_props.gridline.showFirstLine) {
                drawGridLine(selection,
                  axRange[0][0],
                  lastLevelHeight,
                  axRange[0][0],
                  lastLevelHeight - m_props.gridline.length);
              }

              if (m_props.gridline.showLastLine) {
                drawGridLine(selection,
                  axRange[axRange.length - 1][0],
                  lastLevelHeight,
                  axRange[axRange.length - 1][0],
                  lastLevelHeight - m_props.gridline.length);
              }
            }

            var aAngle, cosAngle, sinAngle;
            if (scaleToDraw.length === 1) {
              x1 = axRange[0][0];
              x2 = axRange[axRange.length - 1][1];
              y1 = lastLevelHeight;
              y2 = lastLevelHeight;

              dPath = "M" + x1 + " " + (y1 + m_tickSize);
              dPath += "L" + x1 + " " + y1;
              dPath += "L" + x2 + " " + y2;
              dPath += "L" + x2 + " " + (y2 + m_tickSize);
              if (m_props.axisline.visible) {
                axLine = selection.append("path");
                if (angle) {
                  aAngle = angle * Math.PI / 180;
                  cosAngle = Math.cos(aAngle);
                  sinAngle = (45 === angle) ? cosAngle : Math.sin(aAngle);
                  dPath = 'M ' + axRange[0][0] + ' ' + lastLevelHeight;
                  dPath += 'L' + (axRange[0][0] + axRange[axRange.length - 1][1] * sinAngle) + ' ' + (lastLevelHeight - axRange[axRange.length - 1][1] * cosAngle);
                  dPath += 'Z';
                }
                axLine.each(function() {
                  this.setAttribute("class", m_vClassNames.axisLine);
                  this.setAttribute("d", dPath);
                  this.setAttribute("fill", "none");
                  this.setAttribute("stroke", m_props.color);
                  this.setAttribute("stroke-width", m_props.lineSize);
                  this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                });

              }
            } else if (scaleToDraw.length >= 2 && (iScale === scaleToDraw.length - 1)) {
              axLine = selection.append("line");
              axLine.each(function() {
                this.setAttribute("class", m_vClassNames.axisLine);
                this.setAttribute("x1", axRange[0][0]);
                this.setAttribute("x2", axRange[axRange.length - 1][1]);
                this.setAttribute("y1", lastLevelHeight);
                this.setAttribute("y2", lastLevelHeight);
                this.setAttribute("stroke", m_props.color);
                this.setAttribute("stroke-width", m_props.lineSize);
                this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
              });
            }

            if (scaleToDraw.length >= 2 && m_props.label.visible) {
              axLine = selection.append("line");
              axLine.each(function() {
                this.setAttribute("class", m_vClassNames.axisLine);
                this.setAttribute("x1", axRange[0][0]);
                this.setAttribute("x2", axRange[axRange.length - 1][1]);
                this.setAttribute("y1", lastLevelHeight + lineOffset);
                this.setAttribute("y2", lastLevelHeight + lineOffset);
                this.setAttribute("stroke", m_props.color);
                this.setAttribute("stroke-width", m_props.lineSize);
                this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
              });
            }

            //draw gridline in the last scaleToDraw///////////////////////
            if (m_props.gridline.visible && iScale === (scaleToDraw.length - 1)) {
              for (i = 0; i < axDomain.length; i++) {
                drawGridLine(selection,
                  axRange[i][0],
                  lastLevelHeight + lineOffset,
                  axRange[i][0],
                  lastLevelHeight + lineOffset + m_props.gridline.length
                );
                if ((i === (axDomain.length - 1)) || (axRange[i][1] !== axRange[i + 1][0])) {
                  drawGridLine(selection,
                    axRange[i][1],
                    lastLevelHeight + lineOffset,
                    axRange[i][1],
                    lastLevelHeight + lineOffset + m_props.gridline.length
                  );
                }
              }
            }
            //end draw gridline in the last scaleToDraw///////////////////////


            for (i = 0; i < axDomain.length; i++) {
              if (scaleToDraw.length === 1 || (scaleToDraw.length !== 1 && !m_props.label.visible)) //draw ticks
              {
                if (i > 0 && (axRange[i][0] !== axRange[i - 1][1])) {
                  axTick1 = selection.append("line");
                  axTick1.each(function() {
                    this.setAttribute("class", m_vClassNames.axisLine);
                    this.setAttribute("x1", axRange[i][0]);
                    this.setAttribute("x2", axRange[i][0]);
                    this.setAttribute("y1", 0);
                    this.setAttribute("y2", m_tickSize);
                    this.setAttribute("stroke", m_props.color);
                    this.setAttribute("stroke-width", m_props.lineSize);
                    this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                  });
                }
                if (i !== (axDomain.length - 1)) {
                  axTick2 = selection.append("line");
                  axTick2.each(function() {
                    this.setAttribute("class", m_vClassNames.axisLine);
                    this.setAttribute("x1", axRange[i][1]);
                    this.setAttribute("x2", axRange[i][1]);
                    this.setAttribute("y1", 0);
                    this.setAttribute("y2", m_tickSize);
                    this.setAttribute("stroke", m_props.color);
                    this.setAttribute("stroke-width", m_props.lineSize);
                    this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                  });

                  if (angle) {
                    aAngle = angle * Math.PI / 180;
                    cosAngle = Math.cos(aAngle);
                    sinAngle = (45 === angle) ? cosAngle : Math.sin(aAngle);
                    var tAngle = tickAngle * Math.PI / 180;
                    var cosTAngle = Math.cos(tAngle);
                    var sinTAngle = Math.sin(tAngle);

                    var tickStartX = axRange[i][1] * sinAngle;
                    var tickStartY = -axRange[i][1] * cosAngle;
                    x2 = tickStartX + m_tickSize * cosTAngle;
                    y2 = tickStartY + m_tickSize * sinTAngle;

                    axTick2.attr('x1', tickStartX).attr('y1', tickStartY).attr('x2', x2).attr('y2', y2);
                  }

                }
              }

              if (scaleToDraw.length >= 2 && m_props.label.visible) {
                axLine = selection.append("line");
                axLine.each(function() {
                  this.setAttribute("class", m_vClassNames.axisLine);
                  this.setAttribute("x1", axRange[i][0]);
                  this.setAttribute("x2", axRange[i][0]);
                  this.setAttribute("y1", lastLevelHeight);
                  this.setAttribute("y2", lastLevelHeight + lineOffset);
                  this.setAttribute("stroke", m_props.color);
                  this.setAttribute("stroke-width", m_props.lineSize);
                  this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                });

                if ((i === (axDomain.length - 1)) || (axRange[i][1] !== axRange[i + 1][0])) {
                  axLine = selection.append("line");
                  axLine.each(function() {
                    this.setAttribute("class", m_vClassNames.axisLine);
                    this.setAttribute("x1", axRange[i][1]);
                    this.setAttribute("x2", axRange[i][1]);
                    this.setAttribute("y1", lastLevelHeight);
                    this.setAttribute("y2", lastLevelHeight + lineOffset);
                    this.setAttribute("stroke", m_props.color);
                    this.setAttribute("stroke-width", m_props.lineSize);
                    this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                  });
                }
              }
            }

            labelsToDraw = scaleToDraw[iScale].labelsToDraw;
            drawTopBottomLabels(selection, labelsToDraw, lastLevelHeight, maxTextHeight, axDomain, isVertical, scaleToDraw.length !== 1);

            lastLevelHeight += (maxTextHeight + 2 * m_textOffset);
          }
        } else if (m_position === "top") {
          lastLevelHeight = 0;

          for (iScale = 0; iScale < scaleToDraw.length; iScale++) {
            if (!m_props.label.visible && iScale !== (scaleToDraw.length - 1)) {
              continue;
            }

            axDomain = scaleToDraw[iScale].domain; //["a", "b"]
            axRange = scaleToDraw[iScale].range; //[[0, 100], [100. 200], ...]

            //count the max text size
            re = maxLabelTextHeight(axDomain, axRange);
            isVertical = re.isVertical;
            maxTextHeight = isTruncated ? maxLabelTextSize(scaleToDraw[iScale].labelsToDraw, isVertical).maxHeight : re.maxLabelTextHeight;

            lineOffset = maxTextHeight + 2 * m_textOffset;
            if (!m_props.label.visible) {
              maxTextHeight = 0;
              lineOffset = 0;
            }

            lineOffset = isTruncated ? m_spaceLimit : lineOffset;

            if (iScale === (scaleToDraw.length - 1)) {
              if (m_props.gridline.showFirstLine) {
                drawGridLine(selection,
                  axRange[0][0],
                  lineOffset + lastLevelHeight,
                  axRange[0][0],
                  lineOffset + lastLevelHeight + m_props.gridline.length
                );
              }

              if (m_props.gridline.showLastLine) {
                drawGridLine(selection,
                  axRange[axRange.length - 1][1],
                  lineOffset + lastLevelHeight,
                  axRange[axRange.length - 1][1],
                  lineOffset + lastLevelHeight + m_props.gridline.length
                );
              }
            }

            if ((scaleToDraw.length === 1)) {
              x1 = axRange[0][0];
              x2 = axRange[axRange.length - 1][1];
              y1 = lineOffset + lastLevelHeight;
              y2 = lineOffset + lastLevelHeight;

              dPath = "M" + x1 + " " + (y1 - m_tickSize);
              dPath += "L" + x1 + " " + y1;
              dPath += "L" + x2 + " " + y2;
              dPath += "L" + x2 + " " + (y2 - m_tickSize);

              axLine = selection.append("path");
              axLine.each(function() {
                this.setAttribute("class", m_vClassNames.axisLine);
                this.setAttribute("d", dPath);
                this.setAttribute("fill", "none");
                this.setAttribute("stroke", m_props.color);
                this.setAttribute("stroke-width", m_props.lineSize);
                this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
              });
            } else if (scaleToDraw.length >= 2 && (iScale === scaleToDraw.length - 1)) {
              axLine = selection.append("line");
              axLine.each(function() {
                this.setAttribute("class", m_vClassNames.axisLine);
                this.setAttribute("x1", axRange[0][0]);
                this.setAttribute("x2", axRange[axRange.length - 1][1]);
                this.setAttribute("y1", lineOffset + lastLevelHeight);
                this.setAttribute("y2", lineOffset + lastLevelHeight);
                this.setAttribute("stroke", m_props.color);
                this.setAttribute("stroke-width", m_props.lineSize);
                this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
              });
            }

            if (scaleToDraw.length >= 2 && m_props.label.visible) {
              axLine = selection.append("line");
              axLine.each(function() {
                this.setAttribute("class", m_vClassNames.axisLine);
                this.setAttribute("x1", axRange[0][0]);
                this.setAttribute("x2", axRange[axRange.length - 1][1]);
                this.setAttribute("y1", lastLevelHeight);
                this.setAttribute("y2", lastLevelHeight);
                this.setAttribute("stroke", m_props.color);
                this.setAttribute("stroke-width", m_props.lineSize);
                this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
              });

            }

            //draw gridline in the last scaleToDraw///////////////////////
            if (m_props.gridline.visible && iScale === (scaleToDraw.length - 1)) {
              for (i = 0; i < axDomain.length; i++) {
                drawGridLine(selection,
                  axRange[i][0],
                  lastLevelHeight + lineOffset,
                  axRange[i][0],
                  lastLevelHeight + lineOffset + m_props.gridline.length
                );
                if ((i === (axDomain.length - 1)) || (axRange[i][1] !== axRange[i + 1][0])) {
                  drawGridLine(selection,
                    axRange[i][1],
                    lastLevelHeight + lineOffset,
                    axRange[i][1],
                    lastLevelHeight + lineOffset + m_props.gridline.length
                  );
                }
              }
              //we need an extra line to close the gridline area, otherwise, if we have only one axis, the gridline area will be kept open
              drawGridLine(selection,
                axRange[0][0],
                lastLevelHeight + lineOffset + m_props.gridline.length,
                axRange[i - 1][1],
                lastLevelHeight + lineOffset + m_props.gridline.length
              );
            }
            //end draw gridline in the last scaleToDraw///////////////////////

            for (i = 0; i < axDomain.length; i++) {
              if (scaleToDraw.length === 1 || (scaleToDraw.length !== 1 && !m_props.label.visible)) //draw ticks
              {
                if (i > 0 && (axRange[i][0] !== axRange[i - 1][1])) {
                  axTick1 = selection.append("line");
                  axTick1.each(function() {
                    this.setAttribute("class", m_vClassNames.axisLine);
                    this.setAttribute("x1", axRange[i][0]);
                    this.setAttribute("x2", axRange[i][0]);
                    this.setAttribute("y1", lineOffset);
                    this.setAttribute("y2", lineOffset - m_tickSize);
                    this.setAttribute("stroke", m_props.color);
                    this.setAttribute("stroke-width", m_props.lineSize);
                    this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                  });

                }

                ////////////////in single case, first and last tick is already drawn in path, ignore them here////////
                if (i !== (axDomain.length - 1)) {
                  axTick2 = selection.append("line");
                  axTick2.each(function() {
                    this.setAttribute("class", m_vClassNames.axisLine);
                    this.setAttribute("x1", axRange[i][1]);
                    this.setAttribute("x2", axRange[i][1]);
                    this.setAttribute("y1", lineOffset);
                    this.setAttribute("y2", lineOffset - m_tickSize);
                    this.setAttribute("stroke", m_props.color);
                    this.setAttribute("stroke-width", m_props.lineSize);
                    this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                  });
                }
              }

              if (scaleToDraw.length >= 2 && m_props.label.visible) {
                axLine = selection.append("line");
                axLine.each(function() {
                  this.setAttribute("class", m_vClassNames.axisLine);
                  this.setAttribute("x1", axRange[i][0]);
                  this.setAttribute("x2", axRange[i][0]);
                  this.setAttribute("y1", lastLevelHeight);
                  this.setAttribute("y2", lastLevelHeight + lineOffset);
                  this.setAttribute("stroke", m_props.color);
                  this.setAttribute("stroke-width", m_props.lineSize);
                  this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                });

                //Jimmy/9/22/2012 to @Catkin, in which scenario axRange[i][1] will not be equal with axRange[i+1][0]?
                if ((i === (axDomain.length - 1)) || (axRange[i][1] !== axRange[i + 1][0])) {
                  axLine = selection.append("line");
                  axLine.each(function() {
                    this.setAttribute("class", m_vClassNames.axisLine);
                    this.setAttribute("x1", axRange[i][1]);
                    this.setAttribute("x2", axRange[i][1]);
                    this.setAttribute("y1", lastLevelHeight);
                    this.setAttribute("y2", lastLevelHeight + lineOffset);
                    this.setAttribute("stroke", m_props.color);
                    this.setAttribute("stroke-width", m_props.lineSize);
                    this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                  });
                }
              }
            }

            labelsToDraw = scaleToDraw[iScale].labelsToDraw;
            drawTopBottomLabels(selection, labelsToDraw, lastLevelHeight, maxTextHeight, axDomain, isVertical, scaleToDraw.length !== 1);
            lastLevelHeight += (maxTextHeight + 2 * m_textOffset);
          }
        }
      }
      
      axis.spaceLimit = function(_spaceLimit) {
        if (!arguments.length){
          return m_spaceLimit;
        }

        if (!m_disableSpaceLimit) {
          m_spaceLimit = _spaceLimit;
        }

        return axis;
      };

      var adjustLabelForIE = function(text) {
        if (UADetector.isIE()) {
          //dominant-baseline does not work
          var textHeight = m_style.realStyle.label['font-size'].toString();
          var indexPX = textHeight.indexOf("px");
          if (indexPX >= 0) {
            textHeight = textHeight.substr(0, indexPX);
          }

          //textHeight = fastMeasure(text, m_style.realStyle.label).height;
          var y = text.attr("y");
          text.attr("y", Number(y) + textHeight / 2);
          text.attr("dominant-baseline", "auto");
        }
      };

      //get customlabel text from from the rawObj, if the type is url, return the original text
      var getCustomlabelText = function(rawObj) {
        var ret;
        if (rawObj.info) {
          var clobj = rawObj.info.customlabel;
          if (clobj) {
            if (clobj.type === 'url') {
              ret = rawObj.val;
            } else if (clobj.type === 'string') {
              ret = clobj.val;
            }
          } else {
            ret = rawObj.val;
          }
        } else {
          ret = rawObj.val;
        }
        if (ret === '') {
          ret = ' ';
        }
        //so we will first resolve customlabel and then do format
        ret = isInvalidString(ret) ? langManager.get('IDS_ISNOVALUE') : ret;
        ret = FormatManager.format(ret, m_props.label.formatString);
        return ret;
      };

      var getCustomlabelCfg = function(rawObj) {
        if (rawObj.info && rawObj.info.customlabel) {
          return rawObj.info.customlabel;
        }
      };

      var getTruncatedText = function(text, limit) {
        var style = 'font-weight: ' + m_style.realStyle.label['font-weight'] + '; font-family: ' + m_style.realStyle.label['font-family'] + '; font-size: ' + m_style.realStyle.label['font-size'] + ';';
        return TextUtils.ellipsis(text, undefined, limit, style);
      };

      var buildLeftRightToDrawLabels = function(allLabels, allLabelsLocation, isMultilayer, spaceLimit) {
        //Jimmy/12/26/2012 extend allLabels from stringArray to objectArray to support customlabel
        //we always draw the bottom label for yAxis.

        //build the "todraw" array
        //count all the labels y1 and y2, and save them.
        var fullHeight = 0;
        var allTicksLabels = [];
        var i, item;
        for (i = 0; i < allLabels.length; i++) {
          item = {};
          item.text = getCustomlabelText(allLabels[i]);
          item.custom = getCustomlabelCfg(allLabels[i]);
          item.labelContexts = allLabels[i].labelContexts;
          if (spaceLimit >= 0) {
            item.text = getTruncatedText(item.text, spaceLimit - 2 * m_textOffset);
          }
          //count y1 and y2
          var itemMeasure = fastMeasure(item.text, m_style.realStyle.label);
          var centerY = allLabelsLocation[i][0] + (allLabelsLocation[i][1] - allLabelsLocation[i][0]) / 2;
          item.width = itemMeasure.width;
          item.height = itemMeasure.height;
          item.startY = allLabelsLocation[i][0];
          item.rectHeight = allLabelsLocation[i][1] - allLabelsLocation[i][0];
          item.y = centerY;
          item.y1 = centerY - item.height / 2;
          item.y2 = centerY + item.height / 2;
          item.originalIndex = i;
          allLabels[i].drawLabel = false;
          allTicksLabels.push(item);

          fullHeight += item.rectHeight;
        }


        //now we should decide which label to draw.
        //iBeyond = 0:0,1,2,3,4,5,6,...
        //iBeyond = 1:0, ,2, ,4, ,6,...
        //iBeyond = 2:0, , ,3, , ,6,...
        //...
        //iBeyond = (allTicksLabels.length - 1):0
        var ticksLabelsToDraw = [], previousIndex, iBeyond;
        if (m_props.label.hideStrategy !== 'greedy') {
          //we must filter those labels which have already overflown the border.
          var filteredTicksLabels = allTicksLabels.concat();
          for (i = filteredTicksLabels.length - 1; i > -1; --i) {
            if (allLabelsLocation[0] && allLabelsLocation.length &&
              (filteredTicksLabels[i].y2 > allLabelsLocation[allLabelsLocation.length - 1][1] || filteredTicksLabels[i].y1 < allLabelsLocation[0][0])) {
              filteredTicksLabels.splice(i, 1);
            }
          }

          for (iBeyond = 0; iBeyond <= (filteredTicksLabels.length - 1); iBeyond++) {
            var isDrawable = true;
            for (i = (filteredTicksLabels.length - 1); i >= 0; i -= (iBeyond + 1)) {
              item = filteredTicksLabels[i];
              if (i !== (filteredTicksLabels.length - 1)) {
                previousIndex = i + (iBeyond + 1);

                if (filteredTicksLabels[i].y2 >= filteredTicksLabels[previousIndex].y1) {
                  isDrawable = false;
                  break;
                }
              }
              if (item.height > fullHeight) {
                break;
              }

              ticksLabelsToDraw.push(item);
              allLabels[item.originalIndex].drawLabel = true;
            }
            if (isDrawable) {
              break;
            } else {
              ticksLabelsToDraw = [];
            }
          }
        } else {

          for (previousIndex = iBeyond = (allTicksLabels.length - 1); iBeyond >= 0; iBeyond--) {
            item = allTicksLabels[iBeyond];

            if (previousIndex === iBeyond && allLabelsLocation[iBeyond][1] !== allLabelsLocation[iBeyond][0]) {
              if (isMultilayer && item.y1 > allLabelsLocation[iBeyond][0] && item.y2 < allLabelsLocation[iBeyond][1]) {
                ticksLabelsToDraw.push(item);
                allLabels[item.originalIndex].drawLabel = true;
              } else if (!isMultilayer) {
                if (item.height <= fullHeight) {
                  ticksLabelsToDraw.push(item);
                  allLabels[item.originalIndex].drawLabel = true;
                }
              }
            } else {
              if (item.y2 <= allTicksLabels[previousIndex].y1 && allLabelsLocation[iBeyond][1] !== allLabelsLocation[iBeyond][0]) {
                if (isMultilayer) {
                  //if have more than one layers, need to detecte whether the label is between gridlines
                  if (item.y1 > allLabelsLocation[iBeyond][0] && item.y2 < allLabelsLocation[iBeyond][1]) {
                    ticksLabelsToDraw.push(item);
                    allLabels[item.originalIndex].drawLabel = true;
                    previousIndex = iBeyond;
                  }
                } else {
                  //if have only one layer , just need to detecte whether overlap is exist
                  ticksLabelsToDraw.push(item);
                  allLabels[item.originalIndex].drawLabel = true;
                  previousIndex = iBeyond;
                }
              }
            }
          }
          //for greedy situation, we must filter it after because each cell has different width/height.
          for (i = ticksLabelsToDraw.length - 1; i > -1; --i) {
            if (allLabelsLocation[0] && allLabelsLocation.length &&
              (ticksLabelsToDraw[i].y2 > allLabelsLocation[allLabelsLocation.length - 1][1] || ticksLabelsToDraw[i].y1 < allLabelsLocation[0][0])) {
              allLabels[ticksLabelsToDraw[i].originalIndex].drawLabel = false;
              ticksLabelsToDraw.splice(i, 1);
            }
          }

        }
        return ticksLabelsToDraw;
      };

      var buildTopBottomToDrawLabels = function(allLabels, allLabelsLocation, isVertical, isMultilayer, spaceLimit) {
        //Jimmy/12/26/2012 extend allLabels from stringArray to objectArray to support customlabel
        //we always draw the first label for xAxis.

        //build the "todraw" array
        //count all the labels y1 and y2, and save them.
        var fullWidth = 0;
        var allTicksLabels = [];
        var i, item;
        for (i = 0; i < allLabels.length; i++) {
          item = {};
          item.text = getCustomlabelText(allLabels[i]);
          item.custom = getCustomlabelCfg(allLabels[i]);
          item.labelContexts = allLabels[i].labelContexts;

          if (spaceLimit >= 0) {
            item.text = getTruncatedText(item.text, spaceLimit - 2 * m_textOffset);
          }

          //count x1 and x2
          var itemMeasure = fastMeasure(item.text, m_style.realStyle.label);
          if (isVertical) {
            item.width = itemMeasure.height;
            item.height = itemMeasure.width;
          } else {
            item.width = itemMeasure.width;
            item.height = itemMeasure.height;
          }

          var centerX = allLabelsLocation[i][0] + (allLabelsLocation[i][1] - allLabelsLocation[i][0]) / 2;

          item.x = centerX;
          item.x1 = centerX - item.width / 2;
          item.x2 = centerX + item.width / 2;

          item.startX = allLabelsLocation[i][0];
          item.rectWidth = allLabelsLocation[i][1] - allLabelsLocation[i][0];
          item.originalIndex = i;
          allLabels[i].drawLabel = false;

          allTicksLabels.push(item);

          fullWidth += item.rectWidth;
        }

        //now we should decide which label to draw.
        //iBeyond = 0:0,1,2,3,4,5,6,...
        //iBeyond = 1:0, ,2, ,4, ,6,...
        //iBeyond = 2:0, , ,3, , ,6,...
        //...
        //iBeyond = (allTicksLabels.length - 1):0
        var ticksLabelsToDraw = [], previousIndex, iBeyond;
        if (m_props.label.hideStrategy !== 'greedy') {
          //we must filter those labels which have already overflown the border.
          var filteredTicksLabels = allTicksLabels.concat();
          for (i = filteredTicksLabels.length - 1; i > -1; --i) {
            if (allLabelsLocation[0] && allLabelsLocation.length &&
              (filteredTicksLabels[i].x2 > allLabelsLocation[allLabelsLocation.length - 1][1] || filteredTicksLabels[i].x1 < allLabelsLocation[0][0])) {
              filteredTicksLabels.splice(i, 1);
            }
          }
          for (iBeyond = 0; iBeyond <= (filteredTicksLabels.length - 1); iBeyond++) {
            var isDrawable = true;
            for (i = 0; i < filteredTicksLabels.length; i += (iBeyond + 1)) {
              item = filteredTicksLabels[i];
              if (i !== 0) {
                previousIndex = i - (iBeyond + 1);

                if (filteredTicksLabels[i].x1 <= filteredTicksLabels[previousIndex].x2 || allLabelsLocation[iBeyond][1] === allLabelsLocation[iBeyond][0]) {
                  isDrawable = false;
                  break;
                }
              }

              if (item.width > fullWidth) {
                break;
              }

              ticksLabelsToDraw.push(item);
              allLabels[item.originalIndex].drawLabel = true;
            }
            if (isDrawable) {
              break;
            } else {
              ticksLabelsToDraw = [];
            }
          }
        } else {

          for (previousIndex = iBeyond = (allTicksLabels.length - 1); iBeyond >= 0; iBeyond--) {
            item = allTicksLabels[iBeyond];

            if (previousIndex === iBeyond && allLabelsLocation[iBeyond][1] !== allLabelsLocation[iBeyond][0]) {
              if (isMultilayer && item.x1 > allLabelsLocation[iBeyond][0] && item.x2 < allLabelsLocation[iBeyond][1]) {
                ticksLabelsToDraw.push(item);
                allLabels[item.originalIndex].drawLabel = true;
              } else if (!isMultilayer) {
                if (item.width <= fullWidth) {
                  ticksLabelsToDraw.push(item);
                  allLabels[item.originalIndex].drawLabel = true;
                }
              }
            } else {
              if (item.x2 <= allTicksLabels[previousIndex].x1 && allLabelsLocation[iBeyond][1] !== allLabelsLocation[iBeyond][0]) {
                if (isMultilayer) {
                  //if have more than one layers, need to detecte whether the label is between gridlines
                  if (item.x1 > allLabelsLocation[iBeyond][0] && item.x2 < allLabelsLocation[iBeyond][1]) {
                    ticksLabelsToDraw.push(item);
                    allLabels[item.originalIndex].drawLabel = true;
                    previousIndex = iBeyond;
                  }
                } else {
                  //if have only one layer , just need to detecte whether overlap is exist
                  ticksLabelsToDraw.push(item);
                  allLabels[item.originalIndex].drawLabel = true;
                  previousIndex = iBeyond;
                }
              }
            }
          }
          //for greedy situation, we must filter it after because each cell has different width/height.

          for (i = ticksLabelsToDraw.length - 1; i > -1; --i) {
            if (allLabelsLocation[0] && allLabelsLocation.length &&
              (ticksLabelsToDraw[i].x2 > allLabelsLocation[allLabelsLocation.length - 1][1] || ticksLabelsToDraw[i].x1 < allLabelsLocation[0][0])) {
              allLabels[ticksLabelsToDraw[i].originalIndex].drawLabel = false;
              ticksLabelsToDraw.splice(i, 1);
            }
          }
        }

        return ticksLabelsToDraw;
      };

      var drawTopBottomLabels = function(selection, labelsToDraw, lastLevelHeight, maxTextHeight, axDomain, isVertical, isHierarchical) {
        if (labelsToDraw === undefined) {
          return;
        }

        for (var i = 0; i < labelsToDraw.length; i++) {
          var label = TypeUtils.isExist(labelsToDraw[i].text) ? labelsToDraw[i].text : '';
          var axLabels;
          if (m_props.label.visible) {
            if (angle) {
              var labelAreaOffset = 2;

              var aAngle = angle * Math.PI / 180;
              var cosAngle = Math.cos(aAngle);
              var sinAngle = (45 === angle) ? cosAngle : Math.sin(aAngle);
              var tAngle = tickAngle * Math.PI / 180;
              var cosTAngle = Math.cos(tAngle);
              var sinTAngle = Math.sin(tAngle);

              var tickStartX = labelsToDraw[i].x * sinAngle;
              var tickStartY = -labelsToDraw[i].x * cosAngle;

              var labelTextX = tickStartX + (m_tickSize + m_textOffset) * cosTAngle;
              var labelTextY = tickStartY + lastLevelHeight + (m_textOffset + m_tickSize) * sinTAngle;

              var labelAreaX = labelTextX - labelAreaOffset;
              var labelAreaY = labelTextY - labelsToDraw[i].width / 2 - labelAreaOffset;
              var labelAreaWidth = labelsToDraw[i].height + 2 * labelAreaOffset; //the text is vertical
              var labelAreaHeight = labelsToDraw[i].width + 2 * labelAreaOffset;

              //for debug
              if (tickAngle > 90) {
                labelAreaX -= (labelAreaWidth - 2 * labelAreaOffset);
              }

              //label G
              axLabels = selection.append("g");
              axLabels.each(function() {
                this.setAttribute("fill", m_style.defaultStyle.label.fill);
                this.setAttribute("class", m_axisLabelClassCombined);
                this.setAttribute("font-size", m_style.defaultStyle.label['font-size']);
                this.setAttribute("font-weight", m_style.defaultStyle.label['font-weight']);
                this.setAttribute("font-family", m_style.defaultStyle.label['font-family']);
              });

              //draw labelArea
              var labelArea = axLabels.append("rect");
              labelArea.each(function() {
                this.setAttribute("x", labelAreaX);
                this.setAttribute("y", labelAreaY);
                this.setAttribute("width", labelAreaWidth);
                this.setAttribute("height", labelAreaHeight);
                this.setAttribute("opacity", 0);
                this.setAttribute("class", "v-labelarea");
              });
              labelArea.node().labelContexts = labelsToDraw[i].labelContexts;

              //draw label text
              var axLabelText = axLabels.append("text").text(label);
              axLabelText.each(function() {
                this.setAttribute("x", labelTextX);
                this.setAttribute("y", labelTextY);
                this.setAttribute("dominant-baseline", "middle"); //"auto")//"hanging")//"central")
                this.setAttribute("text-anchor", 'start'); // text-align
                this.setAttribute("pointer-events", "none");
              });


              if (tickAngle > 90) {
                axLabelText.attr("text-anchor", 'end');
                axLabels.attr('transform', 'rotate( ' + (tickAngle - 180) + ' ' + labelTextX + ' ' + labelTextY + ')');
              } else {
                axLabels.attr('transform', 'rotate( ' + (tickAngle) + ' ' + labelTextX + ' ' + labelTextY + ')');
              }
            } else {
              var labelG = selection;
              var offsetForBorder = 1, isTextSize, rect;
              if (m_position === "bottom") {

                isTextSize = m_props.forceLabelArea || labelsToDraw[i].width > labelsToDraw[i].rectWidth;
                rect = labelG.append("rect");
                if (isTextSize) {
                  rect.each(function() {
                    this.setAttribute("x", labelsToDraw[i].x - labelsToDraw[i].width / 2 - offsetForBorder);
                    this.setAttribute("y", lastLevelHeight + maxTextHeight / 2 - offsetForBorder - m_textOffset / 2);
                    this.setAttribute("width", labelsToDraw[i].width + 2 * offsetForBorder);
                    this.setAttribute("height", labelsToDraw[i].height + 2 * offsetForBorder);
                    this.setAttribute("opacity", 0);
                    this.setAttribute("class", "v-labelarea");
                  });
                } else {
                  rect.each(function() {
                    this.setAttribute("x", labelsToDraw[i].startX);
                    this.setAttribute("y", lastLevelHeight + offsetForBorder);
                    this.setAttribute("width", labelsToDraw[i].rectWidth);
                    this.setAttribute("height", maxTextHeight + 2 * m_textOffset - offsetForBorder);
                    this.setAttribute("opacity", 0);
                    this.setAttribute("class", "v-labelarea");
                  });
                }
                rect.node().labelContexts = labelsToDraw[i].labelContexts;
              } else if (m_position === "top") {
                if (labelsToDraw[i].labelContexts.length > 0) {

                  isTextSize = m_props.forceLabelArea || labelsToDraw[i].width > labelsToDraw[i].rectWidth;
                  rect = labelG.append("rect");
                  if (isTextSize) {
                    rect.each(function() {
                      this.setAttribute("x", labelsToDraw[i].x - labelsToDraw[i].width / 2 - offsetForBorder);
                      this.setAttribute("y", lastLevelHeight + maxTextHeight / 2 + m_textOffset / 2 - offsetForBorder);
                      this.setAttribute("width", labelsToDraw[i].width + 2 * offsetForBorder);
                      this.setAttribute("height", labelsToDraw[i].height + 2 * offsetForBorder);
                      this.setAttribute("opacity", 0);
                      this.setAttribute("class", "v-labelarea");
                    });
                  } else {
                    rect.each(function() {
                      this.setAttribute("x", labelsToDraw[i].startX);
                      this.setAttribute("y", lastLevelHeight);
                      this.setAttribute("width", labelsToDraw[i].rectWidth);
                      this.setAttribute("height", maxTextHeight + 2 * m_textOffset);
                      this.setAttribute("opacity", 0);
                      this.setAttribute("class", "v-labelarea");
                    });
                  }

                  rect.node().labelContexts = labelsToDraw[i].labelContexts;
                }
              }

              axLabels = labelG.append("g");
              axLabels.each(function() {
                this.setAttribute("fill", m_style.defaultStyle.label.fill);
                this.setAttribute("class", m_axisLabelClassCombined);
                this.setAttribute("font-size", m_style.defaultStyle.label['font-size']);
                this.setAttribute("font-weight", m_style.defaultStyle.label['font-weight']);
                this.setAttribute("font-family", m_style.defaultStyle.label['font-family']);
              });
              var axTexts = axLabels.append("text").text(label);
              axTexts.each(function() {

                this.setAttribute("pointer-events", "none");
                this.setAttribute("x", labelsToDraw[i].x);
                this.setAttribute("y", lastLevelHeight + maxTextHeight / 2 + m_textOffset);
                this.setAttribute("dominant-baseline", "middle"); //"auto")//"hanging")//"central")
                this.setAttribute("text-anchor", "middle"); // text-align
              });


              if (isVertical) {
                if (!isHierarchical) {
                  if (m_position === 'top') {
                    axTexts.attr('text-anchor', 'start')
                      .attr("y", lastLevelHeight + maxTextHeight + m_textOffset);
                  } else if (m_position === 'bottom') {
                    axTexts.attr("y", lastLevelHeight + m_textOffset).attr('text-anchor', 'end');
                  }
                }

                var ac = "-90";
                axTexts.attr("transform", "rotate( " + ac + " " + axTexts.attr("x") + " " + axTexts.attr("y") + " )");

              }
              adjustLabelForIE(axTexts);
            }
          }
        }
      };

      axis.mouseover = function(target) {
        //high light the target
        target.setAttribute("opacity", 1);
        target.setAttribute("class", "v-labelarea v-hovershadow");
        target.setAttribute("fill", m_labelAreaMouseOverColor);
      };

      axis.mouseout = function(target) {
        //un high light all the label areas
        target.setAttribute("class", "v-labelarea");
        target.setAttribute("opacity", 0);
      };

      axis.cleanLabelAreas = function() {
        if (m_selection) {
          m_selection.selectAll(".v-labelarea")
            .attr("class", "v-labelarea")
            .attr("opacity", 0);
        }
      };

      axis.setTitle = function(_) {
        m_title = _;
        return axis;
      };
        
      axis.mouseup = function(target) {
        //un high light the target
        target.setAttribute("opacity", 1);
        target.setAttribute("class", "v-labelarea v-hovershadow");
        target.setAttribute("fill", m_labelAreaMouseOverColor);
      };

      axis.mousedown = function(target) {
        //high light the target
        target.setAttribute("opacity", 1);
        target.setAttribute("class", "v-labelarea v-hovershadow-mousedown");
        target.setAttribute("fill", m_labelAreaMouseDownColor);
      };

      axis.position = function(_position) {
        if (!arguments.length){
          return m_position;
        }
        m_position = _position;
        return axis;
      };

      axis.properties = function(_properties) {
        if (arguments.length === 0){
          return m_props;
        }

        m_props = Objects.extend(true, m_props, _properties);
        return axis;
      };

      axis.style = function(_style) {
        if (arguments.length === 0){
          return m_style;
        }
        m_style = Objects.extend(true, m_style, _style);
        return axis;
      };

      axis.axScale = function(_axScale) {
        if (!arguments.length){
          return m_axScale;
        }
        m_axScale = _axScale;
        return axis;
      };

      axis.getPreferredSize = function() {

        var scaleToDraw = adjustScale();

        var axisWidth = 0;
        var axisHeight = 0;

        var axisSpacings = [];
        var minTruncateSize = 0;

        for (var i = 0; i < scaleToDraw.length; i++) {
          if (!m_props.label.visible && i !== (scaleToDraw.length - 1)) {
            continue;
          }

          var axDomain = scaleToDraw[i].domain; //["a", "b"]
          var axRange = scaleToDraw[i].range; //[[0, 100], [100. 200], ...]

          if (axDomain.length === 0 || axRange.length === 0) {
            continue;
          }

          if (m_position === "bottom" || m_position === "top") {
            axisWidth = Math.abs(axRange[axRange.length - 1][1] - axRange[0][0]) + m_styleLineSrokeWidth;

            var offsetHeight = 0;
            if (m_props.label.visible) {
              var maxHeight;
              if (i === 0) {
                maxHeight = maxLabelTextHeight(axDomain, axRange, undefined, true);
                minTruncateSize = maxHeight.minTruncateSize;
              } else {
                maxHeight = maxLabelTextHeight(axDomain, axRange);
              }
              offsetHeight += maxHeight.maxLabelTextHeight;
            }

            offsetHeight = offsetHeight > 0 ? offsetHeight + 2 * m_textOffset : offsetHeight;
            axisHeight += offsetHeight;

            axisSpacings.push(offsetHeight);
          } else if (m_position === "left" || m_position === "right") {
            var offsetWidth = 0;

            if (m_props.label.visible) {
              var maxWidth;
              if (i === 0) {
                maxWidth = maxLabelTextWidth(axDomain, axRange, true);
                minTruncateSize = maxWidth.minTruncateSize;
              } else {
                maxWidth = maxLabelTextWidth(axDomain, axRange);
              }
              offsetWidth += maxWidth.maxLabelTextWidth;
            }
            offsetWidth = offsetWidth > 0 ? offsetWidth + 2 * m_textOffset : offsetWidth;

            axisWidth += offsetWidth;
            axisSpacings.push(offsetWidth);

            axisHeight = Math.abs(axRange[axRange.length - 1][1] - axRange[0][0]) + m_styleLineSrokeWidth;
          }
        }

        //--------------
        if (m_spaceLimit >= 0) {
          var spacings = axisSpacings;
          var spaceLeft = m_spaceLimit;

          var spacingToDraw = 0;


          for (i = 0; i < spacings.length; i++) {
            if (spaceLeft >= spacings[i]) {
              spacingToDraw += spacings[i];
              spaceLeft -= spacings[i];
              spaceLeft = NumberUtils.precise(spaceLeft);
            } else {
              break;
            }
          }

          if (spacingToDraw === 0 && spacings.length > 0) {
            if (minTruncateSize && minTruncateSize + 2 * m_textOffset < m_spaceLimit) {
              spacingToDraw = m_spaceLimit;
            } else {
              spacingToDraw += spacings[0];
            }
          }


          if (m_position === "bottom" || m_position === "top") {
            axisHeight = spacingToDraw;
          } else if (m_position === "left" || m_position === "right") {
            axisWidth = spacingToDraw;
          }
        }

        //------------------------------------
        if (!m_props.isTruncateAvailable) {
          minTruncateSize = 0;
        } else if (minTruncateSize > 0) {
          minTruncateSize += 2 * m_textOffset;
        }

        return {
          width: axisWidth,
          height: axisHeight,
          spacings: axisSpacings,
          minTruncateSize: minTruncateSize
        };
      };

      axis.matrix = function(_) {
        if (!arguments.length) {
          return m_matrix;
        }
        m_matrix = _;
        return axis;
      };

      axis.labelAngle = function(_) {
        if (!arguments.length) {
          return labelAngle;
        }
        labelAngle = _;
        return axis;
      };

      axis.tickAngle = function(_) {
        if (!arguments.length) {
          return tickAngle;
        }
        tickAngle = _;
        return axis;
      };

      axis.angle = function(_) {
        if (!arguments.length) {
          return angle;
        }
        angle = _;
        return axis;
      };

      axis.labelAlign = function(_) {
        if (!arguments.length) {
          return labelAlign;
        }
        labelAlign = _;
        return axis;
      };

      axis.destroy = function() {
        m_selection = null;
        //Jimmy: its name is confuse, makes people think it's a d3 scale
        m_axScale = null;
      };

      var resolveMaxAndMinInDomain = function(domain, rangeArray, checkEach, checkTruncate) {
        var heightArray = [];
        var widthArray = [];
        var isVerticalFont = false;
        var minTruncateSize = 0;
        for (var i = 0; i < domain.length; i++) {
          var tHeight = 0;
          var tWidth = 0;

          if (domain[i].drawLabel || checkEach) {
            var originalStr = getCustomlabelText(domain[i]);
            var tSize = fastMeasure(originalStr, m_style.realStyle.label);

            tHeight = tSize.height;
            tWidth = tSize.width;
            var interval = rangeArray[i][1] - rangeArray[i][0];

            if (checkTruncate) {
              var truncateSize;
              if (originalStr.length > 3) {
                truncateSize = fastMeasure(originalStr.slice(0, 3).concat('...'), m_style.realStyle.label).width;
                truncateSize = truncateSize > tSize.width ? tSize.width : truncateSize;
              } else {
                truncateSize = tSize.width;
              }

              minTruncateSize = truncateSize > minTruncateSize ? truncateSize : minTruncateSize;
            }

            if ((tHeight < tWidth) && interval !== 0 && tWidth > interval) {
              if (m_position === "top" || m_position === "bottom") {
                isVerticalFont = true;
              }
            }
          }

          heightArray.push(tHeight);
          widthArray.push(tWidth);
        }

        return {
          'heights': heightArray,
          'widths': widthArray,
          'isVerticalFont': isVerticalFont,
          'minTruncateSize': minTruncateSize
        };
      };

      var maxLabelTextHeight = function(domain, rangeArray, checkEach, checkTruncate) {
        //Jimmy/10/26/2012 we extend domain from string array to object to support customlabel
        var re = {
          "maxLabelTextHeight": 0,
          "isVertical": false
        };
        var maxTextHeight = 0;
        var isVerticalFont = false;
        var sizes = resolveMaxAndMinInDomain(domain, rangeArray, checkEach, checkTruncate);
        isVerticalFont = m_props.forceVerticalFont === true ? true : sizes.isVerticalFont;

        for (var i = 0; i < domain.length; i++) {
          if (domain[i].drawLabel || checkEach) {
            if (isVerticalFont) {
              if (maxTextHeight < sizes.widths[i]) {
                maxTextHeight = sizes.widths[i];
              }
            } else {
              if (maxTextHeight < sizes.heights[i]) {
                maxTextHeight = sizes.heights[i];
              }
            }
          }
        }
        re.maxLabelTextHeight = maxTextHeight;
        re.isVertical = isVerticalFont;
        re.minTruncateSize = re.isVertical ? sizes.minTruncateSize : -1;
        return re;
      };

      var maxLabelTextWidth = function(domain, rangeArray, checkTruncate) {
        var re = {
          "maxLabelTextWidth": 0,
          "isVertical": false
        };
        var maxTextWidth = 0;
        var isVerticalFont = false;
        var sizes = resolveMaxAndMinInDomain(domain, rangeArray, undefined, checkTruncate);
        isVerticalFont = m_props.forceVerticalFont === true ? true : sizes.isVerticalFont;

        for (var i = 0; i < domain.length; i++) {
          if (domain[i].drawLabel) {
            if (isVerticalFont) {
              if (maxTextWidth < sizes.heights[i]) {
                maxTextWidth = sizes.heights[i];
              }
            } else {
              if (maxTextWidth < sizes.widths[i]) {
                maxTextWidth = sizes.widths[i];
              }
            }
          }
        }

        re.maxLabelTextWidth = maxTextWidth;
        re.isVertical = isVerticalFont;
        re.minTruncateSize = sizes.minTruncateSize;
        return re;
      };

      var maxLabelTextSize = function(labels, isVertical) {
        var maxWidth = 0,
          maxHeight = 0;
        for (var i = 0; i < labels.length; i++) {
          var tSize = fastMeasure(labels[i].text, m_style.realStyle.label);
          maxWidth = tSize.width > maxWidth ? tSize.width : maxWidth;
          maxHeight = tSize.height > maxHeight ? tSize.height : maxHeight;
        }
        return {
          maxWidth: isVertical ? maxHeight : maxWidth,
          maxHeight: isVertical ? maxWidth : maxHeight
        };
      };

      var fastMeasure = function(_text, _style) {
        return TextUtils.superFastMeasure(_text, _style['font-size'],
          _style['font-weight'],
          _style['font-family']);
      };

      var isInvalidString = function(str) {
        if (typeof(str) !== "string" && NumberUtils.isNoValue(str)) {
          return true;
        }
        return false;
      };

      return axis;
    };

    return ret;
  });
define('sap/viz/modules/axis/SimpleCategory',['sap/viz/base/utils/oo',
'sap/viz/modules/axis/BaseCategory',
'sap/viz/modules/dispatch',
'sap/viz/modules/axis/simpleCategoryCore'],
function Setup(oo, BaseCategory, dispatch, simpleCategoryCore) {
    var axis = function(manifest, ctx) {
        axis.superclass.constructor.apply(this,arguments);

        axis.prototype.setCoreModule(simpleCategoryCore);
    };

    //the start point
    oo.extend(axis,BaseCategory);
    
    //overwritten fun
    axis.prototype.render = function(selection, isNewSVG)
    {
        return axis.superclass.render.call(this, selection, isNewSVG);
    };    

    return axis;
});

define('sap/viz/modules/axis/simpleCategoryBottomCore',['jquery', 'sap/viz/modules/Constants', 'sap/viz/util/TextUtils', 'sap/viz/util/NumberUtils', 'sap/viz/base/utils/Objects', 'sap/viz/lang/langManager',
    'sap/viz/base/utils/TypeUtils', 'sap/viz/modules/threeD/Point', 'sap/viz/modules/threeD/matrix',
    'sap/viz/format/FormatManager', 'sap/viz/base/UADetector'],
  function Setup(jQuery, ModuleConstants, TextUtils, NumberUtils, Objects, langManager, TypeUtils, Point, matrix, FormatManager, UADetector) {

    var ret = function() {

      var m_title = [];

      var m_position;
      var m_axScale;
      var m_selection;

      var m_textOffset;
      var m_tickSize = 5;

      var m_styleLineSrokeWidth = 1;
      var m_styleGridLineColor = "#d8d8d8";
      var m_axLabelClassName = "viz-axis-label";

      var m_labelAreaMouseOverColor = "#cccccc";
      var m_labelAreaMouseDownColor = "#808080";

      var m_disableSpaceLimit = false;

      var m_style = null; //used to hold style passed from axis
      var m_props = {
        "title": {
          "visible": false,
          "text": undefined
        },
        "gridline": {
          "visible": false,
          "color": m_styleGridLineColor,
          "showFirstLine": false,
          "length": 0,
          "showLastLine": false,
          "type": "line"
        },
        "type": "value",
        "visible": true,
        "label": {
          "visible": true,
          "formatString": "",
          hideStrategy: ''
        },
        "position": "left",
        "color": "#333333",
        "forceLabelArea": false,
        "shapeRendering": true,
        "forceVerticalFont": false
      };

      var m_vClassNames = {
        axis: "v-axis",
        axisBody: "v-body",
        axisTitle: "v-title",
        axisLabel: "v-label",
        axisLine: "v-categoryaxisline",
        gridLine: "v-gridline",
        morphableLabel: ModuleConstants.CSS.CLASS.MORPHABLELABEL
      };

      var m_axisLabelClassCombined = m_vClassNames.axisLabel + ' ' + m_axLabelClassName + ' ' + m_vClassNames.morphableLabel;

      var m_matrix = matrix(),
        labelAngle = null,
        labelAlign = null,
        angle = null,
        tickAngle = null;

      var m_spaceLimit = -1;

      var adjustScale = function(spaceLimit) {
        //we have to adjust the scale because we may not draw all the levels.
        var scaleToDraw = [];
        var isMultilayer = m_axScale.length > 1 ? true : false;
        if (isMultilayer) {
          m_textOffset = 6;
        } else {
          m_textOffset = 11;
        }

        for (var iScale = 0; iScale < m_axScale.length; iScale++) {
          var axDomain = m_axScale[iScale].domain; //["a", "b"]
          var axRange = m_axScale[iScale].range; //[[0, 100], [100. 200], ...]

          //count the max text size
          var re = maxLabelTextHeight(axDomain, axRange, true);
          var isVertical = re.isVertical;

          if (m_position === "left" || m_position === "right") {
            m_axScale[iScale].labelsToDraw = buildLeftRightToDrawLabels(axDomain, axRange, isMultilayer, spaceLimit);
          } else {
            m_axScale[iScale].labelsToDraw = buildTopBottomToDrawLabels(axDomain, axRange, isVertical, isMultilayer, spaceLimit);
          }

          if (iScale === 0) {
            scaleToDraw.push(m_axScale[iScale]);
            if (spaceLimit >= 0) {
              break;
            }
          } else if (m_axScale[iScale].labelsToDraw.length === m_axScale[iScale].domain.length) {
            scaleToDraw.push(m_axScale[iScale]);
          }
          //for mekko chart ,the scale is not equal. So if a label can be draw, we should draw the whole layer.
          else if (m_axScale[iScale].labelsToDraw.length > 0 && TypeUtils.isExist(m_axScale.noEqual) && m_axScale.noEqual === true) {
            scaleToDraw.push(m_axScale[iScale]);
          }
        }
        return scaleToDraw;
      };

      var drawGridLine = function(selection, x1, y1, x2, y2) {
        var gridline = selection.append("line")
          .attr("class", m_vClassNames.gridLine)
          .attr("y1", y1)
          .attr("y2", y2)
          .attr("x1", x1)
          .attr("x2", x2)
          .attr("stroke", m_props.gridline.color)
          .attr("stroke-width", m_props.gridline.size)
          .attr("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
        if (m_props.gridline.type === "dotted") {
          gridline.attr("stroke-dasharray", "3, 2");
        }
      };

      function axis(selection) {
        m_selection = selection;
        //we have to adjust the scale
        var scaleToDraw = adjustScale();
        var isTruncated = false;

        var levelHeight = 45;

        var i;
        //---we should dicide show or hide somethings because of the spaceLimit
        if (m_spaceLimit >= 0) {
          var scaleToAdjust = [];
          var preferredSize = axis.getPreferredSize();
          var spacings = preferredSize.spacings;
          var minTruncateSize = preferredSize.minTruncateSize;
          var spaceLeft = m_spaceLimit;


          for (i = 0; i < spacings.length; i++) {
            if (spaceLeft >= spacings[i]) {
              scaleToAdjust.push(scaleToDraw[i]);
              spaceLeft -= spacings[i];
              spaceLeft = NumberUtils.precise(spaceLeft);
            } else {
              if (i === 0 && minTruncateSize > 0 && spaceLeft >= minTruncateSize) {
                isTruncated = true;
              }
              break;
            }
          }

          if (scaleToAdjust.length === 0 && scaleToDraw.length > 0 && !isTruncated) {
            //scaleToAdjust.push(scaleToDraw[0]);//always draw one
            var lastDomain = [];
            for (i = 0; i < scaleToDraw[0].domain.length; i++) {
              lastDomain.push('');
            }
            scaleToAdjust.push({
              domain: lastDomain,
              range: scaleToDraw[0].range
            });
          }

          scaleToDraw = scaleToAdjust;
          if (isTruncated) {
            scaleToDraw = adjustScale(m_spaceLimit);
          }
        }
        //------------------------------------------------------
        var isMultilayer = scaleToDraw.length > 1 ? true : false;
        var lastLevelWidth, lastLevelHeight;
        var iScale, axDomain, axRange;
        var re, maxTextWidth, lineOffset, isVertical, maxTextHeight;
        var x1, x2, y1, y2, dPath;
        var axLine, axTick1, axTick2;
        var labelsToDraw, customlabelCfg, m_label, labelG, axLabels, axTexts;
       
          lastLevelHeight = 0;

          for (iScale = (scaleToDraw.length - 1); iScale >= 0; iScale--) {
            if (!m_props.label.visible && iScale !== (scaleToDraw.length - 1)) {
              continue;
            }

            axDomain = scaleToDraw[iScale].domain; //["a", "b"]
            axRange = scaleToDraw[iScale].range; //[[0, 100], [100. 200], ...]

            //count the max text size
            re = maxLabelTextHeight(axDomain, axRange);
            isVertical = re.isVertical;
            maxTextHeight = isTruncated ? maxLabelTextSize(scaleToDraw[iScale].labelsToDraw, isVertical).maxHeight : re.maxLabelTextHeight;

            lineOffset = levelHeight;//maxTextHeight + 2 * m_textOffset;
            if (!m_props.label.visible) {
              maxTextHeight = 0;
              lineOffset = 0;
            }

            lineOffset = isTruncated ? m_spaceLimit : lineOffset;

            if (iScale === (scaleToDraw.length - 1)) {
              if (m_props.gridline.showFirstLine) {
                drawGridLine(selection,
                  axRange[0][0],
                  lastLevelHeight,
                  axRange[0][0],
                  lastLevelHeight - m_props.gridline.length);
              }

              if (m_props.gridline.showLastLine) {
                drawGridLine(selection,
                  axRange[axRange.length - 1][0],
                  lastLevelHeight,
                  axRange[axRange.length - 1][0],
                  lastLevelHeight - m_props.gridline.length);
              }
            }

            var aAngle, cosAngle, sinAngle;
            if (scaleToDraw.length === 1) {
              x1 = axRange[0][0];
              x2 = axRange[axRange.length - 1][1];
              y1 = lastLevelHeight;
              y2 = lastLevelHeight;

              dPath = "M" + x1 + " " + (y1 + m_tickSize);
              dPath += "L" + x1 + " " + y1;
              dPath += "L" + x2 + " " + y2;
              dPath += "L" + x2 + " " + (y2 + m_tickSize);
              if (m_props.axisline.visible) {
                axLine = selection.append("path");
                axLine.each(function() {
                  this.setAttribute("class", m_vClassNames.axisLine);
                  this.setAttribute("d", dPath);
                  this.setAttribute("fill", "none");
                  this.setAttribute("stroke", m_props.color);
                  this.setAttribute("stroke-width", m_props.lineSize);
                  this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                });

              }
            } else if (scaleToDraw.length >= 2 && (iScale === scaleToDraw.length - 1)) {
              axLine = selection.append("line");
              axLine.each(function() {
                this.setAttribute("class", m_vClassNames.axisLine);
                this.setAttribute("x1", axRange[0][0]);
                this.setAttribute("x2", axRange[axRange.length - 1][1]);
                this.setAttribute("y1", lastLevelHeight);
                this.setAttribute("y2", lastLevelHeight);
                this.setAttribute("stroke", m_props.color);
                this.setAttribute("stroke-width", m_props.lineSize);
                this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
              });
            }

            if (scaleToDraw.length >= 2 && m_props.label.visible) {
              axLine = selection.append("line");
              axLine.each(function() {
                this.setAttribute("class", m_vClassNames.axisLine);
                this.setAttribute("x1", axRange[0][0]);
                this.setAttribute("x2", axRange[axRange.length - 1][1]);
                this.setAttribute("y1", lastLevelHeight + lineOffset);
                this.setAttribute("y2", lastLevelHeight + lineOffset);
                this.setAttribute("stroke", m_props.color);
                this.setAttribute("stroke-width", m_props.lineSize);
                this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
              });
            }

            //draw gridline in the last scaleToDraw///////////////////////
            if (m_props.gridline.visible && iScale === (scaleToDraw.length - 1)) {
              for (i = 0; i < axDomain.length; i++) {
                drawGridLine(selection,
                  axRange[i][0],
                  lastLevelHeight + lineOffset,
                  axRange[i][0],
                  lastLevelHeight + lineOffset + m_props.gridline.length
                );
                if ((i === (axDomain.length - 1)) || (axRange[i][1] !== axRange[i + 1][0])) {
                  drawGridLine(selection,
                    axRange[i][1],
                    lastLevelHeight + lineOffset,
                    axRange[i][1],
                    lastLevelHeight + lineOffset + m_props.gridline.length
                  );
                }
              }
            }
            //end draw gridline in the last scaleToDraw///////////////////////


            for (i = 0; i < axDomain.length; i++) {
                  axTick1 = selection.append("line");
                  axTick1.each(function() {
                    this.setAttribute("class", m_vClassNames.axisLine);
                    this.setAttribute("x1", axRange[i][0]);
                    this.setAttribute("x2", axRange[i][0]);
                    this.setAttribute("y1", 0);
                    this.setAttribute("y2", m_tickSize);
                    this.setAttribute("stroke", m_props.color);
                    this.setAttribute("stroke-width", m_props.lineSize);
                    this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                  });

                  axTick2 = selection.append("line");
                  axTick2.each(function() {
                    this.setAttribute("class", m_vClassNames.axisLine);
                    this.setAttribute("x1", axRange[i][1]);
                    this.setAttribute("x2", axRange[i][1]);
                    this.setAttribute("y1", 0);
                    this.setAttribute("y2", m_tickSize);
                    this.setAttribute("stroke", m_props.color);
                    this.setAttribute("stroke-width", m_props.lineSize);
                    this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                  });

              if (scaleToDraw.length >= 2 && m_props.label.visible) {
                var vOffset = 0;
                if(iScale !== 0)
                {
                    vOffset = m_tickSize;
                }
                axLine = selection.append("line");
                axLine.each(function() {
                  this.setAttribute("class", m_vClassNames.axisLine);
                  this.setAttribute("x1", axRange[i][0]);
                  this.setAttribute("x2", axRange[i][0]);
                  this.setAttribute("y1", lastLevelHeight + vOffset);
                  this.setAttribute("y2", lastLevelHeight + lineOffset);
                  this.setAttribute("stroke", "#dddddd");
                  this.setAttribute("stroke-width", m_props.lineSize);
                  this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                });

                if ((i === (axDomain.length - 1)) || (axRange[i][1] !== axRange[i + 1][0])) {
                  axLine = selection.append("line");
                  axLine.each(function() {
                    this.setAttribute("class", m_vClassNames.axisLine);
                    this.setAttribute("x1", axRange[i][1]);
                    this.setAttribute("x2", axRange[i][1]);
                    this.setAttribute("y1", lastLevelHeight + vOffset);
                    this.setAttribute("y2", lastLevelHeight + lineOffset);
                    this.setAttribute("stroke", "#dddddd");
                    this.setAttribute("stroke-width", m_props.lineSize);
                    this.setAttribute("shape-rendering", m_props.shapeRendering ? "crispEdges" : "auto");
                  });
                }
              }
            }

            labelsToDraw = scaleToDraw[iScale].labelsToDraw;
            drawTopBottomLabels(selection, labelsToDraw, lastLevelHeight, maxTextHeight, axDomain, isVertical, scaleToDraw.length !== 1);

            lastLevelHeight += levelHeight;//(maxTextHeight + 2 * m_textOffset);
          }
      }
      
      axis.spaceLimit = function(_spaceLimit) {
        if (!arguments.length){
          return m_spaceLimit;
        }

        if (!m_disableSpaceLimit) {
          m_spaceLimit = _spaceLimit;
        }

        return axis;
      };

      var adjustLabelForIE = function(text) {
        if (UADetector.isIE()) {
          //dominant-baseline does not work
          var textHeight = m_style.realStyle.label['font-size'].toString();
          var indexPX = textHeight.indexOf("px");
          if (indexPX >= 0) {
            textHeight = textHeight.substr(0, indexPX);
          }

          //textHeight = fastMeasure(text, m_style.realStyle.label).height;
          var y = text.attr("y");
          text.attr("y", Number(y) + textHeight / 2);
          text.attr("dominant-baseline", "auto");
        }
      };

      //get customlabel text from from the rawObj, if the type is url, return the original text
      var getCustomlabelText = function(rawObj) {
        var ret;
        if (rawObj.info) {
          var clobj = rawObj.info.customlabel;
          if (clobj) {
            if (clobj.type === 'url') {
              ret = rawObj.val;
            } else if (clobj.type === 'string') {
              ret = clobj.val;
            }
          } else {
            ret = rawObj.val;
          }
        } else {
          ret = rawObj.val;
        }
        if (ret === '') {
          ret = ' ';
        }
        //so we will first resolve customlabel and then do format
        ret = isInvalidString(ret) ? langManager.get('IDS_ISNOVALUE') : ret;
        ret = FormatManager.format(ret, m_props.label.formatString);
        return ret;
      };

      var getCustomlabelCfg = function(rawObj) {
        if (rawObj.info && rawObj.info.customlabel) {
          return rawObj.info.customlabel;
        }
      };

      var getTruncatedText = function(text, limit) {
        var style = 'font-weight: ' + m_style.realStyle.label['font-weight'] + '; font-family: ' + m_style.realStyle.label['font-family'] + '; font-size: ' + m_style.realStyle.label['font-size'] + ';';
        return TextUtils.ellipsis(text, undefined, limit, style);
      };

      var buildLeftRightToDrawLabels = function(allLabels, allLabelsLocation, isMultilayer, spaceLimit) {
        //Jimmy/12/26/2012 extend allLabels from stringArray to objectArray to support customlabel
        //we always draw the bottom label for yAxis.

        //build the "todraw" array
        //count all the labels y1 and y2, and save them.
        var fullHeight = 0;
        var allTicksLabels = [];
        var i, item;
        for (i = 0; i < allLabels.length; i++) {
          item = {};
          item.text = getCustomlabelText(allLabels[i]);
          item.custom = getCustomlabelCfg(allLabels[i]);
          item.labelContexts = allLabels[i].labelContexts;
          if (spaceLimit >= 0) {
            item.text = getTruncatedText(item.text, spaceLimit - 2 * m_textOffset);
          }
          //count y1 and y2
          var itemMeasure = fastMeasure(item.text, m_style.realStyle.label);
          var centerY = allLabelsLocation[i][0] + (allLabelsLocation[i][1] - allLabelsLocation[i][0]) / 2;
          item.width = itemMeasure.width;
          item.height = itemMeasure.height;
          item.startY = allLabelsLocation[i][0];
          item.rectHeight = allLabelsLocation[i][1] - allLabelsLocation[i][0];
          item.y = centerY;
          item.y1 = centerY - item.height / 2;
          item.y2 = centerY + item.height / 2;
          item.originalIndex = i;
          allLabels[i].drawLabel = false;
          allTicksLabels.push(item);

          fullHeight += item.rectHeight;
        }


        //now we should decide which label to draw.
        //iBeyond = 0:0,1,2,3,4,5,6,...
        //iBeyond = 1:0, ,2, ,4, ,6,...
        //iBeyond = 2:0, , ,3, , ,6,...
        //...
        //iBeyond = (allTicksLabels.length - 1):0
        var ticksLabelsToDraw = [], previousIndex, iBeyond;
        if (m_props.label.hideStrategy !== 'greedy') {
          //we must filter those labels which have already overflown the border.
          var filteredTicksLabels = allTicksLabels.concat();
          for (i = filteredTicksLabels.length - 1; i > -1; --i) {
            if (allLabelsLocation[0] && allLabelsLocation.length &&
              (filteredTicksLabels[i].y2 > allLabelsLocation[allLabelsLocation.length - 1][1] || filteredTicksLabels[i].y1 < allLabelsLocation[0][0])) {
              filteredTicksLabels.splice(i, 1);
            }
          }

          for (iBeyond = 0; iBeyond <= (filteredTicksLabels.length - 1); iBeyond++) {
            var isDrawable = true;
            for (i = (filteredTicksLabels.length - 1); i >= 0; i -= (iBeyond + 1)) {
              item = filteredTicksLabels[i];
              if (i !== (filteredTicksLabels.length - 1)) {
                previousIndex = i + (iBeyond + 1);

                if (filteredTicksLabels[i].y2 >= filteredTicksLabels[previousIndex].y1) {
                  isDrawable = false;
                  break;
                }
              }
              if (item.height > fullHeight) {
                break;
              }

              ticksLabelsToDraw.push(item);
              allLabels[item.originalIndex].drawLabel = true;
            }
            if (isDrawable) {
              break;
            } else {
              ticksLabelsToDraw = [];
            }
          }
        } else {

          for (previousIndex = iBeyond = (allTicksLabels.length - 1); iBeyond >= 0; iBeyond--) {
            item = allTicksLabels[iBeyond];

            if (previousIndex === iBeyond && allLabelsLocation[iBeyond][1] !== allLabelsLocation[iBeyond][0]) {
              if (isMultilayer && item.y1 > allLabelsLocation[iBeyond][0] && item.y2 < allLabelsLocation[iBeyond][1]) {
                ticksLabelsToDraw.push(item);
                allLabels[item.originalIndex].drawLabel = true;
              } else if (!isMultilayer) {
                if (item.height <= fullHeight) {
                  ticksLabelsToDraw.push(item);
                  allLabels[item.originalIndex].drawLabel = true;
                }
              }
            } else {
              if (item.y2 <= allTicksLabels[previousIndex].y1 && allLabelsLocation[iBeyond][1] !== allLabelsLocation[iBeyond][0]) {
                if (isMultilayer) {
                  //if have more than one layers, need to detecte whether the label is between gridlines
                  if (item.y1 > allLabelsLocation[iBeyond][0] && item.y2 < allLabelsLocation[iBeyond][1]) {
                    ticksLabelsToDraw.push(item);
                    allLabels[item.originalIndex].drawLabel = true;
                    previousIndex = iBeyond;
                  }
                } else {
                  //if have only one layer , just need to detecte whether overlap is exist
                  ticksLabelsToDraw.push(item);
                  allLabels[item.originalIndex].drawLabel = true;
                  previousIndex = iBeyond;
                }
              }
            }
          }
          //for greedy situation, we must filter it after because each cell has different width/height.
          for (i = ticksLabelsToDraw.length - 1; i > -1; --i) {
            if (allLabelsLocation[0] && allLabelsLocation.length &&
              (ticksLabelsToDraw[i].y2 > allLabelsLocation[allLabelsLocation.length - 1][1] || ticksLabelsToDraw[i].y1 < allLabelsLocation[0][0])) {
              allLabels[ticksLabelsToDraw[i].originalIndex].drawLabel = false;
              ticksLabelsToDraw.splice(i, 1);
            }
          }

        }
        return ticksLabelsToDraw;
      };

      var buildTopBottomToDrawLabels = function(allLabels, allLabelsLocation, isVertical, isMultilayer, spaceLimit) {
        //Jimmy/12/26/2012 extend allLabels from stringArray to objectArray to support customlabel
        //we always draw the first label for xAxis.

        //build the "todraw" array
        //count all the labels y1 and y2, and save them.
        var fullWidth = 0;
        var allTicksLabels = [];
        var i, item;
        for (i = 0; i < allLabels.length; i++) {
          item = {};
          item.text = getCustomlabelText(allLabels[i]);
          item.custom = getCustomlabelCfg(allLabels[i]);
          item.labelContexts = allLabels[i].labelContexts;

          if (spaceLimit >= 0) {
            item.text = getTruncatedText(item.text, spaceLimit - 2 * m_textOffset);
          }

          //count x1 and x2
          var itemMeasure = fastMeasure(item.text, m_style.realStyle.label);
          if (isVertical) {
            item.width = itemMeasure.height;
            item.height = itemMeasure.width;
          } else {
            item.width = itemMeasure.width;
            item.height = itemMeasure.height;
          }

          var centerX = allLabelsLocation[i][0] + (allLabelsLocation[i][1] - allLabelsLocation[i][0]) / 2;

          item.x = centerX;
          item.x1 = centerX - item.width / 2;
          item.x2 = centerX + item.width / 2;

          item.startX = allLabelsLocation[i][0];
          item.rectWidth = allLabelsLocation[i][1] - allLabelsLocation[i][0];
          item.originalIndex = i;
          allLabels[i].drawLabel = false;

          allTicksLabels.push(item);

          fullWidth += item.rectWidth;
        }

        //now we should decide which label to draw.
        //iBeyond = 0:0,1,2,3,4,5,6,...
        //iBeyond = 1:0, ,2, ,4, ,6,...
        //iBeyond = 2:0, , ,3, , ,6,...
        //...
        //iBeyond = (allTicksLabels.length - 1):0
        var ticksLabelsToDraw = [], previousIndex, iBeyond;
        if (m_props.label.hideStrategy !== 'greedy') {
          //we must filter those labels which have already overflown the border.
          var filteredTicksLabels = allTicksLabels.concat();
          for (i = filteredTicksLabels.length - 1; i > -1; --i) {
            if (allLabelsLocation[0] && allLabelsLocation.length &&
              (filteredTicksLabels[i].x2 > allLabelsLocation[allLabelsLocation.length - 1][1] || filteredTicksLabels[i].x1 < allLabelsLocation[0][0])) {
              filteredTicksLabels.splice(i, 1);
            }
          }
          for (iBeyond = 0; iBeyond <= (filteredTicksLabels.length - 1); iBeyond++) {
            var isDrawable = true;
            for (i = 0; i < filteredTicksLabels.length; i += (iBeyond + 1)) {
              item = filteredTicksLabels[i];
              if (i !== 0) {
                previousIndex = i - (iBeyond + 1);

                if (filteredTicksLabels[i].x1 <= filteredTicksLabels[previousIndex].x2 || allLabelsLocation[iBeyond][1] === allLabelsLocation[iBeyond][0]) {
                  isDrawable = false;
                  break;
                }
              }

              if (item.width > fullWidth) {
                break;
              }

              ticksLabelsToDraw.push(item);
              allLabels[item.originalIndex].drawLabel = true;
            }
            if (isDrawable) {
              break;
            } else {
              ticksLabelsToDraw = [];
            }
          }
        } else {

          for (previousIndex = iBeyond = (allTicksLabels.length - 1); iBeyond >= 0; iBeyond--) {
            item = allTicksLabels[iBeyond];

            if (previousIndex === iBeyond && allLabelsLocation[iBeyond][1] !== allLabelsLocation[iBeyond][0]) {
              if (isMultilayer && item.x1 > allLabelsLocation[iBeyond][0] && item.x2 < allLabelsLocation[iBeyond][1]) {
                ticksLabelsToDraw.push(item);
                allLabels[item.originalIndex].drawLabel = true;
              } else if (!isMultilayer) {
                if (item.width <= fullWidth) {
                  ticksLabelsToDraw.push(item);
                  allLabels[item.originalIndex].drawLabel = true;
                }
              }
            } else {
              if (item.x2 <= allTicksLabels[previousIndex].x1 && allLabelsLocation[iBeyond][1] !== allLabelsLocation[iBeyond][0]) {
                if (isMultilayer) {
                  //if have more than one layers, need to detecte whether the label is between gridlines
                  if (item.x1 > allLabelsLocation[iBeyond][0] && item.x2 < allLabelsLocation[iBeyond][1]) {
                    ticksLabelsToDraw.push(item);
                    allLabels[item.originalIndex].drawLabel = true;
                    previousIndex = iBeyond;
                  }
                } else {
                  //if have only one layer , just need to detecte whether overlap is exist
                  ticksLabelsToDraw.push(item);
                  allLabels[item.originalIndex].drawLabel = true;
                  previousIndex = iBeyond;
                }
              }
            }
          }
          //for greedy situation, we must filter it after because each cell has different width/height.

          for (i = ticksLabelsToDraw.length - 1; i > -1; --i) {
            if (allLabelsLocation[0] && allLabelsLocation.length &&
              (ticksLabelsToDraw[i].x2 > allLabelsLocation[allLabelsLocation.length - 1][1] || ticksLabelsToDraw[i].x1 < allLabelsLocation[0][0])) {
              allLabels[ticksLabelsToDraw[i].originalIndex].drawLabel = false;
              ticksLabelsToDraw.splice(i, 1);
            }
          }
        }

        return ticksLabelsToDraw;
      };

      var drawTopBottomLabels = function(selection, labelsToDraw, lastLevelHeight, maxTextHeight, axDomain, isVertical, isHierarchical) {
        if (labelsToDraw === undefined) {
          return;
        }

        for (var i = 0; i < labelsToDraw.length; i++) {
          var label = TypeUtils.isExist(labelsToDraw[i].text) ? labelsToDraw[i].text : '';
          var axLabels;
          if (m_props.label.visible) {
            if (angle) {
              var labelAreaOffset = 2;

              var aAngle = angle * Math.PI / 180;
              var cosAngle = Math.cos(aAngle);
              var sinAngle = (45 === angle) ? cosAngle : Math.sin(aAngle);
              var tAngle = tickAngle * Math.PI / 180;
              var cosTAngle = Math.cos(tAngle);
              var sinTAngle = Math.sin(tAngle);

              var tickStartX = labelsToDraw[i].x * sinAngle;
              var tickStartY = -labelsToDraw[i].x * cosAngle;

              var labelTextX = tickStartX + (m_tickSize + m_textOffset) * cosTAngle;
              var labelTextY = tickStartY + lastLevelHeight + (m_textOffset + m_tickSize) * sinTAngle;

              var labelAreaX = labelTextX - labelAreaOffset;
              var labelAreaY = labelTextY - labelsToDraw[i].width / 2 - labelAreaOffset;
              var labelAreaWidth = labelsToDraw[i].height + 2 * labelAreaOffset; //the text is vertical
              var labelAreaHeight = labelsToDraw[i].width + 2 * labelAreaOffset;

              //for debug
              if (tickAngle > 90) {
                labelAreaX -= (labelAreaWidth - 2 * labelAreaOffset);
              }

              //label G
              axLabels = selection.append("g");
              axLabels.each(function() {
                this.setAttribute("fill", m_style.defaultStyle.label.fill);
                this.setAttribute("class", m_axisLabelClassCombined);
                this.setAttribute("font-size", m_style.defaultStyle.label['font-size']);
                this.setAttribute("font-weight", m_style.defaultStyle.label['font-weight']);
                this.setAttribute("font-family", m_style.defaultStyle.label['font-family']);
              });

              //draw labelArea
              var labelArea = axLabels.append("rect");
              labelArea.each(function() {
                this.setAttribute("x", labelAreaX);
                this.setAttribute("y", labelAreaY);
                this.setAttribute("width", labelAreaWidth);
                this.setAttribute("height", labelAreaHeight);
                this.setAttribute("opacity", 0);
                this.setAttribute("class", "v-labelarea");
              });
              labelArea.node().labelContexts = labelsToDraw[i].labelContexts;

              //draw label text
              var axLabelText = axLabels.append("text").text(label);
              axLabelText.each(function() {
                this.setAttribute("x", labelTextX);
                this.setAttribute("y", labelTextY);
                this.setAttribute("dominant-baseline", "middle"); //"auto")//"hanging")//"central")
                this.setAttribute("text-anchor", 'start'); // text-align
                this.setAttribute("pointer-events", "none");
              });


              if (tickAngle > 90) {
                axLabelText.attr("text-anchor", 'end');
                axLabels.attr('transform', 'rotate( ' + (tickAngle - 180) + ' ' + labelTextX + ' ' + labelTextY + ')');
              } else {
                axLabels.attr('transform', 'rotate( ' + (tickAngle) + ' ' + labelTextX + ' ' + labelTextY + ')');
              }
            } else {
              var labelG = selection;
              var offsetForBorder = 1, isTextSize, rect;
              if (m_position === "bottom") {

                isTextSize = m_props.forceLabelArea || labelsToDraw[i].width > labelsToDraw[i].rectWidth;
                rect = labelG.append("rect");
                if (isTextSize) {
                  rect.each(function() {
                    this.setAttribute("x", labelsToDraw[i].x - labelsToDraw[i].width / 2 - offsetForBorder);
                    this.setAttribute("y", lastLevelHeight + maxTextHeight / 2 - offsetForBorder - m_textOffset / 2);
                    this.setAttribute("width", labelsToDraw[i].width + 2 * offsetForBorder);
                    this.setAttribute("height", labelsToDraw[i].height + 2 * offsetForBorder);
                    this.setAttribute("opacity", 0);
                    this.setAttribute("class", "v-labelarea");
                  });
                } else {
                  rect.each(function() {
                    this.setAttribute("x", labelsToDraw[i].startX);
                    this.setAttribute("y", lastLevelHeight + offsetForBorder);
                    this.setAttribute("width", labelsToDraw[i].rectWidth);
                    this.setAttribute("height", maxTextHeight + 2 * m_textOffset - offsetForBorder);
                    this.setAttribute("opacity", 0);
                    this.setAttribute("class", "v-labelarea");
                  });
                }
                rect.node().labelContexts = labelsToDraw[i].labelContexts;
              } else if (m_position === "top") {
                if (labelsToDraw[i].labelContexts.length > 0) {

                  isTextSize = m_props.forceLabelArea || labelsToDraw[i].width > labelsToDraw[i].rectWidth;
                  rect = labelG.append("rect");
                  if (isTextSize) {
                    rect.each(function() {
                      this.setAttribute("x", labelsToDraw[i].x - labelsToDraw[i].width / 2 - offsetForBorder);
                      this.setAttribute("y", lastLevelHeight + maxTextHeight / 2 + m_textOffset / 2 - offsetForBorder);
                      this.setAttribute("width", labelsToDraw[i].width + 2 * offsetForBorder);
                      this.setAttribute("height", labelsToDraw[i].height + 2 * offsetForBorder);
                      this.setAttribute("opacity", 0);
                      this.setAttribute("class", "v-labelarea");
                    });
                  } else {
                    rect.each(function() {
                      this.setAttribute("x", labelsToDraw[i].startX);
                      this.setAttribute("y", lastLevelHeight);
                      this.setAttribute("width", labelsToDraw[i].rectWidth);
                      this.setAttribute("height", maxTextHeight + 2 * m_textOffset);
                      this.setAttribute("opacity", 0);
                      this.setAttribute("class", "v-labelarea");
                    });
                  }

                  rect.node().labelContexts = labelsToDraw[i].labelContexts;
                }
              }

              axLabels = labelG.append("g");
              axLabels.each(function() {
                this.setAttribute("fill", m_style.defaultStyle.label.fill);
                this.setAttribute("class", m_axisLabelClassCombined);
                this.setAttribute("font-size", m_style.defaultStyle.label['font-size']);
                this.setAttribute("font-weight", m_style.defaultStyle.label['font-weight']);
                this.setAttribute("font-family", m_style.defaultStyle.label['font-family']);
              });
              var axTexts = axLabels.append("text").text(label);
              axTexts.each(function() {

                this.setAttribute("pointer-events", "none");
                this.setAttribute("x", labelsToDraw[i].x);
                this.setAttribute("y", lastLevelHeight + maxTextHeight / 2 + m_textOffset);
                this.setAttribute("dominant-baseline", "middle"); //"auto")//"hanging")//"central")
                this.setAttribute("text-anchor", "middle"); // text-align
              });


              if (isVertical) {
                if (!isHierarchical) {
                  if (m_position === 'top') {
                    axTexts.attr('text-anchor', 'start')
                      .attr("y", lastLevelHeight + maxTextHeight + m_textOffset);
                  } else if (m_position === 'bottom') {
                    axTexts.attr("y", lastLevelHeight + m_textOffset).attr('text-anchor', 'end');
                  }
                }

                var ac = "-90";
                axTexts.attr("transform", "rotate( " + ac + " " + axTexts.attr("x") + " " + axTexts.attr("y") + " )");

              }
              adjustLabelForIE(axTexts);
            }
          }
        }
      };

      axis.mouseover = function(target) {
        //high light the target
        target.setAttribute("opacity", 1);
        target.setAttribute("class", "v-labelarea v-hovershadow");
        target.setAttribute("fill", m_labelAreaMouseOverColor);
      };

      axis.mouseout = function(target) {
        //un high light all the label areas
        target.setAttribute("class", "v-labelarea");
        target.setAttribute("opacity", 0);
      };

      axis.cleanLabelAreas = function() {
        if (m_selection) {
          m_selection.selectAll(".v-labelarea")
            .attr("class", "v-labelarea")
            .attr("opacity", 0);
        }
      };

      axis.setTitle = function(_) {
        m_title = _;
        return axis;
      };
        
      axis.mouseup = function(target) {
        //un high light the target
        target.setAttribute("opacity", 1);
        target.setAttribute("class", "v-labelarea v-hovershadow");
        target.setAttribute("fill", m_labelAreaMouseOverColor);
      };

      axis.mousedown = function(target) {
        //high light the target
        target.setAttribute("opacity", 1);
        target.setAttribute("class", "v-labelarea v-hovershadow-mousedown");
        target.setAttribute("fill", m_labelAreaMouseDownColor);
      };

      axis.position = function(_position) {
        if (!arguments.length){
          return m_position;
        }
        m_position = _position;
        return axis;
      };

      axis.properties = function(_properties) {
        if (arguments.length === 0){
          return m_props;
        }

        m_props = Objects.extend(true, m_props, _properties);
        return axis;
      };

      axis.style = function(_style) {
        if (arguments.length === 0){
          return m_style;
        }
        m_style = Objects.extend(true, m_style, _style);
        return axis;
      };

      axis.axScale = function(_axScale) {
        if (!arguments.length){
          return m_axScale;
        }
        m_axScale = _axScale;
        return axis;
      };

      axis.getPreferredSize = function() {

        var scaleToDraw = adjustScale();

        var axisWidth = 0;
        var axisHeight = 0;

        var axisSpacings = [];
        var minTruncateSize = 0;

        for (var i = 0; i < scaleToDraw.length; i++) {
          if (!m_props.label.visible && i !== (scaleToDraw.length - 1)) {
            continue;
          }

          var axDomain = scaleToDraw[i].domain; //["a", "b"]
          var axRange = scaleToDraw[i].range; //[[0, 100], [100. 200], ...]

          if (axDomain.length === 0 || axRange.length === 0) {
            continue;
          }

          if (m_position === "bottom" || m_position === "top") {
            axisWidth = Math.abs(axRange[axRange.length - 1][1] - axRange[0][0]) + m_styleLineSrokeWidth;

            var offsetHeight = 0;
            if (m_props.label.visible) {
              var maxHeight;
              if (i === 0) {
                maxHeight = maxLabelTextHeight(axDomain, axRange, undefined, true);
                minTruncateSize = maxHeight.minTruncateSize;
              } else {
                maxHeight = maxLabelTextHeight(axDomain, axRange);
              }
              offsetHeight += maxHeight.maxLabelTextHeight;
            }

            offsetHeight = offsetHeight > 0 ? offsetHeight + 2 * m_textOffset : offsetHeight;
            axisHeight += offsetHeight;

            axisSpacings.push(offsetHeight);
          } else if (m_position === "left" || m_position === "right") {
            var offsetWidth = 0;

            if (m_props.label.visible) {
              var maxWidth;
              if (i === 0) {
                maxWidth = maxLabelTextWidth(axDomain, axRange, true);
                minTruncateSize = maxWidth.minTruncateSize;
              } else {
                maxWidth = maxLabelTextWidth(axDomain, axRange);
              }
              offsetWidth += maxWidth.maxLabelTextWidth;
            }
            offsetWidth = offsetWidth > 0 ? offsetWidth + 2 * m_textOffset : offsetWidth;

            axisWidth += offsetWidth;
            axisSpacings.push(offsetWidth);

            axisHeight = Math.abs(axRange[axRange.length - 1][1] - axRange[0][0]) + m_styleLineSrokeWidth;
          }
        }

        //--------------
        if (m_spaceLimit >= 0) {
          var spacings = axisSpacings;
          var spaceLeft = m_spaceLimit;

          var spacingToDraw = 0;


          for (i = 0; i < spacings.length; i++) {
            if (spaceLeft >= spacings[i]) {
              spacingToDraw += spacings[i];
              spaceLeft -= spacings[i];
              spaceLeft = NumberUtils.precise(spaceLeft);
            } else {
              break;
            }
          }

          if (spacingToDraw === 0 && spacings.length > 0) {
            if (minTruncateSize && minTruncateSize + 2 * m_textOffset < m_spaceLimit) {
              spacingToDraw = m_spaceLimit;
            } else {
              spacingToDraw += spacings[0];
            }
          }


          if (m_position === "bottom" || m_position === "top") {
            axisHeight = spacingToDraw;
          } else if (m_position === "left" || m_position === "right") {
            axisWidth = spacingToDraw;
          }
        }

        //------------------------------------
        if (!m_props.isTruncateAvailable) {
          minTruncateSize = 0;
        } else if (minTruncateSize > 0) {
          minTruncateSize += 2 * m_textOffset;
        }

        return {
          width: axisWidth,
          height: axisHeight,
          spacings: axisSpacings,
          minTruncateSize: minTruncateSize
        };
      };

      axis.matrix = function(_) {
        if (!arguments.length) {
          return m_matrix;
        }
        m_matrix = _;
        return axis;
      };

      axis.labelAngle = function(_) {
        if (!arguments.length) {
          return labelAngle;
        }
        labelAngle = _;
        return axis;
      };

      axis.tickAngle = function(_) {
        if (!arguments.length) {
          return tickAngle;
        }
        tickAngle = _;
        return axis;
      };

      axis.angle = function(_) {
        if (!arguments.length) {
          return angle;
        }
        angle = _;
        return axis;
      };

      axis.labelAlign = function(_) {
        if (!arguments.length) {
          return labelAlign;
        }
        labelAlign = _;
        return axis;
      };

      axis.destroy = function() {
        m_selection = null;
        //Jimmy: its name is confuse, makes people think it's a d3 scale
        m_axScale = null;
      };

      var resolveMaxAndMinInDomain = function(domain, rangeArray, checkEach, checkTruncate) {
        var heightArray = [];
        var widthArray = [];
        var isVerticalFont = false;
        var minTruncateSize = 0;
        for (var i = 0; i < domain.length; i++) {
          var tHeight = 0;
          var tWidth = 0;

          if (domain[i].drawLabel || checkEach) {
            var originalStr = getCustomlabelText(domain[i]);
            var tSize = fastMeasure(originalStr, m_style.realStyle.label);

            tHeight = tSize.height;
            tWidth = tSize.width;
            var interval = rangeArray[i][1] - rangeArray[i][0];

            if (checkTruncate) {
              var truncateSize;
              if (originalStr.length > 3) {
                truncateSize = fastMeasure(originalStr.slice(0, 3).concat('...'), m_style.realStyle.label).width;
                truncateSize = truncateSize > tSize.width ? tSize.width : truncateSize;
              } else {
                truncateSize = tSize.width;
              }

              minTruncateSize = truncateSize > minTruncateSize ? truncateSize : minTruncateSize;
            }

            if ((tHeight < tWidth) && interval !== 0 && tWidth > interval) {
              if (m_position === "top" || m_position === "bottom") {
                isVerticalFont = true;
              }
            }
          }

          heightArray.push(tHeight);
          widthArray.push(tWidth);
        }

        return {
          'heights': heightArray,
          'widths': widthArray,
          'isVerticalFont': isVerticalFont,
          'minTruncateSize': minTruncateSize
        };
      };

      var maxLabelTextHeight = function(domain, rangeArray, checkEach, checkTruncate) {
        //Jimmy/10/26/2012 we extend domain from string array to object to support customlabel
        var re = {
          "maxLabelTextHeight": 0,
          "isVertical": false
        };
        var maxTextHeight = 0;
        var isVerticalFont = false;
        var sizes = resolveMaxAndMinInDomain(domain, rangeArray, checkEach, checkTruncate);
        isVerticalFont = m_props.forceVerticalFont === true ? true : sizes.isVerticalFont;

        for (var i = 0; i < domain.length; i++) {
          if (domain[i].drawLabel || checkEach) {
            if (isVerticalFont) {
              if (maxTextHeight < sizes.widths[i]) {
                maxTextHeight = sizes.widths[i];
              }
            } else {
              if (maxTextHeight < sizes.heights[i]) {
                maxTextHeight = sizes.heights[i];
              }
            }
          }
        }
        re.maxLabelTextHeight = maxTextHeight;
        re.isVertical = isVerticalFont;
        re.minTruncateSize = re.isVertical ? sizes.minTruncateSize : -1;
        return re;
      };

      var maxLabelTextWidth = function(domain, rangeArray, checkTruncate) {
        var re = {
          "maxLabelTextWidth": 0,
          "isVertical": false
        };
        var maxTextWidth = 0;
        var isVerticalFont = false;
        var sizes = resolveMaxAndMinInDomain(domain, rangeArray, undefined, checkTruncate);
        isVerticalFont = m_props.forceVerticalFont === true ? true : sizes.isVerticalFont;

        for (var i = 0; i < domain.length; i++) {
          if (domain[i].drawLabel) {
            if (isVerticalFont) {
              if (maxTextWidth < sizes.heights[i]) {
                maxTextWidth = sizes.heights[i];
              }
            } else {
              if (maxTextWidth < sizes.widths[i]) {
                maxTextWidth = sizes.widths[i];
              }
            }
          }
        }

        re.maxLabelTextWidth = maxTextWidth;
        re.isVertical = isVerticalFont;
        re.minTruncateSize = sizes.minTruncateSize;
        return re;
      };

      var maxLabelTextSize = function(labels, isVertical) {
        var maxWidth = 0,
          maxHeight = 0;
        for (var i = 0; i < labels.length; i++) {
          var tSize = fastMeasure(labels[i].text, m_style.realStyle.label);
          maxWidth = tSize.width > maxWidth ? tSize.width : maxWidth;
          maxHeight = tSize.height > maxHeight ? tSize.height : maxHeight;
        }
        return {
          maxWidth: isVertical ? maxHeight : maxWidth,
          maxHeight: isVertical ? maxWidth : maxHeight
        };
      };

      var fastMeasure = function(_text, _style) {
        return TextUtils.superFastMeasure(_text, _style['font-size'],
          _style['font-weight'],
          _style['font-family']);
      };

      var isInvalidString = function(str) {
        if (typeof(str) !== "string" && NumberUtils.isNoValue(str)) {
          return true;
        }
        return false;
      };

      return axis;
    };

    return ret;
  });
define('sap/viz/modules/axis/SimpleCategoryBottom',['sap/viz/base/utils/oo',
'sap/viz/modules/axis/SimpleCategory',
'sap/viz/modules/dispatch',
'sap/viz/modules/axis/simpleCategoryBottomCore'],
function Setup(oo, SimpleCategory, dispatch, simpleCategoryBottomCore) {
    var axis = function(manifest, ctx) {
        axis.superclass.constructor.apply(this,arguments);

        axis.prototype.setCoreModule(simpleCategoryBottomCore);
    };

    //the start point
    oo.extend(axis,SimpleCategory);

    return axis;
});

define('sap/viz/modules/axis/MultipleCategoryBottom',['sap/viz/base/utils/oo',
'sap/viz/modules/axis/SimpleCategoryBottom',
'sap/viz/modules/dispatch'],
function Setup(oo, SimpleCategoryBottom, dispatch) {
    var axis = function(manifest, ctx) {
        axis.superclass.constructor.apply(this,arguments);
        this._multipleCategory_axisNumber = 2;
        this._multipleCategory_className = "v-multiCategory";
        this._multipleCategory_titleSelection = null;
    };

    //the start point
    oo.extend(axis,SimpleCategoryBottom);

    //overwritten fun
    axis.prototype.render = function(selection)
    {
        var originalSelection = selection;
        //count the width
        var rangeBand = axis.prototype.scale().rangeBand();
        var rangeArray = axis.prototype.scale().range();
        var axisItemWidth = rangeBand * rangeArray.length; 

        var axisClass = selection.select("*");
        axisClass.remove();
        selection = selection.append("svg");
        var helper = this._axis_baseCategoryHelperModule;
        var size = helper.size();
        selection.attr('width', size.width).attr('height', size.height);
        selection = selection.append("g").attr("class", this._multipleCategory_className);

        var i;
        for(i = 0; i < this._multipleCategory_axisNumber; i++)
        {
            var sItem = selection.append("g");
            sItem.attr("class", "v-subaxis" + (i + 1));
            sItem.attr('transform', 'translate(' + (i*axisItemWidth) + ',' + (0) + ')');

            axis.superclass.render.call(this, sItem, false);
        }

        axis.prototype.titleRender(originalSelection, this._axis_baseCategoryHelperModule);
        return this;
    };

    axis.prototype.getTitleSelection = function(originalSelection)
    {
        var titleClassName = "v-multipleCategoryBottomAxisTitle";
        var currentDOM = originalSelection.node();
        
        var parentDOM = currentDOM.parentNode;
        var titleSelection = d3.select(parentDOM).select("." + titleClassName);
        if(titleSelection.empty())
        {
            titleSelection = d3.select(parentDOM).append("div");
            titleSelection.attr("class", titleClassName);
        }
        return titleSelection;
    };

    axis.prototype.titleRender = function(originalSelection, helper)
    {
        //draw the title
        //make or use a title selection
        var titleSelection = axis.prototype.getTitleSelection(originalSelection);
        titleSelection.select("*").remove();
        var currentDOM = originalSelection.node();

        var titleWidth = 100;//fastMeasure (m_titleTextArray[iScale], m_style.realStyle.title).width;

        //set div style
        var m_baseOffset = 90;
        var titleStyle = titleSelection.node().style;
        titleStyle.width = titleWidth + "px";//currentDOM.style.width;
        titleStyle.position = currentDOM.style.position;
        titleStyle.overflow = "hidden";
        titleStyle.height = m_baseOffset + "px";

        var startLeft = currentDOM.style.left;
        var startTop = currentDOM.style.top;
        startLeft = parseFloat(startLeft.substring(0,startLeft.length-2));
        startTop = parseFloat(startTop.substring(0,startTop.length-2));

        titleStyle.left = (startLeft) + "px";
        titleStyle.top = (startTop) + "px";

        titleSelection = titleSelection.append("svg");
        var svgStyle = titleSelection.node().style;
        svgStyle.height = helper.size().height + "px";

        //draw title
        var m_textOffset = 32;
        var levelHeight = 45;

        var m_style = axis.superclass.style.call(this);

        var title = axis.prototype.title();
        var i;
        for(i = 0; i < title.length; i++)
        {
            titleSelection
            .append("g")
            .attr("fill", m_style.defaultStyle.title.fill)
            .attr("font-size", m_style.defaultStyle.label['font-size'])
            .attr("font-weight", "bold")
            .attr("font-family", m_style.defaultStyle.label['font-family'])                        
            .append("text")
            .attr("pointer-events","none")
            .attr("x", 20)
            .attr("y", m_textOffset + levelHeight * (title.length - 1 - i))
            .attr("dominant-baseline", "middle")//"auto")//"hanging")//"central")
            .attr("text-anchor", "start") // text-align
            .text(title[i]);
        }
    };

    axis.prototype.axisnumber = function(_)
    {
        if(!arguments.length)
        {
            return this._multipleCategory_axisNumber;
        }

        this._multipleCategory_axisNumber = _;
        return this;
    };

    axis.prototype.height = function(_)
    {
        if(_)//set
        {
            axis.superclass.height.call(this, _/this._multipleCategory_axisNumber);
            return this;
        }
        else//get
        {
            var oneItemHeight = axis.superclass.height.apply(this, arguments);
            return oneItemHeight * this._multipleCategory_axisNumber;
        }
    };

    axis.prototype.startPadding = function()
    {
        return 0;
    };

    axis.prototype.endPadding = function()
    {
        return 0;
    };

    axis.prototype.size = function(_)
    {
        if(_)//set
        {
            _.height = _.height/this._multipleCategory_axisNumber;
            axis.superclass.height.call(this, _);
            return this;
        }
        else//get
        {
            var allSize = axis.superclass.height.apply(this, arguments);
            allSize.height *= this._multipleCategory_axisNumber;
            return allSize;
        }
    };

    return axis;
});

define('sap/viz/modules/manifests/axis/MultipleCategoryBottom',['sap/viz/modules/manifests/Module','sap/viz/modules/Constants',
'sap/viz/modules/axis/MultipleCategoryBottom'],
function Setup(Manifest, Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.axis.MultipleCategoryBottom',
    'type' : Constants.Type.Supplementary,
    'name' : 'MultipleCategoryBottom',
    'base' : "sap.viz.modules.axis",
    'properties' : {
    },
    'css' : {
      '.v-title' : {
        'description' : 'Define style for the title.',
        'value' : {
          'fill' : '#333333',
          'font-family' : "Helvetica Neue, Helvetica, Arial, sans-serif",
          'font-size' : '12px',
          'font-weight' : 'bold'
        }
      },
      '.v-label' : {
        'description' : 'Define style for the label.',
        'value' : {
          'fill' : '#333333',
          'font-family' : "Helvetica Neue, Helvetica, Arial, sans-serif",
          'font-size' : '12px',
          'font-weight' : 'normal'
        }
      }    
    },
    'configure' : null,
    fn : fn
  };
  Manifest.register(module);
});

define('sap/viz/manifests/trellis/TrellisColumnChart',['sap/viz/manifests/Viz', 'sap/viz/manifests/trellis/BaseTrellisChart',
'sap/viz/modules/manifests/controller/Interaction',
'sap/viz/modules/manifests/Tooltip',
'sap/viz/modules/manifests/DataLabel',
'sap/viz/modules/manifests/DivContainer', 'sap/viz/modules/manifests/TrellisContainer', 
'sap/viz/modules/manifests/XYContainer', 'sap/viz/modules/manifests/Axis', 
'sap/viz/modules/manifests/axis/MultipleValueLeft', 'sap/viz/modules/manifests/axis/MultipleCategoryBottom',
'sap/viz/modules/manifests/xy/VerticalBar'], 
function Setup(Manifest) {
  var trellisChart = {
    id : 'viz/trellis_column',
    name : 'IDS_BASETRELLISCOLUMNCHART',
    base : 'viz/base/trellis',
    modules : {
      root : {
        modules : {
          legends : {
            modules : {
              legend : {
                data : { aa : [ 3 ] }
              }
            }
          },          
          main : {
            modules : {
              xAxis : {
                id : 'sap.viz.modules.axis.MultipleCategoryBottom',
                data : {
                  aa : [1]
                },
                configure : {
                  'description' : 'Settings for the category axis of an XY chart.',
                  properties : {
                    type : 'category',
                    position : 'bottom',
                    gridline : {
                      visible : false
                    }
                  },
                  propertiesOverride : {
                    gridline : {
                      isExported : false
                    },
                    label : {
                      isExported : false
                    },
                    axisline : {
                      isExported : false
                    },
                    scale : {
                      fixedRange : {
                        isExported : false
                      },
                      minValue : {
                        isExported : false
                      },
                      maxValue : {
                        isExported : false
                      },
                      isExported : false
                    }
                  }
                }
              },

              yAxis : {
                id : 'sap.viz.modules.axis.MultipleValueLeft',
                data : null,
                configure : {
                  'description' : 'Settings for the value axis of an XY chart.',
                  properties : {
                    type : 'value',
                    position : 'left',
                    gridline : {
                      visible : true
                    }
                  },
                  propertiesOverride : {
                    gridline : {
                      isExported : true
                    },
                    label : {
                      isExported : true
                    },
                    axisline : {
                      isExported : true
                    },
                    scale : {
                      fixedRange : {
                        isExported : true
                      },
                      minValue : {
                        isExported : true
                      },
                      maxValue : {
                        isExported : true
                      },
                      isExported : true
                    }
                  }
                }
              },              
              plot : {
                modules : {
                    tooltip : {
                        id : 'sap.viz.modules.tooltip',
                        configure : {
                          propertyCategory : 'tooltip',
                          properties : { chartType : 'verticalbar', orientation : 'left' }
                        }
                      },
                      interaction : {
                        id : 'sap.viz.modules.controller.interaction',
                        configure : {
                          clientID : 'plota',
                          propertyCategory : 'interaction',
                          properties : {
                            supportedEventNames: ['mouseup', 'mousedown', 'mousemove', 'mouseover', 'mouseout', 'touchstart'],
                            holdSelection : true
                          }
                        }
                    },                    
                  background : {
                    id : 'sap.viz.modules.background',
                    configure : {
                      propertyCategory : 'background',
                      properties : {
                        direction : 'vertical'
                      }
                    }
                  },
                  dataLabel : {
                      id : 'sap.viz.modules.datalabel',
                      configure : {
                        propertyCategory : 'dataLabel',
                        properties : {
                          orientation : 'vertical',                         
                          outsidePosition : 'up'
                        }
                      }
                    },
                  plot : {
                    id : 'sap.viz.modules.verticalbar',
                    configure : {
                      'description' : 'Settings regarding the chart area and plot area as well as general chart options.',
                      propertyCategory : 'plotArea'
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    feeds : {
      multiplier : {
        max : 1
      },
      secondaryValues : null,
      axisLabels : {
        max : 1
      }
    },
    dependencies : {
      attributes : [{
        targetModule : 'root.main.trellisXAxis',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'xCategoryScale'
      }, {
        targetModule : 'root.main.trellisYAxis',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'yCategoryScale'
      },{
         targetModule : 'root.legends.legend',
         target : 'colorPalette',
         sourceModule : 'root.main.plot.plot',
         source : 'colorPalette'
      },{
        targetModule : 'root.main',
        target : 'primaryDataRange',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryDataRange'
      },{
        targetModule : 'root.main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'root.main',
        source : 'primaryDataRange'
      },{
        targetModule : 'root.main.yAxis',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryScale'
      },{
        targetModule : 'root.main.plot.plot',
        target : 'setAxisGap',
        sourceModule : 'root.main.yAxis',
        source : 'getAxisGap'
      },{
        targetModule : 'root.main.xAxis',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'categoryScale'
      }
      ],
      events : [{
          targetModule : 'root.main.plot.tooltip',
          listener : 'showTooltip',
          sourceModule : 'root.main.plot',
          type : 'showTooltip'
        }, {
          targetModule : 'root.main.plot.tooltip',
          listener : 'hideTooltip',
          sourceModule : 'root.main.plot',
          type : 'hideTooltip'
        }, 
        {
            targetModule : 'root.main.plot.interaction',
            listener : 'registerEvent',
            sourceModule : 'root.main.plot',
            type : 'initialized.interaction'
         },{
             targetModule : 'root.main.plot.interaction',
             listener : 'highlightedByLegend',
             sourceModule : 'root.legends.legend',
             type : 'highlightedByLegend'
         }, {
             targetModule : 'root.legends.legend',
             listener : 'deselectLegend',
             sourceModule : 'root.main.plot.interaction',
             type : 'deselectLegend'
         }, {
            targetModule : 'root.main.plot.interaction',
            listener : 'defaultSelection',
            sourceModule : 'root.main.plot',
            type : 'initialized.defaultSelection'
         }        
         ]
    }
  };

  Manifest.register(trellisChart);
});

define('sap/viz/load',[
'sap/viz/manifests/RadarChart',
'sap/viz/manifests/TagCloudChart',
'sap/viz/manifests/NetworkChart',
'sap/viz/manifests/HeatMapChart',
'sap/viz/manifests/TreeMapChart',
'sap/viz/manifests/TreeChart',
'sap/viz/manifests/scatter/BubbleChart',
'sap/viz/manifests/scatter/ScatterChart',
'sap/viz/manifests/MultiScatterChart',
'sap/viz/manifests/MultiBubbleChart',
'sap/viz/manifests/ScatterMatrixChart',
'sap/viz/manifests/MultiLineChart',
'sap/viz/manifests/MultiHorizontalLineChart',
'sap/viz/manifests/MultiDualLineChart',
'sap/viz/manifests/MultiDualHorizontalLineChart',
'sap/viz/manifests/pie/DonutChart',
'sap/viz/manifests/pie/DonutWithDepthChart',
'sap/viz/manifests/pie/PieChart',
'sap/viz/manifests/pie/PieWithDepthChart',
'sap/viz/manifests/MultiPieChart',
'sap/viz/manifests/MultiPieWithDepthChart',
'sap/viz/manifests/MultiDonutChart',
'sap/viz/manifests/MultiDonutWithDepthChart',
'sap/viz/manifests/xy/PercentageStackedVerticalBarChart',
'sap/viz/manifests/xy/PercentageStackedBarChart',
'sap/viz/manifests/xy/StackedVerticalBarChart',
'sap/viz/manifests/xy/StackedBarChart',
'sap/viz/manifests/xy/DualStackedBarChart',
'sap/viz/manifests/xy/DualStackedVerticalBarChart',
'sap/viz/manifests/xy/DualPercentageStackedBarChart',
'sap/viz/manifests/xy/DualPercentageStackedVerticalBarChart',
'sap/viz/manifests/xy/DualVerticalBarChart',
'sap/viz/manifests/xy/DualBarChart',
'sap/viz/manifests/xy/VerticalBarChart',
'sap/viz/manifests/xy/BarChart',
'sap/viz/manifests/xy/ImageBarChart',
'sap/viz/manifests/xy/BaseVerticalChart',
'sap/viz/manifests/xy/BaseHorizontalChart',
'sap/viz/manifests/xy/HorizontalWaterfallChart',
'sap/viz/manifests/xy/WaterfallChart',
'sap/viz/manifests/xy/StackedWaterfallChart',
'sap/viz/manifests/xy/HorizontalStackedWaterfallChart',
'sap/viz/manifests/xy/DualHorizontalLineChart',
'sap/viz/manifests/xy/HorizontalLineChart',
'sap/viz/manifests/xy/DualLineChart',
'sap/viz/manifests/xy/LineChart',
'sap/viz/manifests/xy/CombinationChart',
'sap/viz/manifests/xy/DualCombinationChart',
'sap/viz/manifests/xy/HorizontalCombinationChart',
'sap/viz/manifests/xy/DualHorizontalCombinationChart',
'sap/viz/manifests/xy/VerticalBoxplotChart',
'sap/viz/manifests/xy/HorizontalBoxplotChart',
'sap/viz/manifests/xy/MekkoChart',
'sap/viz/manifests/xy/PercentageMekkoChart',
'sap/viz/manifests/xy/HorizontalMekkoChart',
'sap/viz/manifests/xy/PercentageHorizontalMekkoChart',
'sap/viz/manifests/xy/AreaChart',
'sap/viz/manifests/xy/PercentageAreaChart',
'sap/viz/manifests/xy/HorizontalAreaChart',
'sap/viz/manifests/xy/PercentageHorizontalAreaChart',
'sap/viz/manifests/xyz/Column3DChart',
'sap/viz/manifests/xyz/Bar3DChart',
'sap/viz/manifests/MultiRadarChart',
'sap/viz/manifests/MultiVerticalBarChart',
'sap/viz/manifests/MultiBarChart',
'sap/viz/manifests/MultiDualVerticalBarChart',
'sap/viz/manifests/MultiDualBarChart',
'sap/viz/manifests/MultiStackedBarChart',
'sap/viz/manifests/MultiStackedVerticalBarChart',
'sap/viz/manifests/MultiDualStackedBarChart',
'sap/viz/manifests/MultiDualStackedVerticalBarChart',
'sap/viz/manifests/MultiPercentageStackedBarChart',
'sap/viz/manifests/MultiPercentageStackedVerticalBarChart',
'sap/viz/manifests/MultiDualPercentageStackedBarChart',
'sap/viz/manifests/MultiDualPercentageStackedVerticalBarChart',
'sap/viz/manifests/MultiAreaChart',
'sap/viz/manifests/MultiPercentageAreaChart',
'sap/viz/manifests/MultiHorizontalAreaChart',
'sap/viz/manifests/MultiPercentageHorizontalAreaChart',
'sap/viz/manifests/trellis/TrellisColumnChart'],function Setup() {return;});
define('sap/viz/data/handler/BaseDataHandler',['sap/viz/base/utils/FunctionUtils','sap/viz/base/utils/TypeUtils','sap/viz/lang/langManager'],
 function Setup(FunctionUtils, TypeUtils, langManager){
 
   
   /**
    * determine which feed should be appended with MeasureNamesDimension 
    * @param feeds feeds Array
    * @returns feedId  to auto feed mnd
    */
   function determineMNDFeed(feeds){
     
     var dimensionFeed = [];
     var allFeeded = true;
     //first to see if MND is manually feeded
     var i = 0;
     for(; i < feeds.length; i++){
       var feed = feeds[i];
       if(feed.type() === "Dimension" && feed.acceptMND() >= 0){
         if(feed.hasMNDFeeded()){
            return feed.feedId();
         }else if(feed.getDataCount() < feed.max()){
           dimensionFeed[feed.acceptMND()] = feed;
           if(allFeeded){
              allFeeded = feed.hasFeeded();
           }
         }
           
       } 
     }
     
     if(dimensionFeed.length === 0){
        return "";
     }
     
     //Second, see which feed should be auto feeded MND
     //case 1: all feeds has been feeded, decide by mndPriority
     
     if(allFeeded){
        return dimensionFeed[dimensionFeed.length - 1].feedId();
     }
      
     //case 2: not all feeds has been feeded, feed MND to non-feeded feed with highest priority
     for(i = dimensionFeed.length - 1; i >= 0; i--){
       if(dimensionFeed[i] && !dimensionFeed[i].hasFeeded()){
          return dimensionFeed[i].feedId();
       }
     }
     
     return "";
   }
   
   /**
    * return a validate value according to val passed by user
    * 1 if val is string, just return
    * 2 if val is number, convert to string , return
    * 3 if val is other type, return null
    * 
    */
   function validateStringValue(val){
     if(TypeUtils.isString(val)){
        return val;
     }else if(TypeUtils.isNumber(val)){
        return val.toString();
     }else{
        return null;
     }
   }
   
   /**
    * return a validate value according to val passed by user
    * 1 if val is number, just return
    * 2 if val is string, convert to number , return
    * 3 if val is other type, return null
    * 
    */
   function validateNumberValue(val){
     if(TypeUtils.isNumber(val)){
        return parseFloat(val);
     }else{
        return null;
     }
   }
   
   function initDataPointUpperLimit(rawData, upperLimit){
       var limit = [ Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY];
       
       var rawDataCount = rawData.getDataPointCount();
       if(upperLimit === Number.POSITIVE_INFINITY || !TypeUtils.isNumber(upperLimit) || upperLimit >= rawDataCount){
          return limit;
       }
       
       //get total measure values count
       var mvCount = 0;
       var mvgCount = rawData.getMeasureValuesGroupCount();
       for(var i = 0; i < mvgCount; i++){
         mvCount += rawData.getMeasureValuesGroupByIdx(i).getMeasureValues().length;
       }
       
       //limit of one measure value
       var mvLimit = Math.floor(upperLimit / mvCount);
       
       var aaCount = rawData.getAnalysisAxisCount();
       if(aaCount === 0 || aaCount === 1){
          limit[0] = mvLimit; 
       }else if(aaCount === 2){
         var mv = rawData.getMeasureValuesGroupByIdx(0).getMeasureValues()[0];
         //var aa2Point = mv.getValues().length;
         var aa1Point = mv.getValues()[0].length;
         if(mvLimit/aa1Point < 1){
           limit[0] = mvLimit;
           limit[1] = 1;
         }else{
           limit[1] = Math.floor(mvLimit/aa1Point);
         }
       }
       
       return limit;
   }
   
   function BaseDataHandler(feeder, rawData, upperLimit){
          this._feeder  = feeder;
          this._feeds   = feeder.getFeeds();
          this._mndFeed = determineMNDFeed(this._feeds);
          this._limit = initDataPointUpperLimit(rawData, upperLimit);
   }
   
   
   BaseDataHandler.prototype.getFeedValues = function(feedId){
      var feed = this._feeder.findFeed(feedId);
      if(!feed){
         FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_NOT_FIND_FEED_DEFINITION', feedId)  );
      }
      
      if(feed.type() === "Dimension"){
         return this.getDimensionFeedValues(feed);
      }else if(feed.type() === "Measure"){
         return this.getMeasureFeedValues(feed);
      }
     
   };
   
   
   BaseDataHandler.prototype.getDimensionFeedValues = function(feed){
     
      var feedValues = [];
      var hasManualMND = false;
      
      var datas = feed.data();
      
      var obj;
      
      var mndDefaultString = langManager.get('IDS_DEFAULTMND');
      if(datas.length > 0){
        
        for(var i = 0; i < datas.length; i++ ){
          var data = datas[i];
       
          if(data){
            if(data.getType() === "measureNamesDimension"){ 
                obj = {};
                
                //col
                obj['col'] = {'val': mndDefaultString};
                obj['type'] = 'MND';
                
                obj['rows'] = this.getMeasureNamesValues(); 
                feedValues.push(obj);
                hasManualMND = true;
                
            }else if(data.getType() === "analysisAxis"){
              
              var dimensionLabels = data.getDimensionLabels();
              var aaIndex = this._feeder.getAnalysisAxisIndex(feed);
              
              for(var j = 0 ; j < dimensionLabels.length; j++){
                  obj = {};
                  
                  //col
                  obj['col'] = {'val': validateStringValue(dimensionLabels[j].getId())};
                  //rows
                  var rows = [];
                  var values =  dimensionLabels[j].getValues();
                  var infos =  dimensionLabels[j].infos();
                  var limit = values.length;
                  if(this._limit[aaIndex] !== Number.POSITIVE_INFINITY){
                     limit = this._limit[aaIndex];
                  }
                  
                  for(var k = 0; k < limit; k++){
                        var value = { 'val':validateStringValue(values[k]), 
                                      'ctx': {
                                                          'type' : 'Dimension',
                                                          'path': {
                                                                     'aa': aaIndex,
                                                                     'di':  j,
                                                                     'dii': k  }
                                                         }
                                                };
                        
                        if(TypeUtils.isExist(infos)){
                           value.info = infos[k];
                        }
                        
                    rows.push(value);
     
                  }
                  
                  obj['rows'] = rows;
                    
                  feedValues.push(obj);
               }                
            }else{
              FunctionUtils.error(langManager.getLogMessage('IDS_ERROR_WRONG_TYPE'));
            } 
          }
          
        }
      }
     
      if(feed.feedId() === this._mndFeed && hasManualMND === false){
          //col
          obj = {};
          obj['col'] = {'val': mndDefaultString};
          obj['type'] = 'MND';
          
          obj['rows'] = this.getMeasureNamesValues();
          
          feedValues.unshift(obj);
      }
      
      return feedValues.length > 0 ? feedValues : null;
   };
   
     BaseDataHandler.prototype.getMeasureFeedValues = function(feed){
       var feedValues = [];
       var measureValues = feed.getMeasureValues();

         var mgIndex = this._feeder.getMeasureValuesGroupIndex(feed);
         for(var i = 0; i < measureValues.length; i++){
                 var obj = {};
                 
                 //col
                 obj['col'] =  validateStringValue(measureValues[i].getId());
                 
                 //rows
                 var rows = [];
                 var values =  measureValues[i].getValues(); //values is an aa2 * aa1 array;
                 var infos = measureValues[i].infos();
                 //aa2
                 var aa2Limit = values.length;
                 if(this._limit[1] !== Number.POSITIVE_INFINITY){
                    aa2Limit = this._limit[1];
                 }
                 
                 for(var j = 0; j < aa2Limit; j++){
                   var value = values[j];
                   var row = [], rowValue = {};
                   //aa1
                   var aa1Limit = value.length;
                   if(this._limit[0] !== Number.POSITIVE_INFINITY){
                      aa1Limit = this._limit[0];
                   }
                   
                   for(var k = 0; k < aa1Limit; k++){
                     rowValue = {
                        'val' : validateNumberValue(value[k]),
                        'ctx' : {
                          'type' : 'Measure',
                          'path' : {
                            'mg' : mgIndex,
                            'mi' : i,
                            'dii_a1' : k,
                            'dii_a2' : j
                          }
                        }
                      };
                     if(TypeUtils.isExist(infos)){
                       rowValue.info = infos[j][k];
                   }
                     row.push(rowValue);
                   }
                   
                   rows.push(row);
                 }
                 
                 obj['rows'] = rows;
                 
                 feedValues.push(obj);
         }
         
          return feedValues.length > 0 ? feedValues : null;
   };
   
   
     BaseDataHandler.prototype.getMeasureNamesValues = function(){
       var values = [];
     var mgFeeds = this._feeder.getMeasureValuesGroupFeeds();
     for(var i = 0; i < mgFeeds.length; i++){
       if(mgFeeds[i].hasFeeded()){   
           var mvs = mgFeeds[i].getMeasureValues();
           for(var j = 0; j < mvs.length; j++){
             values.push({'val':validateStringValue(mvs[j].getId()),'ctx': { 'path' : {'mg': i, 'mi': j}}});
           }   
         }    
       }  
     
     return values;
   };
   
   return BaseDataHandler;
 });
define('sap/viz/chart/mvc/ChartApplication',['sap/viz/base/utils/Objects', 'sap/viz/mvc/VizApplication', 'sap/viz/TemplateManager', 'sap/viz/chart/mvc/ChartController', 'sap/viz/manifest', 'sap/viz/load', 
'sap/viz/data/feed/feeder','sap/viz/data/handler/BaseDataHandler',
'sap/viz/data/MultiAxesDataAdapter','sap/viz/config', 'sap/viz/base/utils/log/LogUtil','sap/viz/base/utils/FunctionUtils','sap/viz/lang/langManager'], 
function(Objects, VizApplication, TemplateManager, ChartController, manifest, load, Feeder, BaseDataHandler, MultiAxesDataAdapter, globalSettings, LOG,FunctionUtils,LangManager){
  /* Represents the application class. */
  var ChartApplication = VizApplication.extend({
    RootControllerClass : ChartController,
    appDidFinishLaunching : function ( options ) {
      // Format data set from data feeds.
      var launchOptions = options.launchOptions;
      
      LOG.profiling("Property:merge_with_template");
      var template = TemplateManager.current();
      var type = launchOptions.vizType;
      var mergeWithTemplate = Objects.extend(true, null, template.props(type), launchOptions.options);
      LOG.profiling("Property:merge_with_template"); 
      
      this._vc_vizType = launchOptions.vizType;
      this._vc_dataset = launchOptions.data.rawData;
      this._vc_feeding = launchOptions.feeding;
      this._vc_properties = mergeWithTemplate;
      this._vc_css = (template.css || "") + (launchOptions.css || "");

      var vc_config = globalSettings.get(this._vc_vizType) ?globalSettings.get(this._vc_vizType) : {} ;
      this.max_canvas = globalSettings.enableCanvg() && vc_config.max_canvas ? vc_config.max_canvas : Number.POSITIVE_INFINITY;
      LOG.profiling("Data:turn_to_adapter");
      var dataAdapter;
      if (globalSettings.get("isCrossTable")) {
        dataAdapter = this._vc_createAdapter(this._vc_vizType, this._vc_dataset, this._vc_feeding, this.max_canvas);
      } else if (globalSettings.get("isFlatTable")){
        //Currently FlatTableDataset will direct set to each modules along with feeding information.
        dataAdapter = {
          dataset: this._vc_dataset,
          feeding: this._vc_feeding
        };
      } else {
        dataAdapter = this._vc_dataset;
      }

      LOG.profiling("Data:turn_to_adapter");
      try{
      this.controller.initUIComponent({
         vizType : this._vc_vizType,
         dataset : dataAdapter,
         option : this._vc_properties,// Chart properties,
         css : this._vc_css,
         events : launchOptions.events
      });
      }catch(error){
            //We catch all the exceptions here and set it to a wrong data type error.
            //TODO: Handler the different kinds of exceptions.
            FunctionUtils.error(LangManager.getLogMessage('IDS_ERROR_WRONG_TYPE'));
      }
    },
    
    _vc_createAdapter : function(vizType, rawData, feeding, upperLimit) {
      var feeder = Feeder(manifest.viz.get(vizType).allFeeds(true), rawData, feeding);
      var dataHandler = new BaseDataHandler(feeder, rawData, upperLimit);
      var feeds = feeder.getFeeds();
      var dataAdapter = new MultiAxesDataAdapter(feeder.getBindingInfo());
      dataAdapter.fakeData(rawData.hasFakeData());
      dataAdapter.emptyDataset(rawData.isEmptyDataset());
      dataAdapter.dataPointCount(rawData.getDataPointCount());
      var id, dataItems;
      for ( var i = 0, len = feeds.length; i < len; i++ ) {
      id = feeds[i].feedId();
        dataItems = dataHandler.getFeedValues(id);
        if(dataItems !== null){
          if(feeds[i].type() === "Dimension"){
            dataAdapter.addAnalysisAxis({values:dataItems, index: feeds[i].getIndex() - 1});
          }else{
            dataAdapter.addMeasureValuesGroup({values:dataItems, index: feeds[i].getIndex() - 1});
          }
        }     
      }
      return dataAdapter;
    },
    
    css : function() {
        return this.controller.css.apply(this.controller, arguments);
    },
    
    size : function(size) {
        if (size !== undefined) {
            if(size.width && size.height && !size.auto) {
                this.vizFrame.size(size);
            }
            if (typeof size.auto === "boolean") {
                this.vizFrame.autoResize(size.auto);
            } 
            return this;
        } else {
            return this.vizFrame.size();
        }
    },
    
    getSelectedObjects : function(withDataCtx, withInfo) {
        return this.controller.getSelectedObjects(withDataCtx, withInfo);
    },
    
    setSelectedObjects : function(items, clearFlag) {
        return this.controller.setSelectedObjects(items, clearFlag);
    },
    
    getAllFeedingZone : function() {
        return this.controller.getAllFeedingZone();
    },
    
    update : function(updates) {
      if(updates){
        var needRender = false;
        //TODO Jimmy/9/19/2012 finish update property workflow
        //especially properties like 'numberOfDimensionsInColumn' which will
        //affect the structure, and ideally, we need merge all updates into one
        //function in each module, currently we still call them separately  
        if(updates.properties) {
          if(this.controller){
            this._vc_properties = updates.properties;
            this.controller.updateProperties(this._vc_properties);
            needRender = true;
          }
        }
        
        if(updates.css) {
            this.controller.css(updates.css);
            needRender = true;
        }
        
        if(updates.data || updates.feeding) {
          if(updates.data) {
              this._vc_dataset = updates.data;
          }
          if(updates.feeding) {
              this._vc_feeding = updates.feeding;
          }
          var newAdapter = this._vc_createAdapter(this._vc_vizType, this._vc_dataset, this._vc_feeding, this.max_canvas);
          this.controller.setDataset(newAdapter);
          needRender = true;
        }
        if(needRender)
        {
       this.controller.render();
        }
      }
    },  
    getSupportedEvents : function () {
        return this.controller.getSupportedEvents();
    },
    
    setDataset : function ( dataset ) {
      this._vc_dataset = dataset;
      var newAdapter = this._vc_createAdapter(this._vc_vizType, this._vc_dataset, this._vc_feeding);
      this.controller.setDataset(newAdapter);
    },
    
    getDataset : function (){
      return this._vc_dataset;
    },
    
    updateProperties : function (props) {
      if(this._controller){
        this._vc_properties = props;
        this.controller.updateProperties(this._vc_properties);
      }
    },
    
    getProperties : function() {
        return this.controller.getProperties();
    }
  });
  return ChartApplication;
});
define('sap/viz/core',['jquery', 'sap/viz/data/CrosstableDataset', 'sap/viz/base/utils/TypeUtils', 'sap/viz/util/Objects',
    'sap/viz/base/utils/log/LogUtil', 'sap/viz/chart/mvc/ChartApplication', 'sap/viz/manifest', 'sap/viz/config',
    'sap/viz/base/utils/FunctionUtils', 'sap/viz/lang/langManager'
  ],
  function Setup($, CrosstableDataset, TypeUtils, Objects, LOG, ChartApplication, manifest, config, FunctionUtils, langManager) {

    var riv =
    /**
     * @lends sap.viz.core
     * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead. You can use sap.viz.api.core.createViz instead.
     */
    {
      /**
       * @constructs
       */
      constructor: function() {

      },

      /**
       * @ignore
       */
      instances: [], // Stores references to chart applications for easy processing of global events.

      /**
       * The main entry point of creating a chart.
       * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead. You can use sap.viz.api.core.createViz instead.
       * @param {Object} usrOptions
       * <pre>
       * {
       *   type: 'viz/bar', //refer to  <a href="../chartproperty/chartproperty.html">chartproperty.html</a>  for all supported viz chart TypeUtils
       *   properties: {}, //refer to  <a href="../chartproperty/chartproperty.html">chartproperty.html</a>  for all supported options for each viz type
       *   css: String, //refer to  <a href="../chartproperty/chartproperty.html">chartproperty.html</a>  for all supported css items for each viz type
       *   container: HTMLDivElement, // HTMLDivElement is the container of viz chart in html
       *   data: {@link sap.viz.data.CrosstableDataset},
       *   feeding: {@link sap.viz.VizInstance#feeding},
       *   events: {}, //Events is an object with key and value pair. Key is the event name, and the value is an object containing function and scope. For example, {'initialized':{ fn: function(){return;}, scope: this}}.
       * }
       * </pre>
       * @returns {Object} vizApplication instance {@link sap.viz.VizInstance}
       *
       * @example <caption>Live Demo:</caption>
       *{@link http://shg-ci-web.dhcp.pgdev.sap.corp/snippet_platform_api/#006474|Try this}.
       */
      createViz: function(usrOptions) {
        var _eventsListeners = {},
          _feeding = usrOptions.feeding,
          _riv = this;
        // if user did not give data, we will add a null data to show chart
        if (!usrOptions.data) {
          usrOptions.data = new CrosstableDataset();
          // new a valid null data according to the chart's type
          var allfeeds = manifest.viz.get(usrOptions.type).allFeeds(true);
          var analysisAxis = [];
          var measureValuesGroup = [];
          var i = 0;
          var j = 0;
          if (allfeeds !== undefined && allfeeds !== null && allfeeds.length > 0) {
            for (; i < allfeeds.length; i++) {
              var type = allfeeds[i].type;
              if (type === "Dimension") {
                j = 0;
                for (; j < allfeeds[i].min; j++) {
                  analysisAxis.push({
                    'index': analysisAxis.length + 1,
                    'data': [{
                      'values': [''],
                      'infos': [{}]
                    }]
                  });
                }
              }
              if (type === "Measure") {
                j = 0;
                for (; j < allfeeds[i].min; j++) {
                  measureValuesGroup.push({
                    'index': measureValuesGroup.length + 1,
                    'data': [{
                      'values': [
                        ['']
                      ]
                    }]
                  });
                }
              }
            }
          } else {
            analysisAxis.push({
              'index': 1,
              'data': [{
                'values': [''],
                'infos': [{}]
              }]
            });
            measureValuesGroup.push({
              'index': 1,
              'data': [{
                'values': [
                  ['']
                ]
              }]
            });
          }
          usrOptions.data.setData({
            'analysisAxis': analysisAxis,
            'measureValuesGroup': measureValuesGroup
          });
        }
        if (usrOptions.options !== undefined && usrOptions.properties === undefined) {
          usrOptions.properties = usrOptions.options;
        }

        LOG.context(':creation:' + Objects.size(usrOptions.properties) + ':' + usrOptions.data.getDataPointCount() + ':' + Objects.size(usrOptions.css));

        var viz =
        /**
         * @lends sap.viz.VizInstance.prototype
         */
        {
          /**
           * it can only be created by {@link sap.viz.core}
           * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead. You can use sap.viz.api.core.VizInstance instead.
           * @constructs
           */
          constructor: function() {},

          /**
           * add event listener. one eventType can only have one listener, to register multiple listeners to a certain eventType you
           * have to add additional namespace after the eventType, such as 'selectData.foo' or 'selectData.bar'
           * @param {String} evtType refer to  <a href="../chartproperty/chartproperty.html">chartproperty.html</a>  for supported events for each kind of chart
           * @param {Function} callback listener function
           * @returns {Object} {@link sap.viz.VizInstance}
           */
          on: function(evtType, callback, scope) {
            _eventsListeners[evtType] = {
              callback: callback,
              scope: scope
            };
            this.app.controller.rootUIComponent.attachEvent(evtType, callback, scope);

            return this;
          },
          /**
           * Get/set chart size.
           * If set auto = true, the width and height are optional and would be ignored, the chart size will be adjusted
           * automatically according to container size.
           * @param {Object} size {width:xx, height:xx, [auto: Boolean]} | {auto: Boolean}
           * @returns {Object} {@link sap.viz.VizInstance}
           * @example <caption>Live Demo:</caption>
           * {@link http://shg-ci-web.dhcp.pgdev.sap.corp/snippet_platform_api/#000633|Try this}.
           */
          size: function(size) {
            if (!arguments.length) {
              return this.app.size();
            }
            this.app.size(size);

            return this;
          },

          /**
           * Get/Set selected data points.
           * To get selection, please use selection() or selection({Object}).
           * To set selection, please use selection([{Object}, {Object}, ...]),
           * or selection([{Object}, {Object}, ...], {Object})
           *
           *
           * @param {Array}  [selectionPoint] Array of Objects with either data or ctx should be set Points. Each point is
           * <pre style="font-size: 13px;font-family: Verdana;line-height:120%">
           * {
           *     data: {key: 'value', ...},//optional
           *     ctx:  [{mi: 0, ...}, {...}, ...], // optional. Higher priority than data.
           * }
           * </pre>
           * @param {Object} [options] seleciton options.
           * <pre style="font-size: 13px;font-family: Verdana;line-height:120%">
           *{
           *     clearSelection: Boolean,// optional . Default value is false. Useful only in setting selection.
           *     withDataCtx: Boolean, // optional. Default value is false. Useful only in getting selection.
           *}
           * </pre>
           * @returns {Array|Boolean}
           *                          Array of Points(for getting selection). Each point is
           * <pre style="font-size: 13px;font-family: Verdana;line-height:120%">
           *{
           *     data: {key: 'value', ...},
           *     ctx:  [{mi: 0, ...}, {...}, ...], // optional. Depends on "withDataCtx".
           *}
           * </pre>
           *or Boolean (for setting selection)
           * <pre style="font-size: 13px;font-family: Verdana;line-height:120%">
           *     True means setting selection sucessful.
           *     False means setting selection unsuccessful.
           * </pre>
           * @example <caption>Sample Code:</caption>
           * <pre style="font-size: 13px;font-family: Verdana;line-height:120%">
           * VizInstance.selection([{
           * 	  data:{'Country' : 'China','Year' : '2001','Product' : 'Motorcycle','Profit' : 129},
           * 	  ctx :{'dii_a1': 0,'dii_a2': 0,mg: 0,mi: 0}
           * }],{clearSelection: true});
           * <br/>
           * </pre>
           * @example <caption>Live Demo:</caption>
           * {@link http://shg-ci-web.dhcp.pgdev.sap.corp/snippet_platform_api/#008468|Try this}.
           */
          selection: function() {
            var items = null;
            var selOptions = null;

            var isGet = false;
            if (arguments.length <= 0) {
              isGet = true;
            } else if (arguments.length <= 1) {
              if (arguments[0] instanceof Array) {
                isGet = false;
                items = arguments[0];
              } else {
                isGet = true;
                selOptions = arguments[0];
              }
            } else {
              isGet = false;
              items = arguments[0];
              selOptions = arguments[1];
            }

            var clearSelection = false;
            var withDataCtx = false;
            var withInfo = false;
            if (selOptions) {
              clearSelection = selOptions.clearSelection;
              withDataCtx = selOptions.withDataCtx;
              withInfo = selOptions.withInfo;
            }

            var reValue;
            if (isGet) {
              reValue = this.app.getSelectedObjects(withDataCtx, withInfo);
            } else {
              reValue = this.app.setSelectedObjects(items, clearSelection);
            }
            return reValue;
          },

          /**
           * Get/set chart data.
           * @param {Object} data {@link sap.viz.data.CrosstableDataset}
           * @returns {Object} {@link sap.viz.VizInstance}
           */
          data: function(data) {
            if (!arguments.length) {
              return this.app.getDataset();
            }
            this.update({
              'data': data
            });

            // re-bind event listener as upon data update, sub plots may be recreated
            for (var evt in _eventsListeners) {
              if (_eventsListeners.hasOwnProperty(evt)) {
                this.on(evt, _eventsListeners[evt].callback, _eventsListeners[evt].scope);
              }
            }

            return this;
          },

          /**
           * Get/set chart properties.
           * @param {Object} props refer to  <a href="../chartproperty/chartproperty.html">chartproperty.html</a>
           * @returns {Object} {@link sap.viz.VizInstance}
           * @example <caption>Sample Code:</caption>
           * chartInstance.properties({title: { visible : true,text : 'Sample Bar Chart Title'}});
           */
          properties: function(props) {
            if (!arguments.length) {
              return this.app.getProperties();
            }

            LOG.context(':updateProperty:' + Objects.size(props));

            this.update({
              properties: props
            });
            return this;
          },

          /**
           * Append a new internal css.
           * @param {Object} cssText the css text
           * @returns {Object} {@link sap.viz.VizInstance}
           * @example <caption>Sample Code:</caption>
           * chartInstance.css('.v-m-title .v-title:{fill : #333333}');
           */
          css: function(css) {
            if (!arguments.length) {
              return this.app.css();
            }
            this.update({
              css: css
            });
            return this;
          },

          /**
           * Get/set data feeding info
           * @param {Array} feedingObj every element in the array is in the following structure:
           * <pre>
           * {
           *   'feedId':feedId  // feed id for example 'regionColor', refer to  <a href="../chartproperty/chartproperty.html">chartproperty.html</a>
           *   'binding': [{
           *     'type' : 'analysisAxis' | 'measureValuesGroup' | 'measureNamesDimension',
           *     'index':  Number
           *   }]
           * }
           * </pre>
           *@returns {Object} {@link sap.viz.VizInstance}
           */
          feeding: function(feedingObj) {
            if (!arguments.length) {
              return _feeding;
            }
            _feeding = feedingObj;
            this.update({
              feeding: feedingObj
            });
            return this;
          },

          /**
           * Get current feeding zone information
           * @returns {Array} feeding information group by visualization element
           * <pre>
           * [
           *     {
           *         'name': 'plot' | 'legend' | 'sizeLegend' | 'xAxis' | 'yAxis' | 'xAxis2' | 'yAxis2' | 'zAxis' | 'multiplier'
           *         'feedDef' : [{}],
           *         'bound' : [[[]]]
           *     }
           * ]
           * </pre>
           */
          feedingZone: function() {
            return this.app.getAllFeedingZone();
          },

          /**
           * Update various items in one go.
           * @param {Object} updates {data: {@link sap.viz.data.CrosstableDataset}, feeding: feedingObj, css: cssString, properties: propertiesObj }
           * @returns {Object} {@link sap.viz.VizInstance}
           */
          update: function(updates) {
            if (updates) {
              //we actually support use a null value to clear current feeding and switch to use
              //auto feed
              if (TypeUtils.isDefined(updates.feeding)) {
                _feeding = updates.feeding;
              }
              this.app.update(updates);
            }
            return this;
          },


          /**
           * Destroy this chart instance. This will remove all dom
           * nodes of chart and its listeners.
           */
          destroy: function() {
            _riv.instances.splice(_riv.instances.indexOf(this), 1);
            this.app.destroy();
            this.app = null;
          },

          /**
           * export chart instance into a JSON object which contains
           * all information of the chart including type, data, properties,
           * css, feeding and size
           */
          toJSON: function() {
            var doc = {};
            doc.type = usrOptions.type;
            doc.data = {
              type: "crosstable",
              val: this.app.getDataset().data()
            };
            doc.properties = this.properties();
            doc.css = this.css();
            doc.feeding = _feeding;
            doc.size = this.app.size();
            return doc;
          }
        };

        if (usrOptions.data instanceof CrosstableDataset){
          config.register({
            id: 'isCrossTable',
            value: true
          });
        } else {
          FunctionUtils.error(LangManager.getLogMessage('IDS_ERROR_WRONG_TYPE'));
        }

        viz.app = new ChartApplication({
          holder: usrOptions.container,
          launchOptions: {
            vizType: usrOptions.type,
            options: usrOptions.properties,
            css: usrOptions.css,
            data: {
              rawData: usrOptions.data
            },
            feeding: usrOptions.feeding || usrOptions.dataFeeding,
            /* dataFeeding for backward compatibility*/
            events: usrOptions.events
          }
        });

        Object.defineProperty(viz, "type", {
          value: usrOptions.type,
          enumerable: true
        });

        _riv.instances.push(viz);
        return viz;
      },

      /**
       * Destroy chart.
       * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead. You can use sap.viz.api.core.destroyViz instead.
       * @param {Object...} viz instances to be destroyed
       */
      destroyViz: function() {
        for (var i = -1, j = arguments.length; ++i < j;) {
          arguments[i].destroy();
        }
      },

      /**
       * export chart instance into a JSON object which contains
       * all information of the chart including type, data, properties,
       * css, feeding and size
       * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead. You can use sap.viz.api.core.exportViz instead.
       * @param {Object} chartInstance {@link sap.viz.VizInstance}
       */
      exportViz: function(chart) {
        return chart.toJSON();
      }
    };

    return riv;
  });
define('sap/viz/ccl',['sap/viz/core','sap/viz/data/CrosstableDataset'],
function Setup(Core, CrosstableDataset) {

	var ccl =
	/** @lends sap.viz.ccl */
	{
		/**
		 * @constructs
		 */
		constructor : function() {
			return;
		},

		/**
		 * load chart from JSON into a div
		 * @param {Object...} viz json document
		 * @param {Object...} div object to contain the visualization
		 * @deprecated This function is working in CVOM 4.0, but will not be supported since CVOM 5.0 in the future, please consider to use new version of this API instead. You can use sap.viz.api.core.loadViz instead.
		 */
		loadViz : function(doc, container) {
			var option = {};
			option.container = container;
			option.type = doc.type;
			option.options = doc.properties;
			option.data = new CrosstableDataset();
			option.data.setData(doc.data.val);
			option.css = doc.css;
			option.feeding = doc.feeding;

			return Core.createViz(option);
		}
	};

	return ccl;

});
define('sap/viz/api/data/CrosstableDataset',['sap/viz/data/CrosstableDataset', 'sap/viz/base/utils/ObjectUtils', 'sap/viz/base/utils/TypeUtils'],function Setup(CrosstableDataset, ObjectUtils, TypeUtils){

    /**
     * sap.viz.api.data.CrosstableDataset
     * @class sap.viz.api.data.CrosstableDataset
     */
    var crosstableD = function(){
        this._crosstableDataset = new CrosstableDataset();
    }
    /**
     * Get or Set the data in CrosstableDataset
     * @method sap.viz.api.data.CrosstableDataset.prototype.data
     * @param {Object|undefined} value
     *                      optional, pass the data object consist of "analysisAxis" and "measureValuesGroup",
     *                 {@link http://viz.dhcp.pgdev.sap.corp/viz/wiki/ProductGuides/Tutorials/XTabDataModel|Check the detail}.
     * 
     *<pre style = "font-size : 14px; line-height : 14px; font-family : Verdana;">
     * Example: 
     * {
     *      "analysisAxis" : [{
     *          "index" : 1,
     *          "data" : [{
     *              "type" : "Dimension",
     *              "name" : "Product",
     *              "values" : ["Car", "Truck", "Motorcycle", "Bicycle"]
     *          }]
     *      }, {
     *          "index" : 2,
     *          "data" : [{
     *              "type" : "Dimension",
     *              "name" : "Country",
     *              "values" : ["China", "USA"]
     *          }, {
     *              "type" : "Dimension",
     *              "name" : "Year",
     *              "values" : ["2001", "2001"]
     *          }]
     *      }],
     *      "measureValuesGroup" : [{
     *          "index" : 1,
     *          "data" : [{
     *              "type" : "Measure",
     *              "name" : "Profit",
     *              "values" : [[25, 136, 23, 116], [58, 128, 43, 73]]
     *          }, {
     *              "type" : "Measure",
     *              "name" : "Revenue",
     *              "values" : [[50, 236, 43, 126], [158, 228, 143, 183]]
     *          }]
     *      }]
     *  }
     * </pre>
     * {@link http://viz.dhcp.pgdev.sap.corp/viz/wiki/ProductGuides/Tutorials/XTabDataModel|Understanding CrossTableDataset}
     */
    crosstableD.prototype.data = function(value) {
        if (value !== undefined) {
            this._crosstableDataset.data(ObjectUtils.clone(value));
        } else {
            return ObjectUtils.clone(this._crosstableDataset.data());
        }
    }

    /**
     * Get/Set additional info for the crosstable dataset
     * By now, only "additionalData" info type is supported
     * @name sap.viz.api.data.CrosstableDataset#info
     * @method sap.viz.api.data.CrosstableDataset.prototype.info
     * @param {Array|String} [arguments]
     *                               Array of Objects is for setting info and passes different types of infos objects.
     * <pre>
     * Schema:
     * [{
     *     "type": "additionalData",
     *     "info": [{
     *        "name": "<dimension_name>",
     *        // Match dimension member's 1D Array structure
     *        "infoValues": []
     *     }, {
     *     "name": "<measure_name>",
     *        // Match measure value's 2D Array structure
     *        "infoValues": [[]]
     *     }]
     * }]
     * </pre>
     * <pre>
     * Example:
     * [{
     *    "type" : "additionalData",
     *    "info" : [{
     *        "name" : "Country",
     *        "infoValues" : [{
     *            "CountryID": "1"
     *        }, {
     *            "CountryID": "2"
     *        }]
     *    }, {
     *        "name" : "Profit",
     *        "infoValues" : [[{
     *            "ID" : "11"
     *        }, {
     *            "ID" : "12"
     *        }, {
     *            "ID" : "13"
     *        }, {
     *            "ID" : "14"
     *        }], [{
     *            "ID" : "21"
     *        }, {
     *            "ID" : "22"
     *        }, {
     *            "ID" : "23"
     *        }, {
     *            "ID" : "24"
     *        }]]
     *    }]
     * }]
     * </pre>
     *                               or String is for getting info and passes the name of a specific type of info.
     * <pre>
     * Example:
     * "additionalData"
     * </pre>
     * @returns {Array}
     *                 return a copy of info type passed in
     *                        or a copy all type of info set if no param provided
     * @example <caption>Live Demo:</caption> 
     * {@link http://shg-ci-web.dhcp.pgdev.sap.corp/snippet_platform_api/#9052|Try this}. 
     */
    crosstableD.prototype.info = function(value) {
        if (value !== undefined && !TypeUtils.isString(value)) {
            this._crosstableDataset.info(ObjectUtils.clone(value));
        } else if (TypeUtils.isString(value)) {
            return ObjectUtils.clone(this._crosstableDataset.info(value));
        } else {
            return ObjectUtils.clone(this._crosstableDataset.info());
        }
    }
    
    //Used for VizControls.
    crosstableD.prototype.hasFakeData = function() {
        return this._crosstableDataset.hasFakeData();
    }
    
    return crosstableD;
});

define('sap/viz/api/data/FlatTableDataset',['sap/viz/data/FlatTableDataset', 'sap/viz/base/utils/TypeUtils'], function Setup(FlatTableDataset, TypeUtil) {

	/**
	 * sap.viz.api.data.FlatTableDataset
	 * @ignore 
	 * @class sap.viz.api.data.FlatTableDataset
	 * @param {Object} data json object
	 *
	 * <pre>
	 * Example:
	 * 			{
	 * 				metadata:{
	 * 					fields:[{
	 *     					id: 'Year',
	 *     	    			semanticType: 'dim'
	 *     	    		},{
	 *     	    			id: 'Profit',
	 *     	    			semanticType: 'measure'
	 *     	    		}],
	 * 					summary:{}
	 * 				},
	 * 				data:[
	 * 					[2001,100000],
	 * 					[2002,200000]
	 * 				],
	 * 				info:[	//optional
	 *					{}
	 * 				]
	 * 			}
	 * </pre>
	 */
	var FlatTableD = function(data) {
		this._FlatTableD = new FlatTableDataset(data);
	};
	/**
	 * Set the data in FlatTableDataset
	 * @method sap.viz.api.data.FlatTableDataset.prototype.data
	 * @param {Object} value json object
	 *
	 * <pre>
	 * Example:
	 * 			{
	 * 				metadata:{
	 * 					fields:[{
	 *     					id: 'Year',
	 *     	    			semanticType: 'dim'
	 *     	    		},{
	 *     	    			id: 'Profit',
	 *     	    				semanticType: 'measure'
	 *     	    		}],
	 * 					summary:{}
	 * 				},
	 * 				data:[
	 * 					[2001,100000],
	 * 					[2002,200000]
	 * 				]
	 * 			}
	 * </pre>
	 */
	FlatTableD.prototype.data = function(value) {
		return this._FlatTableD.data(value);
	};
	
	/**
	 * Get the data of specified column
	 * @name sap.viz.api.data.FlatTableDataset#metadata
	 * @method sap.viz.api.data.FlatTableDataset.prototype.metadata
	 * @param {String} id   id of column
	 * @returns {Array}
	 */
	FlatTableD.prototype.metadata = function(id) {
		if(id != null) {
			return this._FlatTableD.getMetadata(id);
		}
	};
	
	/**
	 * Get the column id of measures
	 * @name sap.viz.api.data.FlatTableDataset#measures
	 * @method sap.viz.api.data.FlatTableDataset.prototype.measures
	 * @returns {Array}
	 */
	FlatTableD.prototype.measures = function() {
		return this._FlatTableD.getMeasures();
	};
	/**
	 * Get the column id of dimensions
	 * @name sap.viz.api.data.FlatTableDataset#dimensions
	 * @method sap.viz.api.data.FlatTableDataset.prototype.dimensions
	 * @returns {Array}
	 */
	FlatTableD.prototype.dimensions = function() {
		return this._FlatTableD.getDimensions();
	};

	/**
	 * Transform the data into an object table
	 * @name sap.viz.api.data.FlatTableDataset#table
	 * @method sap.viz.api.data.FlatTableDataset.prototype.table
	 * @returns {Array} the data in the object table format
	 */
	FlatTableD.prototype.table = function() {
		return this._FlatTableD.getTable();
	};
	
	/**
	 * Get/Set the specified row item of some specified type
	 * @name sap.viz.api.data.FlatTableDataset#row
	 * @method sap.viz.api.data.FlatTableDataset.prototype.row
	 * @param  {Number}  rowIndex the index of the row you want to get
	 * @param {Undefined|Array} param  to get the data in raw format or set the row
	 * Example: 
	 * FlatTableDataset.row(index) is the get method to get row.
	 * FlatTableDataset.row(index,[2001, 'Q2', 'CAN', 300, 200]) is the set method the set row.
	 * @returns {Array|Object|} return the raw value if this is a get function.
	 */
	FlatTableD.prototype.row = function(rowIndex, param) {
		if(TypeUtil.isNumber(rowIndex)) {
			if(TypeUtil.isPlainObject(param)||TypeUtil.isArray(param)){
				this._FlatTableD.setRow(rowIndex, param);
			}else{
				return this._FlatTableD.getRow(rowIndex);
			}
		}
	};

	/**
	 * Seleted the data of specified fields
	 * @name sap.viz.api.data.FlatTableDataset#dataInFields
	 * @method sap.viz.api.data.FlatTableDataset.prototype.dataInFields
	 * @param {Array} selectedColumns ['fieldId1','fieldId2']
	 * @return {Array} clone of the this._table or its subset
	 */
	FlatTableD.prototype.dataInFields = function(selectedFields) {
		return this._FlatTableD.dataInFields(selectedFields);
	};
	
	/**
	 * Get/set of the info of dataset
	 * By now, only 'additionalData' info type is supported.
	 * @name sap.viz.api.data.FlatTableDataset#info
	 * @method sap.viz.api.data.FlatTableDataset.prototype.info
	 * @param {Undefined|String|Array}infoData
	 * @return {Array}
	 * Example:
	 * 1. dataset.info(); return the info of 'additionalData' type.
	 * 2. dataset.info('additionalData'); return the info of the specified data. for current example the type is 'additionalData'.
	 * 3. dataset.info([{
	 * 				type:'additionalData'
	 * 				info:[[1,2,3,4]]
	 * 			}]);					set the new info with it's type and info data.
	 */
	//TODO:NOT finished code.
	FlatTableD.prototype.info = function (infoData) {
		return this._FlatTableD.info(infoData);
	};
	
	
	return FlatTableD;
});

define('sap/viz/extapi/core',[], function Setup() {
	
	/**
	 * sap.viz.extapi.core
	 * @Class sap.viz.extapi.core
	 */
	var coreExtAPi = {};
	/**
	 * @ignore
	 */
	coreExtAPi._actionMap = {};
	
	/**
	 * Register sap.viz.api.core.VizInstance's action, the action handler is registered for each VizInstance.
	 * @name sap.viz.extapi.core.registerVizAction
	 * @method sap.viz.extapi.core.registerVizAction
	 * @param {String} name
	 *                      One action name can has only one handler function.
	 * @param {String} handlerPath
	 *                      e.g. "root.main.getMap" will be delegated to MainModule instance's getMap(), and "this" scope is the MainModule instance
	 */
	coreExtAPi.registerVizAction = function(keyName, handlerPath) {
		coreExtAPi._actionMap[keyName] = handlerPath;

	}
	
	/**
	 * Unregister the function by the keyname
	 *@name sap.viz.extapi.core#unregisterVizAction
	 *@method sap.viz.extapi.core.unregisterVizAction
	 * @param {String} key The registered name of the action.
	 */
	coreExtAPi.unregisterVizAction = function(keyName) {
		if(coreExtAPi._actionMap[keyName]){
			coreExtAPi._actionMap[keyName] = undefined;
			delete coreExtAPi._actionMap[keyName];
		}

	}
	return coreExtAPi;
});

define('sap/viz/api/core/VizInstance',['jquery', 'sap/viz/base/utils/TypeUtils', 'sap/viz/util/Objects',
		'sap/viz/base/utils/log/LogUtil', 'sap/viz/chart/mvc/ChartApplication',
		'sap/viz/base/utils/FunctionUtils', 'sap/viz/api/data/CrosstableDataset',
		'sap/viz/api/data/FlatTableDataset', 'sap/viz/extapi/core', 
		'sap/viz/base/utils/ObjectUtils', 'sap/viz/config'
	],
	function Setup($, TypeUtils, Objects, LOG, ChartApplication, FunctionUtils, CrosstableDataset, FlatTableDataset, ExtCore, ObjectUtils, config) {
		var vizInstance = function(_eventsListeners, _feeding, _riv) {
			this.__className = "sap.viz.api.core.VizInstance";
			this.app = null;
			this._eventsListeners = _eventsListeners;
			this._feeding = _feeding;
			this._riv = _riv;
			this._description = null;
			this._data = new CrosstableDataset();
			this._usrOptions = {};
		}

		vizInstance.prototype =
		/**
		 * @lends sap.viz.api.core.VizInstance.prototype
		 */
		{
			/**
			 * VizInstance can only be created by {@link sap.viz.api.core.createViz}
			 * @constructs
			 */
			constructor: function() {},
			/**
			 * Add event listener. <br>
			 * An eventType can have only one listener; to register multiple listeners to a certain eventType, you
			 * have to add additional namespaces after the eventType, such as 'selectData.foo' or 'selectData.bar'.
			 * @param {String} evtType Refer to  <a href="../chartproperty/chartproperty.html">chartproperty.html</a> for supported events for each kind of chart
			 * @param {Function} callback listener function
			 * @returns {Object} {@link sap.viz.api.core.VizInstance}
			 */
			on: function(evtType, callback, scope) {
				this._eventsListeners[evtType] = {
					callback: callback,
					scope: scope
				};
				this.app.controller.rootUIComponent.attachEvent(evtType, callback, scope);

				return this;
			},
			/**
			 * Get/Set chart size. <br>
			 * If set auto = true, the width and height are optional and will be ignored. The chart size will be adjusted
			 * automatically according to container size.
			 * @param {Object} size  {"width" : Number, "height" : Number, ["auto" : Boolean]} | {"auto" : Boolean}
			 * @returns {Object} {@link sap.viz.api.core.VizInstance}
			 * @example <caption>Live Demo:</caption>
			 * {@link http://shg-ci-web.dhcp.pgdev.sap.corp/snippet_platform_api/#006474|Try this}.
			 */
			size: function(size) {
				if (!arguments.length) {
					return this.app.size();
				}
				this.app.size(size);

				return this;
			},
			/**
			 * Get/Set selected data points. <br>
			 * To get selection, please use selection() or selection(Options). <br>
			 * To set selection, please use selection(selectionPoint),
			 * or selection(selectionPoint, Options)
			 *
			 *
			 * @param {Array}  [selectionPoint] Array of Objects with either data or ctx should be set Points. Each point is
			 * <pre style="font-size: 13px;font-family: Verdana;line-height:120%">
			 * {
			 *     "data": {key: 'value', ...}, // optional
			 *     "ctx":  [{mi: 0, ...}, {...}, ...], // optional. Higher priority than data.
			 * }
			 * </pre>
			 * @param {Object} [options] selection options.
			 * <pre style="font-size: 13px;font-family: Verdana;line-height:120%">
			 *{
			 *     "clearSelection": Boolean, // optional. Default value is false. Useful only in setting selection.
			 *     "withDataCtx": Boolean, // optional. Default value is false. Useful only in getting selection.
			 *}
			 * </pre>
			 * @returns {Array|Boolean}
			 *                          Array of Points(for getting selection). Each point is
			 * <pre style="font-size: 13px;font-family: Verdana;line-height:120%">
			 *{
			 *     "data": {key: 'value', ...},
			 *     "ctx":  [{mi: 0, ...}, {...}, ...], // optional. Depends on "withDataCtx".
			 *}
			 * </pre>
			 *or Boolean (for setting selection)
			 * <pre style="font-size: 13px;font-family: Verdana;line-height:120%">
			 *     True means setting selection is sucessful.
			 *     False means setting selection is unsuccessful.
			 * </pre>
			 * @example <caption>Sample Code:</caption>
			 *
			 * Get sample:
			 *
			 * <pre style="font-size: 13px;font-family: Verdana;line-height:120%">
			 *
			 *  VizInstance.selection(); This will get the selected data points.
			 *  VizInstance.selection({withDataCtx: false}); This will get the selected data points without data context.
			 * </pre>
			 *
			 * Set sample:
			 *
			 * <pre style="font-size: 13px;font-family: Verdana;line-height:120%">
			 * VizInstance.selection([{
			 * 	  "data":{"Country" : "China","Year" : "2001","Product" : "Motorcycle","Profit" : 129},
			 * 	  "ctx" :{"dii_a1": 0,"dii_a2": 0,"mg": 0,"mi": 0}
			 * }],{"clearSelection": true});
			 * <br/>
			 *
			 * If you want to clear all selections, you need to set the input selection data to empty:
			 *
			 *     VizInstance.selection([],{"clearSelection": true})  or
			 *     VizInstance.selection({},{"clearSelection": true});
			 * </pre>
			 * @example <caption>Live Demo:</caption>
			 * {@link http://shg-ci-web.dhcp.pgdev.sap.corp/snippet_platform_api/#002126|Try this}.
			 */
			selection: function() {
				var items = null;
				var selOptions = null;

				var isGet = false;
				if (arguments.length <= 0) {
					isGet = true;
				} else if (arguments.length <= 1) {
					if (arguments[0] instanceof Array) {
						isGet = false;
						items = arguments[0];
					} else {
						isGet = true;
						selOptions = arguments[0];
					}
				} else {
					isGet = false;
					items = arguments[0];
					selOptions = arguments[1];
				}

				var clearSelection = false;
				var withDataCtx = false;
				var withInfo = false;
				if (selOptions) {
					clearSelection = selOptions.clearSelection;
					withDataCtx = selOptions.withDataCtx;
					withInfo = selOptions.withInfo;
				}

				var reValue;
				if (isGet) {
					reValue = this.app.getSelectedObjects(withDataCtx, withInfo);
				} else {
					reValue = this.app.setSelectedObjects(items, clearSelection);
				}
				return reValue;
			},
			/**
			 * Get/Set chart data.
			 * @param {Object} data {@link sap.viz.api.data.CrosstableDataset}
			 * @returns {Object} {@link sap.viz.api.core.VizInstance}
			 */
			data: function(data) {
				if (!arguments.length) {
					this._data.data(this.app.getDataset().data());
					return this._data;
				}
				this._data.data(data._crosstableDataset.data());
				this.update({
					'data': this._data
				});

				// re-bind event listener as upon data update, sub plots may be recreated
				for (var evt in this._eventsListeners) {
					if (this._eventsListeners.hasOwnProperty(evt)) {
						this.on(evt, this._eventsListeners[evt].callback, this._eventsListeners[evt].scope);
					}
				}

				return this;
			},
			/**
			 * Get/Set chart properties.
			 * @param {Object} props Refer to  <a href="../chartproperty/chartproperty.html">chartproperty.html</a>
			 * @returns {Object} {@link sap.viz.api.core.VizInstance}
			 * @example <caption>Sample Code:</caption>
			 * VizInstance.properties({title: { visible : true,text :'Sample Bar Chart Title'}});
			 */
			properties: function(props) {
				if (!arguments.length) {
					return ObjectUtils.clone(this.app.getProperties());
				}

				LOG.context(':updateProperty:' + Objects.size(props));

				this.update({
					properties: ObjectUtils.clone(props)
				});
				return this;
			},
			/**
			 * Append or get an internal css.
			 * @param {String|undefined} [cssText]  The css text
			 * @returns {Object|String} {@link sap.viz.api.core.VizInstance} | css string
			 * @example <caption>Sample Code:</caption>
			 * <pre>
			 * Set method: VizInstance.css('.v-m-title .v-title:{ fill : #333333}');
			 * Get method: VizInstance.css();
			 * </pre>
			 */
			css: function(css) {
				if (!arguments.length) {
					return ObjectUtils.clone(this.app.css());
				}
				this.update({
					css: ObjectUtils.clone(css)
				});
				return this;
			},
			/**
			 * Get/Set data feeding information.
			 * @param {Array} feedingObj Every element in the array is in the following structure:
			 * <pre>
			 * {
			 *   "feedId":feedId  // feed id for example "regionColor"; refer to  <a href="../chartproperty/chartproperty.html">chartproperty.html</a>
			 *   "binding": [{
			 *     "type" : "analysisAxis" | "measureValuesGroup" | "measureNamesDimension",
			 *     "index":  Number
			 *   }]
			 * }
			 * </pre>
			 *@returns {Object} {@link sap.viz.api.core.VizInstance}
			 */
			feeding: function(feedingObj) {
				if (!arguments.length) {
					return ObjectUtils.clone(this._feeding);
				}
				this._feeding = ObjectUtils.clone(feedingObj);
				this.update({
					feeding: this._feeding
				});
				return this;
			},
			/**
			 * Get current feeding zone information.
			 * @returns {Array} feeding information group by visualization element
			 * <pre style="font-size: 13px;font-family: Verdana;line-height:120%">
			 * [
			 *     {
			 *         "name": "plot" | "legend" | "sizeLegend" | "xAxis" | "yAxis" | "xAxis2" | "yAxis2" | "zAxis" | "multiplier"|"mainPlot"|"valueaxis"
			 *         "feedDef" : [{}],
			 *         "bound" : [[[]]]
			 *     }
			 * ]
			 * </pre>
			 */
			feedingZone: function() {
				return this.app.getAllFeedingZone();
			},
			/**
			 * Update various items in one go.
			 * @param {Object} updates {data: {@link sap.viz.api.data.CrosstableDataset}, "feeding": feedingObj, "css": cssString, "properties": propertiesObj }
			 * @returns {Object} {@link sap.viz.api.core.VizInstance}
			 */
			update: function(updates) {
				if (updates) {
					//we actually support use a null value to clear current feeding and switch to use
					//auto feed
					var updateValue = JSON.parse(JSON.stringify(updates));
					if (TypeUtils.isDefined(updates.feeding)) {
						this._feeding = updates.feeding;
					}
					if (TypeUtils.isDefined(updates.data)) {
						this._data.data(updates.data._crosstableDataset.data());
						updateValue.data = this._data._crosstableDataset;
					}
					this.app.update(updateValue);
				}
				return this;
			},
			/**
			 * Destroy this chart instance. This will remove all dom
			 * nodes of the chart and the chart's listeners.
			 */
			destroy: function() {
				this._riv.instances.splice(this._riv.instances.indexOf(this), 1);
				this.app.destroy();
			},
			/**
			 * Export chart instance into a JSON object which contains
			 * all information of the chart including type, data, properties,
			 * css, feeding, and size.
			 * @returns {Object}  VizDoc object that contains all the information of VizInstance.
			 * <pre style="font-size: 13px;font-family: Verdana;line-height:120%">
			 * {
			 *   "type": String, //refer to  <a href="../chartproperty/chartproperty.html">chartproperty.html</a>  for all supported viz chart TypeUtils
			 *   "properties": {}, //refer to  <a href="../chartproperty/chartproperty.html">chartproperty.html</a>  for all supported options for each viz type
			 *   "css": String, //refer to  <a href="../chartproperty/chartproperty.html">chartproperty.html</a>  for all supported css items for each viz type
			 *   "size": {
			 * 		"auto": Boolean,//Size is auto fit or not.
			 * 		"width": Number,
			 * 		"height": Number
			 *      },
			 *   "data": {
			 * 		"type":"Crosstable"|"FlatTable",
			 * 		"val":dataset
			 * 		},
			 *   "feeding": {@link sap.viz.api.core.VizInstance#feeding},
			 *   "events": {}, //Events is an object with key and value pair. Key is the event name, and the value is an object containing function and scope. For example, {'initialized':{ fn: function(){return;}, scope: this}}.
			 * }
			 * </pre>
			 */
			toJSON: function() {
				var doc = {};
				doc.type = this._usrOptions.type;
				doc.data = {
					type: "Crosstable",
					val: ObjectUtils.clone(this.app.getDataset().data())
				};
				doc.properties = this.properties();
				doc.css = this.css();
				doc.feeding = this.feeding();
				doc.size = this.app.size();
				return doc;
			}
		};

		/**
		 * Remove event listener.
		 * @method sap.viz.api.core.VizInstance.prototype.off
		 * @param {String} eventType EventType name
		 *
		 * @return {sap.viz.api.core.VizInstance} self
		 */
		vizInstance.prototype.off = function(eventType) {
			if (eventType != null) {
				if (this._eventsListeners[eventType] !== undefined) {
					this._eventsListeners[eventType] = undefined;
					this.app.controller.rootUIComponent.attachEvent(eventType, FunctionUtils.noop);

				}
			}

			return this;
		};

		vizInstance.prototype.setApp = function(usrOptions) {
			this._usrOptions = usrOptions;
			var isFlatTable = usrOptions.data instanceof FlatTableDataset;
			config.register({
				id: 'isFlatTable',
				value: isFlatTable
			});
			var isCrossTable = usrOptions.data instanceof CrosstableDataset;
			config.register({
				id: 'isCrossTable',
				value: isCrossTable
			});
			this.app = new ChartApplication({
				holder: usrOptions.container,
				launchOptions: {
					vizType: usrOptions.type,
					options: usrOptions.properties,
					css: usrOptions.css,
					data: {
						rawData: !isCrossTable ? usrOptions.data : usrOptions.data._crosstableDataset
					},
					feeding: usrOptions.feeding || usrOptions.dataFeeding,
					/* dataFeeding for backward compatibility*/
					events: usrOptions.events
				}
			});
		}
		/**
		 * Trigger viz action
		 * @method sap.viz.api.core.VizInstance.prototype.action
		 * @param {String} name the action's key name
		 *
		 * @param {Object} [args]  the action arguments in JSON format
		 *
		 * @return {Object} action return value
		 */

		vizInstance.prototype.action = function(keyName, args) {
			if (ExtCore._actionMap) {
				var functionName = ExtCore._actionMap[keyName];
				if (functionName != null) {
					//parse the function name. To maker sure the following type is correct for parsing.
					//example:"controller.rootUIComponent._modules['root.main'].getMap"
					var func = this.app.controller.rootUIComponent._modules['root.main'];
					var scopeExists = true;
					var namespaces = functionName.split('.');
					var scope = func;
					var typeExists = true;
					for (var j = 0; j < namespaces.length; ++j) {
						if (func[namespaces[j]] !== undefined) {
							scope = func;
							func = func[namespaces[j]];
						} else {
							typeExists = false;
							break;
						}
					}
					if (typeExists) {
						var returnValue = null;
						if (args !== undefined) {
							returnValue = func.call(scope, args);
						} else {
							returnValue = func.call(scope);
						}
						//clone the return object then return it back.	
						if (TypeUtils.isPlainObject(returnValue) || TypeUtils.isArray(returnValue)) {
							returnValue = JSON.parse(JSON.stringify(returnValue));
						}
						return returnValue;
					}
				}
			}

		}
		/**
		 * Get/Set viz description
		 * @method sap.viz.api.core.VizInstance.prototype.description
		 * @param {Object|undefined} [value]
		 *         VizInstance will hold the passed-in description,
		 *        but if the properties are changed, it must be re-passed to VizInstance to take effect.
		 * <pre>
		 *              {
		 *                      "type": String // read-only, viz type
		 *                      "classId": String // the viz DIV's class uid
		 *              }
		 * </pre>
		 */
		vizInstance.prototype.description = function(value) {
			//This is now a get method;
			if (arguments.length <= 0) {
				if (this._description === null) {
					this._description = {};
					if (this.app && this.app.controller) {
						this._description.type = this.app.controller._vizType;
						if (this.app.controller.rootUIComponent) {
							this._description.classId = this.app.controller.rootUIComponent.id;
						}
					}

				}

			} else {
				//This is a get function, and type/classId is read only value.
			}
			return this._description;
		}
		return vizInstance;
	});
define('sap/viz/api/core',['jquery', 'sap/viz/base/utils/TypeUtils', 'sap/viz/util/Objects', 'sap/viz/base/utils/log/LogUtil', 'sap/viz/chart/mvc/ChartApplication', 'sap/viz/manifest', 'sap/viz/api/core/VizInstance','sap/viz/api/data/CrosstableDataset'], function Setup($, TypeUtils, Objects, LOG, ChartApplication, manifest, vizInstance,CrosstableDataset) {
	var riv =

	/**
	 * @module sap.viz.api.core
	 */
	{
		/**
		 * @ignore
		 */
		instances : [], // Stores references to chart applications for easy processing of global events.

		/**
		 * The main entry point of creating a chart.
		 * @method sap.viz.api.core#createViz
		 * @param {Object} usrOptions
		 * <pre>
		 * {
		 *   "type": "viz/bar", //refer to  <a href="../chartproperty/chartproperty.html">chartproperty.html</a>  for all supported viz chart TypeUtils
		 *   "properties": {}, //refer to  <a href="../chartproperty/chartproperty.html">chartproperty.html</a>  for all supported options for each viz type
		 *   "css": String, //refer to  <a href="../chartproperty/chartproperty.html">chartproperty.html</a>  for all supported css items for each viz type
		 *   "container": HTMLDivElement, // HTMLDivElement is the container of viz chart in html
		 *   "data": {@link sap.viz.api.data.CrosstableDataset},
		 *   "feeding": {@link sap.viz.api.core.VizInstance#feeding},
		 *   "events": {}, //Events is an object with key and value pair. Key is the event name, and the value is an object containing function and scope. For example, {'initialized':{ fn: function(){return;}, scope: this}}.
		 * }
		 * </pre>
		 * @returns {Object} vizApplication instance {@link sap.viz.api.core.VizInstance}
		 * 
    	 * @example <caption>Live Demo:</caption> 
	     * {@link http://shg-ci-web.dhcp.pgdev.sap.corp/snippet_platform_api/#006474|Try this}. 
		 */
		createViz : function(usrOptions) {
			var _eventsListeners = {}, _feeding = usrOptions.feeding, _riv = this;
			// if user did not give data, we will add a null data to show chart
			if(!usrOptions.data) {
				usrOptions.data = new CrosstableDataset();
				// new a valid null data according to the chart's type
				var allfeeds = manifest.viz.get(usrOptions.type).allFeeds(true);
				var analysisAxis = [];
				var measureValuesGroup = [];
				var i = 0;
				var j = 0;
				if(allfeeds !== undefined && allfeeds !== null && allfeeds.length > 0) {
					for(; i < allfeeds.length; i++) {
						var type = allfeeds[i].type;
						if(type === "Dimension") {
							j = 0;
							for(; j < allfeeds[i].min; j++) {
								analysisAxis.push({
									'index' : analysisAxis.length + 1,
									'data' : [{
										'values' : [''],
										'infos' : [{}]
									}]
								});
							}
						}
						if(type === "Measure") {
							j = 0;
							for(; j < allfeeds[i].min; j++) {
								measureValuesGroup.push({
									'index' : measureValuesGroup.length + 1,
									'data' : [{
										'values' : [['']]
									}]
								});
							}
						}
					}
				} else {
					analysisAxis.push({
						'index' : 1,
						'data' : [{
							'values' : [''],
							'infos' : [{}]
						}]
					});
					measureValuesGroup.push({
						'index' : 1,
						'data' : [{
							'values' : [['']]
						}]
					});
				}
				usrOptions.data.data({
					'analysisAxis' : analysisAxis,
					'measureValuesGroup' : measureValuesGroup
				});
			}
			if(usrOptions.options !== undefined && usrOptions.properties === undefined) {
				usrOptions.properties = usrOptions.options;
			}

			// LOG.context(':creation:' + Objects.size(usrOptions.properties) + ':' + usrOptions.data.getDataPointCount() + ':' + Objects.size(usrOptions.css));

			var viz = new vizInstance(_eventsListeners,_feeding,_riv);
			viz.setApp(usrOptions);

			Object.defineProperty(viz, "type", {
				value : usrOptions.type,
				enumerable : true
			});

			_riv.instances.push(viz);
			return viz;
		},
		/**
		 * Destroy chart.
		 * @method sap.viz.api.core#destroyViz
		 * @param {Array} chartInstances Array of vizInstances to be destroyed
		 */
		destroyViz : function() {
			for(var i = -1, j = arguments.length; ++i < j; ) {
				arguments[i].destroy();
			}
		},
		/**
		 * export chart instance into a JSON object which contains
		 * all information of the chart including type, data, properties,
		 * css, feeding and size
		 * @method sap.viz.api.core#exportViz
		 * @param {Object} chartInstance VizInstance({@link sap.viz.api.core.VizInstance}) which need to be exported
       	         * @return  {Object} JSONObject
		 * <pre style="font-size: 13px;font-family: Verdana;line-height:120%">
		 * {
		 *   "type": "viz/bar", //refer to  <a href="../chartproperty/chartproperty.html">chartproperty.html</a>  for all supported viz chart TypeUtils
		 *   "properties": {}, //refer to  <a href="../chartproperty/chartproperty.html">chartproperty.html</a>  for all supported options for each viz type
		 *   "css": String, //refer to  <a href="../chartproperty/chartproperty.html">chartproperty.html</a>  for all supported css items for each viz type
		 *   "data": {@link sap.viz.api.data.CrosstableDataset},
		 *   "feeding": {@link sap.viz.api.core.VizInstance#feeding},
		 * }
		 * </pre>
		 */
		exportViz : function(chart) {
			return chart.toJSON();
		},
		
		/**
		 * @method sap.viz.api.core#loadViz
		 * @param {JSON} vizJSON 		 
		 *  <pre>
		 * {
		 *   "type": "viz/bar", //refer to  <a href="../chartproperty/chartproperty.html">chartproperty.html</a>  for all supported viz chart TypeUtils
		 *   "properties": {}, //refer to  <a href="../chartproperty/chartproperty.html">chartproperty.html</a>  for all supported options for each viz type
		 *   "css": String, //refer to  <a href="../chartproperty/chartproperty.html">chartproperty.html</a>  for all supported css items for each viz type
		 *   "data": {@link sap.viz.api.data.CrosstableDataset},
		 *   "feeding": {@link sap.viz.api.core.VizInstance#feeding},
		 * }
		 * </pre>
		 * @param {HTMLDivElement} container JQuery html element. For example, $('body')
		 * @returns {sap.viz.api.core.VizInstance} {@link sap.viz.api.core.VizInstance}
		 */
		loadViz: function(vizJSON, container){
			if(arguments.length === 2){
				var chartJSON = JSON.parse(JSON.stringify(vizJSON));
				chartJSON.container = container;
				var data = new CrosstableDataset();
				data.data(chartJSON.data.val);
				chartJSON.data = data;
				return this.createViz(chartJSON);
			}

		}
	};

	return riv;
});

define('sap/viz/api/env',['sap/viz/env', 'sap/viz/config', 'sap/viz/base/utils/TypeUtils', 'sap/viz/base/utils/ObjectUtils'], function Setup(environment, config, TypeUtils, ObjectUtils) {
    var env =
    /**
     * 
     * @module sap.viz.api.env
     */
    {
        /**
         * Experimental
         * @method sap.viz.api.env.globalSettings
         * @param {Object|undefined} globalSettings
         * If there is no input parameter, this is a get globalSettings function, otherwise this is a set globalSettings function.
         * <pre>
         * Example:
         * 
         *      sap.viz.api.env.globalSettings({"enableCanvg": true, "enableCanvgConfig": {"viz/bar": {"max_svg": 2100, "max_canvas": 4000}}}); //Set globalSettings
         *      var globalSettings = sap.viz.api.env.globalSettings(); //Get globalSettings, it returns an cloned object which contains globalSettings.
         * </pre>
         * @returns {Object}
         *                  return a copy of global settings
         */
        globalSettings : function(values) {
            if (arguments.length === 1 && TypeUtils.isPlainObject(values)) {
                var values = ObjectUtils.clone(values);
                if (values.enableCanvg) {
                    environment.initialize(values);
                }
                if (values.enableCanvgConfig && TypeUtils.isPlainObject(values.enableCanvgConfig)) {
                    for (var i in values.enableCanvgConfig) {
                        config.register({
                            id : i,
                            value : values.enableCanvgConfig[i]
                        });
                    }
                }
            } else if (arguments.length === 0) {
                var values = {};
                if (environment.getEnvSetting() && environment.getEnvSetting().enableCanvg) {
                    values = {
                        enableCanvg : environment.getEnvSetting().enableCanvg
                    };
                }
                if (config.getConfigs()) {
                    var configs = {
                        enableCanvgConfig : config.getConfigs()
                    };
                    values = ObjectUtils.extend(true, {}, values, configs);
                }
                return values;
            }
        },
    };
    return env;
});

define('sap/viz/api/env/Language',['sap/viz/lang/langManager', 'sap/viz/base/utils/TypeUtils', 'sap/viz/base/Logger'], function Setup(langManager, TypeUtils, Logger) {
	var language = 
	/**
	 * @lends sap.viz.api.env.Language
	 */	
	{
		/**
		 * @constructs
		 */
		constructor : function() {

		},
			
		/**
		 * Set current language
		 *
		 * @param {String} language
		 *                      language value like en, de, fr, zh_CN, ja, ru, pt
		 * @param {Function} completeCallback
		 *                      optional, function(language){...}
		 * @param {Function} failedCallback
		 *                      optional, function(language, errorMsg){...}
		 * @return {sap.viz.api.env.Language} self
		 *
		 * @example <caption>Live Demo:</caption> 
		 * {@link http://shg-ci-web.dhcp.pgdev.sap.corp/snippet_platform_api/#004286|Try this}.
		 */
		set : function(language, completeCallback, failedCallback) {
			if (TypeUtils.isString(language) && 
				(arguments.length === 1 ||
				(arguments.length === 2 && TypeUtils.isFunction(completeCallback)) || 
				(arguments.length === 3 && TypeUtils.isFunction(completeCallback) && TypeUtils.isFunction(failedCallback)))) {
				langManager.apply(language, completeCallback, failedCallback);
				return language;
			} else {
				Logger.warn(langManager.getLogMessage('IDS_WARN_PARAMETER_NOT_CORRECT'));
				return;
			}
		},

	/**
	 * Get current language
	 *
	 * @return {String} language value like en, de, fr, es, zh_CN, ja, ru, pt
	 */
	get : function() {
	return langManager.current();
	},
	
	/**
	 * Get error message in current language by error code
	 * @param {Number} code
	 * error code
	 *
	 * @return {String} error message
	 * 
	 * @example sap.viz.api.env.Language.getErrorMessage('50000') = "Length of dimension cannot be zero."(locale == en);
	 */
	getErrorMessage : function(code){
		return langManager.getLogMessageByID(code);
	}

};
return language;
});

define('sap/viz/api/env/Locale',['sap/viz/Locale', 'sap/viz/base/utils/TypeUtils','sap/viz/base/Logger', 'sap/viz/lang/langManager'], function Setup(Locale, TypeUtils, Logger, langManager) {
	var locale = 
	/**
	 * @lends sap.viz.api.env.Locale
	 */		
	{
		/**
		 * @constructs
		 */
		constructor : function() {

		},
			
		/**
		 * Set current locale
		 *
		 * @param {String}
		 *             locale value like en, de, fr, es, zh_CN, ja, ru, pt
		 * @return {sap.viz.api.env.Locale} self
		 * @example <caption>Live Demo:</caption> 
		 * {@link http://shg-ci-web.dhcp.pgdev.sap.corp/snippet_platform_api/#009303|Try this}. 
		 */
		set : function(l) {
			if (arguments.length === 1 && TypeUtils.isString(l)) {
				Locale.locale(l);
				return locale;
			} else {
				Logger.warn(langManager.getLogMessage('IDS_WARN_LOCALE_NOT_CORRECT'));
				return;
			}
		},

		/**
		 * Get current locale
		 *
		 * @return {String} locale value like en, de, fr, zh_CN, ja, ru, pt
		 */
		get : function() {
			return Locale.locale();
		},
	};
	return locale;
}); 

define('sap/viz/ResourceManager',[ 'sap/viz/base/utils/ObjectUtils', 'sap/viz/base/utils/LinkedHashMap',
		'sap/viz/lang/langManager', 'sap/viz/TemplateManager', 'sap/viz/base/utils/TypeUtils'], function Setup(ObjectUtils, LinkedHashMap,
		langManager, TemplateManager, TypeUtils) {
	var _resourcePathMap = new LinkedHashMap();
	
	// These values are used as key to get related resource path
	var GEO_MANAGER_RESOURCE_PATH = 'sap.viz.GeoManager.resourcePath';
	var TEMPLATE_MANAGER_LOAD_PATH = 'sap.viz.api.env.Template.loadPaths';
	var LANG_MANAGER_LOAD_PATH = 'sap.viz.api.env.Language.loadPaths';
	var TEMPLATE_MANAGER_EXTLOAD_PATH = 'sap.viz.extapi.env.Template.loadPaths';
	var LANG_MANAGER_EXTLOAD_PATH = 'sap.viz.extapi.env.Language.loadPaths';
	var array = [GEO_MANAGER_RESOURCE_PATH, TEMPLATE_MANAGER_LOAD_PATH, LANG_MANAGER_LOAD_PATH, TEMPLATE_MANAGER_EXTLOAD_PATH, LANG_MANAGER_EXTLOAD_PATH];
	var SAP_VIZ_GEO_MANAGER = 'window.sap.viz.GeoManager';
	
	// if the package ONLY includes sap.viz.sdk, only needs to set sdk language loadpath.
	var LANG_MANAGER_LOAD_PATH_SDK = 'sap.viz.env.Language.loadPaths.sdk';
	
	// add default values to map
	_resourcePathMap.add(GEO_MANAGER_RESOURCE_PATH, "../../resources");
	_resourcePathMap.add(TEMPLATE_MANAGER_LOAD_PATH, ["../../../resources/templates/"]);
	_resourcePathMap.add(LANG_MANAGER_LOAD_PATH, ["../../../resources/langs/"]);
	_resourcePathMap.add(LANG_MANAGER_LOAD_PATH_SDK, ["../../../resources/langs/sdk/"]);
	_resourcePathMap.add(TEMPLATE_MANAGER_EXTLOAD_PATH, ["../../../resources/templates/"]);
	_resourcePathMap.add(LANG_MANAGER_EXTLOAD_PATH, ["../../../resources/langs/"]);
	
	var GeoManager;
	function hasGeoManager() {
		var geoManagerExist = true;
		var ns = SAP_VIZ_GEO_MANAGER.split(".");
		var o = window;
		for ( var i = 0; i < ns.length; i++) {
			if (o[ns[i]]) {
				o = o[ns[i]];
			} else {
				geoManagerExist = false;
				break;
			}
		}
		if (geoManagerExist) {
			GeoManager = window.sap.viz.GeoManager;
		}
		return geoManagerExist;
	}
	
	var setManagerPath = {
		'sap.viz.api.env.Template.loadPaths' : function(key, path) {
			if (TypeUtils.isArray(path)) {
				path = path.slice(0);
				TemplateManager.loadPath = path;
			}
		},
		'sap.viz.extapi.env.Template.loadPaths' : function(key, path) {
			if (TypeUtils.isArray(path)) {
				path = path.slice(0);
				TemplateManager.loadPath = path;
			}
		},
		'sap.viz.api.env.Language.loadPaths' : function(key, path) {
			if (TypeUtils.isArray(path)) {
				path = path.slice(0);
				if(path === ["../../../resources/langs/"]){ // default langs folder, change to current resource structure.
					path = ["../../../resources/langs/charts/", "../../../resources/langs/sdk/"];
				}
				
				langManager.loadPath = path;
			}
		},
		'sap.viz.env.Language.loadPaths.sdk' : function(key, path) {
			if (TypeUtils.isArray(path)) {
				path = path.slice(0);
				langManager.loadPath = path;
				_resourcePathMap.add(key, path);				
			}
		},	
		
		'sap.viz.extapi.env.Language.loadPaths' : function(key, path) {
			if (TypeUtils.isArray(path)) {
				path = path.slice(0);
				if(path === ["../../../resources/langs/"]){ // default langs folder, change to current resource structure.
					path = ["../../../resources/langs/charts/", "../../../resources/langs/sdk/"];
				}				
				langManager.loadPath = path;
			}

		},
		'sap.viz.GeoManager.resourcePath' : function(key, path) {
			if (hasGeoManager()) {
				if (TypeUtils.isString(path)) {
					GeoManager.resourcePath(path);
				}	
			}
		},
	};

	var getManagerPath = {
		'sap.viz.api.env.Template.loadPaths' : function() {
			var path = TemplateManager.loadPath;
			if (path instanceof Array) {
				return TemplateManager.loadPath.slice(0);
			}	
			return TemplateManager.loadPath;
		},
		'sap.viz.extapi.env.Template.loadPaths' : function() {
			var path = TemplateManager.loadPath;
			if (path instanceof Array) {
				return TemplateManager.loadPath.slice(0);
			}	
			return TemplateManager.loadPath;
		},
		'sap.viz.api.env.Language.loadPaths' : function() {
			var path = TemplateManager.loadPath;
			if (path instanceof Array) {
				return langManager.loadPath.slice(0);
			}	
			return langManager.loadPath;
		},

		'sap.viz.env.Language.loadPaths.sdk' : function() {
			var path = TemplateManager.loadPath;
			if (path instanceof Array) {
				return langManager.loadPath.slice(0);
			}	
			return langManager.loadPath;
		},

		'sap.viz.extapi.env.Language.loadPaths' : function() {
			var path = TemplateManager.loadPath;
			if (path instanceof Array) {
				return langManager.loadPath.slice(0);
			}	
			return langManager.loadPath;
		},
		'sap.viz.modules.geo.GeoManager.resourcePath' : function() {
			if (hasGeoManager()) {
				return GeoManager.resourcePath();
			}
		},
	};

	var manager = {
		/**
		 * @param {String} key
		 * @param {String|Array} path
		 *     If path is Array, keep a cloned Array in the internal map.
		 */
		setPath : function(key, path) {
			if (array.indexOf(key) > -1) {
				setManagerPath[key](key, path);
			} 
			_resourcePathMap.add(key, path);
		},

		/**
		 * @param {String} key
		 *
		 * @return {String|Array} path
		 */
		getPath : function(key) {
			if (array.indexOf(key) > -1) {
				var path = getManagerPath[key]();
				_resourcePathMap.add(key, path);
				return path;
			} else {
				return _resourcePathMap.get(key);
			}
		},
	};
	return manager;
});
define('sap/viz/api/env/Resource',['sap/viz/ResourceManager', 'sap/viz/base/utils/TypeUtils','sap/viz/base/Logger', 'sap/viz/lang/langManager'], function Setup(ResourceManager, TypeUtils, Logger, langManager) {
	var resource =
	/**
	 * @lends sap.viz.api.env.Resource
	 */
	{
		/**
		 * @constructs
		 */
		constructor : function() {

		},

		/**
		 * Get/Set resource path
		 * @method sap.viz.api.env.Resource#path
		 * @name  sap.viz.api.env.Resource.path
		 * @param {String} key
		 * @param {undefined|String|Array} [path] 
 		 * 	If path is undefined, this is a get path by key function, otherwise this is a set path by key function.
		 * Example:
		 *  	Resource.path('baseURL') is to get path by key.
		 *  	Resource.path('baseURL', 'testurl') is to set path by key.
		 * If path is Array, keep a cloned Array in the internal map.
		 * Predefined Resource Paths:
		 * <pre>
		 *     "sap.viz.GeoManager.resourcePath":       "../../resources"
		 *     "sap.viz.api.env.Template.loadPaths":    ["../../../resources/templates"]
		 *     "sap.viz.api.env.Language.loadPaths":    ["../../../resources/langs/"]
		 * 
		 * Example:
		 * 
		 * Set path:
		 * sap.viz.api.env.Resource.path("sap.viz.GeoManager.resourcePath", "../../resources");
		 * sap.viz.api.env.Resource.path("sap.viz.api.env.Template.loadPaths", ["../../../resources/templates"]);
		 * sap.viz.api.env.Resource.path("sap.viz.api.env.Language.loadPaths", ["../../../resources/langs/"]);
		 * 
		 * Get path:
		 * sap.viz.api.env.Resource.path("sap.viz.GeoManager.resourcePath") = "../../resources";
		 * sap.viz.api.env.Resource.path("sap.viz.api.env.Template.loadPaths") =  ["../../../resources/templates"];
		 * sap.viz.api.env.Resource.path("sap.viz.api.env.Language.loadPaths") =  ["../../../resources/langs/"];
		 * 
		 * </pre>
		 * Or you can use customized paths:
		 * 		sap.viz.api.env.Resource.path("baseURL", "testurl"), you can set any key-value pair which value should be a valid path.
		 * @return {sap.viz.api.env.Resource|String|Array} return self when it is a set function and return String or Array if it is a get function.
		 */
		path : function() {
			if (arguments.length === 1 && TypeUtils.isString(arguments[0])) {
				return ResourceManager.getPath(arguments[0]);
			} else if (arguments.length === 2 && TypeUtils.isString(arguments[0])) {
				ResourceManager.setPath(arguments[0], arguments[1]);
				return resource;
			} else {
				Logger.warn(langManager.getLogMessage('IDS_WARN_PARAMETER_NOT_CORRECT'));
				return;
			}
		},

	};
	return resource;
});

define('sap/viz/api/env/Format',['sap/viz/format/FormatManager', 'sap/viz/base/utils/TypeUtils'], function Setup(FormatManager, TypeUtils) {
	var locale =
	/**
	 * @lends sap.viz.api.env.Format
	 */
	{
		/**
		 * @constructs
		 */
		constructor : function() {

		},
		/**
		 * Customize the global numeric formatter.
		 * If you set a formatter, it will replace the existing formatter.
		 * @param {Object} formatter
		 * {format: function(value, pattern) {...}}
		 *
		 *
		 * <pre>
		 * Example:
		 * 		var customerFormatter = {
		 *			format : function(value, pattern) {
		 *				//add your codes here to convert number value to formatted string according to the pattern string
		 *				return formattedString;
		 *			}
		 *		};
		 *		sap.viz.api.env.Format.numericFormatter(customerFormatter);
		 * </pre>
		 */
		numericFormatter : function(formatter) {
			FormatManager.formatFunc(formatter);
		}
	};
	return locale;
});

define('sap/viz/api/log/Appender',['sap/viz/base/Logger'], function Setup(LOG) {
    
    /**
     * The appender class of sap logger.
     * @Class sap.viz.api.log.Appender
     */
    var appender = {};

    /**
     * Console appender class, the log will displayed on browser console.
     * @member ConsoleAppender
     * @memberof sap.viz.api.log.Appender
     */
    appender.ConsoleAppender = LOG.ConsoleAppender;
    
    /**
     *  DivAppender class, the log will be displayed on web page.
     * @member DivAppender
     * @memberof sap.viz.api.log.Appender
     */
    appender.DivAppender = LOG.DivAppender;
    
    /**
     * AjaxAppender class, the log will be displayed on remote file.
     * @member AjaxAppender
     * @memberof sap.viz.api.log.Appender
     */
    appender.AjaxAppender = LOG.AjaxAppender;

    return appender;
});

define('sap/viz/api/log/Layout',['sap/viz/base/Logger'], function Setup(LOG) {

    /**
         * The layout class of sap logger appender.
         * @class sap.viz.api.log.Layout
         */
        var layout = {};
        
        /**
         * Appender default layout Class.
         * @memberof sap.viz.api.log.Layout
         * @member DefaultLayout
         */
        layout.DefaultLayout = LOG.DefaultLayout;
        
        /**
         * Appender html layout Class.
         * @memberof sap.viz.api.log.Layout
         * @member HTMLLayout
         */
        layout.HTMLLayout = LOG.HTMLLayout;
        
        /**
         * Appender xml layout Class.
         * @memberof sap.viz.api.log.Layout
         * @member XMLLayout
         */
        layout.XMLLayout = LOG.XMLLayout;
        
        /**
         * Appender JSON layout Class.
         * @memberof sap.viz.api.log.Layout
         * @member JSONLayout
         */
        layout.JSONLayout = LOG.JSONLayout;
        

});

define('sap/viz/api/log/Logger',['sap/viz/base/Logger'], function Setup(LOG) {
    /**
     * @class sap.viz.api.log.Logger
     */
    var logger = {};
    /**
     * @ignore
     */
    logger.LEVEL = {};
    
    /**
     * Log level constant, OFF.
     * @constant LEVEL.OFF
     * @memberof sap.viz.api.log.Logger
     */
    logger.LEVEL.OFF= LOG.LEVEL.NO;
    
    /**
     * Log level constant, TRACE
     * @constant LEVEL.TRACE
     * @memberof sap.viz.api.log.Logger
     */
    logger.LEVEL.TRACE = LOG.LEVEL.TRACE;
    
    /**
     * Log level constant, DEBUG
     * @constant LEVEL.DEBUG
     * @memberof sap.viz.api.log.Logger
     */
    logger.LEVEL.DEBUG = LOG.LEVEL.DEBUG;
    
    /**
     * Log level constant, INFO.
     * @constant LEVEL.INFO
     * @memberof sap.viz.api.log.Logger
     */
    logger.LEVEL.INFO = LOG.LEVEL.INFO;
    
    /**
     * Log level constant, WARN.
     * @constant LEVEL.WARN
     * @memberof sap.viz.api.log.Logger
     */
    logger.LEVEL.WARN = LOG.LEVEL.WARN;
    
    /**
     * Log level constant, ERROR.
     * @constant LEVEL.ERROR
     * @memberof sap.viz.api.log.Logger
     */
    logger.LEVEL.ERROR = LOG.LEVEL.ERROR;

    /** 
     * Get or set log appenders.
     * @name sap.viz.api.log.Logger#appenders
     * @method sap.viz.api.log.Logger.appenders
     * @param {Array} value - Array of the instances of sap.viz.api.log.Appender.#Appender
     * <pre>
     * {
     *   The instancecan be 
     *   sap.viz.api.log.Appender.ConsoleAppender
     *   sap.viz.api.log.Appender.DivAppender
     *   sap.viz.api.log.Appender.AjaxAppender
     * }
     * </pre>
     * @returns {Array}  [sap.viz.api.log.ConsoleAppender, sap.viz.api.log.DivAppender]. 
     */
    logger.appenders = function(value){
        if(arguments.length>0){ // set appenders
            for(var i=0;i<value.length; i++){
                LOG.addAppender(value[i]);
            }
            return this;
        }
        return LOG.getAppenders();
    };
    
    /**
     *    Get or set log level.
     * @name sap.viz.api.log.Logger#level
     * @method sap.viz.api.log.Logger.level
     * @param {String} value - sap.viz.log.LEVEL constant.
     * <pre>
     * {
     *   The value can be 
     *   sap.viz.log.LEVEL.NO
     *   sap.viz.log.LEVEL.TRACE
     *   sap.viz.log.LEVEL.DEBUG
     *   sap.viz.log.LEVEL.INFO
     *   sap.viz.log.LEVEL.WARN
     *   sap.viz.log.LEVEL.ERROR
     * }
     * </pre>
     * @returns {String} sap.viz.log.LEVEL constant.
     */
    
    logger.level = function(value){
        if(arguments.length>0){
            LOG.level = value;
        }else{
            return LOG.level;
        }
    };
    
    return logger;
});

define('sap/viz/api/env/Template',['sap/viz/TemplateManager', 'sap/viz/base/utils/ObjectUtils', 'sap/viz/base/utils/TypeUtils','sap/viz/base/Logger' , 'sap/viz/lang/langManager'], function Setup(TemplateManager, ObjectUtils, TypeUtils, Logger, langManager) {
	var template = 
	/**
	 * @lends sap.viz.api.env.Template
	 */		
	{

		/**
		 * @constructs
		 */
		constructor : function() {

		},
		
		/**
		 * Set current template's unique id
		 *
		 * @param {String} id
		 *                          tempalte's unique id
		 * @param {Function} [completeCallback]
		 *                           function(id){...} //parameter id is optional
		 * @param {Function} [failedCallback]
		 *                           function(id, errorMsg){...} //parameter id and errorMsg are optional
		 * @return {sap.viz.api.env.Template} self
		 *
		 * @example <caption>Live Demo:</caption> 
		 * {@link http://shg-ci-web.dhcp.pgdev.sap.corp/snippet_platform_api/#002250|Try this}. 
		 */
		set : function(id, completeCallback, failedCallback) {
			if (TypeUtils.isString(id) && 
				(arguments.length === 1 ||
				(arguments.length === 2 && TypeUtils.isFunction(completeCallback)) || 
				(arguments.length === 3 && TypeUtils.isFunction(completeCallback) && TypeUtils.isFunction(failedCallback)))) {
				TemplateManager.apply(id, completeCallback, this, failedCallback);
				return template;
			} else {
				Logger.warn(langManager.getLogMessage('IDS_WARN_PARAMETER_NOT_CORRECT'));
				return;
			}
		},

		/**
		 * Get current template's unique id
		 *
		 * @return {String} template's unique id
		 * 
		 * Example:
		 * 		sap.viz.api.env.Template.set('flashy', completeCallback, failedCallback);//set template by id
		 *  	sap.viz.api.env.Template.get() = 'flashy';//Get the set template id.
		 */
		get : function() {
			return TemplateManager.current().id;
		},
	};
	return template;
}); 

define('sap/viz/api/manifest/Feed',['sap/viz/feeds/Manifest', 'sap/viz/base/utils/TypeUtils'], function Setup(Feed, TypeUtils) {
    var manifest = 
      /**
       * @lends sap.viz.api.manifest.Feed
       */
    {
        /**
         * @constructs
         */
        constructor : function() {

        },
            
        /**
         *
         * @param {String} [id]
         *                       Returns feed manifest that is associated with the id. If the id is not defined, returns all the feed manifests.
         * @param {Boolean} [throwErrorIfNull]
         *                       Only works when an id argument exists
         * @return {[sap.viz.api.manifest.FeedManifest]} feed manifests, this is a read only object
         *                         A feed manifest registered by {@link sap.viz.extapi.manifest.Feed.register}.</br>
         *
         * @example <caption>Sample Code:</caption>
         * <pre style = "font-size : 14px; line-height : 14px; font-family : Verdana;">
         * var feedById =  sap.viz.api.manifest.Feed.get(id)[0]; //Get feed by specific category id like heatMap, network, pie, radar, scatter, scattermatrix, tagCloud, tree, treeMap and xy, returns an array which contains one feed object.
         * 
         * var feeds =  sap.viz.api.manifest.Feed.get(); //Get all feeds; returns an array which contains all feed objects.
         * 
         * This function replaces API manifest.feeds.each which was in the previous API version. Use this function instead.
         * 
         * If you used sap.viz.manifest.feeds.each(function(obj, id){....}) in previous versions,
         * you can now use the following: var FeedSet =  sap.viz.api.manifest.Feed.get(); FeedSet.forEach(function(obj, id){....});
         *
         * var feedDefinition = sap.viz.api.manifest.Feed.get('heatMap')[0].feeds[0]; //Get first feed definition for category heatMap
         * feed definition return:
         * {
         *     "aaIndex": Number,
         *     "acceptMND": Number,
         *     "id": String, // DimensionId or measureId
         *     "max": Number,
         *     "min": Number,
         *     "name": String,
         *     "type": String{Dimension|Measure}
         * }
         * {@link http://viz.dhcp.pgdev.sap.corp/viz/wiki/ProductGuides/Tutorials/ChartFeed | Understanding Chart Feeds}
         * </pre>
         */
        get : function() {
            return Feed.getManifest.apply(this, arguments);
        }, 
    };
    return manifest;
});

define('sap/viz/api/manifest/Module',['sap/viz/modules/manifests/Module', 'sap/viz/base/utils/TypeUtils'], function Setup(Module, TypeUtils) {
    var manifest = 
  /**
   * @lends sap.viz.api.manifest.Module
   */
    {
        /**
         * @constructs
         */
        constructor : function() {

        },
        
        /**
         *
         * @param {String} [id]
         *                       Returns module manifest that is associated with the id. If the id is not defined, returns all the module manifests.
         * @param {Boolean} [throwErrorIfNull]
         *                      Only works when an id argument exists
         * @return {[sap.viz.api.manifest.ModuleManifest]} module manifests, this is a read only object
        *                       A module manifest registered by {@link sap.viz.extapi.manifest.Module.register}.</br>
        * 
        * @example <caption>Sample Code:</caption>
        * <pre style = "font-size : 14px; line-height : 14px; font-family : Verdana;">
        * var legend = sap.viz.api.manifest.Module.get(legendid); //Get legend module with legend id; returns an array which contains one module object.
        * 
        * var allModules = sap.viz.api.manifest.Module.get(); //Get all modules; returns an array which contains all module objects.
        * 
        * This function replaces API manifest.modules.each which was in the previous API version. Use this function instead.
        * 
        * If you used sap.viz.manifest.modules.each(function(obj, id){....}) in previous versions,
        * you can now use the following: var moduleSet =  sap.viz.api.manifest.Module.get(); moduleSet.forEach(function(obj, id){....});
        * 
        * module manifest returned:
        * {
        *     "id": String, // UNIQ_ID
        *     "type": String, // 'CONTAINER|CHART|SUPPLEMENTARY|CONTROLLER',
        *     "name": String,
        *     "abstract": Boolean, // optional
        *     "base": String, // optional
        *     "properties": Object, 
        *     "css": Object, // style sheet
        *     "fn": Function, // module main function
        *     "subModules": Function,
        * }
        * 
        * {@link http://viz.dhcp.pgdev.sap.corp/viz/wiki/ProductGuides/Tutorials/ChartModule|Understanding Chart Modules}
        * </pre>
         */
        get : function() {
            return Module.getManifest.apply(this, arguments);
        }
    };
    return manifest;
});

define('sap/viz/api/manifest/Viz',['sap/viz/manifests/Viz', 'sap/viz/base/utils/TypeUtils'], function Setup(Viz, TypeUtils) {
    var manifest = 
  /**
   * @lends sap.viz.api.manifest.Viz
   */
    {

        /**
         * @constructs
         */
        constructor : function() {

        },        
        
        /**
         *
         * @param {String} [id]
         *                        Returns viz manifest that is associated with the id. If the id is not defined, returns all the viz manifests.
         * @param {Boolean} [throwErrorIfNull]
         *                       Only works when an id argument exists
         * @return {[sap.viz.api.manifest.VizManifest]} viz manifests, this is a read only object
         *                         A viz manifest registered by {@link sap.viz.extapi.manifest.Viz.register}.</br>
         * 
         * @example <caption>Sample Code:</caption>
         * <pre style = "font-size : 14px; line-height : 14px; font-family : Verdana;">
         * var viz = sap.viz.api.manifest.Viz.get(barType); //Get specified viz by id; returns an array which contains one viz object.
         * 
         * var allFeedOfBar = sap.viz.api.manifest.Viz.get(barType)[0].allFeeds(); //Get all Feeds for barType
         * 
         * var allViz =  sap.viz.api.manifest.Viz.get(); //Get all Viz; returns an array which contains all viz objects.
         * 
         * This function replaces API manifest.viz.each which was in the previous API version. Use this function instead.
         * 
         * If you used sap.viz.manifest.viz.each(function(obj, id){....}) in previous versions,
         * you can now use the following: var VizSet =  sap.viz.api.manifest.Viz.get(); VizSet.forEach(function(obj, id){....});
         * 
         * viz manifest returned:
         * {
         *     "id": String,
         *     "name": String,
         *     "modules": Object, // Modules in the viz, such as title, legend, and so on.
         *     "dependencies": Object, // Dependencies between modules.
         *     "allFeeds": Function, // Get all feed manifests of the viz.
         *     "allProperties": Function, // Get all properties of the viz.
         * }
         * 
         * {@link http://viz.dhcp.pgdev.sap.corp/viz/wiki/ProductGuides/Tutorials/ChartComposition|Understanding The Composition Of Modules}
         * </pre>
         */
        get : function() {
            return Viz.getManifest.apply(this, arguments);
        }
    };

    /**
     * Add API to let clients know whether the feeding is acceptable for one specific feeding area.
     * Take feed ID and the feed metadata as the input, decide whether the feeding is acceptable according to min/max feeding number and current feeding status.
     * @method sap.viz.api.manifest.Viz.feedAcceptable
     * @param {String} chartType
     *                         the feeding chart type.
     * @param {Array} feeding
     *                         Feeding object array.
     * @return {boolean}     true means feed is acceptable
     * 
     * @example <caption>Live Demo:</caption> 
     * {@link http://shg-ci-web.dhcp.pgdev.sap.corp/snippet_platform_api/#4651|Try this}. 
     * 
     */
    manifest.feedAcceptable = function(chartType, feeding) {
        var viztype = Viz.get(chartType);
        if(viztype != undefined) {
            var manifestDescription = viztype.allFeeds(true);
            var returnValue = true;
            if(!(TypeUtils.isArray(manifestDescription) && TypeUtils.isArray(feeding))) {
                //chart type is not exist,
                returnValue = false;
            } else {
                var len = feeding.length;
                var feedLogic = {};
                var i = 0;
                for( i = 0; i < len; i++) {
                    var feedobj = feeding[i];
                    if(TypeUtils.isArray(feedobj.binding)) {
                        feedLogic[feedobj.feedId] = feedobj.binding.length;
                    } else {
                        returnValue = false;
                        break;
                    }
                }
                if(manifestDescription.length != len) {
                    //when the length of feeding description is not equal to feeding object, then we cannot feed correctly.
                    returnValue = false;
                } else if(returnValue == true) {
                    for( i = 0; i < len; i++) {
                        var feedDesObj = manifestDescription[i];
                        if(feedLogic[feedDesObj.id] == null || (feedLogic[feedDesObj.id] < feedDesObj.min || feedLogic[feedDesObj.id] > feedDesObj.max )) {
                            //When the max or min value of feed description is not satisfied or the feed id does not exist in the feed object, return false;
                            returnValue = false;
                            break;
                        }
                    }
                }
            }

            return returnValue;
        }
        return false;
    }
    return manifest;
});

define('sap/viz/extapi/env/Language',['sap/viz/lang/langManager', 'sap/viz/base/utils/TypeUtils', 'sap/viz/base/utils/LinkedHashMap','sap/viz/base/Logger', 'sap/viz/lang/langManager'], function Setup(langManager, TypeUtils, LinkedHashMap, Logger, langManager) {

    var _listeners = new LinkedHashMap();

    var language =
    /**
     * @lends sap.viz.extapi.env.Language
     */
    {
        /**
         * @constructs
         */
        constructor : function() {

        },
        /**
         * Get current language
         *
         * @return {String} language value like en, de, fr, es, zh_CN, ja, ru, pt
         */
        get : function() {
            return langManager.current();
        },

        /**
         * @param {Function} listener
         *                      function(language){...} //parameter language is optional
         * @return {sap.viz.extapi.env.Language} self
         * @example <caption>Live Demo:</caption>
         * {@link http://shg-ci-web.dhcp.pgdev.sap.corp/snippet_platform_api/#003195|Try this}.
         */
        addListener : function(l) {
            if (arguments.length === 1 && TypeUtils.isFunction(l)) {
                var listener = {
                    fn : l
                };
                langManager.addListener(listener);
                _listeners.add(l, listener);
                return language;
            } else {
            	Logger.warn(langManager.getLogMessage('IDS_WARN_PARAMETER_NOT_CORRECT'));
                return;
            }

        },

        /**
         * @param {Function} listener
         *                      function(language){...} //this function must be the original listener function
         * @return {sap.viz.extapi.env.Language} self
         *
         * @example <caption>Live Demo:</caption>
         * {@link http://shg-ci-web.dhcp.pgdev.sap.corp/snippet_platform_api/#003195|Try this}.
         */
        removeListener : function(l) {
            if (arguments.length === 1 && TypeUtils.isFunction(l)) {
                langManager.removeListener(_listeners.get(l));
                _listeners.remove(l);
                return language;
            } else {
            	Logger.warn(langManager.getLogMessage('IDS_WARN_PARAMETER_NOT_CORRECT'));
                return;
            }
        },

        /**
         * @param {Object} languagePackage
         * <pre>
         * { "id" : languageId,
         *     "value" : 
         *     {
         *         "string_key" : string_value,
         *         ...
         *     },
         * }
         * </pre>
         * @return {sap.viz.extapi.env.Language} self
         */
        register : function(languagePackage) {
            if (arguments.length === 1 && TypeUtils.isPlainObject(languagePackage)) {
                langManager.register(languagePackage);
                return language;
            } else {
            	Logger.warn(langManager.getLogMessage('IDS_WARN_PARAMETER_NOT_CORRECT'));
                return;
            }
        },

        /**
         * Get error message in current language by error code
         * @param {Number} id
         * error id
         *
         * @return {String} error message
         * 
         * @example sap.viz.extapi.env.Language.getErrorMessage('50000') = "Length of dimension cannot be zero."(locale == en);
         */
        getErrorMessage : function(id) {
            return langManager.getLogMessageByID(id);
        }
    };
    return language;
});

define('sap/viz/extapi/env/Locale',['sap/viz/Locale', 'sap/viz/base/utils/TypeUtils', 'sap/viz/base/utils/LinkedHashMap','sap/viz/base/Logger', 'sap/viz/lang/langManager'], function Setup(Locale, TypeUtils, LinkedHashMap, Logger, langManager) {
    var _listeners = new LinkedHashMap();
    var locale =
  /**
   * @lends sap.viz.extapi.env.Locale
   */
    {
        /**
         * @constructs
         */
        constructor : function() {

        },    
            
        /**
         * Get current locale
         *
         * @return {String} locale value like en, de, fr, es, zh_CN, ja, ru, pt
         */
        get : function() {
            return Locale.locale();
        },

        /**
         * @param {Function}
         *            listener function(locale){...} //parameter locale is optional
         * @return {sap.viz.extapi.env.Locale} self
         * @example <caption>Live Demo:</caption> 
         * {@link http://shg-ci-web.dhcp.pgdev.sap.corp/snippet_platform_api/#005108|Try this}. 
         */
        addListener : function(l) {
            if (arguments.length === 1 && TypeUtils.isFunction(l)) {
                var listener = {
                    fn : l
                };
                Locale.addListener(listener);
                _listeners.add(l, listener);
                return locale;
            } else {
                Logger.warn(langManager.getLogMessage('IDS_WARN_PARAMETER_NOT_CORRECT'));
                return;
            }
        },

        /**
         * @param {Function} listener
         *            function(locale){...} //this function must be the original listener function
         * @return {sap.viz.extapi.env.Locale} self
         * @example <caption>Live Demo:</caption> 
         * {@link http://shg-ci-web.dhcp.pgdev.sap.corp/snippet_platform_api/#005108|Try this}. 
         */
        removeListener : function(l) {
            if (arguments.length === 1 && TypeUtils.isFunction(l)) {
                Locale.removeListener(_listeners.get(l));
                _listeners.remove(l);
                return locale;
            } else {
            	Logger.warn(langManager.getLogMessage('IDS_WARN_PARAMETER_NOT_CORRECT'));
                return;
            }

        },
    };
    return locale;
});

define('sap/viz/extapi/env/Resource',['sap/viz/ResourceManager', 'sap/viz/base/utils/TypeUtils','sap/viz/base/Logger', 'sap/viz/lang/langManager'], function Setup(ResourceManager, TypeUtils, Logger, langManager) {
    var resource =
    /**
     * @lends sap.viz.extapi.env.Resource
     */
    {
        /**
         * @constructs
         */
        constructor : function() {

        },

        /**
         * Get/Set resource path
         * @method sap.viz.extapi.env.Resource#path
         * @name  sap.viz.extapi.env.Resource.path
         * @param {String} key
         * @param {undefined|String|Array} [path]
          *     If path is undefined, this is a get path by key function, otherwise this is a set path by key function.
         * Example:
         *          Resource.path('baseURL') is to get path by key.
         *          Resource.path('baseURL', 'testurl') is to set path by key.
          * If path is Array, keep a cloned Array in the internal map.
         * Predefined Resource Paths:
         * <pre>
         *   1.  "sap.viz.GeoManager.resourcePath":       "../../resources";
         *   2.  "sap.viz.extapi.env.Template.loadPaths":    ["../../../resources/templates"];
         *   3.  "sap.viz.extapi.env.Language.loadPaths":    ["../../../resources/langs/"];
         *
         * 
         * Example:
         * 
         * Set path:
         * 
         * sap.viz.extapi.env.Resource.path("sap.viz.GeoManager.resourcePath", "../../resources");
         * sap.viz.extapi.env.Resource.path("sap.viz.extapi.env.Template.loadPaths", ["../../../resources/templates"]);
         * sap.viz.extapi.env.Resource.path("sap.viz.extapi.env.Language.loadPaths", ["../../../resources/langs/"]);
         * 
         * Get path:
         * 
         * sap.viz.extapi.env.Resource.path("sap.viz.GeoManager.resourcePath") = "../../resources";
         * sap.viz.extapi.env.Resource.path("sap.viz.extapi.env.Template.loadPaths") =  ["../../../resources/templates"];
         * sap.viz.extapi.env.Resource.path("sap.viz.extapi.env.Language.loadPaths") =  ["../../../resources/langs/"];
         * 
         * Or you can use customized paths:
         *         Resource.path('baseURL', 'testurl'), you can set any key-value pair which value should be a valid path.
         * @return {sap.viz.extapi.env.Resource|String|Array} return self when it is a set function and return String or Array if it is a get function.
         */
        path : function() {
            if (arguments.length === 1 && TypeUtils.isString(arguments[0])) {
                return ResourceManager.getPath(arguments[0]);
            } else if (arguments.length === 2 && TypeUtils.isString(arguments[0])) {
                ResourceManager.setPath(arguments[0], arguments[1]);
                return resource;
            } else {
                Logger.warn(langManager.getLogMessage('IDS_WARN_PARAMETER_NOT_CORRECT'));
                return;
            }
        },

    };
    return resource;
});

define('sap/viz/extapi/env/Template',['sap/viz/TemplateManager', 'sap/viz/base/utils/ObjectUtils', 'sap/viz/base/utils/TypeUtils'], function Setup(TemplateManager, ObjectUtils, TypeUtils) {
    var template =
    /**
     * @lends sap.viz.extapi.env.Template
     */
    {

        /**
         * @constructs
         */
        constructor : function() {

        },
        /**
         * Get current template's unique id
         *
         * @return {String} template's unique id 
         * <pre>
         *  Example: 
         *      sap.viz.extapi.env.Template.set("flashy", completeCallback, failedCallback);//set template by id 
         *      sap.viz.extapi.env.Template.get() = "flashy";//Get the set template id. 
         * </pre>
         */
        get : function() {
            return TemplateManager.current().id;
        },

        /**
         * Get a clone of current applied template object
         *
         * @return {Object} templatePackage
         * <pre>
         * {
         *     "id" : templateId,
         *     "name" : templateName,
         *     "version" : version,
         *     "css" : templateCss, //such as css: ".v-m-main .v-background-body{fill:#eeeeee;}.v-m-main .v-background-body{fill:#eeeeee;}" 
         *     "properties" : 
         *     {
         *            "string_key" : string_value,
         *         ...
         *     },
         * }
         * </pre>
         */
        current : function() {
            var templatePackage = {};
            return ObjectUtils.extend(true, templatePackage, TemplateManager.current());
        },
        /**
         * Add or extend existing template object.
         * The api sap.viz.TemplateManager.extend which in the previous api version is now replaced by this function. <br>
         * 
         * If the template is not exist, it will add this template.
         * If the template is already exist, it will merge and extend the old one with the new template.
         *
         * @method sap.viz.extapi.env.Template#register
         * @name  sap.viz.extapi.env.Template.register
         * @param {Object} templatePackage
         * <pre>
         * {
         *     "id" : templateId,
         *     "name" : templateName,
         *     "version" : version,
         *     "css" : templateCss, //such as css: ".v-m-main .v-background-body{fill:#eeeeee;}.v-m-main .v-background-body{fill:#eeeeee;}" 
         *     "properties" : 
         *     {
         *            "string_key" : string_value,
         *         ...
         *     },
         * }
         * </pre>
         * @return {sap.viz.extapi.env.Template} self
         * @example <caption>Live demos:</caption>
         * {@link http://shg-ci-web.dhcp.pgdev.sap.corp/snippet_platform_api/#5253|Try this}.
         */
    };
    return template;
});

define('sap/viz/extapi/manifest/Feed',['sap/viz/feeds/Manifest'], function Setup(Feed) {
    
    /**
     * sap.viz.extapi.manifest.Feed
     * @class sap.viz.extapi.manifest.Feed
     */
    var FeedManifest = {};

    /**
     * Register an item into category
     * @method sap.viz.extapi.manifest.Feed.register
     * @param {Object} newItems variable parameters, at least need one item to be registered into category
     * @return {sap.viz.extapi.manifest.Feed} manifest itself
     *
     */
    FeedManifest.register = Feed.register;
    /**
     * Unregister an item into category
     * @method sap.viz.extapi.manifest.Feed.unregister
     * @param {String} id
     * @return {Object} the removed feed object
     * <pre>
     * feed manifest returned:
     * {
     *     "aaIndex": Number,
     *     "acceptMND": Number,
     *     "id": String,
     *     "max": Number,
     *     "min": Number,
     *     "name": String,
     *     "type": String{Dimension|Measure} 
     * }
     * </pre>
     * {@link http://viz.dhcp.pgdev.sap.corp/viz/wiki/ProductGuides/Tutorials/ChartFeed | Understanding Chart Feeds}
     */
    FeedManifest.unregister = function(id) {
        if(id!==undefined){
            return Feed.unregister(id);
        }
            
    }
    
    return FeedManifest;
});
define('sap/viz/extapi/manifest/Module',['sap/viz/modules/manifests/Module'], function Setup(Module) {
    
    /**
     * sap.viz.extapi.manifest.Module
     * @class sap.viz.extapi.manifest.Module
     */
    var ModuleManifest = {};
    
    /**
     * Register an item into category
     * @method sap.viz.extapi.manifest.Module.register
     * @param {Object} newItems variable parameters, at least need one item to be registered into category
     * @return {sap.viz.extapi.manifest.Module} manifest itself
     */
    ModuleManifest.register = Module.register;
    
    /**
     * Unregister an item into category
     * @method sap.viz.extapi.manifest.Module.unregister
     * @param {String} id
     * @return {Object} the removed feed object
     * <pre>
     * module manifest returned:
     * {
     *     "id": String, // UNIQ_ID
     *     "type": String, // 'CONTAINER|CHART|SUPPLEMENTARY|CONTROLLER',
     *     "name": String,
     *     "abstract": Boolean, // optional
     *     "base": String, // optional
     *     "properties": Object, 
     *     "css": Object, // style sheet
     *     "fn": Function,// module main function
     *     "subModules": Function,
     * }
     * </pre>
     * {@link http://viz.dhcp.pgdev.sap.corp/viz/wiki/ProductGuides/Tutorials/ChartModule|Understanding Chart Modules}
     */
    ModuleManifest.unregister = function(id) {
        if(id !== undefined){
            return Module.unregister(id);
        }
        
    }

    return ModuleManifest;
});
define('sap/viz/extapi/manifest/Viz',['sap/viz/manifests/Viz'], function Setup(Viz) {
    
    /**
     * sap.viz.extapi.manifest.Viz
     * @class sap.viz.extapi.manifest.Viz
     */
    var VizManifest = {};
    /**
     * Register an item into category
     * @method sap.viz.extapi.manifest.Viz.register
     * @param {Object} newItems variable parameters, at least need one item to be registered into category
     * @return {sap.viz.extapi.manifest.Viz} manifest itself
     */
    VizManifest.register = Viz.register;

    /**
     * Unregister an item into category
     * @method sap.viz.extapi.manifest.Viz.unregister
     * @param {String} id
     * @return {Object} the removed feed object
     * <pre>
     * viz manifest returned:
     * {
     *     "id": String,
     *     "name": String,
     *     "modules": Object, // modules in the viz, such as title, legend and etc.
     *     "dependencies": Object, // dependencies between modules.
     *     "allFeeds": Function, // get all feed manifests of the viz
     *     "allProperties": Function,// get all properties of the viz
     * }
     * </pre>
     * {@link http://viz.dhcp.pgdev.sap.corp/viz/wiki/ProductGuides/Tutorials/ChartComposition|Understanding The Composition Of Modules}
     */
    VizManifest.unregister = function(id) {
        if(id!== undefined){
            return Viz.unregister(id);
        }
        
    }
    
    return VizManifest;
});
//Export modules in the list to global scope
(function(global){
	var exportedList = [
		"sap/viz/data/description/DataContainer",
	    "sap/viz/data/description/MeasureValues",
	    "sap/viz/data/description/MeasureValuesGroup",
	    "sap/viz/data/description/DimensionLabels",
	    "sap/viz/data/description/AnalysisAxis",
	    "sap/viz/data/CrosstableDataset",
	    "sap/viz/manifest",
	    "sap/viz/TemplateManager",
	    "sap/viz/config",
	    "sap/viz/Locale",
	    "sap/viz/lang/langManager",
	    "sap/viz/data/MultiAxesDataAdapter",
	    "sap/viz/format/FormatManager",
	    "sap/viz/data/handler/MeasureDataHandler",
	    "sap/viz/data/handler/SingleChartDataHandler",
	    "sap/viz/core",
	    "sap/viz/ccl",
	    "sap/viz/base/utils/log/Analyzer",
	    "sap/viz/base/utils/log/LogUtil",
	    "sap/viz/env",
	    "sap/viz/api/core/VizInstance",
	    "sap/viz/api/core",
	    "sap/viz/api/data/CrosstableDataset",
	    "sap/viz/api/data/FlatTableDataset",
		"sap/viz/api/log/Appender",
		"sap/viz/api/log/Layout",
		"sap/viz/api/log/Logger",
	    "sap/viz/extapi/core",
	    "sap/viz/api/env",
	    "sap/viz/api/env/Language",
	    "sap/viz/api/env/Locale",
	    "sap/viz/api/env/Resource",
	    "sap/viz/api/env/Template",
	    "sap/viz/api/env/Format",	
	    "sap/viz/api/manifest/Feed",
	    "sap/viz/api/manifest/Module",
	    "sap/viz/api/manifest/Viz",
	    "sap/viz/extapi/env/Language",
	    "sap/viz/extapi/env/Locale",
	    "sap/viz/extapi/env/Resource",
	    "sap/viz/extapi/env/Template",
	    "sap/viz/extapi/manifest/Feed",
	    "sap/viz/extapi/manifest/Module",
	    "sap/viz/extapi/manifest/Viz",
	];
	var jq = global.jQuery;
  
    if (jq) {
        if (jQuery.holdReady) {
            jQuery.holdReady(true);
        } else {
            jQuery.readyWait += 1;
        }
    }
  
    function mergeObject(target, ext) {
        var propKey
        for(propKey in ext){
            if(ext.hasOwnProperty(propKey)){
                target[propKey] = ext[propKey];
            }
        }
        return target;
    }
	//put modules on global object
	require(exportedList, function() {
		var exports = arguments;
		
		exportedList.forEach(function(mod, i) {
			var nameParts = mod.split("/");
			nameParts.reduce(function(p, c, index) {
				if (!p[c]) {
					if (index < nameParts.length - 1) {
						p[c] = {};
					} else {
						p[c] = exports[i];
					}
				}else if(index === nameParts.length - 1){
				    p[c] = mergeObject(p[c], exports[i]);
				}
				return p[c];
			}, global);
		});
		if(jq){
      if (jQuery.holdReady) {
        jQuery.holdReady(false);
      }else{
        jQuery.ready(true);
      }
    }
	}); 

})(this);Object.defineProperty(sap.viz.api, 'VERSION', { value: '2.0', writable: false });
Object.defineProperty(sap.viz.extapi, 'VERSION', { value: '2.0', writable: false });