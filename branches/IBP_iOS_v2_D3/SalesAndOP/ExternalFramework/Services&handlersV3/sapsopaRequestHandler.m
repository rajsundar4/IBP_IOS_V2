/*
 Auto-Generated by SAP NetWeaver Gateway Productivity Accelerator, Version 1.1.1
 
 File: sapsopaRequestHandler.m
 Abstract: A singleton class responsible for sending the appropriate service requests (for retrieving and modifying service data) and parsing the responses into semantic objects, using the sapsopa service proxy and the SDMConnectivityHelper class. The sent requests also consider the service URL and the SAP client defined in the application settings. The class is also responsible for sending the appropriate notifications to the application delegate and view controllers, for handling the request success, failure and authentication challenge.  
 
*/
 
#import "sapsopaRequestHandler.h"
#import "RequestBuilder.h"
#import "Request.h"
#import "Logger.h"
#import "ErrorHandling.h"
#import "ConnectivitySettings.h"
#import "UsernamePasswordAuthenticator.h"
#import "PortalAuthenticator.h"
#import "CertificateAuthenticator.h"
#import "FormsBasedSAMLAuthenticator.h"
#import "KeychainHelper.h"
#import "SUPHelper.h"
#import "ServiceErrorXmlParser.h"
#import "ServiceErrorJsonParser.h"
#import "FormDataRequest.h"
//#import "SDMHttpRequest.h"


NSString * const kOdataBaseService = @"/sap/sop/sopfnd/services/analytics/sapsopa.xsodata";
NSString * const kTokenService = @"/sap/hana/xs/formLogin/token.xsjs";
NSString * const kLoginForm = @"/sap/hana/xs/formLogin/login.xscfunc";
NSString * const kLogoutForm = @"/sap/hana/xs/formLogin/logout.xscfunc";
NSString * const kReportviewService = @"/sap/sop/sopfnd/services/analytics/sopa.xsjs";
NSString * const kUserpreferenceService = @"/sap/sop/services/userpreference.xsjs";
NSString * const kUserFavoritesService = @"/sap/sop/services/favorites.xsjs";
NSString * const kUserSessionService = @"/sap/sop/services/usersession.xsjs";
NSString * const kGenericReadModel = @"/sap/sop/sopfnd/services/model/genericReadModel.xsjs";

//NSString * const kJamCollaborationConfig = @"/sap/sop/jam/CollaborationServices.xsjs?objname=CollaborationConfig";
//NSString * const kJamCollaborationRegistration = @"/sap/sop/jam/CollaborationServices.xsjs?objname=CollaborationRegistration";
//NSString * const kJamCollaborationSession = @"/sap/sop/jam/CollaborationServices.xsjs?objname=CollaborationSession";
//NSString * const kJamGetGroups = @"/sap/sop/jamCollaborationServices.xsjs?objname=Groups&action=getGroups";




#pragma mark - Notifications

NSString * const kResponseItem = @"item";
NSString * const kResponseItems = @"items";
NSString * const kResponseData = @"data";
NSString * const kRequestedMediaLink = @"mediaLink";
NSString * const kServerResponseError = @"serverError";
NSString * const kParsingError = @"parsingError";
NSString * const kResponseParentItem = @"parent";
NSString * const kBatchRequest = @"BatchRequest";

// Notification keys:
NSString * const kAuthenticationNeededNotification = @"AuthenticationNeeded";
NSString * const kBatchCompletedNotification = @"BatchCompletedNotification";

static NSString * const kRequestUserInfoCompletedNotification = @"requestCompletedNotificaiton";




NSString * const kLoadExcludecharsCompletedNotification = @"LoadExcludecharsCompleted";
NSString * const kLoadExcludecharsTypeCompletedNotification = @"LoadExcludecharsTypeCompleted";
NSString * const kCreateExcludecharsTypeCompletedNotification = @"CreateExcludecharsTypeCompleted";
NSString * const kUpdateExcludecharsTypeCompletedNotification = @"UpdateExcludecharsTypeCompleted";
NSString * const kDeleteExcludecharsTypeCompletedNotification = @"DeleteExcludecharsTypeCompleted";

NSString * const kLoadReportpagedefaultCompletedNotification = @"LoadReportpagedefaultCompleted";
NSString * const kLoadReportpagedefaultTypeCompletedNotification = @"LoadReportpagedefaultTypeCompleted";
NSString * const kCreateReportpagedefaultTypeCompletedNotification = @"CreateReportpagedefaultTypeCompleted";
NSString * const kUpdateReportpagedefaultTypeCompletedNotification = @"UpdateReportpagedefaultTypeCompleted";
NSString * const kDeleteReportpagedefaultTypeCompletedNotification = @"DeleteReportpagedefaultTypeCompleted";

NSString * const kLoadReportsCompletedNotification = @"LoadReportsCompleted";
NSString * const kLoadReportsTypeCompletedNotification = @"LoadReportsTypeCompleted";
NSString * const kLoadReportForReportsTypeCompletedNotification = @"LoadReportForReportsTypeCompleted";
NSString * const kLoadReportqueryconstraintsForReportsTypeCompletedNotification = @"LoadReportqueryconstraintsForReportsTypeCompleted";
NSString * const kLoadReportviewsfilterForReportsTypeCompletedNotification = @"LoadReportviewsfilterForReportsTypeCompleted";
NSString * const kCreateReportsTypeCompletedNotification = @"CreateReportsTypeCompleted";
NSString * const kUpdateReportsTypeCompletedNotification = @"UpdateReportsTypeCompleted";
NSString * const kDeleteReportsTypeCompletedNotification = @"DeleteReportsTypeCompleted";

NSString * const kLoadReportpagesCompletedNotification = @"LoadReportpagesCompleted";
NSString * const kLoadReportpagesTypeCompletedNotification = @"LoadReportpagesTypeCompleted";
NSString * const kLoadReportpagelayoutForReportpagesTypeCompletedNotification = @"LoadReportpagelayoutForReportpagesTypeCompleted";
NSString * const kLoadSharedobjectsForReportpagesTypeCompletedNotification = @"LoadSharedobjectsForReportpagesTypeCompleted";
NSString * const kLoadReportpagenavForReportpagesTypeCompletedNotification = @"LoadReportpagenavForReportpagesTypeCompleted";
NSString * const kCreateReportpagesTypeCompletedNotification = @"CreateReportpagesTypeCompleted";
NSString * const kUpdateReportpagesTypeCompletedNotification = @"UpdateReportpagesTypeCompleted";
NSString * const kDeleteReportpagesTypeCompletedNotification = @"DeleteReportpagesTypeCompleted";

NSString * const kLoadReportviewsCompletedNotification = @"LoadReportviewsCompleted";
NSString * const kLoadReportviewsTypeCompletedNotification = @"LoadReportviewsTypeCompleted";
NSString * const kLoadReportviewForReportviewsTypeCompletedNotification = @"LoadReportviewForReportviewsTypeCompleted";
NSString * const kLoadSharedobjectsForReportviewsTypeCompletedNotification = @"LoadSharedobjectsForReportviewsTypeCompleted";
NSString * const kLoadReportviewpagesForReportviewsTypeCompletedNotification = @"LoadReportviewpagesForReportviewsTypeCompleted";
NSString * const kLoadReportviewwbfavForReportviewsTypeCompletedNotification = @"LoadReportviewwbfavForReportviewsTypeCompleted";
NSString * const kCreateReportviewsTypeCompletedNotification = @"CreateReportviewsTypeCompleted";
NSString * const kUpdateReportviewsTypeCompletedNotification = @"UpdateReportviewsTypeCompleted";
NSString * const kDeleteReportviewsTypeCompletedNotification = @"DeleteReportviewsTypeCompleted";

NSString * const kLoadReportpagelayoutCompletedNotification = @"LoadReportpagelayoutCompleted";
NSString * const kLoadReportpagelayoutTypeCompletedNotification = @"LoadReportpagelayoutTypeCompleted";
NSString * const kLoadReportviewForReportpagelayoutTypeCompletedNotification = @"LoadReportviewForReportpagelayoutTypeCompleted";
NSString * const kCreateReportpagelayoutTypeCompletedNotification = @"CreateReportpagelayoutTypeCompleted";
NSString * const kUpdateReportpagelayoutTypeCompletedNotification = @"UpdateReportpagelayoutTypeCompleted";
NSString * const kDeleteReportpagelayoutTypeCompletedNotification = @"DeleteReportpagelayoutTypeCompleted";

NSString * const kLoadReportviewCompletedNotification = @"LoadReportviewCompleted";
NSString * const kLoadReportviewTypeCompletedNotification = @"LoadReportviewTypeCompleted";
NSString * const kCreateReportviewTypeCompletedNotification = @"CreateReportviewTypeCompleted";
NSString * const kUpdateReportviewTypeCompletedNotification = @"UpdateReportviewTypeCompleted";
NSString * const kDeleteReportviewTypeCompletedNotification = @"DeleteReportviewTypeCompleted";

NSString * const kLoadReportCompletedNotification = @"LoadReportCompleted";
NSString * const kLoadReportTypeCompletedNotification = @"LoadReportTypeCompleted";
NSString * const kCreateReportTypeCompletedNotification = @"CreateReportTypeCompleted";
NSString * const kUpdateReportTypeCompletedNotification = @"UpdateReportTypeCompleted";
NSString * const kDeleteReportTypeCompletedNotification = @"DeleteReportTypeCompleted";

NSString * const kLoadReportqueryconstraintsCompletedNotification = @"LoadReportqueryconstraintsCompleted";
NSString * const kLoadReportqueryconstraintsTypeCompletedNotification = @"LoadReportqueryconstraintsTypeCompleted";
NSString * const kCreateReportqueryconstraintsTypeCompletedNotification = @"CreateReportqueryconstraintsTypeCompleted";
NSString * const kUpdateReportqueryconstraintsTypeCompletedNotification = @"UpdateReportqueryconstraintsTypeCompleted";
NSString * const kDeleteReportqueryconstraintsTypeCompletedNotification = @"DeleteReportqueryconstraintsTypeCompleted";

NSString * const kLoadReportviewsfilterCompletedNotification = @"LoadReportviewsfilterCompleted";
NSString * const kLoadReportviewsfilterTypeCompletedNotification = @"LoadReportviewsfilterTypeCompleted";
NSString * const kCreateReportviewsfilterTypeCompletedNotification = @"CreateReportviewsfilterTypeCompleted";
NSString * const kUpdateReportviewsfilterTypeCompletedNotification = @"UpdateReportviewsfilterTypeCompleted";
NSString * const kDeleteReportviewsfilterTypeCompletedNotification = @"DeleteReportviewsfilterTypeCompleted";

NSString * const kLoadSharedobjectsCompletedNotification = @"LoadSharedobjectsCompleted";
NSString * const kLoadSharedobjectsTypeCompletedNotification = @"LoadSharedobjectsTypeCompleted";
NSString * const kCreateSharedobjectsTypeCompletedNotification = @"CreateSharedobjectsTypeCompleted";
NSString * const kUpdateSharedobjectsTypeCompletedNotification = @"UpdateSharedobjectsTypeCompleted";
NSString * const kDeleteSharedobjectsTypeCompletedNotification = @"DeleteSharedobjectsTypeCompleted";

NSString * const kLoadReportpagenavCompletedNotification = @"LoadReportpagenavCompleted";
NSString * const kLoadReportpagenavTypeCompletedNotification = @"LoadReportpagenavTypeCompleted";
NSString * const kCreateReportpagenavTypeCompletedNotification = @"CreateReportpagenavTypeCompleted";
NSString * const kUpdateReportpagenavTypeCompletedNotification = @"UpdateReportpagenavTypeCompleted";
NSString * const kDeleteReportpagenavTypeCompletedNotification = @"DeleteReportpagenavTypeCompleted";

NSString * const kLoadReportviewpagesCompletedNotification = @"LoadReportviewpagesCompleted";
NSString * const kLoadReportviewpagesTypeCompletedNotification = @"LoadReportviewpagesTypeCompleted";
NSString * const kCreateReportviewpagesTypeCompletedNotification = @"CreateReportviewpagesTypeCompleted";
NSString * const kUpdateReportviewpagesTypeCompletedNotification = @"UpdateReportviewpagesTypeCompleted";
NSString * const kDeleteReportviewpagesTypeCompletedNotification = @"DeleteReportviewpagesTypeCompleted";

NSString * const kLoadReportviewwbfavCompletedNotification = @"LoadReportviewwbfavCompleted";
NSString * const kLoadReportviewwbfavTypeCompletedNotification = @"LoadReportviewwbfavTypeCompleted";
NSString * const kCreateReportviewwbfavTypeCompletedNotification = @"CreateReportviewwbfavTypeCompleted";
NSString * const kUpdateReportviewwbfavTypeCompletedNotification = @"UpdateReportviewwbfavTypeCompleted";
NSString * const kDeleteReportviewwbfavTypeCompletedNotification = @"DeleteReportviewwbfavTypeCompleted";

















#pragma mark -

// Service Negotiation constants (used for the service negotiation process):
static NSString * const CatalogServiceUrl = @"/sap/opu/odata/iwfnd/CatalogService/";
static NSString * const TechnicalServiceName = @"";
static NSInteger const TechnicalServiceVersionMin = 0;
static NSInteger const TechnicalServiceVersionMax = 0;

@implementation sapsopaRequestHandler

//
//  Adde by LLC
//

- (BOOL) executeSOPLogoutAndReturnError:(__autoreleasing NSError **) aError
{
    // First get a new csrf token.
    // This is a change required by support pack on hana system.
    
    NSString *serverURL = [NSString stringWithFormat:@"%@%@", self.baseServerURL, kTokenService];
    Request *sopRequest = [Request requestWithURL:[NSURL URLWithString: serverURL]];
    NSLog(@"Request initialized with token URL: %@", serverURL);
    
    [sopRequest addRequestHeader:@"X-CSRF-Token" value:@"Fetch"];
    NSLog(@"Completed token request setup...now starting sync.");
    
    [sopRequest setRequestMethod:@"GET"];
    [sopRequest buildRequestHeaders];
    [sopRequest startSynchronous];
    NSLog(@"response cookies: %@", [sopRequest responseCookies]);
    NSLog(@"response string: %@", [sopRequest responseString]);
    NSLog(@"Response headers: %@", [sopRequest responseHeaders]);
    NSLog(@"Response status code: %d", [sopRequest responseStatusCode]);
    
    // Check http response code for errors
    if ([sopRequest responseStatusCode] != 200) {
        // Check to see that the error parameter was passed in
        if (aError != NULL) {
            // Insert code to populate NSError object
            NSError *returnError = [sopRequest error];
            *aError = [[NSError alloc] initWithDomain:[returnError domain] code:[returnError code] userInfo:[returnError userInfo]];
        }
        return NO;
    }
    
    NSDictionary *cookieDict = [NSHTTPCookie requestHeaderFieldsWithCookies:[sopRequest responseCookies]];
    NSLog(@" Cookie dictionary count:  %d", [cookieDict count]);
    NSLog(@"cookie dictionary: %@", cookieDict);
    
    //NSLog(@"Response data: %@", [sopRequest responseData]);
    NSDictionary *headerDict = sopRequest.responseHeaders;
    //NSString *csrfToken = [headerDict objectForKey:@"x-csrf-token"];
    //NSLog(@"CSRF Token: %@", csrfToken);
    [self setCsrfToken:[headerDict objectForKey:@"x-csrf-token"]];
    NSLog(@"CSRF Token: %@", [self csrfToken]);
    
    sopRequest = nil;
    
    // Now call the logout with the new csrf token.
    
    serverURL = [NSString stringWithFormat:@"%@%@", self.baseServerURL, kLogoutForm];
    NSLog(@"Logout form url: %@", serverURL);
    sopRequest = [FormDataRequest requestWithURL:[NSURL URLWithString:serverURL]];
    NSLog(@"Request initialized with URL.");
    [sopRequest setRequestMethod:@"POST"];
    [sopRequest addRequestHeader:@"X-CSRF-Token" value:[self csrfToken]];
    [sopRequest buildPostBody];
    [sopRequest buildRequestHeaders];
    NSLog(@"request cookies: %@", [sopRequest requestCookies]);
    NSLog(@"request headers: %@", [sopRequest requestHeaders]);
    
    [sopRequest startSynchronous];
    NSLog(@"response cookies: %@", [sopRequest responseCookies]);
    NSLog(@"response string: %@", [sopRequest responseString]);
    NSLog(@"Response headers: %@", [sopRequest responseHeaders]);
    NSLog(@"Response status code: %d", [sopRequest responseStatusCode]);
    
    // Check http response code for errors
    // Modified to exclude 403 error due to bug in SAP server code.  Sessions are not being terminated.
    // Fixed.
    if ([sopRequest responseStatusCode] != 200) {
        //if ([sopRequest responseStatusCode] != 200  || [sopRequest responseStatusCode] != 403) {
        
        // Check to see that the error parameter was passed in
        if (aError != NULL) {
            // Insert code to populate NSError object
            NSError *returnError = [sopRequest error];
            *aError = [[NSError alloc] initWithDomain:[returnError domain] code:[returnError code] userInfo:[returnError userInfo]];
        }
        return NO;
    }
    [self setCsrfToken:nil];
    [self setXsSessionId:nil];
    
    return YES;
    
}

- (void) retrieveCookies
{
    NSArray *cookies;
    NSDictionary *cookieHeaders;
    
    cookies = [[NSHTTPCookieStorage sharedHTTPCookieStorage] cookies];
    cookieHeaders = [NSHTTPCookie requestHeaderFieldsWithCookies:cookies];
    
    NSLog(@"cookies: %@", cookieHeaders);
}

- (void) clearCookies
{
    // Clear xsSessionId and sapxslb cookies.
    
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    for (NSHTTPCookie *each in cookieStorage.cookies) {
        DLog(@"clearCookies:  Cookie name: %@", each.name);
        if ([each.name isEqualToString:@"xsSessionId"] || [each.name isEqualToString:@"sapxslb"])
            [cookieStorage deleteCookie:each];
    }
}

//
//  Added by LLC
//
- (BOOL) executeSOPLoginWithUsername:(NSString *) aUsername andPassword:(NSString *) aPassword andReturnError:(__autoreleasing NSError **) aError
{
    //  Required modifications:
    //  Use ConnectivityHelper create-sync call for POST to login form.
    //  Use ConnectivityHelper call to get CSRF token
    //  Create url from settings appending path to login script.
    
    [self retrieveCookies];
    [self clearCookies];
    [self retrieveCookies];
 
    //  First get the session ID and CSRF token
    NSLog(@"Inside executeSOPLogin function.");
    NSString *serverURL = [NSString stringWithFormat:@"%@%@", self.baseServerURL, kTokenService];
    Request *sopRequest = [Request requestWithURL:[NSURL URLWithString: serverURL]];
    NSLog(@"Request initialized with login URL: %@", serverURL);
    
    [sopRequest addRequestHeader:@"X-CSRF-Token" value:@"Fetch"];
    NSLog(@"Completed request setup...now starting sync.");
    
    [sopRequest setRequestMethod:@"GET"];
    [sopRequest buildRequestHeaders];
    [sopRequest startSynchronous];
    NSLog(@"response cookies: %@", [sopRequest responseCookies]);
    NSLog(@"response string: %@", [sopRequest responseString]);
    NSLog(@"Response headers: %@", [sopRequest responseHeaders]);
    NSLog(@"Response status code: %d", [sopRequest responseStatusCode]);
    
    // Check http response code for errors
    if ([sopRequest responseStatusCode] != 200) {
        
        // Store response status code.
        if(!self.responseCode)
            [self setResponseCode:[sopRequest responseStatusCode]];
        
        // Check to see that the error parameter was passed in
        if (aError != NULL) {
            // Insert code to populate NSError object
            NSError *returnError = [sopRequest error];
            *aError = [[NSError alloc] initWithDomain:[returnError domain] code:[returnError code] userInfo:[returnError userInfo]];
        }
        return NO;
    }
    
    NSDictionary *cookieDict = [NSHTTPCookie requestHeaderFieldsWithCookies:[sopRequest responseCookies]];
    NSLog(@" Cookie dictionary count:  %d", [cookieDict count]);
    NSLog(@"cookie dictionary: %@", cookieDict);
    
    
    //NSLog(@"Response data: %@", [sopRequest responseData]);
    NSDictionary *headerDict = sopRequest.responseHeaders;
    //NSString *csrfToken = [headerDict objectForKey:@"x-csrf-token"];
    //NSLog(@"CSRF Token: %@", csrfToken);
    [self setCsrfToken:[headerDict objectForKey:@"x-csrf-token"]];
    NSLog(@"CSRF Token: %@", [self csrfToken]);
    NSString *setCookie = [headerDict objectForKey:@"Set-Cookie"];
    NSLog(@"Set-Cookie header:  %@", setCookie);
    NSString *sessionString = @"xsSessionId=";
    NSRange range = [setCookie rangeOfString:sessionString];
    range.location = range.location + [sessionString length];
    range.length = 32;
    //NSString *xsSessionId = [setCookie substringWithRange:range];
    //NSLog(@"xs Session ID:  %@", xsSessionId);
    //[self setXsSessionId:[setCookie substringWithRange:range]];
    NSLog(@"xs Session ID:  %@", [self xsSessionId]);
    
    NSArray *cookieArray = sopRequest.responseCookies;
    NSLog(@"Response cookieArray item count:  %d", [cookieArray count]);
    for (int i=0; i<[cookieArray count];i++)
        NSLog(@"Cookie array object %i: %@", i, [cookieArray objectAtIndex:i]);
    
    // Use login form to authenticate user.
    serverURL = [NSString stringWithFormat:@"%@%@", self.baseServerURL, kLoginForm];
    NSLog(@"Login form url: %@", serverURL);
    FormDataRequest *sopRequest2 = [FormDataRequest requestWithURL:[NSURL URLWithString:serverURL]];
    NSLog(@"Request initialized with URL.");
    [sopRequest2 setRequestMethod:@"POST"];
    [sopRequest2 addRequestHeader:@"X-CSRF-Token" value:[self csrfToken]];
    //[sopRequest2 addRequestHeader:@"X-CSRF-Token" value:csrfToken];
    [sopRequest2 addPostValue:aUsername forKey:@"xs-username"];
    [sopRequest2 addPostValue:aPassword forKey:@"xs-password"];
    [sopRequest2 buildPostBody];
    [sopRequest2 buildRequestHeaders];
    [sopRequest2 startSynchronous];
    NSLog(@"response cookies: %@", [sopRequest2 responseCookies]);
    NSLog(@"response string: %@", [sopRequest2 responseString]);
    NSLog(@"Response headers: %@", [sopRequest2 responseHeaders]);
    NSLog(@"Response status code: %d", [sopRequest2 responseStatusCode]);
    
    
    // Check http response code for errors
    // additional error checks to add:
    // -checks for session ID and CSRF token!
    if ([sopRequest2 responseStatusCode] != 200) {
        
        // Store response status code.
        if(!self.responseCode)
            [self setResponseCode:[sopRequest responseStatusCode]];
        
        // Check to see that the error parameter was passed in
        if (aError != NULL) {
            // Insert code to populate NSError object
            NSError *returnError = [sopRequest2 error];
            *aError = [[NSError alloc] initWithDomain:[returnError domain] code:[returnError code] userInfo:[returnError userInfo]];
        }
        return NO;
    }
    
    //  Get csrf token
    serverURL = [NSString stringWithFormat:@"%@%@", self.baseServerURL, kTokenService];
    Request *sopRequest3 = [Request requestWithURL:[NSURL URLWithString: serverURL]];
    NSLog(@"Request initialized with login URL: %@", serverURL);
    
    [sopRequest3 addRequestHeader:@"X-CSRF-Token" value:@"Fetch"];
    [sopRequest3 setRequestMethod:@"GET"];
    [sopRequest3 buildRequestHeaders];
    [sopRequest3 startSynchronous];
    NSLog(@"response cookies: %@", [sopRequest3 responseCookies]);
    NSLog(@"response string: %@", [sopRequest3 responseString]);
    NSLog(@"Response headers: %@", [sopRequest3 responseHeaders]);
    NSLog(@"Response status code: %d", [sopRequest3 responseStatusCode]);
    
    // Check http response code for errors
    if ([sopRequest3 responseStatusCode] != 200) {
        
        // Store response status code.
        if(!self.responseCode)
            [self setResponseCode:[sopRequest responseStatusCode]];
        
        // Check to see that the error parameter was passed in
        if (aError != NULL) {
            // Insert code to populate NSError object
            NSError *returnError = [sopRequest error];
            *aError = [[NSError alloc] initWithDomain:[returnError domain] code:[returnError code] userInfo:[returnError userInfo]];
        }
        return NO;
    }
    
    //NSLog(@"Response data: %@", [sopRequest3 responseData]);
    headerDict = sopRequest3.responseHeaders;
    NSString *csrfToken = [headerDict objectForKey:@"x-csrf-token"];
    NSLog(@"CSRF Token: %@", csrfToken);
    [self setCsrfToken:[headerDict objectForKey:@"x-csrf-token"]];
    NSLog(@"CSRF Token: %@", [self csrfToken]);

    
    return YES;
}


/*!
 @function loadReportJsonSyncWithReportview:andReturnError
 @abstract -
 @discussion Retrieves Json dataset from S&OP system
 @param  NSString* Reportview (chart) ID, NSError aError
 @result NSDictionary data.
 */

- (NSDictionary *) loadReportJsonSyncWithReportview:(NSString *) aReportview andReturnError:(__autoreleasing NSError **) aError
{
    DLog(@"Inside loadReportJsonSync function.");
    NSError *jsonError = [[NSError alloc] init];
    NSDictionary *buffer = [NSDictionary dictionaryWithObjectsAndKeys:@"getReportViewData", @"ACTION", aReportview, @"reportview", nil];
    NSData* jsonData = [NSJSONSerialization dataWithJSONObject:buffer options:NSJSONWritingPrettyPrinted error:&jsonError ];
    
    if (!jsonData) {
        // Check to see that the error parameter was passed in
        //if (aError != NULL) {
        if (aError != NULL) {
            // Insert code to populate NSError object
            *aError = [[NSError alloc] initWithDomain:[jsonError domain] code:[jsonError code] userInfo:[jsonError userInfo]];
        }
        return nil;
    }
    
    NSString *serverURL = [NSString stringWithFormat:@"%@%@", self.baseServerURL, kReportviewService];
    DLog(@"serverURL string:  %@", serverURL);
    Request *sopRequest = [Request requestWithURL:[NSURL URLWithString: serverURL]];
    [sopRequest setRequestMethod:@"POST"];
    [sopRequest addRequestHeader:@"X-CSRF-Token" value:[self csrfToken]];
    [sopRequest appendPostData:jsonData];
    [sopRequest buildPostBody];
    [sopRequest buildRequestHeaders];
    
    NSLog(@"request cookies: %@", [sopRequest requestCookies]);
    NSLog(@"request headers: %@", [sopRequest requestHeaders]);
    //NSString *postBody = (NSString *)[sopRequest.postBody get
    
    //NSLog(@"post body: %@", postBody);
    
    [sopRequest startSynchronous];
    
    NSLog(@"response cookies: %@", [sopRequest responseCookies]);
    NSLog(@"response string: %@", [sopRequest responseString]);
    NSLog(@"Response headers: %@", [sopRequest responseHeaders]);
    NSLog(@"Response status code: %d", [sopRequest responseStatusCode]);
    NSLog(@"Response status message: %@", [sopRequest responseStatusMessage]);
    NSLog(@"Response data: %@", [sopRequest responseData]);
    
    // Check http response code for errors
    // Note:  Can receive 200 status but still receive no data!
    
    if ([sopRequest responseStatusCode] != 200) {
        // Check to see that the error parameter was passed in
        if (aError != NULL) {
            // Insert code to populate NSError object
            NSError *returnError = [sopRequest error];
            *aError = [[NSError alloc] initWithDomain:[returnError domain] code:[returnError code] userInfo:[returnError userInfo]];
            //*aError = [[NSError alloc] initWithDomain:@"JSONCallError" code:[sopRequest responseStatusCode] userInfo:[sopRequest responseStatusMessage]];
        }
        return nil;
    }
    
    NSData *responseData = [NSData dataWithData:[sopRequest responseData]];
    NSDictionary *data = [NSJSONSerialization JSONObjectWithData: responseData options:NSJSONReadingMutableContainers error:&jsonError];
    
    //if (!data) {
    if ([jsonError code]) {
        if (aError != NULL) {
            // Insert code to populate NSError object
            *aError = [[NSError alloc] initWithDomain:[jsonError domain] code:[jsonError code] userInfo:[jsonError userInfo]];
        }
    }
    
    if ([data count] == 0) {
        // Check to see that the error parameter was passed in
        if (aError != NULL) {
            // Insert code to populate NSError object
            NSDictionary *errorDict = [[NSDictionary alloc] initWithObjectsAndKeys:@"No data returned from json call.", @"jsonError", nil];
            *aError = [[NSError alloc] initWithDomain:@"loadReportJsonSyncWithReportview" code:100 userInfo:errorDict];
        }
    }
    
    if ([data isKindOfClass:[NSDictionary class]]) {
        NSDictionary *tempDict = [data objectForKey:@"d"];
        NSMutableArray *dataArray = [tempDict objectForKey:@"results"];
        return dataArray;
    } else {
        return data;
    }
    
    DLog(@"In method-JSON data: %@", data);
    

    // Filter data to eliminate new strings introduced with S&OP 3.0.1.4
    //NSMutableDictionary *dResponseData = [data objectForKey:@"d"];
    //DLog(@"dResponseData: %@", dResponseData);
    //NSMutableDictionary *resultsData = [dResponseData objectForKey:@"results"];
    //DLog(@"resultsData: %@", resultsData);
    
    //return resultsData;
    return data;
}

//
//  Added by LLC
//

- (BOOL) getUserSession:(NSString *) aUsername andReturnError:(__autoreleasing NSError **) aError
{
    NSError *jsonError = [[NSError alloc] init];
    NSString *serverURL = [NSString stringWithFormat:@"%@%@?api=userName", self.baseServerURL, kUserSessionService];
    NSLog(@"url: %@", serverURL);
    
    Request *sopRequest = [Request requestWithURL:[NSURL URLWithString: serverURL]];
    [sopRequest setRequestMethod:@"GET"];
    NSLog(@"request headers:  %@", [sopRequest requestHeaders]);
    NSLog(@"cookie headers:  %@", [sopRequest requestCookies]);
    [sopRequest buildRequestHeaders];
    NSLog(@"request headers:  %@", [sopRequest requestHeaders]);
    NSLog(@"cookie headers:  %@", [sopRequest requestCookies]);
    [sopRequest startSynchronous];
    
    if ([sopRequest responseStatusCode] != 200) {
        // Check to see that the error parameter was passed in
        if (aError != NULL) {
            // Insert code to populate NSError object
            NSError *returnError = [sopRequest error];
            *aError = [[NSError alloc] initWithDomain:[returnError domain] code:[returnError code] userInfo:[returnError userInfo]];
        }
        return NO;
    }
    
    NSLog(@"response cookies: %@", [sopRequest responseCookies]);
    NSLog(@"response string: %@", [sopRequest responseString]);
    NSLog(@"Response headers: %@", [sopRequest responseHeaders]);
    NSLog(@"Response data: %@", [sopRequest responseData]);
    
    NSData *responseData = [NSData dataWithData:[sopRequest responseData]];
    NSDictionary *data = [NSJSONSerialization JSONObjectWithData: responseData options:NSJSONReadingMutableContainers error:&jsonError];
    
    NSString *ucUsername = [aUsername uppercaseString];
    if ([ucUsername isEqualToString:[data valueForKey:@"userName"]])
        return YES;
    else
        return NO;
}

//
//  Added by LLC
//

- (NSString *) getUserPlanningAreaWithUsername:(NSString *) aUsername andReturnError:(__autoreleasing NSError **) aError
{
    NSError* jsonError = [[NSError alloc] init];
    
    NSString *serverURL = [NSString stringWithFormat:@"%@%@?userid=%@&api=planArea", self.baseServerURL, kUserpreferenceService, aUsername];
    NSLog(@"url: %@", serverURL);
    
    
    Request *sopRequest = [Request requestWithURL:[NSURL URLWithString: serverURL]];
    [sopRequest setRequestMethod:@"GET"];
    [sopRequest buildRequestHeaders];
    [sopRequest startSynchronous];
    
    if ([sopRequest responseStatusCode] != 200) {
        // Check to see that the error parameter was passed in
        if (aError != NULL) {
            // Insert code to populate NSError object
            NSError *returnError = [sopRequest error];
            *aError = [[NSError alloc] initWithDomain:[returnError domain] code:[returnError code] userInfo:[returnError userInfo]];
        }
        return nil;
    }
    
    NSLog(@"response cookies: %@", [sopRequest responseCookies]);
    NSLog(@"response string: %@", [sopRequest responseString]);
    NSLog(@"Response headers: %@", [sopRequest responseHeaders]);
    NSLog(@"Response data: %@", [sopRequest responseData]);
    
    NSData *responseData = [NSData dataWithData:[sopRequest responseData]];
    NSDictionary *data = [NSJSONSerialization JSONObjectWithData: responseData options:NSJSONReadingMutableContainers error:&jsonError];
    
    if (!data) {
        // Check to see that the error parameter was passed in
        if (aError != NULL) {
            // Insert code to populate NSError object
            *aError = [[NSError alloc] initWithDomain:[jsonError domain] code:[jsonError code] userInfo:[jsonError userInfo]];
        }
        return nil;
    }
    //NSLog(@"In method-JSON data: %@", data);
    
    return [data valueForKey:@"PLAN_AREA"];
    
}

//
//  Added by LLC
//

- (NSDictionary *) getUserFavoritesWithUsername:(NSString *) aUsername andPlanArea:(NSString *) aPlanArea andReturnError:(__autoreleasing NSError **) aError
{
    NSError *jsonError = [[NSError alloc] init];
    
    NSDictionary *buffer = [NSDictionary dictionaryWithObjectsAndKeys:@"getFavorites", @"ACTION", aUsername, @"USERID", aPlanArea, @"PLANAREA",nil];
    NSData* jsonData = [NSJSONSerialization dataWithJSONObject:buffer options:NSJSONWritingPrettyPrinted error:&jsonError ];
    
    if (!jsonData) {
        // Check to see that the error parameter was passed in
        if (aError != NULL) {
            // Insert code to populate NSError object
            *aError = [[NSError alloc] initWithDomain:[jsonError domain] code:[jsonError code] userInfo:[jsonError userInfo]];
        }
        return nil;
    }
    NSString *serverURL = [NSString stringWithFormat:@"%@%@", self.baseServerURL, kUserFavoritesService];
    NSLog(@"getFavorites URL: %@", serverURL);
    
    Request *sopRequest = [Request requestWithURL:[NSURL URLWithString: serverURL]];
    [sopRequest setRequestMethod:@"POST"];
    [sopRequest appendPostData:jsonData];
    [sopRequest buildPostBody];
    [sopRequest buildRequestHeaders];
    [sopRequest startSynchronous];
    
    if ([sopRequest responseStatusCode] != 200) {
        // Check to see that the error parameter was passed in
        if (aError != NULL) {
            // Insert code to populate NSError object
            NSError *returnError = [sopRequest error];
            *aError = [[NSError alloc] initWithDomain:[returnError domain] code:[returnError code] userInfo:[returnError userInfo]];
        }
        return nil;
    }
    
    NSLog(@"response cookies: %@", [sopRequest responseCookies]);
    NSLog(@"response string: %@", [sopRequest responseString]);
    NSLog(@"Response headers: %@", [sopRequest responseHeaders]);
    NSLog(@"Response data: %@", [sopRequest responseData]);
    
    NSData *responseData = [NSData dataWithData:[sopRequest responseData]];
    NSDictionary *data = [NSJSONSerialization JSONObjectWithData: responseData options:NSJSONReadingMutableContainers error:&jsonError];
    
    if (!data) {
        // Check to see that the error parameter was passed in
        if (aError != NULL) {
            // Insert code to populate NSError object
            *aError = [[NSError alloc] initWithDomain:[jsonError domain] code:[jsonError code] userInfo:[jsonError userInfo]];
        }
        return nil;
    }
    //NSLog(@"In method-JSON data: %@", data);
    
    return data;
    
}


#pragma mark - Initialization

- (id)init
{
    self = [super init];
    if (self) { 
        service = [[sapsopaService alloc] init]; // This will be re-initiated with the updated metadata from the server (according to the user locale), in first login. See executeLoginWithUsername:andPassword:error method implementation.
		
        connectivityHelper = [[SDMConnectivityHelper alloc] init];
        connectivityHelper.delegate = self;
        
        self.useServiceNegotiation = YES; // Can be later set to 'NO' to disable service negotiation
        
        deviceLanguage = [NSLocale preferredLanguages][0]; // Language ISO 639 code (2 letters)
    }
    return self;
}

#pragma mark - Singleton

+ (sapsopaRequestHandler *)uniqueInstance
{
    static sapsopaRequestHandler *instance;
	
    @synchronized(self) {
        if (!instance) {
            instance = [[sapsopaRequestHandler alloc] init];
        }
        return instance;
    }
}

#pragma mark - User Login

- (NSData *)executeServiceDocumentRequestAndReturnError:(NSError * __autoreleasing *)error
{
    id<Requesting> serviceDocumentRequest = [connectivityHelper executeBasicSyncRequestWithQuery:[[ODataQuery alloc] initWithURL:[NSURL URLWithString:self.serviceDocumentURL]]];
    
    if ((!serviceDocumentRequest.error) && (serviceDocumentRequest.responseStatusCode == 200) && serviceDocumentRequest.responseData) {
        //Authentication succeeded
        return serviceDocumentRequest.responseData;
    }
    else {
        //Authentication failed
        NSString *errorMessage = NSLocalizedString(@"Login failed.", @"Login failed.");
        if (error) {
            *error = [[NSError alloc] initWithDomain:ERROR_DOMAIN code:LOGIN_ERROR_CODE userInfo:@{NSLocalizedDescriptionKey: errorMessage}];
        }
        LOGERROR(@"Error getting service document. Login failed.");
        return nil;
    }
}

- (NSData *)executeServiceMetadataRequestAndReturnError:(NSError * __autoreleasing *)error
{
    NSString *serviceMetadataUrl = [NSString stringWithFormat:@"%@/$metadata",self.serviceDocumentURL];
    id<Requesting> serviceMetadataRequest = [connectivityHelper executeBasicSyncRequestWithQuery:[[ODataQuery alloc] initWithURL:[NSURL URLWithString:serviceMetadataUrl]]];
    
    if ((!serviceMetadataRequest.error) && (serviceMetadataRequest.responseStatusCode == 200) && serviceMetadataRequest.responseData) {
        //Authentication succeeded
        return serviceMetadataRequest.responseData;
    }
    else {
        //Authentication failed
        NSString *errorMessage = NSLocalizedString(@"Login failed.", @"Login failed.");
        if (error) {
            *error = [[NSError alloc] initWithDomain:ERROR_DOMAIN code:LOGIN_ERROR_CODE userInfo:@{NSLocalizedDescriptionKey: errorMessage}];
        }
        LOGERROR(@"Error getting service metadata. Login failed");
        return nil;
    }
}

- (id <Authenticating>)activateCertificateAuthentication
{
    CertificateAuthenticator *authenticator = [[CertificateAuthenticator alloc] init];
    // The initialized certificate authenticator takes the certificate from the Keychain and exposes it using the following property
    certificate = authenticator.certificate;
    return authenticator;
}

- (id <Authenticating>)activatePortalAuthenticationWithUsername:(NSString *)aUsername andPassword:(NSString *)aPassword
{
    return [[PortalAuthenticator alloc] initWithUsername:aUsername andPassword:aPassword];
}

- (id <Authenticating>)activateUsernamePasswordAuthenticationWithUsername:(NSString *)aUsername andPassword:(NSString *)aPassword
{
    return [[UsernamePasswordAuthenticator alloc] initWithUsername:aUsername andPassword:aPassword];
}

- (id <Authenticating>)activateFormsBasedSAMLAuthenticationWithUsername:(NSString *)aUsername andPassword:(NSString *)aPassword
{
    return [[FormsBasedSAMLAuthenticator alloc] initWithUsername:aUsername andPassword:aPassword];
}

// Initiate the appropriate authenticating implementation according to the Authentication Type configured in the ConnectivitySettings.
- (id <Authenticating>)activateAuthenticationWithUsername:(NSString *)aUsername andPassword:(NSString *)aPassword
{
    id <Authenticating> authenticator;
    // in case in SUP mode, authentication type is defined between SUP Server and Gateway, so we need a simple UsernamePasswordAuthenticator
    if([ConnectivitySettings isSUPMode]) {
        return [[UsernamePasswordAuthenticator alloc] initWithUsername:aUsername andPassword:aPassword];
    }
    else if ([ConnectivitySettings isGWAASMode]) {
        // in case in GWaaS mode, authentication type is defined on the IDP, so we need the FormsBasedSAMLAuthenticator
        return [self activateFormsBasedSAMLAuthenticationWithUsername:aUsername andPassword:aPassword];
    }
    else {
        // in this case we don't use SUP server or GWaaS so we need to define the correct authenticator
        if ([ConnectivitySettings authenticationType] == UsernamePasswordAuthenticationType) {
            authenticator =  [self activateUsernamePasswordAuthenticationWithUsername:aUsername andPassword:aPassword];
        }
        else if ([ConnectivitySettings authenticationType] == PortalAuthenticationType) {
           authenticator =  [self activatePortalAuthenticationWithUsername:aUsername andPassword:aPassword];
        }
        else if ([ConnectivitySettings authenticationType] == CertificateAuthenticationType) {
            authenticator = [self activateCertificateAuthentication];
        }
        else if ([ConnectivitySettings authenticationType] == FormsBasedSAMLAuthenticationType) {
            authenticator = [self activateFormsBasedSAMLAuthenticationWithUsername:aUsername andPassword:aPassword];
        }
    }
    // Set SAP client:
    authenticator.sapClient = self.client; 
    
    return authenticator;
}

- (BOOL)isServiceDocumentURLValidAndReturnError:(NSError * __autoreleasing *)error
{
    if ([self.serviceDocumentURL length] == 0) {
        NSString *errorMessage = NSLocalizedString(@"Service URL is empty.", @"Service URL is empty.");
        if([ConnectivitySettings isSUPMode]) {
            errorMessage = NSLocalizedString(@"Application End Point URL returned from SUP server is empty.", @"Application End Point URL returned from SUP server is empty."); 
        }
        if (error) {
            *error = [[NSError alloc] initWithDomain:ERROR_DOMAIN code:SERVICE_URL_EMPTY_ERROR_CODE userInfo:@{NSLocalizedDescriptionKey: errorMessage}];
        }
        LOGERROR(errorMessage);
        return NO;
    }
    return YES;
}

- (BOOL)setURLAndClientWithSUPApplicationEndPointAndReturnError:(NSError * __autoreleasing *)error
{
    NSString *endPointURL = nil;
    if ([KeychainHelper isCredentialsSaved]){
        CredentialsData *credentials = [KeychainHelper loadCredentialsAndReturnError:error];
        if (credentials) {
            endPointURL = [SUPHelper getSUPApplicationEndPointWithCredentials:credentials error:error];
        }
    }
    
    if ([endPointURL length] == 0) {
        self.serviceDocumentURL = nil;
        self.client = nil;
        NSString *errorMessage = NSLocalizedString(@"Login failed.", @"Login failed.");
        if (error) {
            *error = [[NSError alloc] initWithDomain:ERROR_DOMAIN code:LOGIN_ERROR_CODE userInfo:@{NSLocalizedDescriptionKey: errorMessage}];
        }
        NSString *errorLogMessage = [NSString stringWithFormat:@"Error getting Application End Point URL from SUP server. Login failed. %@.",[*error localizedDescription]];
        LOGERROR(errorLogMessage);
        return NO;
    }
    
    // Extract Base URL and SAP Client from application end point URL:
    
    NSRange range = [endPointURL rangeOfString:@"?"];
    
    if (range.location != NSNotFound) {

        self.serviceDocumentURL = [endPointURL substringToIndex:range.location]; // URL without parameters
        
        // Extract SAP Client parameter:
        NSString *parameters = [endPointURL substringFromIndex:(range.location + range.length)];
        range = [parameters rangeOfString:@"sap-client="];
        NSString *clientValue = nil;
        if (range.location != NSNotFound) {
            
           clientValue = [parameters substringFromIndex:(range.location + range.length)];
            
            // Remove what's after & or / charachters (if exist) from client value
            NSRange range = [clientValue rangeOfString:@"&"];
            if (range.location == NSNotFound) {
               range = [clientValue rangeOfString:@"/"];        
            }
            if (range.location != NSNotFound) {
                clientValue = [clientValue substringToIndex:range.location];
            }
        }
        
        self.client = clientValue;
    }
    else {
        self.serviceDocumentURL = endPointURL;
        self.client = nil;
    }
    
    return YES;
}

- (BOOL)executeLoginWithUsername:(NSString *)aUsername andPassword:(NSString *)aPassword error:(NSError *__autoreleasing *)error
{
    // In case local metadata is used to initiate the service proxy, validate the service before continue with authentication flow
    if (self.useLocalMetadata && ![self isServiceValid]) {
        NSString *errorMessage = NSLocalizedString(@"Service metadata is invalid. Please contact your administrator.", @"Service metadata is invalid. Please contact your administrator.");
        if (error) {
            *error = [[NSError alloc] initWithDomain:ERROR_DOMAIN code:SERVICE_METADATA_PARSE_ERROR_CODE userInfo:@{NSLocalizedDescriptionKey: errorMessage}];
        }
        LOGERROR(errorMessage);
        return NO;
    }
    
    // Activate required authentication type (and set SAP client):
    id <Authenticating> authenticator = [self activateAuthenticationWithUsername:aUsername andPassword:aPassword];
    
    if ([ConnectivitySettings isSUPMode]) {
        // Get application end point from SUP server and use it as a base for the application requests.
        BOOL applicationEndPointReceived = [self setURLAndClientWithSUPApplicationEndPointAndReturnError:error];
        authenticator.sapClient = self.client;
        if (!applicationEndPointReceived) {
            return NO;
        }
    }
    
    // Check that the service URL property was set (from App Delegate or from SUP application end point)
    if (![self isServiceDocumentURLValidAndReturnError:error]) {
        return NO;
    }

    // In case local metadata is used, it's enought to call authenticator to validate credentials without parsing the response
    if (self.useLocalMetadata) {
        // Get service document using the authenticator (negotiation is not supported in this scenario):
        NSData *serviceDocumentData = [authenticator authenticateWithODataQuery:[[ODataQuery alloc] initWithURL:[NSURL URLWithString:self.serviceDocumentURL]] error:error];
        
        if (serviceDocumentData) {
            return YES;
        }
        return NO;
    }
    // In case local metadata is not used, negotiate the best matching service version, get the service data, the service metadata, and re-initialize the service proxy object
    else {
        //Negotiate using the authenticator:
        BOOL serviceNegotiationResult = [self negotiateServiceVersionAndUpdateServiceDocumentUrlUsingAuthenticator:authenticator error:error];
        
        NSData *serviceDocumentData = nil;
        if (serviceNegotiationResult) {
            LOGNOTICE(@"Service negotiation succeeded.");
            // Get service document without authentication (rely on session cookie)
            serviceDocumentData = [self executeServiceDocumentRequestAndReturnError:error];
        }
        else {
            // Get service document using the authenticator:
            serviceDocumentData = [authenticator authenticateWithODataQuery:[[ODataQuery alloc] initWithURL:[NSURL URLWithString:self.serviceDocumentURL]] error:error];
        }
        // Get service metadata and use it to init the service proxy object:
        if (serviceDocumentData) {
            NSData *serviceMetadataData = [self executeServiceMetadataRequestAndReturnError:error];
            if (serviceMetadataData) {
                service = [[sapsopaService alloc] initWithServiceDocument:serviceDocumentData andMedatadata:serviceMetadataData];
                [service setServiceDocumentUrl:self.serviceDocumentURL];
                if ([self isServiceValid]) {
                    return YES;
                }
                else {
                    NSString *errorMessage = NSLocalizedString(@"Service metadata is invalid. Please contact your administrator.", @"Service metadata is invalid. Please contact your administrator.");
                    if (error) {
                        *error = [[NSError alloc] initWithDomain:ERROR_DOMAIN code:SERVICE_METADATA_PARSE_ERROR_CODE userInfo:@{NSLocalizedDescriptionKey: errorMessage}];
                    }
                    LOGERROR(errorMessage);
                    return NO;
                }
            }
        }
        return NO;
    }    
}

- (BOOL)executeLoginWithCertificateWithPassword:(NSString *)aPassword andFileName:(NSString *)aFileName andFileExtension:(NSString *)aFileExtension error:(NSError *__autoreleasing *)error
{
    if ([ConnectivitySettings isSUPMode]) {
        NSString *thePath = [[NSBundle mainBundle]
                             pathForResource:aFileName ofType:aFileExtension];
        if ([thePath length] > 0) {
	        CredentialsData *credentialsData = nil;
            @try {
                credentialsData = [SUPHelper getCredentialsFromCertificateFile:thePath withCertificatePassword:aPassword error:error];
            }
            @catch (NSException* e) {
                NSString *logError = [e description];
                LOGERROR(logError);
            }
	        if (!credentialsData) {
	        	NSString *errorMessage = NSLocalizedString(@"Failed to get certificate string from file", @"Failed to get certificate string from file");
	        	if (error) {
                    if(*error) {
                        NSString *logMessage = [*error localizedDescription];
                        LOGERROR(logMessage);
                    }
                    else {
                        *error = [NSError errorWithDomain:ERROR_DOMAIN code:CERTIFICATE_HANDLING_ERROR_CODE userInfo:@{NSLocalizedDescriptionKey: errorMessage}];
                        LOGERROR(errorMessage);
                    }
                }
                else {
                    LOGERROR(errorMessage);
                }
                return NO;
            }
	        return [self executeLoginWithUsername:credentialsData.username andPassword:credentialsData.password error:error];
        }
        else {
        	NSString *localizedMessage = NSLocalizedString(@"Failed to extract Identity from certificate. Verify that certificate named %@.%@ exists", @"Failed to extract Identity from certificate. Verify that certificate named %@.%@ exists");
        	NSString *errorMessage = [NSString stringWithFormat:localizedMessage, aFileName, aFileExtension];
        	if(error) {
        		*error = [[NSError alloc] initWithDomain:ERROR_DOMAIN code:CERTIFICATE_HANDLING_ERROR_CODE userInfo:@{NSLocalizedDescriptionKey: errorMessage}];
        	}
        	LOGERROR(errorMessage);
        	return NO;
        }
    }
    return [self executeLoginWithUsername:nil andPassword:nil error:error];
}

- (BOOL)executeLoginWithCertificateWithError:(NSError *__autoreleasing *)error
{
    return [self executeLoginWithCertificateWithPassword:nil andFileName:nil andFileExtension:nil error:error];
}


#pragma mark - Service Negotitation Methods

- (NSData *)executeServiceNegotiationRequestUsingAuthenticator:(id <Authenticating>)authenticator AndReturnError:(NSError * __autoreleasing *)error
{
	NSData *serviceNegotiationResponse = nil;
    NSError *serviceNegotiationError = nil;
	
    ODataQuery *query = [serviceNegotiator getBestMatchingServiceQuery];
	if (query) {
		serviceNegotiationResponse = [authenticator authenticateWithODataQuery:query error:&serviceNegotiationError];
	}
	else {
		return nil;
	}
    
    if (!serviceNegotiationError) {
		return serviceNegotiationResponse;
    }
    else {
        NSString *errorMessage = NSLocalizedString(@"Service negotiation failed.", @"Service negotiation failed.");
        if (error) {
            *error = [[NSError alloc] initWithDomain:ERROR_DOMAIN code:SERVICE_NEGOTIATION_ERROR_CODE userInfo:@{NSLocalizedDescriptionKey: errorMessage}];
        }
        LOGERROR(@"Error getting best matching service. Service negotiation failed.");
        return nil;
    }
}

- (BOOL)negotiateServiceVersionAndUpdateServiceDocumentUrlUsingAuthenticator:(id <Authenticating>)authenticator error:(NSError * __autoreleasing *)error
{
	if (!self.useServiceNegotiation) {
		LOGNOTICE(@"Skipping service negotiation process.");
		return NO;
	}
		
	NSString *catalogServiceUrl = CatalogServiceUrl;
    // If in GWaaS mode then set appropriate catalog service url 
    if ([ConnectivitySettings isGWAASMode]) {
        catalogServiceUrl = @"/CATALOGSERVICE/";
    }
    
	// Initialize service negotiation object
	serviceNegotiator = [[ServiceNegotiator alloc] initWithServiceUrl:self.serviceDocumentURL andCatalogRelativeUrl:catalogServiceUrl];
	
	if (!serviceNegotiator) {
		LOGNOTICE(@"ServiceNegotiator was not initialized. Skipping service negotiation process.");
		return NO;
	}
	
	serviceNegotiator.technicalServiceName = TechnicalServiceName;
	serviceNegotiator.technicalServiceVersionMin = TechnicalServiceVersionMin;
	serviceNegotiator.technicalServiceVersionMax = TechnicalServiceVersionMax;
	
	NSData *serviceData = [self executeServiceNegotiationRequestUsingAuthenticator:authenticator AndReturnError:error];
	
	if (serviceData && [serviceNegotiator parseBestMatchingServiceResultWithData:serviceData]) {
		if (serviceNegotiator.bestMatchingServiceUrl && serviceNegotiator.bestMatchingServiceUrl.length > 0) {
			LOGNOTICE(@"Service negotiation process completed successfully. Updating service document URL.");
			self.serviceDocumentURL = serviceNegotiator.bestMatchingServiceUrl;
            // Make sure the service negotiation process runs only once.
            self.useServiceNegotiation = NO;
            return YES;
		}
	}
	return NO;
}

#pragma mark - Batch

- (void)startBatchWithNotificationName:(NSString *)aNotificationName
{
    [self loadCSRFData];
    
    NSDictionary *userInfoDict = nil;
    if ([aNotificationName length] > 0) {
        userInfoDict = @{kBatchCompletedNotification : aNotificationName};
    }
    [connectivityHelper startBatchAsyncWithURL:[[service.serviceDocumentQuery getUrl] absoluteString] andDelegate:self andSelector:@selector(executeBatchCompleted:) andUserInfo:userInfoDict];
}

- (void)closeExistingChangeSet
{
    [connectivityHelper closeExistingChangeSet];
}

- (void)executeBatch
{
    [connectivityHelper executeBatchAsync:csrfData];
}

- (void)executeBatchCompleted:(BatchRequest *)batchRequest
{
    NSArray *requests = [batchRequest requestArray];
    for (int i = 0; i < [requests count]; i++) {
        if ([requests[i] isKindOfClass:[NSArray class]]) {
            for (Request *request in requests[i]) {
                [self performSelectorOnMainThread:request.didFinishSelector withObject:request waitUntilDone:NO];
            }
        }
        else {
            [self performSelectorOnMainThread:((Request *)requests[i]).didFinishSelector withObject:requests[i] waitUntilDone:NO];
        }
    }
    
    NSDictionary *userInfo = batchRequest.userInfo;
    NSString *notificationName = userInfo[kBatchCompletedNotification];
    if ([notificationName length] > 0) {
        NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:userInfo];
        userInfoDict[kBatchRequest] = batchRequest;
        [[NSNotificationCenter defaultCenter] postNotificationName:notificationName object:self userInfo:userInfoDict];
    }

}

#pragma mark - Instance methods

- (BOOL)isServiceValid
{
    return (service != nil);
}

- (void)setServiceDocumentURL:(NSString *)serviceDocumentURL
{
    _serviceDocumentURL = serviceDocumentURL;
    
    if ([self.serviceDocumentURL length] > 0) {
        [service setServiceDocumentUrl:self.serviceDocumentURL];
    }
}

- (void)setSAPClient:(NSString *)client
{
    _client = client;
    connectivityHelper.sapClient = self.client;
}

- (void)loadCSRFData
{
    if (!csrfData ) {
        csrfData  = [connectivityHelper getCSRFDataForServiceQuery:service.serviceDocumentQuery];
    }
}




#pragma mark - excludechars methods
#pragma mark Read

- (void)loadExcludecharsCompleted:(id <Requesting>)request
{
    NSDictionary *userInfoDict;
    NSError *error;
    NSMutableArray *items = [service getExcludecharsWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict = @{kParsingError: error};
    }
    else {
    	userInfoDict = @{kResponseItems: items};
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadExcludecharsCompletedNotification object:self userInfo:userInfoDict];
}

- (void)loadExcludechars
{
    ODataQuery *query = service.excludecharsQuery;
    NSDictionary *userInfoDict = @{kRequestUserInfoCompletedNotification : kLoadExcludecharsCompletedNotification};
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadExcludecharsCompleted:) andUserInfo:userInfoDict];
}


- (void)loadExcludecharsTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSError *error;
    excludecharsType *item = [excludecharsType parseExcludecharsTypeEntryWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict[kParsingError] = error;
    }
    else {
    	userInfoDict[kResponseItem] = item;
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadExcludecharsTypeCompletedNotification object:self userInfo:userInfoDict];
}

- (void)loadExcludecharsType:(excludecharsType *)aExcludecharsType
{
    ODataQuery *query = [[ODataQuery alloc] initWithURL:aExcludecharsType.baseUrl];
    NSDictionary *userInfoDict = @{kResponseParentItem : aExcludecharsType, kRequestUserInfoCompletedNotification : kLoadExcludecharsTypeCompletedNotification};
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadExcludecharsTypeCompleted:) andUserInfo:userInfoDict];
}

#pragma mark Create

- (void)createExcludecharsTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        excludecharsType *item = [excludecharsType parseExcludecharsTypeEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kCreateExcludecharsTypeCompletedNotification object:self userInfo:userInfoDict];

}

- (void)createExcludecharsType:(excludecharsType *)aExcludecharsType
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aExcludecharsType error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aExcludecharsType error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateExcludecharsTypeCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aExcludecharsType , kRequestUserInfoCompletedNotification : kCreateExcludecharsTypeCompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:service.excludecharsQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createExcludecharsTypeCompleted:) andUserInfo:userInfoDict];
    }
}

#pragma mark Update

- (void)updateExcludecharsTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        excludecharsType *item = [excludecharsType parseExcludecharsTypeEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateExcludecharsTypeCompletedNotification object:self userInfo:userInfoDict];

}

- (void)updateExcludecharsType:(excludecharsType *)aExcludecharsType
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForUpdateRequest:aExcludecharsType error:&error];
    }
    else {
        payload = [service getXMLForUpdateRequest:aExcludecharsType error:&error];
    }
    
    if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateExcludecharsTypeCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        ODataQuery *query = [[ODataQuery alloc] initWithURL:aExcludecharsType.baseUrl];
    	NSDictionary *userInfoDict = @{kResponseParentItem : aExcludecharsType , kRequestUserInfoCompletedNotification : kUpdateExcludecharsTypeCompletedNotification};
    	[connectivityHelper executeUpdateAsyncRequestWithQuery:query andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(updateExcludecharsTypeCompleted:) andUserInfo:userInfoDict andEtag:aExcludecharsType.etag];
    }
}

#pragma mark Delete

- (void)deleteExcludecharsTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    [[NSNotificationCenter defaultCenter] postNotificationName:kDeleteExcludecharsTypeCompletedNotification object:self userInfo:userInfoDict];   
}

- (void)deleteExcludecharsType:(excludecharsType *)aExcludecharsType 
{
	[self loadCSRFData];
    ODataQuery *query = [[ODataQuery alloc] initWithURL:aExcludecharsType.baseUrl];
    NSDictionary *userInfoDict = @{kResponseParentItem : aExcludecharsType , kRequestUserInfoCompletedNotification : kDeleteExcludecharsTypeCompletedNotification};
    [connectivityHelper executeDeleteAsyncRequestWithQuery:query andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(deleteExcludecharsTypeCompleted:) andUserInfo:userInfoDict andEtag:aExcludecharsType.etag];
}

#pragma mark - reportpagedefault methods
#pragma mark Read

- (void)loadReportpagedefaultCompleted:(id <Requesting>)request
{
    NSDictionary *userInfoDict;
    NSError *error;
    NSMutableArray *items = [service getReportpagedefaultWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict = @{kParsingError: error};
    }
    else {
    	userInfoDict = @{kResponseItems: items};
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadReportpagedefaultCompletedNotification object:self userInfo:userInfoDict];
}

- (void)loadReportpagedefault
{
    ODataQuery *query = service.reportpagedefaultQuery;
    NSDictionary *userInfoDict = @{kRequestUserInfoCompletedNotification : kLoadReportpagedefaultCompletedNotification};
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadReportpagedefaultCompleted:) andUserInfo:userInfoDict];
}


- (void)loadReportpagedefaultTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSError *error;
    reportpagedefaultType *item = [reportpagedefaultType parseReportpagedefaultTypeEntryWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict[kParsingError] = error;
    }
    else {
    	userInfoDict[kResponseItem] = item;
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadReportpagedefaultTypeCompletedNotification object:self userInfo:userInfoDict];
}

- (void)loadReportpagedefaultType:(reportpagedefaultType *)aReportpagedefaultType
{
    ODataQuery *query = [[ODataQuery alloc] initWithURL:aReportpagedefaultType.baseUrl];
    NSDictionary *userInfoDict = @{kResponseParentItem : aReportpagedefaultType, kRequestUserInfoCompletedNotification : kLoadReportpagedefaultTypeCompletedNotification};
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadReportpagedefaultTypeCompleted:) andUserInfo:userInfoDict];
}

#pragma mark Create

- (void)createReportpagedefaultTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        reportpagedefaultType *item = [reportpagedefaultType parseReportpagedefaultTypeEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kCreateReportpagedefaultTypeCompletedNotification object:self userInfo:userInfoDict];

}

- (void)createReportpagedefaultType:(reportpagedefaultType *)aReportpagedefaultType
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aReportpagedefaultType error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aReportpagedefaultType error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateReportpagedefaultTypeCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aReportpagedefaultType , kRequestUserInfoCompletedNotification : kCreateReportpagedefaultTypeCompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:service.reportpagedefaultQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createReportpagedefaultTypeCompleted:) andUserInfo:userInfoDict];
    }
}

#pragma mark Update

- (void)updateReportpagedefaultTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        reportpagedefaultType *item = [reportpagedefaultType parseReportpagedefaultTypeEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateReportpagedefaultTypeCompletedNotification object:self userInfo:userInfoDict];

}

- (void)updateReportpagedefaultType:(reportpagedefaultType *)aReportpagedefaultType
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForUpdateRequest:aReportpagedefaultType error:&error];
    }
    else {
        payload = [service getXMLForUpdateRequest:aReportpagedefaultType error:&error];
    }
    
    if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateReportpagedefaultTypeCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        ODataQuery *query = [[ODataQuery alloc] initWithURL:aReportpagedefaultType.baseUrl];
    	NSDictionary *userInfoDict = @{kResponseParentItem : aReportpagedefaultType , kRequestUserInfoCompletedNotification : kUpdateReportpagedefaultTypeCompletedNotification};
    	[connectivityHelper executeUpdateAsyncRequestWithQuery:query andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(updateReportpagedefaultTypeCompleted:) andUserInfo:userInfoDict andEtag:aReportpagedefaultType.etag];
    }
}

#pragma mark Delete

- (void)deleteReportpagedefaultTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    [[NSNotificationCenter defaultCenter] postNotificationName:kDeleteReportpagedefaultTypeCompletedNotification object:self userInfo:userInfoDict];   
}

- (void)deleteReportpagedefaultType:(reportpagedefaultType *)aReportpagedefaultType 
{
	[self loadCSRFData];
    ODataQuery *query = [[ODataQuery alloc] initWithURL:aReportpagedefaultType.baseUrl];
    NSDictionary *userInfoDict = @{kResponseParentItem : aReportpagedefaultType , kRequestUserInfoCompletedNotification : kDeleteReportpagedefaultTypeCompletedNotification};
    [connectivityHelper executeDeleteAsyncRequestWithQuery:query andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(deleteReportpagedefaultTypeCompleted:) andUserInfo:userInfoDict andEtag:aReportpagedefaultType.etag];
}

#pragma mark - reports methods
#pragma mark Read

- (void)loadReportsCompleted:(id <Requesting>)request
{
    NSDictionary *userInfoDict;
    NSError *error;
    NSMutableArray *items = [service getReportsWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict = @{kParsingError: error};
    }
    else {
    	userInfoDict = @{kResponseItems: items};
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadReportsCompletedNotification object:self userInfo:userInfoDict];
}

- (void)loadReports
{
    ODataQuery *query = service.reportsQuery;
    NSDictionary *userInfoDict = @{kRequestUserInfoCompletedNotification : kLoadReportsCompletedNotification};
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadReportsCompleted:) andUserInfo:userInfoDict];
}


- (void)loadReportsTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSError *error;
    reportsType *item = [reportsType parseExpandedReportsTypeEntryWithData:request.responseData andServiceDocument:service.sdmServiceDocument error:&error];
    if (error) {
    	userInfoDict[kParsingError] = error;
    }
    else {
    	userInfoDict[kResponseItem] = item;
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadReportsTypeCompletedNotification object:self userInfo:userInfoDict];
}

- (void)loadReportsType:(reportsType *)aReportsType
{
    [self loadReportsType:aReportsType expand:NO];
}

- (void)loadReportsType:(reportsType *)aReportsType expand:(BOOL)expand
{
    ODataQuery *query = [[ODataQuery alloc] initWithURL:aReportsType.baseUrl];
    if (expand) {
        [query expand:@"report,reportqueryconstraints,reportviewsfilter"]; 
    }
    NSDictionary *userInfoDict = @{kResponseParentItem : aReportsType , kRequestUserInfoCompletedNotification : kLoadReportsTypeCompletedNotification};
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadReportsTypeCompleted:) andUserInfo:userInfoDict];
}

- (void)loadReportForReportsTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSError *error;
    reportsType *parentReportsTypeItem = request.userInfo[kResponseParentItem];
    [parentReportsTypeItem loadReportWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict[kParsingError] = error;
    }
    else {
    	userInfoDict[kResponseItems] = parentReportsTypeItem.report;
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadReportForReportsTypeCompletedNotification object:self userInfo:userInfoDict];   
}

- (void)loadReportForReportsType:(reportsType *)aReportsType
{
    ODataQuery *query = aReportsType.reportQuery;
    NSDictionary *userInfoDict = @{kResponseParentItem : aReportsType , kRequestUserInfoCompletedNotification : kLoadReportForReportsTypeCompletedNotification}; 
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadReportForReportsTypeCompleted:) andUserInfo:userInfoDict];
}

- (void)loadReportqueryconstraintsForReportsTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSError *error;
    reportsType *parentReportsTypeItem = request.userInfo[kResponseParentItem];
    [parentReportsTypeItem loadReportqueryconstraintsWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict[kParsingError] = error;
    }
    else {
    	userInfoDict[kResponseItems] = parentReportsTypeItem.reportqueryconstraints;
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadReportqueryconstraintsForReportsTypeCompletedNotification object:self userInfo:userInfoDict];   
}

- (void)loadReportqueryconstraintsForReportsType:(reportsType *)aReportsType
{
    ODataQuery *query = aReportsType.reportqueryconstraintsQuery;
    NSDictionary *userInfoDict = @{kResponseParentItem : aReportsType , kRequestUserInfoCompletedNotification : kLoadReportqueryconstraintsForReportsTypeCompletedNotification}; 
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadReportqueryconstraintsForReportsTypeCompleted:) andUserInfo:userInfoDict];
}

- (void)loadReportviewsfilterForReportsTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSError *error;
    reportsType *parentReportsTypeItem = request.userInfo[kResponseParentItem];
    [parentReportsTypeItem loadReportviewsfilterWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict[kParsingError] = error;
    }
    else {
    	userInfoDict[kResponseItems] = parentReportsTypeItem.reportviewsfilter;
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadReportviewsfilterForReportsTypeCompletedNotification object:self userInfo:userInfoDict];   
}

- (void)loadReportviewsfilterForReportsType:(reportsType *)aReportsType
{
    ODataQuery *query = aReportsType.reportviewsfilterQuery;
    NSDictionary *userInfoDict = @{kResponseParentItem : aReportsType , kRequestUserInfoCompletedNotification : kLoadReportviewsfilterForReportsTypeCompletedNotification}; 
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadReportviewsfilterForReportsTypeCompleted:) andUserInfo:userInfoDict];
}

#pragma mark Create

- (void)createReportsTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        reportsType *item = [reportsType parseReportsTypeEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kCreateReportsTypeCompletedNotification object:self userInfo:userInfoDict];

}

- (void)createReportsType:(reportsType *)aReportsType
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aReportsType error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aReportsType error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateReportsTypeCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aReportsType , kRequestUserInfoCompletedNotification : kCreateReportsTypeCompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:service.reportsQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createReportsTypeCompleted:) andUserInfo:userInfoDict];
    }
}

- (void)createReportType:(reportType *)aNewReportType forReportsType:(reportsType *)aReportsType
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aNewReportType error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aNewReportType error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateReportTypeCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aNewReportType , kRequestUserInfoCompletedNotification : kCreateReportTypeCompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:aReportsType.reportQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createReportTypeCompleted:) andUserInfo:userInfoDict];
    }
}

- (void)createReportqueryconstraintsType:(reportqueryconstraintsType *)aNewReportqueryconstraintsType forReportsType:(reportsType *)aReportsType
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aNewReportqueryconstraintsType error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aNewReportqueryconstraintsType error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateReportqueryconstraintsTypeCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aNewReportqueryconstraintsType , kRequestUserInfoCompletedNotification : kCreateReportqueryconstraintsTypeCompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:aReportsType.reportqueryconstraintsQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createReportqueryconstraintsTypeCompleted:) andUserInfo:userInfoDict];
    }
}

- (void)createReportviewsfilterType:(reportviewsfilterType *)aNewReportviewsfilterType forReportsType:(reportsType *)aReportsType
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aNewReportviewsfilterType error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aNewReportviewsfilterType error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateReportviewsfilterTypeCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aNewReportviewsfilterType , kRequestUserInfoCompletedNotification : kCreateReportviewsfilterTypeCompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:aReportsType.reportviewsfilterQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createReportviewsfilterTypeCompleted:) andUserInfo:userInfoDict];
    }
}

#pragma mark Update

- (void)updateReportsTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        reportsType *item = [reportsType parseReportsTypeEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateReportsTypeCompletedNotification object:self userInfo:userInfoDict];

}

- (void)updateReportsType:(reportsType *)aReportsType
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForUpdateRequest:aReportsType error:&error];
    }
    else {
        payload = [service getXMLForUpdateRequest:aReportsType error:&error];
    }
    
    if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateReportsTypeCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        ODataQuery *query = [[ODataQuery alloc] initWithURL:aReportsType.baseUrl];
    	NSDictionary *userInfoDict = @{kResponseParentItem : aReportsType , kRequestUserInfoCompletedNotification : kUpdateReportsTypeCompletedNotification};
    	[connectivityHelper executeUpdateAsyncRequestWithQuery:query andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(updateReportsTypeCompleted:) andUserInfo:userInfoDict andEtag:aReportsType.etag];
    }
}

#pragma mark Delete

- (void)deleteReportsTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    [[NSNotificationCenter defaultCenter] postNotificationName:kDeleteReportsTypeCompletedNotification object:self userInfo:userInfoDict];   
}

- (void)deleteReportsType:(reportsType *)aReportsType 
{
	[self loadCSRFData];
    ODataQuery *query = [[ODataQuery alloc] initWithURL:aReportsType.baseUrl];
    NSDictionary *userInfoDict = @{kResponseParentItem : aReportsType , kRequestUserInfoCompletedNotification : kDeleteReportsTypeCompletedNotification};
    [connectivityHelper executeDeleteAsyncRequestWithQuery:query andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(deleteReportsTypeCompleted:) andUserInfo:userInfoDict andEtag:aReportsType.etag];
}

#pragma mark - reportpages methods
#pragma mark Read

- (void)loadReportpagesCompleted:(id <Requesting>)request
{
    NSDictionary *userInfoDict;
    NSError *error;
    NSMutableArray *items = [service getReportpagesWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict = @{kParsingError: error};
    }
    else {
    	userInfoDict = @{kResponseItems: items};
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadReportpagesCompletedNotification object:self userInfo:userInfoDict];
}

- (void)loadReportpages
{
    ODataQuery *query = service.reportpagesQuery;
    NSDictionary *userInfoDict = @{kRequestUserInfoCompletedNotification : kLoadReportpagesCompletedNotification};
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadReportpagesCompleted:) andUserInfo:userInfoDict];
}


- (void)loadReportpagesTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSError *error;
    reportpagesType *item = [reportpagesType parseExpandedReportpagesTypeEntryWithData:request.responseData andServiceDocument:service.sdmServiceDocument error:&error];
    if (error) {
    	userInfoDict[kParsingError] = error;
    }
    else {
    	userInfoDict[kResponseItem] = item;
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadReportpagesTypeCompletedNotification object:self userInfo:userInfoDict];
}

- (void)loadReportpagesType:(reportpagesType *)aReportpagesType
{
    [self loadReportpagesType:aReportpagesType expand:NO];
}

- (void)loadReportpagesType:(reportpagesType *)aReportpagesType expand:(BOOL)expand
{
    ODataQuery *query = [[ODataQuery alloc] initWithURL:aReportpagesType.baseUrl];
    if (expand) {
        [query expand:@"reportpagelayout,sharedobjects,reportpagenav"]; 
    }
    NSDictionary *userInfoDict = @{kResponseParentItem : aReportpagesType , kRequestUserInfoCompletedNotification : kLoadReportpagesTypeCompletedNotification};
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadReportpagesTypeCompleted:) andUserInfo:userInfoDict];
}

- (void)loadReportpagelayoutForReportpagesTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSError *error;
    reportpagesType *parentReportpagesTypeItem = request.userInfo[kResponseParentItem];
    [parentReportpagesTypeItem loadReportpagelayoutWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict[kParsingError] = error;
    }
    else {
    	userInfoDict[kResponseItems] = parentReportpagesTypeItem.reportpagelayout;
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadReportpagelayoutForReportpagesTypeCompletedNotification object:self userInfo:userInfoDict];   
}

- (void)loadReportpagelayoutForReportpagesType:(reportpagesType *)aReportpagesType
{
    ODataQuery *query = aReportpagesType.reportpagelayoutQuery;
    NSDictionary *userInfoDict = @{kResponseParentItem : aReportpagesType , kRequestUserInfoCompletedNotification : kLoadReportpagelayoutForReportpagesTypeCompletedNotification}; 
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadReportpagelayoutForReportpagesTypeCompleted:) andUserInfo:userInfoDict];
}

- (void)loadSharedobjectsForReportpagesTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSError *error;
    reportpagesType *parentReportpagesTypeItem = request.userInfo[kResponseParentItem];
    [parentReportpagesTypeItem loadSharedobjectsWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict[kParsingError] = error;
    }
    else {
    	userInfoDict[kResponseItems] = parentReportpagesTypeItem.sharedobjects;
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadSharedobjectsForReportpagesTypeCompletedNotification object:self userInfo:userInfoDict];   
}

- (void)loadSharedobjectsForReportpagesType:(reportpagesType *)aReportpagesType
{
    ODataQuery *query = aReportpagesType.sharedobjectsQuery;
    NSDictionary *userInfoDict = @{kResponseParentItem : aReportpagesType , kRequestUserInfoCompletedNotification : kLoadSharedobjectsForReportpagesTypeCompletedNotification}; 
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadSharedobjectsForReportpagesTypeCompleted:) andUserInfo:userInfoDict];
}

- (void)loadReportpagenavForReportpagesTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSError *error;
    reportpagesType *parentReportpagesTypeItem = request.userInfo[kResponseParentItem];
    [parentReportpagesTypeItem loadReportpagenavWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict[kParsingError] = error;
    }
    else {
    	userInfoDict[kResponseItems] = parentReportpagesTypeItem.reportpagenav;
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadReportpagenavForReportpagesTypeCompletedNotification object:self userInfo:userInfoDict];   
}

- (void)loadReportpagenavForReportpagesType:(reportpagesType *)aReportpagesType
{
    ODataQuery *query = aReportpagesType.reportpagenavQuery;
    NSDictionary *userInfoDict = @{kResponseParentItem : aReportpagesType , kRequestUserInfoCompletedNotification : kLoadReportpagenavForReportpagesTypeCompletedNotification}; 
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadReportpagenavForReportpagesTypeCompleted:) andUserInfo:userInfoDict];
}

#pragma mark Create

- (void)createReportpagesTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        reportpagesType *item = [reportpagesType parseReportpagesTypeEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kCreateReportpagesTypeCompletedNotification object:self userInfo:userInfoDict];

}

- (void)createReportpagesType:(reportpagesType *)aReportpagesType
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aReportpagesType error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aReportpagesType error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateReportpagesTypeCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aReportpagesType , kRequestUserInfoCompletedNotification : kCreateReportpagesTypeCompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:service.reportpagesQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createReportpagesTypeCompleted:) andUserInfo:userInfoDict];
    }
}

- (void)createReportpagelayoutType:(reportpagelayoutType *)aNewReportpagelayoutType forReportpagesType:(reportpagesType *)aReportpagesType
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aNewReportpagelayoutType error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aNewReportpagelayoutType error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateReportpagelayoutTypeCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aNewReportpagelayoutType , kRequestUserInfoCompletedNotification : kCreateReportpagelayoutTypeCompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:aReportpagesType.reportpagelayoutQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createReportpagelayoutTypeCompleted:) andUserInfo:userInfoDict];
    }
}

- (void)createSharedobjectsType:(sharedobjectsType *)aNewSharedobjectsType forReportpagesType:(reportpagesType *)aReportpagesType
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aNewSharedobjectsType error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aNewSharedobjectsType error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateSharedobjectsTypeCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aNewSharedobjectsType , kRequestUserInfoCompletedNotification : kCreateSharedobjectsTypeCompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:aReportpagesType.sharedobjectsQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createSharedobjectsTypeCompleted:) andUserInfo:userInfoDict];
    }
}

- (void)createReportpagenavType:(reportpagenavType *)aNewReportpagenavType forReportpagesType:(reportpagesType *)aReportpagesType
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aNewReportpagenavType error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aNewReportpagenavType error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateReportpagenavTypeCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aNewReportpagenavType , kRequestUserInfoCompletedNotification : kCreateReportpagenavTypeCompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:aReportpagesType.reportpagenavQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createReportpagenavTypeCompleted:) andUserInfo:userInfoDict];
    }
}

#pragma mark Update

- (void)updateReportpagesTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        reportpagesType *item = [reportpagesType parseReportpagesTypeEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateReportpagesTypeCompletedNotification object:self userInfo:userInfoDict];

}

- (void)updateReportpagesType:(reportpagesType *)aReportpagesType
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForUpdateRequest:aReportpagesType error:&error];
    }
    else {
        payload = [service getXMLForUpdateRequest:aReportpagesType error:&error];
    }
    
    if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateReportpagesTypeCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        ODataQuery *query = [[ODataQuery alloc] initWithURL:aReportpagesType.baseUrl];
    	NSDictionary *userInfoDict = @{kResponseParentItem : aReportpagesType , kRequestUserInfoCompletedNotification : kUpdateReportpagesTypeCompletedNotification};
    	[connectivityHelper executeUpdateAsyncRequestWithQuery:query andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(updateReportpagesTypeCompleted:) andUserInfo:userInfoDict andEtag:aReportpagesType.etag];
    }
}

#pragma mark Delete

- (void)deleteReportpagesTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    [[NSNotificationCenter defaultCenter] postNotificationName:kDeleteReportpagesTypeCompletedNotification object:self userInfo:userInfoDict];   
}

- (void)deleteReportpagesType:(reportpagesType *)aReportpagesType 
{
	[self loadCSRFData];
    ODataQuery *query = [[ODataQuery alloc] initWithURL:aReportpagesType.baseUrl];
    NSDictionary *userInfoDict = @{kResponseParentItem : aReportpagesType , kRequestUserInfoCompletedNotification : kDeleteReportpagesTypeCompletedNotification};
    [connectivityHelper executeDeleteAsyncRequestWithQuery:query andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(deleteReportpagesTypeCompleted:) andUserInfo:userInfoDict andEtag:aReportpagesType.etag];
}

#pragma mark - reportviews methods
#pragma mark Read

- (void)loadReportviewsCompleted:(id <Requesting>)request
{
    NSDictionary *userInfoDict;
    NSError *error;
    NSMutableArray *items = [service getReportviewsWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict = @{kParsingError: error};
    }
    else {
    	userInfoDict = @{kResponseItems: items};
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadReportviewsCompletedNotification object:self userInfo:userInfoDict];
}

- (void)loadReportviews
{
    ODataQuery *query = service.reportviewsQuery;
    NSDictionary *userInfoDict = @{kRequestUserInfoCompletedNotification : kLoadReportviewsCompletedNotification};
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadReportviewsCompleted:) andUserInfo:userInfoDict];
}


- (void)loadReportviewsTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSError *error;
    reportviewsType *item = [reportviewsType parseExpandedReportviewsTypeEntryWithData:request.responseData andServiceDocument:service.sdmServiceDocument error:&error];
    if (error) {
    	userInfoDict[kParsingError] = error;
    }
    else {
    	userInfoDict[kResponseItem] = item;
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadReportviewsTypeCompletedNotification object:self userInfo:userInfoDict];
}

- (void)loadReportviewsType:(reportviewsType *)aReportviewsType
{
    [self loadReportviewsType:aReportviewsType expand:NO];
}

- (void)loadReportviewsType:(reportviewsType *)aReportviewsType expand:(BOOL)expand
{
    ODataQuery *query = [[ODataQuery alloc] initWithURL:aReportviewsType.baseUrl];
    if (expand) {
        [query expand:@"reportview,sharedobjects,reportviewpages,reportviewwbfav"]; 
    }
    NSDictionary *userInfoDict = @{kResponseParentItem : aReportviewsType , kRequestUserInfoCompletedNotification : kLoadReportviewsTypeCompletedNotification};
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadReportviewsTypeCompleted:) andUserInfo:userInfoDict];
}

- (void)loadReportviewForReportviewsTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSError *error;
    reportviewsType *parentReportviewsTypeItem = request.userInfo[kResponseParentItem];
    [parentReportviewsTypeItem loadReportviewWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict[kParsingError] = error;
    }
    else {
    	userInfoDict[kResponseItems] = parentReportviewsTypeItem.reportview;
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadReportviewForReportviewsTypeCompletedNotification object:self userInfo:userInfoDict];   
}

- (void)loadReportviewForReportviewsType:(reportviewsType *)aReportviewsType
{
    ODataQuery *query = aReportviewsType.reportviewQuery;
    NSDictionary *userInfoDict = @{kResponseParentItem : aReportviewsType , kRequestUserInfoCompletedNotification : kLoadReportviewForReportviewsTypeCompletedNotification}; 
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadReportviewForReportviewsTypeCompleted:) andUserInfo:userInfoDict];
}

- (void)loadSharedobjectsForReportviewsTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSError *error;
    reportviewsType *parentReportviewsTypeItem = request.userInfo[kResponseParentItem];
    [parentReportviewsTypeItem loadSharedobjectsWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict[kParsingError] = error;
    }
    else {
    	userInfoDict[kResponseItems] = parentReportviewsTypeItem.sharedobjects;
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadSharedobjectsForReportviewsTypeCompletedNotification object:self userInfo:userInfoDict];   
}

- (void)loadSharedobjectsForReportviewsType:(reportviewsType *)aReportviewsType
{
    ODataQuery *query = aReportviewsType.sharedobjectsQuery;
    NSDictionary *userInfoDict = @{kResponseParentItem : aReportviewsType , kRequestUserInfoCompletedNotification : kLoadSharedobjectsForReportviewsTypeCompletedNotification}; 
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadSharedobjectsForReportviewsTypeCompleted:) andUserInfo:userInfoDict];
}

- (void)loadReportviewpagesForReportviewsTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSError *error;
    reportviewsType *parentReportviewsTypeItem = request.userInfo[kResponseParentItem];
    [parentReportviewsTypeItem loadReportviewpagesWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict[kParsingError] = error;
    }
    else {
    	userInfoDict[kResponseItems] = parentReportviewsTypeItem.reportviewpages;
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadReportviewpagesForReportviewsTypeCompletedNotification object:self userInfo:userInfoDict];   
}

- (void)loadReportviewpagesForReportviewsType:(reportviewsType *)aReportviewsType
{
    ODataQuery *query = aReportviewsType.reportviewpagesQuery;
    NSDictionary *userInfoDict = @{kResponseParentItem : aReportviewsType , kRequestUserInfoCompletedNotification : kLoadReportviewpagesForReportviewsTypeCompletedNotification}; 
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadReportviewpagesForReportviewsTypeCompleted:) andUserInfo:userInfoDict];
}

- (void)loadReportviewwbfavForReportviewsTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSError *error;
    reportviewsType *parentReportviewsTypeItem = request.userInfo[kResponseParentItem];
    [parentReportviewsTypeItem loadReportviewwbfavWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict[kParsingError] = error;
    }
    else {
    	userInfoDict[kResponseItems] = parentReportviewsTypeItem.reportviewwbfav;
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadReportviewwbfavForReportviewsTypeCompletedNotification object:self userInfo:userInfoDict];   
}

- (void)loadReportviewwbfavForReportviewsType:(reportviewsType *)aReportviewsType
{
    ODataQuery *query = aReportviewsType.reportviewwbfavQuery;
    NSDictionary *userInfoDict = @{kResponseParentItem : aReportviewsType , kRequestUserInfoCompletedNotification : kLoadReportviewwbfavForReportviewsTypeCompletedNotification}; 
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadReportviewwbfavForReportviewsTypeCompleted:) andUserInfo:userInfoDict];
}

#pragma mark Create

- (void)createReportviewsTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        reportviewsType *item = [reportviewsType parseReportviewsTypeEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kCreateReportviewsTypeCompletedNotification object:self userInfo:userInfoDict];

}

- (void)createReportviewsType:(reportviewsType *)aReportviewsType
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aReportviewsType error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aReportviewsType error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateReportviewsTypeCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aReportviewsType , kRequestUserInfoCompletedNotification : kCreateReportviewsTypeCompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:service.reportviewsQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createReportviewsTypeCompleted:) andUserInfo:userInfoDict];
    }
}

- (void)createReportviewType:(reportviewType *)aNewReportviewType forReportviewsType:(reportviewsType *)aReportviewsType
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aNewReportviewType error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aNewReportviewType error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateReportviewTypeCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aNewReportviewType , kRequestUserInfoCompletedNotification : kCreateReportviewTypeCompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:aReportviewsType.reportviewQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createReportviewTypeCompleted:) andUserInfo:userInfoDict];
    }
}

- (void)createSharedobjectsType:(sharedobjectsType *)aNewSharedobjectsType forReportviewsType:(reportviewsType *)aReportviewsType
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aNewSharedobjectsType error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aNewSharedobjectsType error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateSharedobjectsTypeCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aNewSharedobjectsType , kRequestUserInfoCompletedNotification : kCreateSharedobjectsTypeCompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:aReportviewsType.sharedobjectsQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createSharedobjectsTypeCompleted:) andUserInfo:userInfoDict];
    }
}

- (void)createReportviewpagesType:(reportviewpagesType *)aNewReportviewpagesType forReportviewsType:(reportviewsType *)aReportviewsType
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aNewReportviewpagesType error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aNewReportviewpagesType error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateReportviewpagesTypeCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aNewReportviewpagesType , kRequestUserInfoCompletedNotification : kCreateReportviewpagesTypeCompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:aReportviewsType.reportviewpagesQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createReportviewpagesTypeCompleted:) andUserInfo:userInfoDict];
    }
}

- (void)createReportviewwbfavType:(reportviewwbfavType *)aNewReportviewwbfavType forReportviewsType:(reportviewsType *)aReportviewsType
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aNewReportviewwbfavType error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aNewReportviewwbfavType error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateReportviewwbfavTypeCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aNewReportviewwbfavType , kRequestUserInfoCompletedNotification : kCreateReportviewwbfavTypeCompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:aReportviewsType.reportviewwbfavQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createReportviewwbfavTypeCompleted:) andUserInfo:userInfoDict];
    }
}

#pragma mark Update

- (void)updateReportviewsTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        reportviewsType *item = [reportviewsType parseReportviewsTypeEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateReportviewsTypeCompletedNotification object:self userInfo:userInfoDict];

}

- (void)updateReportviewsType:(reportviewsType *)aReportviewsType
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForUpdateRequest:aReportviewsType error:&error];
    }
    else {
        payload = [service getXMLForUpdateRequest:aReportviewsType error:&error];
    }
    
    if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateReportviewsTypeCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        ODataQuery *query = [[ODataQuery alloc] initWithURL:aReportviewsType.baseUrl];
    	NSDictionary *userInfoDict = @{kResponseParentItem : aReportviewsType , kRequestUserInfoCompletedNotification : kUpdateReportviewsTypeCompletedNotification};
    	[connectivityHelper executeUpdateAsyncRequestWithQuery:query andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(updateReportviewsTypeCompleted:) andUserInfo:userInfoDict andEtag:aReportviewsType.etag];
    }
}

#pragma mark Delete

- (void)deleteReportviewsTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    [[NSNotificationCenter defaultCenter] postNotificationName:kDeleteReportviewsTypeCompletedNotification object:self userInfo:userInfoDict];   
}

- (void)deleteReportviewsType:(reportviewsType *)aReportviewsType 
{
	[self loadCSRFData];
    ODataQuery *query = [[ODataQuery alloc] initWithURL:aReportviewsType.baseUrl];
    NSDictionary *userInfoDict = @{kResponseParentItem : aReportviewsType , kRequestUserInfoCompletedNotification : kDeleteReportviewsTypeCompletedNotification};
    [connectivityHelper executeDeleteAsyncRequestWithQuery:query andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(deleteReportviewsTypeCompleted:) andUserInfo:userInfoDict andEtag:aReportviewsType.etag];
}

#pragma mark - reportpagelayout methods
#pragma mark Read

- (void)loadReportpagelayoutCompleted:(id <Requesting>)request
{
    NSDictionary *userInfoDict;
    NSError *error;
    NSMutableArray *items = [service getReportpagelayoutWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict = @{kParsingError: error};
    }
    else {
    	userInfoDict = @{kResponseItems: items};
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadReportpagelayoutCompletedNotification object:self userInfo:userInfoDict];
}

- (void)loadReportpagelayout
{
    ODataQuery *query = service.reportpagelayoutQuery;
    NSDictionary *userInfoDict = @{kRequestUserInfoCompletedNotification : kLoadReportpagelayoutCompletedNotification};
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadReportpagelayoutCompleted:) andUserInfo:userInfoDict];
}


- (void)loadReportpagelayoutTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSError *error;
    reportpagelayoutType *item = [reportpagelayoutType parseExpandedReportpagelayoutTypeEntryWithData:request.responseData andServiceDocument:service.sdmServiceDocument error:&error];
    if (error) {
    	userInfoDict[kParsingError] = error;
    }
    else {
    	userInfoDict[kResponseItem] = item;
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadReportpagelayoutTypeCompletedNotification object:self userInfo:userInfoDict];
}

- (void)loadReportpagelayoutType:(reportpagelayoutType *)aReportpagelayoutType
{
    [self loadReportpagelayoutType:aReportpagelayoutType expand:NO];
}

- (void)loadReportpagelayoutType:(reportpagelayoutType *)aReportpagelayoutType expand:(BOOL)expand
{
    ODataQuery *query = [[ODataQuery alloc] initWithURL:aReportpagelayoutType.baseUrl];
    if (expand) {
        [query expand:@"reportview"]; 
    }
    NSDictionary *userInfoDict = @{kResponseParentItem : aReportpagelayoutType , kRequestUserInfoCompletedNotification : kLoadReportpagelayoutTypeCompletedNotification};
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadReportpagelayoutTypeCompleted:) andUserInfo:userInfoDict];
}

- (void)loadReportviewForReportpagelayoutTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSError *error;
    reportpagelayoutType *parentReportpagelayoutTypeItem = request.userInfo[kResponseParentItem];
    [parentReportpagelayoutTypeItem loadReportviewWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict[kParsingError] = error;
    }
    else {
    	userInfoDict[kResponseItems] = parentReportpagelayoutTypeItem.reportview;
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadReportviewForReportpagelayoutTypeCompletedNotification object:self userInfo:userInfoDict];   
}

- (void)loadReportviewForReportpagelayoutType:(reportpagelayoutType *)aReportpagelayoutType
{
    ODataQuery *query = aReportpagelayoutType.reportviewQuery;
    NSDictionary *userInfoDict = @{kResponseParentItem : aReportpagelayoutType , kRequestUserInfoCompletedNotification : kLoadReportviewForReportpagelayoutTypeCompletedNotification}; 
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadReportviewForReportpagelayoutTypeCompleted:) andUserInfo:userInfoDict];
}

#pragma mark Create

- (void)createReportpagelayoutTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        reportpagelayoutType *item = [reportpagelayoutType parseReportpagelayoutTypeEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kCreateReportpagelayoutTypeCompletedNotification object:self userInfo:userInfoDict];

}

- (void)createReportpagelayoutType:(reportpagelayoutType *)aReportpagelayoutType
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aReportpagelayoutType error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aReportpagelayoutType error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateReportpagelayoutTypeCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aReportpagelayoutType , kRequestUserInfoCompletedNotification : kCreateReportpagelayoutTypeCompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:service.reportpagelayoutQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createReportpagelayoutTypeCompleted:) andUserInfo:userInfoDict];
    }
}

- (void)createReportviewType:(reportviewType *)aNewReportviewType forReportpagelayoutType:(reportpagelayoutType *)aReportpagelayoutType
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aNewReportviewType error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aNewReportviewType error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateReportviewTypeCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aNewReportviewType , kRequestUserInfoCompletedNotification : kCreateReportviewTypeCompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:aReportpagelayoutType.reportviewQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createReportviewTypeCompleted:) andUserInfo:userInfoDict];
    }
}

#pragma mark Update

- (void)updateReportpagelayoutTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        reportpagelayoutType *item = [reportpagelayoutType parseReportpagelayoutTypeEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateReportpagelayoutTypeCompletedNotification object:self userInfo:userInfoDict];

}

- (void)updateReportpagelayoutType:(reportpagelayoutType *)aReportpagelayoutType
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForUpdateRequest:aReportpagelayoutType error:&error];
    }
    else {
        payload = [service getXMLForUpdateRequest:aReportpagelayoutType error:&error];
    }
    
    if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateReportpagelayoutTypeCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        ODataQuery *query = [[ODataQuery alloc] initWithURL:aReportpagelayoutType.baseUrl];
    	NSDictionary *userInfoDict = @{kResponseParentItem : aReportpagelayoutType , kRequestUserInfoCompletedNotification : kUpdateReportpagelayoutTypeCompletedNotification};
    	[connectivityHelper executeUpdateAsyncRequestWithQuery:query andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(updateReportpagelayoutTypeCompleted:) andUserInfo:userInfoDict andEtag:aReportpagelayoutType.etag];
    }
}

#pragma mark Delete

- (void)deleteReportpagelayoutTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    [[NSNotificationCenter defaultCenter] postNotificationName:kDeleteReportpagelayoutTypeCompletedNotification object:self userInfo:userInfoDict];   
}

- (void)deleteReportpagelayoutType:(reportpagelayoutType *)aReportpagelayoutType 
{
	[self loadCSRFData];
    ODataQuery *query = [[ODataQuery alloc] initWithURL:aReportpagelayoutType.baseUrl];
    NSDictionary *userInfoDict = @{kResponseParentItem : aReportpagelayoutType , kRequestUserInfoCompletedNotification : kDeleteReportpagelayoutTypeCompletedNotification};
    [connectivityHelper executeDeleteAsyncRequestWithQuery:query andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(deleteReportpagelayoutTypeCompleted:) andUserInfo:userInfoDict andEtag:aReportpagelayoutType.etag];
}

#pragma mark - reportview methods
#pragma mark Read

- (void)loadReportviewCompleted:(id <Requesting>)request
{
    NSDictionary *userInfoDict;
    NSError *error;
    NSMutableArray *items = [service getReportviewWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict = @{kParsingError: error};
    }
    else {
    	userInfoDict = @{kResponseItems: items};
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadReportviewCompletedNotification object:self userInfo:userInfoDict];
}

- (void)loadReportview
{
    ODataQuery *query = service.reportviewQuery;
    NSDictionary *userInfoDict = @{kRequestUserInfoCompletedNotification : kLoadReportviewCompletedNotification};
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadReportviewCompleted:) andUserInfo:userInfoDict];
}


- (void)loadReportviewTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSError *error;
    reportviewType *item = [reportviewType parseReportviewTypeEntryWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict[kParsingError] = error;
    }
    else {
    	userInfoDict[kResponseItem] = item;
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadReportviewTypeCompletedNotification object:self userInfo:userInfoDict];
}

- (void)loadReportviewType:(reportviewType *)aReportviewType
{
    ODataQuery *query = [[ODataQuery alloc] initWithURL:aReportviewType.baseUrl];
    NSDictionary *userInfoDict = @{kResponseParentItem : aReportviewType, kRequestUserInfoCompletedNotification : kLoadReportviewTypeCompletedNotification};
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadReportviewTypeCompleted:) andUserInfo:userInfoDict];
}

#pragma mark Create

- (void)createReportviewTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        reportviewType *item = [reportviewType parseReportviewTypeEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kCreateReportviewTypeCompletedNotification object:self userInfo:userInfoDict];

}

- (void)createReportviewType:(reportviewType *)aReportviewType
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aReportviewType error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aReportviewType error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateReportviewTypeCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aReportviewType , kRequestUserInfoCompletedNotification : kCreateReportviewTypeCompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:service.reportviewQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createReportviewTypeCompleted:) andUserInfo:userInfoDict];
    }
}

#pragma mark Update

- (void)updateReportviewTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        reportviewType *item = [reportviewType parseReportviewTypeEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateReportviewTypeCompletedNotification object:self userInfo:userInfoDict];

}

- (void)updateReportviewType:(reportviewType *)aReportviewType
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForUpdateRequest:aReportviewType error:&error];
    }
    else {
        payload = [service getXMLForUpdateRequest:aReportviewType error:&error];
    }
    
    if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateReportviewTypeCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        ODataQuery *query = [[ODataQuery alloc] initWithURL:aReportviewType.baseUrl];
    	NSDictionary *userInfoDict = @{kResponseParentItem : aReportviewType , kRequestUserInfoCompletedNotification : kUpdateReportviewTypeCompletedNotification};
    	[connectivityHelper executeUpdateAsyncRequestWithQuery:query andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(updateReportviewTypeCompleted:) andUserInfo:userInfoDict andEtag:aReportviewType.etag];
    }
}

#pragma mark Delete

- (void)deleteReportviewTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    [[NSNotificationCenter defaultCenter] postNotificationName:kDeleteReportviewTypeCompletedNotification object:self userInfo:userInfoDict];   
}

- (void)deleteReportviewType:(reportviewType *)aReportviewType 
{
	[self loadCSRFData];
    ODataQuery *query = [[ODataQuery alloc] initWithURL:aReportviewType.baseUrl];
    NSDictionary *userInfoDict = @{kResponseParentItem : aReportviewType , kRequestUserInfoCompletedNotification : kDeleteReportviewTypeCompletedNotification};
    [connectivityHelper executeDeleteAsyncRequestWithQuery:query andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(deleteReportviewTypeCompleted:) andUserInfo:userInfoDict andEtag:aReportviewType.etag];
}

#pragma mark - report methods
#pragma mark Read

- (void)loadReportCompleted:(id <Requesting>)request
{
    NSDictionary *userInfoDict;
    NSError *error;
    NSMutableArray *items = [service getReportWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict = @{kParsingError: error};
    }
    else {
    	userInfoDict = @{kResponseItems: items};
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadReportCompletedNotification object:self userInfo:userInfoDict];
}

- (void)loadReport
{
    ODataQuery *query = service.reportQuery;
    NSDictionary *userInfoDict = @{kRequestUserInfoCompletedNotification : kLoadReportCompletedNotification};
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadReportCompleted:) andUserInfo:userInfoDict];
}


- (void)loadReportTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSError *error;
    reportType *item = [reportType parseReportTypeEntryWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict[kParsingError] = error;
    }
    else {
    	userInfoDict[kResponseItem] = item;
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadReportTypeCompletedNotification object:self userInfo:userInfoDict];
}

- (void)loadReportType:(reportType *)aReportType
{
    ODataQuery *query = [[ODataQuery alloc] initWithURL:aReportType.baseUrl];
    NSDictionary *userInfoDict = @{kResponseParentItem : aReportType, kRequestUserInfoCompletedNotification : kLoadReportTypeCompletedNotification};
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadReportTypeCompleted:) andUserInfo:userInfoDict];
}

#pragma mark Create

- (void)createReportTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        reportType *item = [reportType parseReportTypeEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kCreateReportTypeCompletedNotification object:self userInfo:userInfoDict];

}

- (void)createReportType:(reportType *)aReportType
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aReportType error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aReportType error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateReportTypeCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aReportType , kRequestUserInfoCompletedNotification : kCreateReportTypeCompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:service.reportQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createReportTypeCompleted:) andUserInfo:userInfoDict];
    }
}

#pragma mark Update

- (void)updateReportTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        reportType *item = [reportType parseReportTypeEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateReportTypeCompletedNotification object:self userInfo:userInfoDict];

}

- (void)updateReportType:(reportType *)aReportType
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForUpdateRequest:aReportType error:&error];
    }
    else {
        payload = [service getXMLForUpdateRequest:aReportType error:&error];
    }
    
    if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateReportTypeCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        ODataQuery *query = [[ODataQuery alloc] initWithURL:aReportType.baseUrl];
    	NSDictionary *userInfoDict = @{kResponseParentItem : aReportType , kRequestUserInfoCompletedNotification : kUpdateReportTypeCompletedNotification};
    	[connectivityHelper executeUpdateAsyncRequestWithQuery:query andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(updateReportTypeCompleted:) andUserInfo:userInfoDict andEtag:aReportType.etag];
    }
}

#pragma mark Delete

- (void)deleteReportTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    [[NSNotificationCenter defaultCenter] postNotificationName:kDeleteReportTypeCompletedNotification object:self userInfo:userInfoDict];   
}

- (void)deleteReportType:(reportType *)aReportType 
{
	[self loadCSRFData];
    ODataQuery *query = [[ODataQuery alloc] initWithURL:aReportType.baseUrl];
    NSDictionary *userInfoDict = @{kResponseParentItem : aReportType , kRequestUserInfoCompletedNotification : kDeleteReportTypeCompletedNotification};
    [connectivityHelper executeDeleteAsyncRequestWithQuery:query andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(deleteReportTypeCompleted:) andUserInfo:userInfoDict andEtag:aReportType.etag];
}

#pragma mark - reportqueryconstraints methods
#pragma mark Read

- (void)loadReportqueryconstraintsCompleted:(id <Requesting>)request
{
    NSDictionary *userInfoDict;
    NSError *error;
    NSMutableArray *items = [service getReportqueryconstraintsWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict = @{kParsingError: error};
    }
    else {
    	userInfoDict = @{kResponseItems: items};
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadReportqueryconstraintsCompletedNotification object:self userInfo:userInfoDict];
}

- (void)loadReportqueryconstraints
{
    ODataQuery *query = service.reportqueryconstraintsQuery;
    NSDictionary *userInfoDict = @{kRequestUserInfoCompletedNotification : kLoadReportqueryconstraintsCompletedNotification};
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadReportqueryconstraintsCompleted:) andUserInfo:userInfoDict];
}


- (void)loadReportqueryconstraintsTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSError *error;
    reportqueryconstraintsType *item = [reportqueryconstraintsType parseReportqueryconstraintsTypeEntryWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict[kParsingError] = error;
    }
    else {
    	userInfoDict[kResponseItem] = item;
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadReportqueryconstraintsTypeCompletedNotification object:self userInfo:userInfoDict];
}

- (void)loadReportqueryconstraintsType:(reportqueryconstraintsType *)aReportqueryconstraintsType
{
    ODataQuery *query = [[ODataQuery alloc] initWithURL:aReportqueryconstraintsType.baseUrl];
    NSDictionary *userInfoDict = @{kResponseParentItem : aReportqueryconstraintsType, kRequestUserInfoCompletedNotification : kLoadReportqueryconstraintsTypeCompletedNotification};
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadReportqueryconstraintsTypeCompleted:) andUserInfo:userInfoDict];
}

#pragma mark Create

- (void)createReportqueryconstraintsTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        reportqueryconstraintsType *item = [reportqueryconstraintsType parseReportqueryconstraintsTypeEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kCreateReportqueryconstraintsTypeCompletedNotification object:self userInfo:userInfoDict];

}

- (void)createReportqueryconstraintsType:(reportqueryconstraintsType *)aReportqueryconstraintsType
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aReportqueryconstraintsType error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aReportqueryconstraintsType error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateReportqueryconstraintsTypeCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aReportqueryconstraintsType , kRequestUserInfoCompletedNotification : kCreateReportqueryconstraintsTypeCompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:service.reportqueryconstraintsQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createReportqueryconstraintsTypeCompleted:) andUserInfo:userInfoDict];
    }
}

#pragma mark Update

- (void)updateReportqueryconstraintsTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        reportqueryconstraintsType *item = [reportqueryconstraintsType parseReportqueryconstraintsTypeEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateReportqueryconstraintsTypeCompletedNotification object:self userInfo:userInfoDict];

}

- (void)updateReportqueryconstraintsType:(reportqueryconstraintsType *)aReportqueryconstraintsType
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForUpdateRequest:aReportqueryconstraintsType error:&error];
    }
    else {
        payload = [service getXMLForUpdateRequest:aReportqueryconstraintsType error:&error];
    }
    
    if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateReportqueryconstraintsTypeCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        ODataQuery *query = [[ODataQuery alloc] initWithURL:aReportqueryconstraintsType.baseUrl];
    	NSDictionary *userInfoDict = @{kResponseParentItem : aReportqueryconstraintsType , kRequestUserInfoCompletedNotification : kUpdateReportqueryconstraintsTypeCompletedNotification};
    	[connectivityHelper executeUpdateAsyncRequestWithQuery:query andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(updateReportqueryconstraintsTypeCompleted:) andUserInfo:userInfoDict andEtag:aReportqueryconstraintsType.etag];
    }
}

#pragma mark Delete

- (void)deleteReportqueryconstraintsTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    [[NSNotificationCenter defaultCenter] postNotificationName:kDeleteReportqueryconstraintsTypeCompletedNotification object:self userInfo:userInfoDict];   
}

- (void)deleteReportqueryconstraintsType:(reportqueryconstraintsType *)aReportqueryconstraintsType 
{
	[self loadCSRFData];
    ODataQuery *query = [[ODataQuery alloc] initWithURL:aReportqueryconstraintsType.baseUrl];
    NSDictionary *userInfoDict = @{kResponseParentItem : aReportqueryconstraintsType , kRequestUserInfoCompletedNotification : kDeleteReportqueryconstraintsTypeCompletedNotification};
    [connectivityHelper executeDeleteAsyncRequestWithQuery:query andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(deleteReportqueryconstraintsTypeCompleted:) andUserInfo:userInfoDict andEtag:aReportqueryconstraintsType.etag];
}

#pragma mark - reportviewsfilter methods
#pragma mark Read

- (void)loadReportviewsfilterCompleted:(id <Requesting>)request
{
    NSDictionary *userInfoDict;
    NSError *error;
    NSMutableArray *items = [service getReportviewsfilterWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict = @{kParsingError: error};
    }
    else {
    	userInfoDict = @{kResponseItems: items};
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadReportviewsfilterCompletedNotification object:self userInfo:userInfoDict];
}

- (void)loadReportviewsfilter
{
    ODataQuery *query = service.reportviewsfilterQuery;
    NSDictionary *userInfoDict = @{kRequestUserInfoCompletedNotification : kLoadReportviewsfilterCompletedNotification};
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadReportviewsfilterCompleted:) andUserInfo:userInfoDict];
}


- (void)loadReportviewsfilterTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSError *error;
    reportviewsfilterType *item = [reportviewsfilterType parseReportviewsfilterTypeEntryWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict[kParsingError] = error;
    }
    else {
    	userInfoDict[kResponseItem] = item;
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadReportviewsfilterTypeCompletedNotification object:self userInfo:userInfoDict];
}

- (void)loadReportviewsfilterType:(reportviewsfilterType *)aReportviewsfilterType
{
    ODataQuery *query = [[ODataQuery alloc] initWithURL:aReportviewsfilterType.baseUrl];
    NSDictionary *userInfoDict = @{kResponseParentItem : aReportviewsfilterType, kRequestUserInfoCompletedNotification : kLoadReportviewsfilterTypeCompletedNotification};
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadReportviewsfilterTypeCompleted:) andUserInfo:userInfoDict];
}

#pragma mark Create

- (void)createReportviewsfilterTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        reportviewsfilterType *item = [reportviewsfilterType parseReportviewsfilterTypeEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kCreateReportviewsfilterTypeCompletedNotification object:self userInfo:userInfoDict];

}

- (void)createReportviewsfilterType:(reportviewsfilterType *)aReportviewsfilterType
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aReportviewsfilterType error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aReportviewsfilterType error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateReportviewsfilterTypeCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aReportviewsfilterType , kRequestUserInfoCompletedNotification : kCreateReportviewsfilterTypeCompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:service.reportviewsfilterQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createReportviewsfilterTypeCompleted:) andUserInfo:userInfoDict];
    }
}

#pragma mark Update

- (void)updateReportviewsfilterTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        reportviewsfilterType *item = [reportviewsfilterType parseReportviewsfilterTypeEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateReportviewsfilterTypeCompletedNotification object:self userInfo:userInfoDict];

}

- (void)updateReportviewsfilterType:(reportviewsfilterType *)aReportviewsfilterType
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForUpdateRequest:aReportviewsfilterType error:&error];
    }
    else {
        payload = [service getXMLForUpdateRequest:aReportviewsfilterType error:&error];
    }
    
    if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateReportviewsfilterTypeCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        ODataQuery *query = [[ODataQuery alloc] initWithURL:aReportviewsfilterType.baseUrl];
    	NSDictionary *userInfoDict = @{kResponseParentItem : aReportviewsfilterType , kRequestUserInfoCompletedNotification : kUpdateReportviewsfilterTypeCompletedNotification};
    	[connectivityHelper executeUpdateAsyncRequestWithQuery:query andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(updateReportviewsfilterTypeCompleted:) andUserInfo:userInfoDict andEtag:aReportviewsfilterType.etag];
    }
}

#pragma mark Delete

- (void)deleteReportviewsfilterTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    [[NSNotificationCenter defaultCenter] postNotificationName:kDeleteReportviewsfilterTypeCompletedNotification object:self userInfo:userInfoDict];   
}

- (void)deleteReportviewsfilterType:(reportviewsfilterType *)aReportviewsfilterType 
{
	[self loadCSRFData];
    ODataQuery *query = [[ODataQuery alloc] initWithURL:aReportviewsfilterType.baseUrl];
    NSDictionary *userInfoDict = @{kResponseParentItem : aReportviewsfilterType , kRequestUserInfoCompletedNotification : kDeleteReportviewsfilterTypeCompletedNotification};
    [connectivityHelper executeDeleteAsyncRequestWithQuery:query andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(deleteReportviewsfilterTypeCompleted:) andUserInfo:userInfoDict andEtag:aReportviewsfilterType.etag];
}

#pragma mark - sharedobjects methods
#pragma mark Read

- (void)loadSharedobjectsCompleted:(id <Requesting>)request
{
    NSDictionary *userInfoDict;
    NSError *error;
    NSMutableArray *items = [service getSharedobjectsWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict = @{kParsingError: error};
    }
    else {
    	userInfoDict = @{kResponseItems: items};
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadSharedobjectsCompletedNotification object:self userInfo:userInfoDict];
}

- (void)loadSharedobjects
{
    ODataQuery *query = service.sharedobjectsQuery;
    NSDictionary *userInfoDict = @{kRequestUserInfoCompletedNotification : kLoadSharedobjectsCompletedNotification};
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadSharedobjectsCompleted:) andUserInfo:userInfoDict];
}


- (void)loadSharedobjectsTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSError *error;
    sharedobjectsType *item = [sharedobjectsType parseSharedobjectsTypeEntryWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict[kParsingError] = error;
    }
    else {
    	userInfoDict[kResponseItem] = item;
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadSharedobjectsTypeCompletedNotification object:self userInfo:userInfoDict];
}

- (void)loadSharedobjectsType:(sharedobjectsType *)aSharedobjectsType
{
    ODataQuery *query = [[ODataQuery alloc] initWithURL:aSharedobjectsType.baseUrl];
    NSDictionary *userInfoDict = @{kResponseParentItem : aSharedobjectsType, kRequestUserInfoCompletedNotification : kLoadSharedobjectsTypeCompletedNotification};
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadSharedobjectsTypeCompleted:) andUserInfo:userInfoDict];
}

#pragma mark Create

- (void)createSharedobjectsTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        sharedobjectsType *item = [sharedobjectsType parseSharedobjectsTypeEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kCreateSharedobjectsTypeCompletedNotification object:self userInfo:userInfoDict];

}

- (void)createSharedobjectsType:(sharedobjectsType *)aSharedobjectsType
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aSharedobjectsType error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aSharedobjectsType error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateSharedobjectsTypeCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aSharedobjectsType , kRequestUserInfoCompletedNotification : kCreateSharedobjectsTypeCompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:service.sharedobjectsQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createSharedobjectsTypeCompleted:) andUserInfo:userInfoDict];
    }
}

#pragma mark Update

- (void)updateSharedobjectsTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        sharedobjectsType *item = [sharedobjectsType parseSharedobjectsTypeEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateSharedobjectsTypeCompletedNotification object:self userInfo:userInfoDict];

}

- (void)updateSharedobjectsType:(sharedobjectsType *)aSharedobjectsType
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForUpdateRequest:aSharedobjectsType error:&error];
    }
    else {
        payload = [service getXMLForUpdateRequest:aSharedobjectsType error:&error];
    }
    
    if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateSharedobjectsTypeCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        ODataQuery *query = [[ODataQuery alloc] initWithURL:aSharedobjectsType.baseUrl];
    	NSDictionary *userInfoDict = @{kResponseParentItem : aSharedobjectsType , kRequestUserInfoCompletedNotification : kUpdateSharedobjectsTypeCompletedNotification};
    	[connectivityHelper executeUpdateAsyncRequestWithQuery:query andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(updateSharedobjectsTypeCompleted:) andUserInfo:userInfoDict andEtag:aSharedobjectsType.etag];
    }
}

#pragma mark Delete

- (void)deleteSharedobjectsTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    [[NSNotificationCenter defaultCenter] postNotificationName:kDeleteSharedobjectsTypeCompletedNotification object:self userInfo:userInfoDict];   
}

- (void)deleteSharedobjectsType:(sharedobjectsType *)aSharedobjectsType 
{
	[self loadCSRFData];
    ODataQuery *query = [[ODataQuery alloc] initWithURL:aSharedobjectsType.baseUrl];
    NSDictionary *userInfoDict = @{kResponseParentItem : aSharedobjectsType , kRequestUserInfoCompletedNotification : kDeleteSharedobjectsTypeCompletedNotification};
    [connectivityHelper executeDeleteAsyncRequestWithQuery:query andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(deleteSharedobjectsTypeCompleted:) andUserInfo:userInfoDict andEtag:aSharedobjectsType.etag];
}

#pragma mark - reportpagenav methods
#pragma mark Read

- (void)loadReportpagenavCompleted:(id <Requesting>)request
{
    NSDictionary *userInfoDict;
    NSError *error;
    NSMutableArray *items = [service getReportpagenavWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict = @{kParsingError: error};
    }
    else {
    	userInfoDict = @{kResponseItems: items};
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadReportpagenavCompletedNotification object:self userInfo:userInfoDict];
}

- (void)loadReportpagenav
{
    ODataQuery *query = service.reportpagenavQuery;
    NSDictionary *userInfoDict = @{kRequestUserInfoCompletedNotification : kLoadReportpagenavCompletedNotification};
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadReportpagenavCompleted:) andUserInfo:userInfoDict];
}


- (void)loadReportpagenavTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSError *error;
    reportpagenavType *item = [reportpagenavType parseReportpagenavTypeEntryWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict[kParsingError] = error;
    }
    else {
    	userInfoDict[kResponseItem] = item;
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadReportpagenavTypeCompletedNotification object:self userInfo:userInfoDict];
}

- (void)loadReportpagenavType:(reportpagenavType *)aReportpagenavType
{
    ODataQuery *query = [[ODataQuery alloc] initWithURL:aReportpagenavType.baseUrl];
    NSDictionary *userInfoDict = @{kResponseParentItem : aReportpagenavType, kRequestUserInfoCompletedNotification : kLoadReportpagenavTypeCompletedNotification};
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadReportpagenavTypeCompleted:) andUserInfo:userInfoDict];
}

#pragma mark Create

- (void)createReportpagenavTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        reportpagenavType *item = [reportpagenavType parseReportpagenavTypeEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kCreateReportpagenavTypeCompletedNotification object:self userInfo:userInfoDict];

}

- (void)createReportpagenavType:(reportpagenavType *)aReportpagenavType
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aReportpagenavType error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aReportpagenavType error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateReportpagenavTypeCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aReportpagenavType , kRequestUserInfoCompletedNotification : kCreateReportpagenavTypeCompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:service.reportpagenavQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createReportpagenavTypeCompleted:) andUserInfo:userInfoDict];
    }
}

#pragma mark Update

- (void)updateReportpagenavTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        reportpagenavType *item = [reportpagenavType parseReportpagenavTypeEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateReportpagenavTypeCompletedNotification object:self userInfo:userInfoDict];

}

- (void)updateReportpagenavType:(reportpagenavType *)aReportpagenavType
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForUpdateRequest:aReportpagenavType error:&error];
    }
    else {
        payload = [service getXMLForUpdateRequest:aReportpagenavType error:&error];
    }
    
    if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateReportpagenavTypeCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        ODataQuery *query = [[ODataQuery alloc] initWithURL:aReportpagenavType.baseUrl];
    	NSDictionary *userInfoDict = @{kResponseParentItem : aReportpagenavType , kRequestUserInfoCompletedNotification : kUpdateReportpagenavTypeCompletedNotification};
    	[connectivityHelper executeUpdateAsyncRequestWithQuery:query andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(updateReportpagenavTypeCompleted:) andUserInfo:userInfoDict andEtag:aReportpagenavType.etag];
    }
}

#pragma mark Delete

- (void)deleteReportpagenavTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    [[NSNotificationCenter defaultCenter] postNotificationName:kDeleteReportpagenavTypeCompletedNotification object:self userInfo:userInfoDict];   
}

- (void)deleteReportpagenavType:(reportpagenavType *)aReportpagenavType 
{
	[self loadCSRFData];
    ODataQuery *query = [[ODataQuery alloc] initWithURL:aReportpagenavType.baseUrl];
    NSDictionary *userInfoDict = @{kResponseParentItem : aReportpagenavType , kRequestUserInfoCompletedNotification : kDeleteReportpagenavTypeCompletedNotification};
    [connectivityHelper executeDeleteAsyncRequestWithQuery:query andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(deleteReportpagenavTypeCompleted:) andUserInfo:userInfoDict andEtag:aReportpagenavType.etag];
}

#pragma mark - reportviewpages methods
#pragma mark Read

- (void)loadReportviewpagesCompleted:(id <Requesting>)request
{
    NSDictionary *userInfoDict;
    NSError *error;
    NSMutableArray *items = [service getReportviewpagesWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict = @{kParsingError: error};
    }
    else {
    	userInfoDict = @{kResponseItems: items};
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadReportviewpagesCompletedNotification object:self userInfo:userInfoDict];
}

- (void)loadReportviewpages
{
    ODataQuery *query = service.reportviewpagesQuery;
    NSDictionary *userInfoDict = @{kRequestUserInfoCompletedNotification : kLoadReportviewpagesCompletedNotification};
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadReportviewpagesCompleted:) andUserInfo:userInfoDict];
}


- (void)loadReportviewpagesTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSError *error;
    reportviewpagesType *item = [reportviewpagesType parseReportviewpagesTypeEntryWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict[kParsingError] = error;
    }
    else {
    	userInfoDict[kResponseItem] = item;
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadReportviewpagesTypeCompletedNotification object:self userInfo:userInfoDict];
}

- (void)loadReportviewpagesType:(reportviewpagesType *)aReportviewpagesType
{
    ODataQuery *query = [[ODataQuery alloc] initWithURL:aReportviewpagesType.baseUrl];
    NSDictionary *userInfoDict = @{kResponseParentItem : aReportviewpagesType, kRequestUserInfoCompletedNotification : kLoadReportviewpagesTypeCompletedNotification};
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadReportviewpagesTypeCompleted:) andUserInfo:userInfoDict];
}

#pragma mark Create

- (void)createReportviewpagesTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        reportviewpagesType *item = [reportviewpagesType parseReportviewpagesTypeEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kCreateReportviewpagesTypeCompletedNotification object:self userInfo:userInfoDict];

}

- (void)createReportviewpagesType:(reportviewpagesType *)aReportviewpagesType
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aReportviewpagesType error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aReportviewpagesType error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateReportviewpagesTypeCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aReportviewpagesType , kRequestUserInfoCompletedNotification : kCreateReportviewpagesTypeCompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:service.reportviewpagesQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createReportviewpagesTypeCompleted:) andUserInfo:userInfoDict];
    }
}

#pragma mark Update

- (void)updateReportviewpagesTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        reportviewpagesType *item = [reportviewpagesType parseReportviewpagesTypeEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateReportviewpagesTypeCompletedNotification object:self userInfo:userInfoDict];

}

- (void)updateReportviewpagesType:(reportviewpagesType *)aReportviewpagesType
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForUpdateRequest:aReportviewpagesType error:&error];
    }
    else {
        payload = [service getXMLForUpdateRequest:aReportviewpagesType error:&error];
    }
    
    if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateReportviewpagesTypeCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        ODataQuery *query = [[ODataQuery alloc] initWithURL:aReportviewpagesType.baseUrl];
    	NSDictionary *userInfoDict = @{kResponseParentItem : aReportviewpagesType , kRequestUserInfoCompletedNotification : kUpdateReportviewpagesTypeCompletedNotification};
    	[connectivityHelper executeUpdateAsyncRequestWithQuery:query andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(updateReportviewpagesTypeCompleted:) andUserInfo:userInfoDict andEtag:aReportviewpagesType.etag];
    }
}

#pragma mark Delete

- (void)deleteReportviewpagesTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    [[NSNotificationCenter defaultCenter] postNotificationName:kDeleteReportviewpagesTypeCompletedNotification object:self userInfo:userInfoDict];   
}

- (void)deleteReportviewpagesType:(reportviewpagesType *)aReportviewpagesType 
{
	[self loadCSRFData];
    ODataQuery *query = [[ODataQuery alloc] initWithURL:aReportviewpagesType.baseUrl];
    NSDictionary *userInfoDict = @{kResponseParentItem : aReportviewpagesType , kRequestUserInfoCompletedNotification : kDeleteReportviewpagesTypeCompletedNotification};
    [connectivityHelper executeDeleteAsyncRequestWithQuery:query andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(deleteReportviewpagesTypeCompleted:) andUserInfo:userInfoDict andEtag:aReportviewpagesType.etag];
}

#pragma mark - reportviewwbfav methods
#pragma mark Read

- (void)loadReportviewwbfavCompleted:(id <Requesting>)request
{
    NSDictionary *userInfoDict;
    NSError *error;
    NSMutableArray *items = [service getReportviewwbfavWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict = @{kParsingError: error};
    }
    else {
    	userInfoDict = @{kResponseItems: items};
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadReportviewwbfavCompletedNotification object:self userInfo:userInfoDict];
}

- (void)loadReportviewwbfav
{
    ODataQuery *query = service.reportviewwbfavQuery;
    NSDictionary *userInfoDict = @{kRequestUserInfoCompletedNotification : kLoadReportviewwbfavCompletedNotification};
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadReportviewwbfavCompleted:) andUserInfo:userInfoDict];
}


- (void)loadReportviewwbfavTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSError *error;
    reportviewwbfavType *item = [reportviewwbfavType parseReportviewwbfavTypeEntryWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict[kParsingError] = error;
    }
    else {
    	userInfoDict[kResponseItem] = item;
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadReportviewwbfavTypeCompletedNotification object:self userInfo:userInfoDict];
}

- (void)loadReportviewwbfavType:(reportviewwbfavType *)aReportviewwbfavType
{
    ODataQuery *query = [[ODataQuery alloc] initWithURL:aReportviewwbfavType.baseUrl];
    NSDictionary *userInfoDict = @{kResponseParentItem : aReportviewwbfavType, kRequestUserInfoCompletedNotification : kLoadReportviewwbfavTypeCompletedNotification};
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadReportviewwbfavTypeCompleted:) andUserInfo:userInfoDict];
}

#pragma mark Create

- (void)createReportviewwbfavTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        reportviewwbfavType *item = [reportviewwbfavType parseReportviewwbfavTypeEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kCreateReportviewwbfavTypeCompletedNotification object:self userInfo:userInfoDict];

}

- (void)createReportviewwbfavType:(reportviewwbfavType *)aReportviewwbfavType
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aReportviewwbfavType error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aReportviewwbfavType error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateReportviewwbfavTypeCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aReportviewwbfavType , kRequestUserInfoCompletedNotification : kCreateReportviewwbfavTypeCompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:service.reportviewwbfavQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createReportviewwbfavTypeCompleted:) andUserInfo:userInfoDict];
    }
}

#pragma mark Update

- (void)updateReportviewwbfavTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        reportviewwbfavType *item = [reportviewwbfavType parseReportviewwbfavTypeEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateReportviewwbfavTypeCompletedNotification object:self userInfo:userInfoDict];

}

- (void)updateReportviewwbfavType:(reportviewwbfavType *)aReportviewwbfavType
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForUpdateRequest:aReportviewwbfavType error:&error];
    }
    else {
        payload = [service getXMLForUpdateRequest:aReportviewwbfavType error:&error];
    }
    
    if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateReportviewwbfavTypeCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        ODataQuery *query = [[ODataQuery alloc] initWithURL:aReportviewwbfavType.baseUrl];
    	NSDictionary *userInfoDict = @{kResponseParentItem : aReportviewwbfavType , kRequestUserInfoCompletedNotification : kUpdateReportviewwbfavTypeCompletedNotification};
    	[connectivityHelper executeUpdateAsyncRequestWithQuery:query andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(updateReportviewwbfavTypeCompleted:) andUserInfo:userInfoDict andEtag:aReportviewwbfavType.etag];
    }
}

#pragma mark Delete

- (void)deleteReportviewwbfavTypeCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    [[NSNotificationCenter defaultCenter] postNotificationName:kDeleteReportviewwbfavTypeCompletedNotification object:self userInfo:userInfoDict];   
}

- (void)deleteReportviewwbfavType:(reportviewwbfavType *)aReportviewwbfavType 
{
	[self loadCSRFData];
    ODataQuery *query = [[ODataQuery alloc] initWithURL:aReportviewwbfavType.baseUrl];
    NSDictionary *userInfoDict = @{kResponseParentItem : aReportviewwbfavType , kRequestUserInfoCompletedNotification : kDeleteReportviewwbfavTypeCompletedNotification};
    [connectivityHelper executeDeleteAsyncRequestWithQuery:query andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(deleteReportviewwbfavTypeCompleted:) andUserInfo:userInfoDict andEtag:aReportviewwbfavType.etag];
}

#pragma mark - Function Import methods

#pragma mark - RequestDelegate

- (void)requestFailed:(Request *)request
{
    int statusCode = request.responseStatusCode;
    if (statusCode == 401) {
        [self authenticationNeededForRequest:request];
        LOGERROR(@"Request failed with authentication error - response status code 401");
    }
    else {
        NSString *errorMessage;
        NSString *logErrorMessage;
        if (statusCode == 403){
            errorMessage = [request responseString];
            NSString *csrfToken = [request responseHeaders][@"x-csrf-token"];
            if (csrfToken.length > 0 && [csrfToken isEqualToString:@"Required"]) {
            	csrfData = nil;
                NSString *localizedMessage = NSLocalizedString(@"CSRF Token is invalid. Try again to get a new token", @"CSRF Token is invalid. Try again to get a new token");
                errorMessage = [NSString stringWithFormat:@"%@. %@", errorMessage, localizedMessage];
                logErrorMessage = [NSString stringWithFormat:@"Request failed due to invalid CSRF with error: %@. Response status code: %d.", errorMessage, statusCode];
            }
        }
        else {
            errorMessage = request.error ? [request.error localizedDescription] : [request responseStatusMessage];
            logErrorMessage = [NSString stringWithFormat:@"Request failed with error: %@. Response status code: %d.", errorMessage, statusCode];
            
            id<ServiceErrorParsing> serviceErrorParser = nil;
            NSString *contentType = [[[request responseHeaders] objectForKey:@"Content-Type"] lowercaseString];
            if ([contentType isEqualToString:@"application/json"]) {
                serviceErrorParser = [[ServiceErrorJsonParser alloc] initWithErrorData:[request responseData]];
            }
            else {
                serviceErrorParser = [[ServiceErrorXmlParser alloc] initWithErrorData:[request responseData]];
            }
            if ([serviceErrorParser parse]) {
                ServiceError *serviceError = [serviceErrorParser result];
                
                if ([serviceError.innerMessage length] > 0){
                    logErrorMessage = [logErrorMessage stringByAppendingString:[NSString stringWithFormat:@" Service error message: %@ Service error inner message: %@", serviceError.message, serviceError.innerMessage]];
                }
                else{
                    logErrorMessage = [logErrorMessage stringByAppendingString:[NSString stringWithFormat:@" Service response: %@", serviceError.message]];
                }
                
                errorMessage = serviceError.message;
            }
            else
            {
                logErrorMessage = [logErrorMessage stringByAppendingString:[NSString stringWithFormat:@" Response body: %@",[request responseString]]];
            }
        }
        LOGERROR(logErrorMessage);
        
        NSMutableDictionary *errorUserInfoDict = [@{} mutableCopy];
        errorUserInfoDict[NSLocalizedDescriptionKey] = errorMessage;
        NSError *error = [NSError errorWithDomain:ERROR_DOMAIN code:REQUEST_FAILED_ERROR_CODE userInfo:errorUserInfoDict];
        
        NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
        userInfoDict[kServerResponseError] = error;
        
        // Send error notification (handled by all the application views)
        [[NSNotificationCenter defaultCenter] postNotificationName:request.userInfo[kRequestUserInfoCompletedNotification] object:self userInfo:userInfoDict];
    }
}


- (void)authenticationNeededForRequest:(Request *)request
{
    //Cancel request and send notification for displaying the login screen
    [request cancelAuthentication];
    [[NSNotificationCenter defaultCenter] postNotificationName:kAuthenticationNeededNotification object:self userInfo:nil];
}

#pragma mark - SDMConnectivityHelperDelegate

- (void)onBeforeSend:(id <Requesting>)request
{
	request.shouldPresentAuthenticationDialog = YES;
    
    if ([ConnectivitySettings isSUPMode]) {
        if ([KeychainHelper isCredentialsSaved]){
            NSError *error = nil;
            CredentialsData *credentials = [KeychainHelper loadCredentialsAndReturnError:&error];
            if (credentials) {
                [request setUsername:credentials.username];
                [request setPassword:credentials.password];
            }
            else if(error) {
                NSString *msg = [error localizedDescription];
                LOGERROR(msg);
            }
            else {
                NSString *msg = NSLocalizedString(@"Error while loading credentials from keychain", @"Error while loading credentials from keychain");
                LOGERROR(msg);
            }
        }
    }
    else if ([ConnectivitySettings authenticationType] == CertificateAuthenticationType) {
        [request setClientCertificateIdentity:certificate];
    }

    //Define the request language as the device language settings. Uncomment the following line to use the user default language as defined on the server.
    [request addRequestHeader:@"sap-language" value:deviceLanguage];
        
    if (self.useJSON) {
        NSString *jsonUrl = [request.url absoluteString];
        // Don't use jSON to fetch metadata or service document
        if ([self isJSONAllowedForUrl:jsonUrl]) {
            [request addRequestHeader:@"Content-Type" value:@"application/json"];
            [request addRequestHeader:@"Accept" value:@"application/json"];
        }
    }
}

- (BOOL)isJSONAllowedForUrl:(NSString *)jsonUrl
{
    if ([jsonUrl rangeOfString:@"$metadata" options:NSCaseInsensitiveSearch].location == NSNotFound) {
        if (![self.serviceDocumentURL isEqualToString:jsonUrl]) {
            return YES;
        }
    }
    
    return NO;
}

@end
